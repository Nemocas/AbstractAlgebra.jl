<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Field Interface · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multvariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li class="current"><a class="toctext" href="fields.html">Field Interface</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Parent-object-caches-1">Parent object caches</a></li><li><a class="toctext" href="#Required-functions-for-all-fields-1">Required functions for all fields</a></li></ul></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="perm.html">-</a></li></ul></li><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Fields</li><li><a href="fields.html">Field Interface</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/fields.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Field Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Field-Interface-1" href="#Field-Interface-1">Field Interface</a></h1><p>AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all fields. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their fields.</p><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>Most fields must supply two types:</p><ul><li><p>a type for the parent object (representing the field itself)</p></li><li><p>a type for elements of that field</p></li></ul><p>For example, the generic fraction field type in AbstractAlgebra.jl provides two  types in generic/GenericTypes.jl: </p><ul><li><p><code>Generic.FracField{T}</code> for the parent objects</p></li><li><p><code>Generic.Frac{T}</code> for the actual fractions</p></li></ul><p>The parent type must belong to <code>AbstractAlgebra.Field</code> and the element type must belong to <code>AbstractAlgebra.FieldElem</code>. Of course, the types may belong to these abstract types transitively.</p><p>For parameterised fields, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring.</p><p>There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.</p><h2><a class="nav-anchor" id="Parent-object-caches-1" href="#Parent-object-caches-1">Parent object caches</a></h2><p>In many cases, it is desirable to have only one object in the system to represent each field. This means that if the same field is constructed twice, elements of the two fields will be compatible as far as arithmetic is concerned.</p><p>In order to facilitate this, global caches of fields are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the <code>Generic.FracField</code> parent objects are looked up in a dictionary <code>FracDict</code> to see if they have been previously defined.</p><p>Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn&#39;t desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two fields are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two fields if they were constructed from identical data.</p><p>If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value <code>cached</code> to the inner constructor of the parent object. See generic/GenericTypes.jl` for examples of how to construct and handle such caches.</p><h2><a class="nav-anchor" id="Required-functions-for-all-fields-1" href="#Required-functions-for-all-fields-1">Required functions for all fields</a></h2><p>In the following, we list all the functions that are required to be provided for fields in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.</p><p>We give this interface for fictitious types <code>MyParent</code> for the type of the field parent object <code>R</code> and <code>MyElem</code> for the type of the elements of the field.</p><p>Note that generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for fields that implement that additional functionality, and should be documented as such.</p><p>In the first place, all fields are rings and therefore any field type must implement all of the Ring interface. The functionality below is in addition to this basic functionality.</p><h3><a class="nav-anchor" id="Data-type-and-parent-object-methods-1" href="#Data-type-and-parent-object-methods-1">Data type and parent object methods</a></h3><pre><code class="language-julia">characteristic(R::MyParent)</code></pre><p>Return the characteristic of the field.</p><h3><a class="nav-anchor" id="Basic-manipulation-of-rings-and-elements-1" href="#Basic-manipulation-of-rings-and-elements-1">Basic manipulation of rings and elements</a></h3><pre><code class="language-julia">isunit(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is invertible, i.e. nonzero in the field.</p><h3><a class="nav-anchor" id="Inversion-1" href="#Inversion-1">Inversion</a></h3><pre><code class="language-julia">inv(f::MyElem)</code></pre><p>Return the inverse of the given element in the field. If <span>$f = 0$</span>, an error is thrown.</p><footer><hr/><a class="previous" href="residue.html"><span class="direction">Previous</span><span class="title">Generic residue rings</span></a><a class="next" href="fraction_fields.html"><span class="direction">Next</span><span class="title">Fraction Field Interface</span></a></footer></article></body></html>
