<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Appendix A: Types in AbstractAlgebra.jl · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../mpolynomial/">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li><a class="toctext" href="../series/">Generic power series</a></li><li><a class="toctext" href="../puiseux/">Generic Puiseux series</a></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fields/">Field Interface</a></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../module/">Module Interface</a></li><li><a class="toctext" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="toctext" href="../submodule/">Submodules</a></li><li><a class="toctext" href="../quotient_module/">Quotient modules</a></li><li><a class="toctext" href="../direct_sum/">Direct Sums</a></li><li><a class="toctext" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li class="current"><a class="toctext" href>Appendix A: Types in AbstractAlgebra.jl</a><ul class="internal"><li><a class="toctext" href="#The-abstract-type-hierarchy-in-AbstractAlgebra.jl-1">The abstract type hierarchy in AbstractAlgebra.jl</a></li><li><a class="toctext" href="#Why-types-aren&#39;t-enough-1">Why types aren&#39;t enough</a></li><li><a class="toctext" href="#More-complex-example-of-parent-objects-1">More complex example of parent objects</a></li><li><a class="toctext" href="#Concrete-types-in-AbstractAlgebra.jl-1">Concrete types in AbstractAlgebra.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Appendix A: Types in AbstractAlgebra.jl</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Appendix A: Types in AbstractAlgebra.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Appendix-A:-Types-in-AbstractAlgebra.jl-1" href="#Appendix-A:-Types-in-AbstractAlgebra.jl-1">Appendix A: Types in AbstractAlgebra.jl</a></h1><p>On this page we discuss the abstract type hierarchy in AbstractAlgebra.jl and objects known as parents which contain additional information about groups, rings, fields and modules, etc., that can&#39;t be stored in types alone.</p><p>These details are technical and can be skipped or skimmed by new users of Julia/AbstractAlgebra.jl. Types are almost never dealt with directly when scripting AbstractAlgebra.jl to do mathematical computations.</p><p>In contrast, AbstractAlgebra.jl developers will want to know how we model mathematical objects and their rings, fields, groups, etc.</p><h2><a class="nav-anchor" id="The-abstract-type-hierarchy-in-AbstractAlgebra.jl-1" href="#The-abstract-type-hierarchy-in-AbstractAlgebra.jl-1">The abstract type hierarchy in AbstractAlgebra.jl</a></h2><p>Abstract types in Julia can also belong to one another in a hierarchy. We make use of such a hierarchy to organise the kinds of mathematical objects in AbstractAlgebra.jl.</p><p>For example, the <code>AbstractAlgebra.Field</code> abstract type belongs to the <code>AbstractAlgebra.Ring</code> abstract type.</p><p>In practice, this means that any generic function in AbstractAlgebra.jl which is designed to work with ring objects will also work with field objects.</p><p>In AbstractAlgebra.jl we also distinguish between the elements of a field, say, and the field itself.</p><p>For example, we have an object of type <code>Generic.PolyRing</code> to model a generic polynomial ring, and elements of that polynomial ring would have type <code>Generic.Poly</code>.</p><p>For this purpose, we also have a hierarchy of abstract types, such as <code>FieldElem</code>, that the types of element objects can belong to.</p><p><img src="../img/types.png" alt="alt text"/></p><h2><a class="nav-anchor" id="Why-types-aren&#39;t-enough-1" href="#Why-types-aren&#39;t-enough-1">Why types aren&#39;t enough</a></h2><p>Naively, one might have expected that rings in AbstractAlgebra.jl could be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.</p><p>Consider the ring <span>$R = \mathbb{Z}/n\mathbb{Z}$</span> for a multiprecision integer <span>$n$</span>. If we were to model the ring <span>$R$</span> as a type, then the type would somehow need to contain the modulus <span>$n$</span>. This is not possible in Julia, and in fact it is not desirable, since the compiler would then recompile all the associated functions every time a different modulus <span>$n$</span> was used.</p><p>We could attach the modulus <span>$n$</span> to the objects representing elements of the ring, rather than their type.</p><p>But now we cannot create new elements of the ring <span>$\mathbb{Z}/n\mathbb{Z}$</span> given only their type, since the type no longer contains the modulus <span>$n$</span>.</p><p>Instead, the way we get around this in AbstractAlgebra.jl is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called <em>parent</em> objects can contain extra information, such as the modulus <span>$n$</span>.</p><p>In order to create new elements of <span>$\mathbb{Z}/n\mathbb{Z}$</span> as above, we overload the <code>call</code> operator for the parent object.</p><p>In the following AbstractAlgebra.jl example, we create the parent object <code>R</code> corresponding to the ring <span>$\mathbb{Z}/7\mathbb{Z}$</span>. We then create a new element <code>a</code> of this ring by calling the parent object <code>R</code>.</p><pre><code class="language-julia">R = ResidueRing(ZZ, 7)
a = R(3)</code></pre><p>Here, <code>R</code> is the parent object, containing the modulus <span>$7$</span>. So this example creates the element <span>$a = 3 \pmod{7}$</span>.</p><h2><a class="nav-anchor" id="More-complex-example-of-parent-objects-1" href="#More-complex-example-of-parent-objects-1">More complex example of parent objects</a></h2><p>Here is some Julia/AbstractAlgebra.jl code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.</p><pre><code class="language-julia">using AbstractAlgebra

R, x = ZZ[&quot;x&quot;]

f = x^2 + 3x + 1

typeof(R) &lt;: PolyRing

typeof(f) &lt;: PolyElem

parent(f) == R</code></pre><h2><a class="nav-anchor" id="Concrete-types-in-AbstractAlgebra.jl-1" href="#Concrete-types-in-AbstractAlgebra.jl-1">Concrete types in AbstractAlgebra.jl</a></h2><p>Here we give a list of the concrete types in AbstractAlgebra.jl.</p><p>In parentheses we put the types of the corresponding parent objects.</p><ul><li><code>Perm{&lt;:Integer}</code> (<code>PermGroup{&lt;:Integer}</code>)</li><li><code>GFElem{&lt;:Integer}</code> (<code>GFField{&lt;:Integer}</code>)</li></ul><p>We also think of various Julia types as though they were AbstractAlgebra.jl types:</p><ul><li><code>BigInt</code> (<code>Integers{BigInt}</code>)</li><li><code>Rational{BigInt}</code> (<code>Rationals{BigInt}</code>)</li></ul><p>Then there are various types for generic constructions over a base ring. They are all parameterised by a type <code>T</code> which is the type of the <em>elements</em> of the base ring they are defined over.</p><ul><li><code>Generic.Poly{T}</code> (<code>Generic.PolyRing{T}</code>)</li><li><code>Generic.MPoly{T}</code> (<code>Generic.MPolyRing{T}</code>)</li><li><code>Generic.RelSeries{T}</code> (<code>Generic.RelSeriesRing{T}</code>)</li><li><code>Generic.AbsSeries{T}</code> (<code>Generic.AbsSeriesRing{T}</code>)</li><li><code>Generic.LaurentSeriesRingElem{T}</code> (<code>Generic.LaurentSeriesRing{T}</code>)</li><li><code>Generic.LaurentSeriesFieldElem{T}</code> (<code>Generic.LaurentSeriesField{T}</code>)</li><li><code>Generic.Res{T}</code> (<code>Generic.ResRing{T}</code>)</li><li><code>Generic.Frac{T}</code> (<code>Generic.FracField{T}</code>)</li><li><code>Generic.Mat{T}</code> (<code>Generic.MatSpace{T}</code>)</li></ul><footer><hr/><a class="previous" href="../map_with_inverse/"><span class="direction">Previous</span><span class="title">Map with inverse</span></a></footer></article></body></html>
