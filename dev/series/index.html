<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic power series · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../mpolynomial/">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li class="current"><a class="toctext" href>Generic power series</a><ul class="internal"><li><a class="toctext" href="#Types-and-parent-objects-1">Types and parent objects</a></li><li><a class="toctext" href="#Series-ring-constructors-1">Series ring constructors</a></li><li><a class="toctext" href="#Big-oh-notation-1">Big-oh notation</a></li><li><a class="toctext" href="#Power-series-models-1">Power series models</a></li><li><a class="toctext" href="#Basic-ring-functionality-1">Basic ring functionality</a></li><li><a class="toctext" href="#Series-functionality-provided-by-AbstractAlgebra.jl-1">Series functionality provided by AbstractAlgebra.jl</a></li></ul></li><li><a class="toctext" href="../puiseux/">Generic Puiseux series</a></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fields/">Field Interface</a></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../module/">Module Interface</a></li><li><a class="toctext" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="toctext" href="../submodule/">Submodules</a></li><li><a class="toctext" href="../quotient_module/">Quotient modules</a></li><li><a class="toctext" href="../direct_sum/">Direct Sums</a></li><li><a class="toctext" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><a class="toctext" href="../types/">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href>Generic power series</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/series.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generic power series</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generic-power-series-1" href="#Generic-power-series-1">Generic power series</a></h1><p>AbstractAlgebra.jl allows the creation of capped relative and absolute power series over  any computable commutative ring <span>$R$</span>.</p><p>Capped relative power series are power series of the form <span>$a_jx^j + a_{j+1}x^{j+1} + \cdots + a_{k-1}x^{k-1} + O(x^k)$</span> where <span>$a_j \in R$</span> and the relative precision <span>$k - j$</span> is at most equal to some specified precision <span>$n$</span>.</p><p>Capped absolute power series are power series of the form <span>$a_jx^j + a_{j+1}x^{j+1} + \cdots + a_{n-1}x^{n-1} + O(x^n)$</span> where <span>$j \geq 0$</span>, <span>$a_j \in R$</span> and the precision <span>$n$</span> is fixed.</p><p>There are two implementations of relative series: relative power series, implemented in <code>src/generic/RelSeries.jl</code> for which <span>$j &gt; 0$</span> in the above description, and Laurent series where <span>$j$</span> can be negative, implemented in <code>src/generic/Laurent.jl</code>. Note that there are two implementations for Laurent series, one over rings and one over fields, though in practice most of the implementation uses the same code in both cases.</p><p>There is a single implementation of absolute series: absolute power series, implemented in <code>src/generic/AbsSeries.jl</code>.</p><p>As well as implementing the Series Ring interface, the series modules in AbstractAlgebra.jl implement the generic algorithms described below.</p><p>All of the generic functionality is part of the <code>Generic</code> submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.</p><h2><a class="nav-anchor" id="Types-and-parent-objects-1" href="#Types-and-parent-objects-1">Types and parent objects</a></h2><p>The types of generic series implemented by AbstractAlgebra.jl are <code>Generic.RelSeries{T}</code>, <code>Generic.AbsSeries{T}</code>, <code>Generic.LaurentSeriesRingElem{T}</code> and <code>Generic.LaurentSeriesFieldElem{T}</code>.</p><p>Relative power series elements belong to the abstract type <code>AbstractAlgebra.RelSeriesElem</code>.</p><p>Laurent series elements belong directly to either <code>AbstractAlgebra.RingElem</code> or <code>AbstractAlgebra.FieldElem</code> since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are relative series.</p><p>Absolute power series elements belong to <code>AbstractAlgebra.AbsSeriesElem</code>.</p><p>The parent types for relative and absolute power series, <code>Generic.RelSeriesRing{T}</code>  and <code>Generic.AbsSeriesRing{T}</code> respectively, belong to <code>AbstractAlgebra.SeriesRing{T}</code>.</p><p>The parent types for Laurent series rings and fields, <code>Generic.LaurentSeriesRing{T}</code> and <code>Generic.LaurentSeriesField{T}</code> respectively, belong directly to  <code>AbstractAlgebra.Ring</code> and <code>AbstractAlgebra.Field</code> respectively.</p><p>The default precision, string representation of the variable and base ring <span>$R$</span> of a generic power series are stored in its parent object. </p><h2><a class="nav-anchor" id="Series-ring-constructors-1" href="#Series-ring-constructors-1">Series ring constructors</a></h2><p>In order to construct series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.</p><pre><code class="language-julia">PowerSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true, model=:capped_relative)</code></pre><pre><code class="language-julia">LaurentSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><pre><code class="language-julia">LaurentSeriesRing(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><p>Given a base ring <code>R</code>, a maximum precision (relative or absolute, depending on the model) and a string <code>s</code> specifying how the generator (variable) should be printed, return a typle <code>S, x</code> representing the series ring and its generator.</p><p>By default, <code>S</code> will depend only on <code>S</code>, <code>x</code> and the maximum precision and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent this.</p><p>In the case of power series, the optional argument <code>model</code> can be set to either <code>:capped_absolute</code> or <code>capped_relative</code>, depending on which power series model is required.</p><p>Here are some examples of constructing various kinds of series rings and coercing various elements into those rings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, x = PowerSeriesRing(ZZ, 10, &quot;x&quot;)
(Univariate power series ring in x over Integers, x+O(x^11))

julia&gt; S, y = PowerSeriesRing(ZZ, 10, &quot;y&quot;; model=:capped_absolute)
(Univariate power series ring in y over Integers, y+O(y^10))

julia&gt; T, z = LaurentSeriesRing(ZZ, 10, &quot;z&quot;)
(Laurent series ring in z over Integers, z+O(z^11))

julia&gt; U, w = LaurentSeriesField(QQ, 10, &quot;w&quot;)
(Laurent series field in w over Rationals, w+O(w^11))

julia&gt; f = R()
0+O(x^10)

julia&gt; g = S(123)
123+O(y^10)

julia&gt; h = U(BigInt(1234))
1234//1+O(w^10)

julia&gt; k = T(z + 1)
1+z+O(z^10)
</code></pre><h2><a class="nav-anchor" id="Big-oh-notation-1" href="#Big-oh-notation-1">Big-oh notation</a></h2><p>Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):</p><pre><code class="language-julia">O(x::SeriesElem)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, x = PowerSeriesRing(ZZ, 10, &quot;x&quot;)
(Univariate power series ring in x over Integers, x+O(x^11))

julia&gt; S, y = LaurentSeriesRing(ZZ, 10, &quot;y&quot;)
(Laurent series ring in y over Integers, y+O(y^11))

julia&gt; f = 1 + 2x + O(x^5)
1+2*x+O(x^5)

julia&gt; g = 2y + 7y^2 + O(y^7)
2*y+7*y^2+O(y^7)
</code></pre><p>What is happening here in practice is that <code>O(x^n)</code> is creating the series <code>0 + O(x^n)</code> and the rules for addition of series dictate that if this is added to a series of  greater precision, then the lower of the two precisions must be used.</p><p>Of course it may be that the precision of the series that <code>O(x^n)</code> is added to is already lower than <code>n</code>, in which case adding <code>O(x^n)</code> has no effect. This is the case if the default precision is too low, since <code>x</code> on its own has the default precision.</p><h2><a class="nav-anchor" id="Power-series-models-1" href="#Power-series-models-1">Power series models</a></h2><p>Capped relative power series have their maximum relative precision capped at some value <code>prec_max</code>. This means that if the leading term of a nonzero power series element is <span>$c_ax^a$</span> and the precision is <span>$b$</span> then the power series is of the form  <span>$c_ax^a + c_{a+1}x^{a+1} + \ldots + O(x^{a + b})$</span>.</p><p>The zero power series is simply taken to be <span>$0 + O(x^b)$</span>.</p><p>The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series <span>$f$</span> and <span>$g$</span> we have that <code>divexact(f*g), g) == f</code>.</p><p>However, capped relative power series are not additively stable, i.e. we do not always have <span>$(f + g) - g = f$</span>.</p><p>Similar comments apply to Laurent series.</p><p>On the other hand, capped absolute power series have their absolute precision capped. This means that if the leading term of a nonzero power series element is <span>$c_ax^a$</span> and the precision is <span>$b$</span> then the power series is of the form <span>$c_ax^a + c_{a+1}x^{a+1} + \ldots + O(x^b)$</span>.</p><p>Capped absolute series are additively stable, but not necessarily multiplicatively stable.</p><p>For all models, the maximum precision is also used as a default precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.</p><p>In all models we say that two power series are equal if they agree up to the minimum <strong>absolute</strong> precision of the two power series.</p><p>Thus, for example, <span>$x^5 + O(x^{10}) == 0 + O(x^5)$</span>, since the minimum absolute precision is <span>$5$</span>.</p><p>During computations, it is possible for power series to lose relative precision due to cancellation. For example if <span>$f = x^3 + x^5 + O(x^8)$</span> and <span>$g = x^3 + x^6 + O(x^8)$</span> then <span>$f - g = x^5 - x^6 + O(x^8)$</span> which now has relative precision <span>$3$</span> instead of relative precision <span>$5$</span>.</p><p>Amongst other things, this means that equality is not transitive. For example <span>$x^6 + O(x^{11}) == 0 + O(x^5)$</span> and <span>$x^7 + O(x^{12}) == 0 + O(x^5)$</span> but <span>$x^6 + O(x^{11}) \neq x^7 + O(x^{12})$</span>.</p><p>Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the <code>isequal</code> function.</p><p>For example, if <span>$f = x^2 + O(x^7)$</span> and <span>$g = x^2 + O(x^8)$</span> and <span>$h = 0 + O(x^2)$</span> then <span>$f == g$</span>, <span>$f == h$</span> and <span>$g == h$</span>, but <code>isequal(f, g)</code>, <code>isequal(f, h)</code> and <code>isequal(g, h)</code> would all return <code>false</code>. However, if <span>$k = x^2 + O(x^7)$</span> then <code>isequal(f, k)</code> would return <code>true</code>.</p><p>There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in <span>$y$</span> over the power series ring in <span>$x$</span> over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of <span>$(0 + O(x^{10}))y + (1 + O(x^{10}))$</span>?</p><p>If one takes it to be <span>$(0 + O(x^{10}))$</span> then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.</p><p>On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!</p><p>One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don&#39;t satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.</p><p>Simply increasing the precision will not necessarily give a &quot;more correct&quot; answer and some computations may not even terminate due to the presence of arithmetic zeroes!</p><p>An absolute power series ring over a ring <span>$R$</span> with precision <span>$p$</span> behaves  very much like the quotient <span>$R[x]/(x^p)$</span> of the polynomial ring over <span>$R$</span>. Therefore one can often treat absolute power series rings as though they were rings. However, this depends on all series being given a precision equal to the specified maximum precision and not a lower precision.</p><h2><a class="nav-anchor" id="Basic-ring-functionality-1" href="#Basic-ring-functionality-1">Basic ring functionality</a></h2><p>All power series models provide the functionality described in the Ring and Series Ring interfaces.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S, x = PowerSeriesRing(ZZ, 10, &quot;x&quot;)
(Univariate power series ring in x over Integers, x+O(x^11))

julia&gt; f = 1 + 3x + x^3 + O(x^10)
1+3*x+x^3+O(x^10)

julia&gt; g = 1 + 2x + x^2 + O(x^10)
1+2*x+x^2+O(x^10)

julia&gt; h = zero(S)
0+O(x^10)

julia&gt; k = one(S)
1+O(x^10)

julia&gt; isone(k)
true

julia&gt; iszero(f)
false

julia&gt; n = pol_length(f)
4

julia&gt; c = polcoeff(f, 3)
1

julia&gt; U = base_ring(S)
Integers

julia&gt; v = var(S)
:x

julia&gt; T = parent(x + 1)
Univariate power series ring in x over Integers

julia&gt; g == deepcopy(g)
true

julia&gt; t = divexact(2g, 2)
1+2*x+x^2+O(x^10)

julia&gt; p = precision(f)
10
</code></pre><h2><a class="nav-anchor" id="Series-functionality-provided-by-AbstractAlgebra.jl-1" href="#Series-functionality-provided-by-AbstractAlgebra.jl-1">Series functionality provided by AbstractAlgebra.jl</a></h2><p>The functionality below is automatically provided by AbstractAlgebra.jl for any series module that implements the full Series Ring interface. This includes AbstractAlgebra&#39;s own generic series rings.</p><p>Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.</p><p>Unless otherwise noted, the functions are available for all series models, including Laurent series. We denote this by using the abstract type <code>AbstractAlgebra.RelSeriesElem</code>, even though absolute series and Laurent series types do not belong to this abstract type.</p><h3><a class="nav-anchor" id="Basic-functionality-1" href="#Basic-functionality-1">Basic functionality</a></h3><pre><code class="language-none">coeff(a::AbstractAlgebra.SeriesElem, n::Int)</code></pre><p>Return the degree <span>$n$</span> coefficient of the given power series. Note coefficients are numbered from <span>$n = 0$</span> for the constant coefficient. If <span>$n$</span> exceeds the current precision of the power series, the function returns a zero coefficient.</p><p>For power series types, <span>$n$</span> must be non-negative. Laurent series do not have this restriction.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T&lt;:ResElem" href="#AbstractAlgebra.Generic.modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T&lt;:ResElem"><code>AbstractAlgebra.Generic.modulus</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">modulus(a::AbstractAlgebra.SeriesElem{T}) where {T &lt;: ResElem}</code></pre><blockquote><p>Return the modulus of the coefficients of the given power series.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isgen-Tuple{RelSeriesElem}" href="#AbstractAlgebra.Generic.isgen-Tuple{RelSeriesElem}"><code>AbstractAlgebra.Generic.isgen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isgen(a::AbstractAlgebra.RelSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isunit-Tuple{RelSeriesElem}" href="#AbstractAlgebra.Generic.isunit-Tuple{RelSeriesElem}"><code>AbstractAlgebra.Generic.isunit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isunit(a::AbstractAlgebra.RelSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given power series is arithmetically equal to a unit, i.e. is invertible, otherwise return <code>false</code>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PowerSeriesRing(QQ, 10, &quot;t&quot;)
(Univariate power series ring in t over Rationals, t+O(t^11))

julia&gt; S, x = PowerSeriesRing(R, 30, &quot;x&quot;)
(Univariate power series ring in x over Univariate power series ring in t over Rationals, x+O(x^31))

julia&gt; a = O(x^4)
0//1+O(t^10)+O(x^4)

julia&gt; b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)
(3//1+t+O(t^10))*x+(1//1+t^2+O(t^10))*x^2+O(x^4)

julia&gt; k = isgen(gen(R))
true

julia&gt; m = isunit(-1 + x + 2x^2)
true

julia&gt; n = valuation(a)
4

julia&gt; p = valuation(b)
1

julia&gt; c = coeff(b, 2)
1//1+t^2+O(t^10)
</code></pre><h3><a class="nav-anchor" id="Shifting-1" href="#Shifting-1">Shifting</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.shift_left-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem" href="#AbstractAlgebra.Generic.shift_left-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem"><code>AbstractAlgebra.Generic.shift_left</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">shift_left(x::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T &lt;: RingElement}</code></pre><blockquote><p>Return the power series <span>$x$</span> shifted left by <span>$n$</span> terms, i.e. multiplied by <span>$x^n$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.shift_right-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem" href="#AbstractAlgebra.Generic.shift_right-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem"><code>AbstractAlgebra.Generic.shift_right</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">shift_right(x::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T &lt;: RingElement}</code></pre><blockquote><p>Return the power series <span>$x$</span> shifted right by <span>$n$</span> terms, i.e. divided by <span>$x^n$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PolynomialRing(QQ, &quot;t&quot;)
(Univariate Polynomial Ring in t over Rationals, t)

julia&gt; S, x = PowerSeriesRing(R, 30, &quot;x&quot;)
(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x+O(x^31))

julia&gt; a = 2x + x^3
2//1*x+x^3+O(x^31)

julia&gt; b = O(x^4)
0//1+O(x^4)

julia&gt; c = 1 + x + 2x^2 + O(x^5)
1//1+x+2//1*x^2+O(x^5)

julia&gt; d = 2x + x^3 + O(x^4)
2//1*x+x^3+O(x^4)

julia&gt; f = shift_left(a, 2)
2//1*x^3+x^5+O(x^33)

julia&gt; g = shift_left(b, 2)
0//1+O(x^6)

julia&gt; h = shift_right(c, 1)
1//1+2//1*x+O(x^4)

julia&gt; k = shift_right(d, 3)
1//1+O(x^1)
</code></pre><h3><a class="nav-anchor" id="Truncation-1" href="#Truncation-1">Truncation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.truncate-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem" href="#Base.truncate-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T&lt;:RingElem"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">truncate(a::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a$</span> truncated to (absolute) precision <span>$n$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PolynomialRing(QQ, &quot;t&quot;)
(Univariate Polynomial Ring in t over Rationals, t)

julia&gt; S, x = PowerSeriesRing(R, 30, &quot;x&quot;)
(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x+O(x^31))

julia&gt; a = 2x + x^3
2//1*x+x^3+O(x^31)

julia&gt; b = O(x^4)
0//1+O(x^4)

julia&gt; c = 1 + x + 2x^2 + O(x^5)
1//1+x+2//1*x^2+O(x^5)

julia&gt; d = 2x + x^3 + O(x^4)
2//1*x+x^3+O(x^4)

julia&gt; f = truncate(a, 3)
2//1*x+O(x^3)

julia&gt; g = truncate(b, 2)
0//1+O(x^2)

julia&gt; h = truncate(c, 7)
1//1+x+2//1*x^2+O(x^5)

julia&gt; k = truncate(d, 5)
2//1*x+x^3+O(x^4)
</code></pre><h3><a class="nav-anchor" id="Division-1" href="#Division-1">Division</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{RelSeriesElem}" href="#Base.inv-Tuple{RelSeriesElem}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><p>inv(a::AbstractAlgebra.RelSeriesElem)</p><blockquote><p>Return the inverse of the power series <span>$a$</span>, i.e. <span>$1/a$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PolynomialRing(QQ, &quot;t&quot;)
(Univariate Polynomial Ring in t over Rationals, t)

julia&gt; S, x = PowerSeriesRing(R, 30, &quot;x&quot;)
(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x+O(x^31))

julia&gt; a = 1 + x + 2x^2 + O(x^5)
1//1+x+2//1*x^2+O(x^5)

julia&gt; b = S(-1)
-1//1+O(x^30)

julia&gt; c = inv(a)
1//1-x-x^2+3//1*x^3-x^4+O(x^5)

julia&gt; d = inv(b)
-1//1+O(x^30)
</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{RelSeriesElem}" href="#Base.exp-Tuple{RelSeriesElem}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">exp(a::AbstractAlgebra.RelSeriesElem)</code></pre><blockquote><p>Return the exponential of the power series <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt-Tuple{RelSeriesElem}" href="#Base.sqrt-Tuple{RelSeriesElem}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span>.</div><div><p>sqrt(a::AbstractAlgebra.RelSeriesElem)</p><blockquote><p>Return the square root of the power series <span>$a$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PolynomialRing(QQ, &quot;t&quot;)
(Univariate Polynomial Ring in t over Rationals, t)

julia&gt; S, x = PowerSeriesRing(R, 30, &quot;x&quot;)
(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x+O(x^31))

julia&gt; T, z = PowerSeriesRing(QQ, 30, &quot;z&quot;)
(Univariate power series ring in z over Rationals, z+O(z^31))

julia&gt; a = 1 + z + 3z^2 + O(z^5)
1//1+z+3//1*z^2+O(z^5)

julia&gt; b = z + 2z^2 + 5z^3 + O(z^5)
z+2//1*z^2+5//1*z^3+O(z^5)

julia&gt; c = exp(x + O(x^40))
1//1+x+1//2*x^2+1//6*x^3+1//24*x^4+1//120*x^5+1//720*x^6+1//5040*x^7+1//40320*x^8+1//362880*x^9+1//3628800*x^10+1//39916800*x^11+1//479001600*x^12+1//6227020800*x^13+1//87178291200*x^14+1//1307674368000*x^15+1//20922789888000*x^16+1//355687428096000*x^17+1//6402373705728000*x^18+1//121645100408832000*x^19+1//2432902008176640000*x^20+1//51090942171709440000*x^21+1//1124000727777607680000*x^22+1//25852016738884976640000*x^23+1//620448401733239439360000*x^24+1//15511210043330985984000000*x^25+1//403291461126605635584000000*x^26+1//10888869450418352160768000000*x^27+1//304888344611713860501504000000*x^28+1//8841761993739701954543616000000*x^29+1//265252859812191058636308480000000*x^30+O(x^31)

julia&gt; d = divexact(x, exp(x + O(x^40)) - 1)
1//1-1//2*x+1//12*x^2-1//720*x^4+1//30240*x^6-1//1209600*x^8+1//47900160*x^10-691//1307674368000*x^12+1//74724249600*x^14-3617//10670622842880000*x^16+43867//5109094217170944000*x^18-174611//802857662698291200000*x^20+77683//14101100039391805440000*x^22-236364091//1693824136731743669452800000*x^24+657931//186134520519971831808000000*x^26-3392780147//37893265687455865519472640000000*x^28+O(x^29)

julia&gt; f = exp(b)
1//1+z+5//2*z^2+43//6*z^3+193//24*z^4+O(z^5)

julia&gt; h = sqrt(a)
1//1+1//2*z+11//8*z^2-11//16*z^3-77//128*z^4+O(z^5)
</code></pre><footer><hr/><a class="previous" href="../series_rings/"><span class="direction">Previous</span><span class="title">Series Ring Interface</span></a><a class="next" href="../puiseux/"><span class="direction">Next</span><span class="title">Generic Puiseux series</span></a></footer></article></body></html>
