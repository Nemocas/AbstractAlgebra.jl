<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate series · AbstractAlgebra.jl</title><meta name="title" content="Multivariate series · AbstractAlgebra.jl"/><meta property="og:title" content="Multivariate series · AbstractAlgebra.jl"/><meta property="twitter:title" content="Multivariate series · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li class="is-active"><a class="tocitem" href>Multivariate series</a><ul class="internal"><li><a class="tocitem" href="#Generic-multivariate-series"><span>Generic multivariate series</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Multivariate-series-ring-constructors"><span>Multivariate series ring constructors</span></a></li><li><a class="tocitem" href="#Basic-ring-functionality"><span>Basic ring functionality</span></a></li><li><a class="tocitem" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl"><span>Power series functionality provided by AbstractAlgebra.jl</span></a></li></ul></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href>Multivariate series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate series</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mseries.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-series"><a class="docs-heading-anchor" href="#Multivariate-series">Multivariate series</a><a id="Multivariate-series-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-series" title="Permalink"></a></h1><p>AbstractAlgebra.jl provide multivariate series over a commutative ring.</p><p>Series with capped absolute precision are provided with and without weights.</p><p>For the unweighted case precision in each variable can be set per series, but is capped at some maximum precision which is set when defining the ring.</p><p>For the weighted case, a single precision is set on the ring only. Terms are truncated at that precision (after applying weights).</p><h2 id="Generic-multivariate-series"><a class="docs-heading-anchor" href="#Generic-multivariate-series">Generic multivariate series</a><a id="Generic-multivariate-series-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-multivariate-series" title="Permalink"></a></h2><p>Generic multivariate series over a commutative ring, <code>AbsMSeries{T}</code> is implemented in <code>src/generic/AbsMSeries.jl</code>.</p><p>Such series are capped absolute series and have type <code>Generic.AbsMSeries{T}</code> where <code>T</code> is the type of elements of the coefficient ring.</p><p>Internally they consist of a multivariate polynomial. For unweighted series they also contain a vector of precisions, one for each variable.</p><p>For weighted series weights and a precision are stored on the ring only. The vector of precisions in the series objects is ignored.</p><p>See the file <code>src/generic/GenericTypes.jl</code> for details of the type.</p><p>The series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.</p><p>Only lex ordering is provided at present both weighted and unweighted, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.</p><p>Parent objects of such series have type <code>Generic.AbsMSeriesRing{T}</code>.</p><p>The symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>Multivariate series element types belong to the abstract type <code>MSeriesElem{T}</code> and the multivariate series ring types belong to the abstract type <code>MSeriesRing{T}</code>. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.</p><h2 id="Multivariate-series-ring-constructors"><a class="docs-heading-anchor" href="#Multivariate-series-ring-constructors">Multivariate series ring constructors</a><a id="Multivariate-series-ring-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-series-ring-constructors" title="Permalink"></a></h2><p>In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructors.</p><p>For the unweighted case:</p><pre><code class="language-julia hljs">power_series_ring(R::Ring, prec::Vector{Int}, s::AbstractVector{&lt;:VarName}; cached::Bool = true)</code></pre><p>Given a base ring <code>R</code> and a vector of strings <code>s</code> specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple <code>U, (x, y, ...)</code> representing the new series ring <span>$S$</span> and the generators <span>$x, y, \ldots$</span> of the ring as a tuple. By default the parent object <code>S</code> will depend on <code>R</code>, the precision vector and the variable names <code>x, y, ...</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object <code>S</code> from being cached.</p><p>In the weighted case:</p><pre><code class="nohighlight hljs">power_series_ring(R::Ring, weights::Vector{Int}, s::AbstractVector{&lt;:VarName}, prec::Int; cached::Bool = true)</code></pre><p>Given a base ring <code>R</code> and a vector of strings <code>s</code> specifying how the generators (variables) should be printed, along with a vector of weights, one for each variable and a bound on the (weighted) precision, return a tuple <code>U, (x, y, ...)</code> representing the new series ring <span>$S$</span> and the generators <span>$x, y, \ldots$</span> of the ring as a tuple. By default the parent object <code>S</code> will depend on <code>R</code>, the precision, the vector of weights and the variable names <code>x, y, ...</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object <code>S</code> from being cached.</p><p>Here are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.</p><p>Note that one can also use the function call <code>O(x^n)</code> with unweighted series to specify the precision in the variable <code>x</code> of a given series expression should be precision <code>n</code>.</p><div class="admonition is-info" id="Note-ad509ae3d2d0de08"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ad509ae3d2d0de08" title="Permalink"></a></header><div class="admonition-body"><p>It is not possible to use <code>x^0</code> in the <code>O()</code> function, since there is no distinction between <code>x^0</code> and <code>y^0</code> as far as the system is concerned. If one wishes to set the precision of a variable to precision <code>0</code>, one must use the <code>set_precision!</code> function described below.</p></div></div><p>If one wants a series with the same precision in all variables, one can use <code>O(R, n)</code> where <code>R</code> is the series ring and <code>n</code> is the desired precision.</p><p>If all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer in the constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = power_series_ring(ZZ, [2, 3], [:x, :y])
(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])

julia&gt; f = R()
O(y^3) + O(x^2)

julia&gt; g = R(123)
123 + O(y^3) + O(x^2)

julia&gt; h = R(BigInt(1234))
1234 + O(y^3) + O(x^2)

julia&gt; k = R(x + 1)
1 + x + O(y^3) + O(x^2)

julia&gt; m = x + y + O(y^2)
y + x + O(y^2) + O(x^2)

julia&gt; R, (x, y) = power_series_ring(ZZ, 3, [:x, :y])
(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])

julia&gt; n = x + y + O(R, 2)
y + x + O(y^2) + O(x^2)

julia&gt; R, (x, y) = power_series_ring(ZZ, [2, 3], 10, [:x, :y])
(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(10), y + O(10)])

julia&gt; R()
O(10)

julia&gt; R(x)
x + O(10)</code></pre><h2 id="Basic-ring-functionality"><a class="docs-heading-anchor" href="#Basic-ring-functionality">Basic ring functionality</a><a id="Basic-ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-ring-functionality" title="Permalink"></a></h2><p>Once a multivariate series ring is constructed, there are various ways to construct series in that ring.</p><p>The easiest way is simply using the generators returned by the <code>power_series_ring</code> constructor and build up the power series using basic arithmetic, as described in the Ring interface.</p><p>The power series rings in AbstractAlgebra.jl implement the full Ring interface.</p><p>We give some examples of such functionality. </p><div class="admonition is-info" id="Note-ea8801ca74adb60b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ea8801ca74adb60b" title="Permalink"></a></header><div class="admonition-body"><p>The divexact function can currently only divide by unit series (i.e. whose constant coefficient is invertible).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = power_series_ring(ZZ, [5], [:x])
(Multivariate power series ring in 1 variable over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])

julia&gt; f = x^3 + 3x + 21
21 + 3*x + x^3 + O(x^5)

julia&gt; h = zero(R)
O(x^5)

julia&gt; k = one(R)
1 + O(x^5)

julia&gt; isone(k)
true

julia&gt; iszero(f)
false

julia&gt; n = length(f)
3

julia&gt; U = base_ring(R)
Integers

julia&gt; v = symbols(R)
1-element Vector{Symbol}:
 :x

julia&gt; T = parent(x + 1)
Multivariate power series ring in 1 variable x
  over integers

julia&gt; f == deepcopy(f)
true

julia&gt; t = divexact(f*x, 1 + x)
21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)

julia&gt; R, (x, y) = power_series_ring(ZZ, [2, 3], 10, [:x, :y])
(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(10), y + O(10)])

julia&gt; f = 3x^2*y + 1
1 + 3*y*x^2 + O(10)

julia&gt; one(R)
1 + O(10)</code></pre><h2 id="Power-series-functionality-provided-by-AbstractAlgebra.jl"><a class="docs-heading-anchor" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl">Power series functionality provided by AbstractAlgebra.jl</a><a id="Power-series-functionality-provided-by-AbstractAlgebra.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl" title="Permalink"></a></h2><p>The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.</p><h3 id="Basic-functionality"><a class="docs-heading-anchor" href="#Basic-functionality">Basic functionality</a><a id="Basic-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality" title="Permalink"></a></h3><p>The following are provided for weighted and unweighted series:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.number_of_variables-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.number_of_variables-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.number_of_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_of_variables(R::AbsMSeriesRing)</code></pre><p>Return the number of variables in the series ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.symbols-Tuple{AbstractAlgebra.MSeriesRing}" href="#AbstractAlgebra.symbols-Tuple{AbstractAlgebra.MSeriesRing}"><code>AbstractAlgebra.symbols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbols(R::MSeriesRing)</code></pre><p>Return a vector of symbols, one for each of the variables of the series ring <span>$R$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/AbsMSeries.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precision(a::AbsMSeries)</code></pre><p>Return a vector of precisions, one for each variable in the series ring. If the ring is weighted the weighted precision is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}" href="#AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}"><code>AbstractAlgebra.coeff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coeff(a::AbsMSeries, n::Int)</code></pre><p>Return the coefficient of the <span>$n$</span>-th nonzero term of the series (or zero if there are fewer than <span>$n$</span> nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.characteristic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">characteristic(R::FracField{T}) where T &lt;: RingElem</code></pre><p>Return the characteristic of the given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/Fraction.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}" href="#AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}"><code>AbstractAlgebra.gen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen(R::AbsMSeriesRing, i::Int)</code></pre><p>Return the <span>$i$</span>-th generator (variable) of the series ring <span>$R$</span>. Numbering starts from <span>$1$</span> for the most significant variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gens(R::AbsMSeriesRing)</code></pre><p>Return a vector of the generators (variables) of the series ring <span>$R$</span>, starting with the most significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_gen-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.is_gen-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.is_gen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_gen(a::AbsMSeries)</code></pre><p>Return true if the series <span>$a$</span> is a generator of its parent series ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_unit-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.is_unit-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.is_unit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_unit(a::AbsMSeries)</code></pre><p>Return <code>true</code> if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(a::AbsMSeries)</code></pre><p>Return the number of nonzero terms in the series <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L50-L54">source</a></section></article><p>The following are only available for unweighted series.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.max_precision</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_precision(R::AbsMSeriesRing)</code></pre><p>Return a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.valuation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valuation(a::AbsMSeries)</code></pre><p>Return the valuation of <span>$a$</span> as a vector of integers, one for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L111-L115">source</a></section></article><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coefficients(a::AbsMSeries)</code></pre><p>Return an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.exponent_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponent_vectors(a::AbsMSeries)</code></pre><p>Return an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L227-L232">source</a></section></article><h3 id="Truncation"><a class="docs-heading-anchor" href="#Truncation">Truncation</a><a id="Truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Truncation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}" href="#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})</code></pre><p>Return <span>$a$</span> truncated to (absolute) precisions given by the vector <code>prec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}" href="#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncate(a::AbstractAlgebra.AbsMSeries, prec::Int)</code></pre><p>Return <span>$a$</span> truncated to precision <code>prec</code>. This either truncates by weight in the weighted cases or truncates each variable to precision <code>prec</code> in the unweighted case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L328-L334">source</a></section></article><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T}, AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T}}} where T&lt;:RingElem" href="#AbstractAlgebra.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T}, AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T}}} where T&lt;:RingElem"><code>AbstractAlgebra.divexact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divexact(x::AbsMSeries{T}, y::AbsMSeries{T}; check::Bool=true) where T &lt;: RingElement</code></pre><p>Return the exact quotient of the series <span>$x$</span> by the series <span>$y$</span>. This function currently assumes <span>$y$</span> is an invertible series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L544-L549">source</a></section></article><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables with indices given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L561-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L587-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S&lt;:MPolyRingElem{T})}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(a::U, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the variables the series ring to which <span>$a$</span> belongs. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/generic/AbsMSeries.jl#L600-L606">source</a></section></article><h3 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any}}" href="#Base.rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(S::MSeriesRing, term_range, v...)</code></pre><p>Return a random element of the series ring <span>$S$</span> with number of terms in the range given by <code>term_range</code> and where coefficients of the series are randomly generated in the base ring using the data given by <code>v</code>. The exponents of the variable in the terms will be less than the precision caps for the Ring <span>$S$</span> when it was created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/29805285735f6b425581e9a299c91cb60dbe0ddd/src/AbsMSeries.jl#L206-L214">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../puiseux/">« Generic Puiseux series</a><a class="docs-footer-nextpage" href="../residue/">Generic residue rings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 19 October 2025 03:35">Sunday 19 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
