<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic multivariate series · AbstractAlgebra.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractAlgebra.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualiation of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../rings/">Ring Interface</a></li><li><a class="tocitem" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="tocitem" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="tocitem" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpolynomial/">Generic sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../series/">Generic power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li class="is-active"><a class="tocitem" href>Generic multivariate series</a><ul class="internal"><li><a class="tocitem" href="#Types-and-parent-objects"><span>Types and parent objects</span></a></li><li><a class="tocitem" href="#Multivariate-series-ring-constructors"><span>Multivariate series ring constructors</span></a></li><li><a class="tocitem" href="#Basic-ring-functionality"><span>Basic ring functionality</span></a></li><li><a class="tocitem" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl"><span>Power series functionality provided by AbstractAlgebra.jl</span></a></li></ul></li><li><a class="tocitem" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../fields/">Field Interface</a></li><li><a class="tocitem" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Module Interface</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../matrix/">Generic matrices</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map/">Map interface</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href>Generic multivariate series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generic multivariate series</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mseries.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Generic-multivariate-series"><a class="docs-heading-anchor" href="#Generic-multivariate-series">Generic multivariate series</a><a id="Generic-multivariate-series-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-multivariate-series" title="Permalink"></a></h1><p>AbstractAlgebra.jl provides generic multivariate series over a commutative ring, implemented in <code>src/generic/AbsMSeries.jl</code>.</p><p>Currently only series with capped absolute precision are provided. The precision in each variable can be set, but is capped at some maximum precision which is set when defining the ring.</p><p>As well as implementing the Ring interface, there are numerous additional generic algorithms provided. We describe this generic functionality below.</p><p>All of the generic functionality is part of a submodule of AbstractAlgebra called <code>Generic</code>. This is exported by default so that it is not necessary to qualify the function names with the submodule name.</p><p>The series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.</p><p>Only lex ordering is provided at present, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.</p><h2 id="Types-and-parent-objects"><a class="docs-heading-anchor" href="#Types-and-parent-objects">Types and parent objects</a><a id="Types-and-parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-parent-objects" title="Permalink"></a></h2><p>Capped absolute generic series implemented using the AbstractAlgebra generics have type <code>Generic.AbsMSeries{T}</code> where <code>T</code> is the type of elements of the coefficient ring. Internally they consist of a multivariate polynomial and a vector of precisions, one for each variable. See the file <code>src/generic/GenericTypes.jl</code> for details.</p><p>Parent objects of such series have type <code>Generic.AbsMSeriesRing{T}</code>.</p><p>The symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.</p><p>The series element types belong to the abstract type <code>AbstractAlgebra.MSeriesElem{T}</code> and the series ring types belong to the abstract type <code>AbstractAlgebra.MSeriesRing{T}</code>. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.</p><h2 id="Multivariate-series-ring-constructors"><a class="docs-heading-anchor" href="#Multivariate-series-ring-constructors">Multivariate series ring constructors</a><a id="Multivariate-series-ring-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-series-ring-constructors" title="Permalink"></a></h2><p>In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructor.</p><pre><code class="language-julia">PowerSeriesRing(R::AbstractAlgebra.Ring, prec::Vector{Int}, s::Vector{U}; cached::Bool = true) where U &lt;: AbstractString</code></pre><p>Given a base ring <code>R</code> and vector of strings <code>s</code> specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple <code>U, (x, y, ...)</code> representing the new series ring <span>$S$</span> and the generators <span>$x, y, \ldots$</span> of the ring as a tuple. By default the parent object <code>S</code> will depend only on <code>R</code> and the variable names <code>x, y, ...</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object <code>S</code> from being cached.</p><p>Here are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.</p><p>Note that one can also use the function call <code>O(x^n)</code> to specify the precision in the variable <code>x</code> of a given series expression should be precision <code>n</code>.</p><p>Note that it is not possible to use <code>x^0</code> in this function, since there is no distinction between <code>x^0</code> and <code>y^0</code> as far as the system is concerned. If one wishes to set the precision of a variable to precision <code>0</code>, one must use the <code>set_precision!</code> function described below.</p><p>If one wants a series with the same precision in all variables, one can use <code>O(R, n)</code> where <code>R</code> is the series ring and <code>n</code> is the desired precision.</p><p>If all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y) = PowerSeriesRing(ZZ, [2, 3], [&quot;x&quot;, &quot;y&quot;])
(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])

julia&gt; f = R()
O(y^3) + O(x^2)

julia&gt; g = R(123)
123 + O(y^3) + O(x^2)

julia&gt; h = R(BigInt(1234))
1234 + O(y^3) + O(x^2)

julia&gt; k = R(x + 1)
1 + x + O(y^3) + O(x^2)

julia&gt; m = x + y + O(y^2)
y + x + O(y^2) + O(x^2)

julia&gt; R, (x, y) = PowerSeriesRing(ZZ, 3, [&quot;x&quot;, &quot;y&quot;])
(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])

julia&gt; n = x + y + O(R, 2)
y + x + O(y^2) + O(x^2)</code></pre><h2 id="Basic-ring-functionality"><a class="docs-heading-anchor" href="#Basic-ring-functionality">Basic ring functionality</a><a id="Basic-ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-ring-functionality" title="Permalink"></a></h2><p>Once a multivariate series ring is constructed, there are various ways to construct series in that ring.</p><p>The easiest way is simply using the generators returned by the <code>PowerSeriesRing</code> constructor and build up the power series using basic arithmetic, as described in the Ring interface.</p><p>The power series rings in AbstractAlgebra.jl implement the full Ring interface.</p><p>We give some examples of such functionality. Note that divexact can currently only divide by unit series (i.e. whose constant coefficient is invertible).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x,) = PowerSeriesRing(ZZ, [5], [&quot;x&quot;])
(Multivariate power series ring in x over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])

julia&gt; f = x^3 + 3x + 21
21 + 3*x + x^3 + O(x^5)

julia&gt; h = zero(R)
O(x^5)

julia&gt; k = one(R)
1 + O(x^5)

julia&gt; isone(k)
true

julia&gt; iszero(f)
false

julia&gt; n = length(f)
3

julia&gt; U = base_ring(R)
Integers

julia&gt; v = symbols(R)
1-element Array{Symbol,1}:
 :x

julia&gt; T = parent(x + 1)
Multivariate power series ring in x over Integers

julia&gt; f == deepcopy(f)
true

julia&gt; t = divexact(f*x, 1 + x)
21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)</code></pre><h2 id="Power-series-functionality-provided-by-AbstractAlgebra.jl"><a class="docs-heading-anchor" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl">Power series functionality provided by AbstractAlgebra.jl</a><a id="Power-series-functionality-provided-by-AbstractAlgebra.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl" title="Permalink"></a></h2><p>The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.</p><h3 id="Basic-functionality"><a class="docs-heading-anchor" href="#Basic-functionality">Basic functionality</a><a id="Basic-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.Generic.nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.Generic.nvars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nvars(R::AbsMSeriesRing)</code></pre><p>Return the number of variables in the series ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.symbols-Tuple{AbstractAlgebra.MSeriesRing}" href="#AbstractAlgebra.Generic.symbols-Tuple{AbstractAlgebra.MSeriesRing}"><code>AbstractAlgebra.Generic.symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbols(R::AbstractAlgebra.MSeriesRing)</code></pre><p>Return a vector of symbols, one for each of the variables of the series ring <span>$R$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">precision(a::AbsMSeries)</code></pre><p>Return a vector of precisions, one for each variable in the series ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.Generic.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.Generic.max_precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_precision(R::AbsMSeriesRing)</code></pre><p>Return a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.Generic.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.Generic.valuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valuation(a::AbsMSeries)</code></pre><p>Return the valuation of <span>$a$</span> as a vector of integers, one for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries,Int64}" href="#AbstractAlgebra.Generic.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries,Int64}"><code>AbstractAlgebra.Generic.coeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coeff(a::AbsMSeries, n::Int)</code></pre><p>Return the coefficient of the <span>$n$</span>-th nonzero term of the series (or zero if there are fewer than <span>$n$</span> nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.Generic.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.Generic.characteristic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">characteristic(R::AbstractAlgebra.FracField{T}) where T &lt;: RingElem</code></pre><p>Return the characteristic of the given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/Fraction.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing,Int64}" href="#AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing,Int64}"><code>AbstractAlgebra.gen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen(R::AbsMSeriesRing, i::Int)</code></pre><p>Return the <span>$i$</span>-th generator (variable) of the series ring <span>$R$</span>. Numbering starts from <span>$1$</span> for the most significant variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" href="#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(R::AbsMSeriesRing)</code></pre><p>Return a vector of the generators (variables) of the series ring <span>$R$</span>, starting with the most significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.isgen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isgen(a::AbsMSeries)</code></pre><p>Return true if the series <span>$a$</span> is a generator of its parent series ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.isunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isunit(a::AbsMSeries)</code></pre><p>Return <code>true</code> if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(a::AbsMSeries)</code></pre><p>Return the number of nonzero terms in the series <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L61">source</a></section></article><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.Generic.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.Generic.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficients(a::AbsMSeries)</code></pre><p>Return an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#AbstractAlgebra.Generic.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.Generic.exponent_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exponent_vectors(a::AbsMSeries)</code></pre><p>Return an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L241">source</a></section></article><h3 id="Truncation"><a class="docs-heading-anchor" href="#Truncation">Truncation</a><a id="Truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Truncation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries,Array{Int64,1}}" href="#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries,Array{Int64,1}}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})</code></pre><p>Return <span>$a$</span> truncated to (absolute) precisions given by the vector <code>prec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L368">source</a></section></article><h3 id="Inversion"><a class="docs-heading-anchor" href="#Inversion">Inversion</a><a id="Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}" href="#Base.inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.inv(x::AbsMSeries)</code></pre><p>Return the inverse of the series <span>$x$</span>. An exception is raised if the series is not a unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L515">source</a></section></article><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T,S} where S,AbstractAlgebra.Generic.AbsMSeries{T,S} where S}} where T&lt;:RingElem" href="#AbstractAlgebra.Generic.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T,S} where S,AbstractAlgebra.Generic.AbsMSeries{T,S} where S}} where T&lt;:RingElem"><code>AbstractAlgebra.Generic.divexact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divexact(x::AbsMSeries{T}, y::AbsMSeries{T}) where T &lt;: RingElement</code></pre><p>Return the exact quotient of the series <span>$x$</span> by the series <span>$y$</span>. This function currently assumes <span>$y$</span> is an invertible series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L553">source</a></section></article><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{Int64,1},Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{Int64,1},Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables with indices given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1},Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1},Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1}}} where U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the variables the series ring to which <span>$a$</span> belongs. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L612">source</a></section></article><h3 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractAlgebra.MSeriesRing,Any,Vararg{Any,N} where N}" href="#Base.rand-Tuple{AbstractAlgebra.MSeriesRing,Any,Vararg{Any,N} where N}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(S::AbstractAlgebra.MSeriesRing, term_range, v...)</code></pre><p>Return a random element of the series ring <span>$S$</span> with number of terms in the range given by <code>term_range</code> and where coefficients of the series are randomly generated in the base ring using the data given by <code>v</code>. The exponents of the variable in the terms will be less than the precision caps for the Ring <span>$S$</span> when it was created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/403843a6ee435aa4f06308a9ddb499b4f4bdeff1/src/generic/AbsMSeries.jl#L692">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../puiseux/">« Generic Puiseux series</a><a class="docs-footer-nextpage" href="../residue_rings/">Residue Ring Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 31 March 2021 14:07">Wednesday 31 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
