<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic Puiseux series · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../mpolynomial/">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li><a class="toctext" href="../series/">Generic power series</a></li><li class="current"><a class="toctext" href>Generic Puiseux series</a><ul class="internal"><li><a class="toctext" href="#Types-and-parent-objects-1">Types and parent objects</a></li><li><a class="toctext" href="#Puisuex-series-ring-constructors-1">Puisuex series ring constructors</a></li><li><a class="toctext" href="#Big-oh-notation-1">Big-oh notation</a></li><li><a class="toctext" href="#Puiseux-series-implementation-1">Puiseux series implementation</a></li><li><a class="toctext" href="#Basic-ring-functionality-1">Basic ring functionality</a></li><li><a class="toctext" href="#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1">Puiseux series functionality provided by AbstractAlgebra.jl</a></li></ul></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fields/">Field Interface</a></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../module/">Module Interface</a></li><li><a class="toctext" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="toctext" href="../submodule/">Submodules</a></li><li><a class="toctext" href="../quotient_module/">Quotient modules</a></li><li><a class="toctext" href="../direct_sum/">Direct Sums</a></li><li><a class="toctext" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><a class="toctext" href="../types/">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href>Generic Puiseux series</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/puiseux.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generic Puiseux series</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generic-Puiseux-series-1" href="#Generic-Puiseux-series-1">Generic Puiseux series</a></h1><p>AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring <span>$R$</span>.</p><p>Puiseux series are power series of the form <span>$a_jx^{j/m} + a_{j+1}x^{(j+1)/m} + \cdots + a_{k-1}x^{(k-1)/m} + O(x^{k/m})$</span> for some integer <span>$m &gt; 0$</span> where <span>$i \geq 0$</span>, <span>$a_i \in R$</span> and the relative precision <span>$k - j$</span> is at most equal to some specified precision <span>$n$</span>.</p><p>The generic Puiseux series module is implemented in <code>src/generic/PuiseuxSeries.jl</code>.</p><p>As well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.</p><p>All of the generic functionality is part of the <code>Generic</code> submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.</p><h2><a class="nav-anchor" id="Types-and-parent-objects-1" href="#Types-and-parent-objects-1">Types and parent objects</a></h2><p>The types of generic polynomials implemented by AbstractAlgebra.jl are <code>Generic.PuiseuxSeriesRingElem{T}</code> and <code>Generic.PuiseuxSeriesFieldElem{T}</code>.</p><p>Both series element types belong to the union type <code>Generic.PuiseuxSeriesElem</code>.</p><p>Puiseux series elements belong directly to either <code>AbstractAlgebra.RingElem</code> or <code>AbstractAlgebra.FieldElem</code> since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.</p><p>The parent types for Puiseux series, <code>Generic.PuiseuxSeriesRing{T}</code>  and <code>Generic.PuiseuxSeriesField{T}</code> respectively, belong to <code>AbstractAlgebra.Ring</code> and <code>AbstractAlgebra.Field</code> respectively.</p><p>The default precision, string representation of the variable and base ring <span>$R$</span> of a generic Puiseux series are stored in its parent object. </p><h2><a class="nav-anchor" id="Puisuex-series-ring-constructors-1" href="#Puisuex-series-ring-constructors-1">Puisuex series ring constructors</a></h2><p>In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.</p><pre><code class="language-julia">PuiseuxSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><pre><code class="language-julia">PuiseuxSeriesRing(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><pre><code class="language-julia">PuiseuxSeriesField(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><p>Given a base ring <code>R</code>, a maximum relative precision and a string <code>s</code> specifying how the generator (variable) should be printed, return a typle <code>S, x</code> representing the Puiseux series ring and its generator.</p><p>By default, <code>S</code> will depend only on <code>S</code>, <code>x</code> and the maximum precision and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent this.</p><p>Here are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)
(Puiseux series ring in x over Integers, x + O(x^11))

julia&gt; S, y = PuiseuxSeriesField(QQ, 10, &quot;y&quot;)
(Puiseux series field in y over Rationals, y + O(y^11))

julia&gt; f = R()
O(x^10)

julia&gt; g = S(123)
123 + O(y^10)

julia&gt; h = R(BigInt(1234))
1234 + O(x^10)

julia&gt; k = S(y + 1)
1 + y + O(y^10)
</code></pre><h2><a class="nav-anchor" id="Big-oh-notation-1" href="#Big-oh-notation-1">Big-oh notation</a></h2><p>Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):</p><pre><code class="language-julia">O(x::SeriesElem)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)
(Puiseux series ring in x over Integers, x + O(x^11))

julia&gt; f = 1 + 2x + O(x^5)
1 + 2*x + O(x^5)

julia&gt; g = 2x^(1//3) + 7x^(2//3) + O(x^(7//3))
2*x^(1//3) + 7*x^(2//3) + O(x^(7//3))</code></pre><p>What is happening here in practice is that <code>O(x^n)</code> is creating the series <code>0 + O(x^n)</code> and the rules for addition of series dictate that if this is added to a series of  greater precision, then the lower of the two precisions must be used.</p><p>Of course it may be that the precision of the series that <code>O(x^n)</code> is added to is already lower than <code>n</code>, in which case adding <code>O(x^n)</code> has no effect. This is the case if the default precision is too low, since <code>x</code> on its own has the default precision.</p><h2><a class="nav-anchor" id="Puiseux-series-implementation-1" href="#Puiseux-series-implementation-1">Puiseux series implementation</a></h2><p>Puiseux series have their maximum relative precision capped at some value <code>prec_max</code>. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.</p><p>The Puiseux series type stores such a Laurent series and a <code>scale</code> or denominator for the exponents. For example, <span>$f(x) = 1 + x^{1/3} + 2x^{2/3} + O(x^{7/3})$</span> would be stored as a Laurent series <span>$1 + x + 2x^2 + O(x^7)$</span> and a scale of <span>$3$</span>..</p><p>The maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.</p><p>In all models we say that two Puiseux series are equal if they agree up to the minimum <strong>absolute</strong> precision of the two power series.</p><p>Thus, for example, <span>$x^5 + O(x^{10}) == 0 + O(x^5)$</span>, since the minimum absolute precision is <span>$5$</span>.</p><p>Sometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the <code>isequal</code> function.</p><p>For example, if <span>$f = x^2 + O(x^7)$</span> and <span>$g = x^2 + O(x^8)$</span> and <span>$h = 0 + O(x^2)$</span> then <span>$f == g$</span>, <span>$f == h$</span> and <span>$g == h$</span>, but <code>isequal(f, g)</code>, <code>isequal(f, h)</code> and <code>isequal(g, h)</code> would all return <code>false</code>. However, if <span>$k = x^2 + O(x^7)$</span> then <code>isequal(f, k)</code> would return <code>true</code>.</p><p>There are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.</p><h2><a class="nav-anchor" id="Basic-ring-functionality-1" href="#Basic-ring-functionality-1">Basic ring functionality</a></h2><p>All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the <code>pol_length</code> and <code>polcoeff</code> functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)
(Puiseux series ring in x over Integers, x + O(x^11))

julia&gt; f = 1 + 3x + x^3 + O(x^10)
1 + 3*x + x^3 + O(x^10)

julia&gt; g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))
1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))

julia&gt; h = zero(S)
O(x^10)

julia&gt; k = one(S)
1 + O(x^10)

julia&gt; isone(k)
true

julia&gt; iszero(f)
false

julia&gt; U = base_ring(S)
Integers

julia&gt; v = var(S)
:x

julia&gt; T = parent(x + 1)
Puiseux series ring in x over Integers

julia&gt; g == deepcopy(g)
true

julia&gt; t = divexact(2g, 2)
1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))

julia&gt; p = precision(f)
10//1
</code></pre><h2><a class="nav-anchor" id="Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1" href="#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1">Puiseux series functionality provided by AbstractAlgebra.jl</a></h2><p>The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.</p><p>Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.</p><h3><a class="nav-anchor" id="Basic-functionality-1" href="#Basic-functionality-1">Basic functionality</a></h3><pre><code class="language-none">coeff(a::Generic.PuiseuxSeriesElem, n::Int)</code></pre><pre><code class="language-none">coeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})</code></pre><p>Return the coefficient of the term of exponent <span>$n$</span> of the given power series. If <span>$n$</span> exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.modulus-Union{Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T&lt;:ResElem" href="#AbstractAlgebra.Generic.modulus-Union{Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T&lt;:ResElem"><code>AbstractAlgebra.Generic.modulus</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">modulus(a::Generic.PuiseuxSeriesElem{T}) where {T &lt;: ResElem}</code></pre><blockquote><p>Return the modulus of the coefficients of the given Puiseux series.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.isgen-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}" href="#AbstractAlgebra.isgen-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}"><code>AbstractAlgebra.isgen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">isgen(a::Generic.PuiseuxSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.isunit-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}" href="#AbstractAlgebra.isunit-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}"><code>AbstractAlgebra.isunit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">isunit(a::Generic.PuiseuxSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given Puiseux series is arithmetically equal to a unit, i.e. is invertible, otherwise return <code>false</code>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PuiseuxSeriesRing(QQ, 10, &quot;t&quot;)
(Puiseux series field in t over Rationals, t + O(t^11))

julia&gt; S, x = PuiseuxSeriesRing(R, 30, &quot;x&quot;)
(Puiseux series field in x over Puiseux series field in t over Rationals, x + O(x^31))

julia&gt; a = O(x^4)
O(x^4)

julia&gt; b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)
(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)

julia&gt; k = isgen(gen(R))
true

julia&gt; m = isunit(-1 + x^(1//3) + 2x^2)
true

julia&gt; n = valuation(a)
4//1

julia&gt; p = valuation(b)
1//1

julia&gt; c = coeff(b, 2)
1 + t^2 + O(t^10)
</code></pre><h3><a class="nav-anchor" id="Division-1" href="#Division-1">Division</a></h3><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>inv(::Generic.PuiseuxSeriesElem)</code>. Check Documenter&#39;s build log for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, x = PuiseuxSeriesRing(QQ, 30, &quot;x&quot;)
(Puiseux series field in x over Rationals, x + O(x^31))

julia&gt; a = 1 + x + 2x^2 + O(x^5)
1 + x + 2*x^2 + O(x^5)

julia&gt; b = R(-1)
-1 + O(x^30)

julia&gt; c = inv(a)
1 - x - x^2 + 3*x^3 - x^4 + O(x^5)

julia&gt; d = inv(b)
-1 + O(x^30)
</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}" href="#Base.exp-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">exp(a::AbstractAlgebra.RelSeriesElem)</code></pre><blockquote><p>Return the exponential of the power series <span>$a$</span>.</p></blockquote></div><div><pre><code class="language-none">exp(a::Generic.LaurentSeriesElem)</code></pre><blockquote><p>Return the exponential of the power series <span>$a$</span>.</p></blockquote></div><div><pre><code class="language-none">exp(a::Generic.PuiseuxSeriesElem{T}) where T &lt;: RingElement</code></pre><blockquote><p>Return the exponential of the given Puiseux series <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}" href="#Base.sqrt-Tuple{Union{PuiseuxSeriesFieldElem{T}, PuiseuxSeriesRingElem{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">Base.sqrt(f::AbstractAlgebra.PolyElem{T}, check::Bool=true) where T &lt;: RingElement</code></pre><blockquote><p>Return the square root of <span>$f$</span> if it is a perfect square, otherwise an exception is raised. If <code>check</code> is set to <code>false</code> the function assumes the input is square and may not fully check this.</p></blockquote></div><div><pre><code class="language-none">sqrt(a::Generic.PuiseuxSeriesElem{T}) where T &lt;: RingElement</code></pre><blockquote><p>Return the square root of the given Puiseux series <span>$a$</span>.</p></blockquote></div><div><pre><code class="language-none">Base.sqrt(a::AbstractAlgebra.FracElem{T}) where T &lt;: RingElem</code></pre><blockquote><p>Return the square root of <span>$a$</span> if it is a square, otherwise raise an exception.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, t = PolynomialRing(QQ, &quot;t&quot;)
(Univariate Polynomial Ring in t over Rationals, t)

julia&gt; S, x = PuiseuxSeriesRing(R, 30, &quot;x&quot;)
(Puiseux series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))

julia&gt; T, z = PuiseuxSeriesRing(QQ, 30, &quot;z&quot;)
(Puiseux series field in z over Rationals, z + O(z^31))

julia&gt; a = 1 + z + 3z^2 + O(z^5)
1 + z + 3*z^2 + O(z^5)

julia&gt; b = z + 2z^2 + 5z^3 + O(z^5)
z + 2*z^2 + 5*z^3 + O(z^5)

julia&gt; c = exp(x + O(x^40))
1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)

julia&gt; d = divexact(x, exp(x + O(x^40)) - 1)
1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)

julia&gt; f = exp(b)
1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)

julia&gt; h = sqrt(a)
1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)
</code></pre><footer><hr/><a class="previous" href="../series/"><span class="direction">Previous</span><span class="title">Generic power series</span></a><a class="next" href="../residue_rings/"><span class="direction">Next</span><span class="title">Residue Ring Interface</span></a></footer></article></body></html>
