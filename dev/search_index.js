var documenterSearchIndex = {"docs":
[{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"map_cache/#Cached-maps","page":"Cached maps","title":"Cached maps","text":"","category":"section"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"All basic map (i.e. those not built up from other maps) in AbstractAlgebra can be cached.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"A cache is a dictionary that can be switched on and off at run time that keeps a cache of previous evaluations of the map. This can be useful if the map is extremely difficult to evaluate, e.g. a discrete logarithm map. Rather than evaluate the map afresh each time, the map first looks up the dictionary of previous known values of the map.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"To facilitate caching of maps, the Generic module provides a type Generic.MapCache, which can be used to wrap any existing map object with a dictionary.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Importantly, the supertype of the resulting MapCache object is identical to that of the map being cached. This means that any functions that would accept the original map will also accept the cached version.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Note that caching of maps only works for maps that correctly abstract access to their fields using accessor functions, as described in the map interface.","category":"page"},{"location":"map_cache/#Cached-map-constructors","page":"Cached maps","title":"Cached map constructors","text":"","category":"section"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"To construct a cached map from an existing map object, we have the following function:","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"cached(M::Map; enabled=true, limit=100)","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Return a cached map with the same supertype as M, caching up to limit values of the map M in a dictionary, assuming that the cache is enabled.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Caches can be disabled by setting the value of the parameter enabled to false. This allows for the user to quickly go through code and completely disable caches of maps that were previously enabled, for testing purposes, etc.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Caches can also be turned on and off at run time (see below).","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Examples","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"julia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> g = cached(f);\n\njulia> f(ZZ(1)) == g(ZZ(1))\ntrue","category":"page"},{"location":"map_cache/#Functionality-for-cached-maps","page":"Cached maps","title":"Functionality for cached maps","text":"","category":"section"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"The following functions are provided for cached maps.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"enable_cache!(M::MapCache)\ndisable_cache!(M::MapCache)","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Temporarily enable or disable the cache for the given map. The values stored in the cache are not lost when it is disabled.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"set_limit!(M::MapCache, limit::Int)","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Set the limit on the number of values that can be cached in the dictionary, to the given value. Setting the value to 0 will effectively disable further caching for this map.","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"Examples","category":"page"},{"location":"map_cache/","page":"Cached maps","title":"Cached maps","text":"julia> f = cached(map_from_func(x -> x + 1, ZZ, ZZ));\n\njulia> a = f(ZZ(1))\n2\n\njulia> disable_cache!(f)\n\njulia> b = f(ZZ(1))\n2\n\njulia> enable_cache!(f)\n\njulia> c = f(ZZ(1))\n2\n\njulia> set_limit!(f, 200)\n200\n\njulia> d = f(ZZ(1))\n2","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"polynomial/#Generic-univariate-polynomials","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/Poly.jl for generic polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"As well as implementing the Univariate Polynomial interface, and relevant parts of the Euclidean Ring interface for polynomials over a field, there are many additional generic algorithms implemented for such polynomial rings. We describe this generic functionality below.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"polynomial/#Types-and-parent-objects","page":"Generic univariate polynomials","title":"Types and parent objects","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Polynomials implemented using the AbstractAlgebra generics have type Generic.Poly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Parent objects of such polynomials have type Generic.PolyRing{T}.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The polynomial element types belong to the abstract type AbstractAlgebra.PolyElem{T} and the polynomial ring types belong to the abstract type AbstractAlgebra.PolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Note that both the generic polynomial ring type Generic.PolyRing{T} and the abstract type it belongs to, AbstractAlgebra.PolyRing{T}, are called PolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"polynomial/#Polynomial-ring-constructors","page":"Generic univariate polynomials","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"PolynomialRing(R::AbstractAlgebra.Ring, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Given a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring. By default the parent object S will depend only on R and x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"A shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"R[\"x\"]","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = QQ[\"z\"]\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> f = R()\n0\n\njulia> g = R(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n\njulia> m = T(z + 1)\nz + 1\n","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a PolynomialRing constructor to allow creation of their polynomial rings.","category":"page"},{"location":"polynomial/#Basic-ring-functionality","page":"Generic univariate polynomials","title":"Basic ring functionality","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The easiest way is simply using the generator returned by the PolynomialRing constructor and build up the polynomial using basic arithmetic, as described in the Ring interface.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The Julia language also has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The polynomial rings in AbstractAlgebra.jl implement the full Ring interface. Of course the entire Univariate Polynomial Ring interface is also implemented.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"We give some examples of such functionality.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + 3*x + 21\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + 2*x + 1\n\njulia> h = zero(S)\n0\n\njulia> k = one(R)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(g)\n3\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Integers\n\njulia> V = base_ring(y + 1)\nUnivariate Polynomial Ring in x over Integers\n\njulia> v = var(S)\n:y\n\njulia> T = parent(y + 1)\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n(x + 1)*y^2 + 2*x + 1\n","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"For polynomials over a field, the Euclidean Ring interface is implemented.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, y)\n\njulia> f = (3*x^2 + x + 2)*y + x^2 + 1\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\n(5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1\n\njulia> h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n(2*x^2 - 8*x + 4)*y^5 + 2*x*y + 1\n\njulia> invmod(f, g)\n(707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765\n\njulia> mulmod(f, g, h)\n(-30*x^2 - 43*x - 9)*y^3 + (-7*x^2 - 23*x - 7)*y^2 + (4*x^2 - 10*x - 3)*y + (x^2 - 2*x)\n\njulia> powermod(f, 3, h)\n(69*x^2 + 243*x + 79)*y^3 + (78*x^2 + 180*x + 63)*y^2 + (27*x^2 + 42*x + 18)*y + 3*x^2 + 3*x + 2\n\njulia> h = mod(f, g)\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> q, r = divrem(f, g)\n(0, (3*x^2 + x + 2)*y + x^2 + 1)\n\njulia> d = gcd(f*h, g*h)\ny + 1//11*x^2 + 6//11\n\njulia> k = gcdinv(f, h)\n(y + 1//11*x^2 + 6//11, 0)\n\njulia> m = lcm(f, h)\n(-14*x^2 - 23*x - 2)*y - 4*x^2 - 5*x + 1\n\njulia> flag, q = divides(g^2, g)\n(true, (5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1)\n\njulia> valuation(3g^3, g) == 3\ntrue\n\njulia> val, q = remove(5g^3, g)\n(3, 5)\n\njulia> r, s, t = gcdx(g, h)\n(1, 311//3530*x^2 - 2419//3530*x + 947//1765, (707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765)\n","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Functions in the Euclidean Ring interface are supported over residue rings that are not fields, except that if an impossible inverse is encountered during the computation an error is thrown.","category":"page"},{"location":"polynomial/#Polynomial-functionality-provided-by-AbstractAlgebra.jl","page":"Generic univariate polynomials","title":"Polynomial functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any polynomial module that implements the full Univariate Polynomial Ring interface. This includes AbstractAlgebra.jl's own generic polynomial rings.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"But if a C library provides all the functionality documented in the Univariate Polynomial Ring interface, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that polynomial type.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Of course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"polynomial/#Basic-functionality","page":"Generic univariate polynomials","title":"Basic functionality","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"modulus{T <: ResElem}(::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.modulus-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:ResElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.modulus","text":"modulus(a::AbstractAlgebra.PolyElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"leading_coefficient(::PolyElem)\ntrailing_coefficient(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.leading_coefficient-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(a::Generic.PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\nleading_coefficient(p::MPolyElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.trailing_coefficient-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.trailing_coefficient","text":"trailing_coefficient(a::Generic.PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"constant_coefficient(::Generic.PolynomialElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.constant_coefficient-Tuple{Union{NCPolyElem{T}, PolyElem{T}} where T}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.constant_coefficient","text":"constant_coefficient(a::Generic.PolynomialElem)\n\nReturn the constant coefficient of the given polynomial. If the polynomial is the zero polynomial, the function will return zero.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"gen(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.gen-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.gen","text":"gen(a::MPolyRing{T}, i::Int) where {T <: RingElement}\n\nReturn the i-th generator (variable) of the given polynomial ring.\n\n\n\ngen(R::AbsSeriesRing{T}) where T <: RingElement\n\nReturn the generator of the power series ring, i.e. x + O(x^n) where n is the precision of the power series ring R.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"isgen(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.isgen-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.isgen","text":"isgen(a::Generic.PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\nisgen(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is a generator (variable) of the polynomial ring it belongs to.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"ismonic(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.ismonic-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.ismonic","text":"ismonic(a::Generic.PolyElem)\n\nReturn true if the given polynomial is monic, i.e. has leading coefficient equal to one, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"isunit(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.isunit-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.isunit","text":"isunit(a::Generic.PolynomialElem)\n\nReturn true if the given polynomial is a unit in its polynomial ring, otherwise return false.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"issquare(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.issquare-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.issquare","text":"issquare(f::AbstractAlgebra.PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::AbstractAlgebra.FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"degree(::Generic.PolynomialElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.degree-Tuple{Union{NCPolyElem{T}, PolyElem{T}} where T}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.degree","text":"degree(a::Generic.PolynomialElem)\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"ismonomial(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.ismonomial-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.ismonomial","text":"ismonomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\nismonomial(x::AbstractAlgebra.MPolyElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"ismonomial_recursive(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.ismonomial_recursive-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.ismonomial_recursive","text":"ismonomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"isterm(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.isterm-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.isterm","text":"isterm(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\nisterm(x::MPoly)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"isterm_recursive(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.isterm_recursive-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.isterm_recursive","text":"isterm_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial has one term. This function is recursive, with all scalar types returning true.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = PolynomialRing(QQ, \"z\")\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> U = ResidueRing(ZZ, 17)\nResidue ring of Integers modulo 17\n\njulia> V, w = PolynomialRing(U, \"w\")\n(Univariate Polynomial Ring in w over Residue ring of Integers modulo 17, w)\n\njulia> a = zero(S)\n0\n\njulia> b = one(S)\n1\n\njulia> c = BigInt(1)//2*z^2 + BigInt(1)//3\n1//2*z^2 + 1//3\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(S)\ny\n\njulia> g = isgen(w)\ntrue\n\njulia> m = isunit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> r = modulus(w)\n17\n\njulia> isterm(2y^2)\ntrue\n\njulia> ismonomial(y^2)\ntrue\n\njulia> ismonomial_recursive(x*y^2)\ntrue\n\njulia> ismonomial(x*y^2)\nfalse\n","category":"page"},{"location":"polynomial/#Iterators","page":"Generic univariate polynomials","title":"Iterators","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"An iterator is provided to return the coefficients of a univariate polynomial. The iterator is called coefficients and allows iteration over the coefficients, starting with the term of degree zero (if there is one). Note that coefficients of each degree are given, even if they are zero. This is best illustrated by example.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = x^2 + 2\nx^2 + 2\n\njulia> C = collect(coefficients(f))\n3-element Array{Any,1}:\n 2\n 0\n 1\n\njulia> for c in coefficients(f)\n          println(c)\n       end\n2\n0\n1","category":"page"},{"location":"polynomial/#Truncation","page":"Generic univariate polynomials","title":"Truncation","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"truncate(::PolyElem, ::Int)","category":"page"},{"location":"polynomial/#Base.truncate-Tuple{PolyElem,Int64}","page":"Generic univariate polynomials","title":"Base.truncate","text":"truncate(a::Generic.PolynomialElem, n::Int)\n\nReturn a truncated to n terms.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"mullow{T <: RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.mullow-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T},Int64}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.mullow","text":"mullow(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}, n::Int) where {T <: RingElement}\n\nReturn atimes b truncated to n terms.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = truncate(f, 1)\n3\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + 3*x^2 + 4*x + 1)*y^2 + (x^4 + x^3 + 2*x^2 + 7*x + 5)*y + 3*x^3 + 6*x + 6\n","category":"page"},{"location":"polynomial/#Reversal","page":"Generic univariate polynomials","title":"Reversal","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"reverse(::PolyElem, ::Int)\nreverse(::PolyElem)","category":"page"},{"location":"polynomial/#Base.reverse-Tuple{PolyElem,Int64}","page":"Generic univariate polynomials","title":"Base.reverse","text":"reverse(x::Generic.PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n","category":"method"},{"location":"polynomial/#Base.reverse-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"Base.reverse","text":"reverse(x::Generic.PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = reverse(f, 7)\n3*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n3*y^2 + (x + 1)*y + x\n","category":"page"},{"location":"polynomial/#Shifting","page":"Generic univariate polynomials","title":"Shifting","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"shift_left(::PolyElem, ::Int)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.shift_left-Tuple{PolyElem,Int64}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.shift_left","text":"shift_left(f::Generic.PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"shift_right(::PolyElem, ::Int)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.shift_right-Tuple{PolyElem,Int64}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.shift_right","text":"shift_right(f::Generic.PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + 3*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"page"},{"location":"polynomial/#Square-root","page":"Generic univariate polynomials","title":"Square root","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Base.sqrt(::PolyElem{T}, ::Bool) where T <: RingElement","category":"page"},{"location":"polynomial/#Base.sqrt-Union{Tuple{T}, Tuple{PolyElem{T},Bool}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic univariate polynomials","title":"Base.sqrt","text":"Base.sqrt(f::AbstractAlgebra.PolyElem{T}, check::Bool=true) where T <: RingElement\n\nReturn the square root of f if it is a perfect square, otherwise an exception is raised. If check is set to false the function assumes the input is square and may not fully check this.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\ng = x^2+6*x+1\nsqrt(g^2)","category":"page"},{"location":"polynomial/#Change-of-base-ring","page":"Generic univariate polynomials","title":"Change of base ring","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"change_base_ring(::Ring, ::PolyElem{T}) where T <: RingElement\nmap_coeffs(::Any, ::PolyElem{<:RingElement})","category":"page"},{"location":"polynomial/#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,PolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic univariate polynomials","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, p::PolyElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.Generic.map_coeffs-Tuple{Any,PolyElem{var\"#s4\"} where var\"#s4\"<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.map_coeffs","text":"map_coeffs(f, p::PolyElem{<: RingElement}; parent::PolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\ng = x^3+6*x + 1\nchange_base_ring(GF(2), g)","category":"page"},{"location":"polynomial/#Pseudodivision","page":"Generic univariate polynomials","title":"Pseudodivision","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Given two polynomials a b, pseudodivision computes polynomials q and r with length(r)  length(b) such that L^d a = bq + r where d = length(a) - length(b) + 1 and L is the leading coefficient of b.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"We call q the pseudoquotient and r the pseudoremainder.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"pseudorem{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.pseudorem-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.pseudorem","text":"pseudorem(f::AbstractAlgebra.PolyElem{T}, g::AbstractAlgebra.PolyElem{T}) where {T <: RingElement}\n\nReturn the pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"pseudodivrem{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.pseudodivrem-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.pseudodivrem","text":"pseudodivrem(f::AbstractAlgebra.PolyElem{T}, g::AbstractAlgebra.PolyElem{T}) where {T <: RingElement}\n\nReturn a tuple (q r) consisting of the pseudoquotient and pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = pseudorem(f, g)\nx^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1\n\njulia> q, r = pseudodivrem(f, g)\n((x^2 + x)*y - x^4 - x^2 + 1, x^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1)\n","category":"page"},{"location":"polynomial/#Content-and-primitive-part","page":"Generic univariate polynomials","title":"Content and primitive part","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"content(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.content-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.content","text":"content(a::AbstractAlgebra.PolyElem)\n\nReturn the content of a, i.e. the greatest common divisor of its coefficients.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"primpart(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.primpart-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.primpart","text":"primpart(a::AbstractAlgebra.PolyElem)\n\nReturn the primitive part of a, i.e. the polynomial divided by its content.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\nk = x*y^2 + (x + 1)*y + 3\n\nn = content(k)\np = primpart(k*(x^2 + 1))","category":"page"},{"location":"polynomial/#Evaluation,-composition-and-substitution","page":"Generic univariate polynomials","title":"Evaluation, composition and substitution","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"evaluate{T <: RingElem}(::PolyElem{T}, ::T)\nevaluate(::PolyElem, ::Integer)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{T}, Tuple{PolyElem{T},T}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.PolyElem, b::T) where {T <: RingElement}\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.Generic.evaluate-Tuple{PolyElem,Integer}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.PolyElem, b::T) where {T <: RingElement}\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"compose(::PolyElem, ::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.compose-Tuple{PolyElem,PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.compose","text":"compose(a::AbstractAlgebra.PolyElem, b::AbstractAlgebra.PolyElem)\n\nCompose the polynomial a with the polynomial b and return the result, i.e. return acirc b.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"subst{T <: RingElem}(::PolyElem{T}, ::Any)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.subst-Union{Tuple{T}, Tuple{PolyElem{T},Any}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.subst","text":"subst(f::AbstractAlgebra.PolyElem{T}, a::Any) where {T <: RingElement}\n\nEvaluate the polynomial f at a. Note that a can be anything, whether a ring element or not.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a).","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> M = R[x + 1 2x; x - 3 2x - 1]\n[x + 1       2*x]\n[x - 3   2*x - 1]\n\njulia> k = evaluate(f, 3)\n12*x + 6\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + 4*x^4 + 7*x^3 + 7*x^2 + 4*x + 4\n\njulia> n = compose(f, g)\n(x^3 + 2*x^2 + x)*y^2 + (2*x^5 + 2*x^4 + 4*x^3 + 9*x^2 + 6*x + 1)*y + x^7 + 4*x^5 + 5*x^4 + 5*x^3 + 10*x^2 + 8*x + 5\n\njulia> p = subst(f, M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> q = f(M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> r = f(23)\n552*x + 26\n","category":"page"},{"location":"polynomial/#Derivative-and-integral","page":"Generic univariate polynomials","title":"Derivative and integral","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"derivative(::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.derivative-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.derivative","text":"derivative(a::Generic.PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\nderivative(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the derivative of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\nderivative(f::AbsSeriesElem{T}) -> AbsSeriesElem\n\nReturn the derivative of the power series f.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"integral{T <: Union{ResElem, FieldElem}}(::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.integral-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:Union{FieldElem, ResElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.integral","text":"integral(x::AbstractAlgebra.PolyElem{T}) where {T <: Union{AbstractAlgebra.ResElem, FieldElement}}\n\nReturn the integral of the polynomial x.\n\n\n\nintegral(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the integral of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\nintegral(f::AbsSeriesElem{T}) -> AbsSeriesElem\n\nReturn the integral of the power series f.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = PolynomialRing(QQ, \"z\")\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> U = ResidueRing(T, z^3 + 3z + 1)\nResidue ring of Univariate Polynomial Ring in z over Rationals modulo z^3 + 3*z + 1\n\njulia> V, w = PolynomialRing(U, \"w\")\n(Univariate Polynomial Ring in w over Residue ring of Univariate Polynomial Ring in z over Rationals modulo z^3 + 3*z + 1, w)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n(z^2 + 2*z + 1)*w^2 + (z + 1)*w - 2*z + 4\n\njulia> h = derivative(f)\n2*x*y + x + 1\n\njulia> k = integral(g)\n(1//3*z^2 + 2//3*z + 1//3)*w^3 + (1//2*z + 1//2)*w^2 + (-2*z + 4)*w\n","category":"page"},{"location":"polynomial/#Resultant-and-discriminant","page":"Generic univariate polynomials","title":"Resultant and discriminant","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"sylvester_matrix{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.sylvester_matrix-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.sylvester_matrix","text":"sylvester_matrix(p::PolyElem, q::PolyElem)\n\nReturn the sylvester matrix of the given polynomials.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"resultant{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.resultant-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.resultant","text":"resultant(p::AbstractAlgebra.PolyElem{T}, q::AbstractAlgebra.PolyElem{T}) where {T <: RingElement}\n\nReturn the resultant of the given polynomials.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"resx{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.resx-Union{Tuple{T}, Tuple{PolyElem{T},PolyElem{T}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.resx","text":"resx(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}) where {T <: RingElement}\n\nReturn a tuple (r s t) such that r is the resultant of a and b and such that r = atimes s + btimes t.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"discriminant(a::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.discriminant-Tuple{PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.discriminant","text":"discriminant(a::AbstractAlgebra.PolyElem)\n\nReturn the discriminant of the given polynomial.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = 6(x + 1)*y + (x^3 + 2x + 2)\n(6*x + 6)*y + x^3 + 2*x + 2\n\njulia> S = sylvester_matrix(f, g)\n[    3*x           x + 1               3]\n[6*x + 6   x^3 + 2*x + 2               0]\n[      0         6*x + 6   x^3 + 2*x + 2]\n\njulia> h = resultant(f, g)\n3*x^7 + 6*x^5 - 6*x^3 + 96*x^2 + 192*x + 96\n\njulia> k = discriminant(f)\nx^2 - 34*x + 1\n","category":"page"},{"location":"polynomial/#Newton-representation","page":"Generic univariate polynomials","title":"Newton representation","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"monomial_to_newton!{T <: RingElem}(::Array{T, 1}, ::Array{T, 1})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.monomial_to_newton!-Union{Tuple{T}, Tuple{Array{T,1},Array{T,1}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.monomial_to_newton!","text":"monomial_to_newton!(P::Array{T, 1}, roots::Array{T, 1}) where {T <: RingElement}\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots r_0 r_1 ldots r_n-2. In other words, this determines output coefficients c_i such that c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) is equal to the input polynomial.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"newton_to_monomial!{T <: RingElem}(::Array{T, 1}, ::Array{T, 1})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.newton_to_monomial!-Union{Tuple{T}, Tuple{Array{T,1},Array{T,1}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.newton_to_monomial!","text":"newton_to_monomial!(P::Array{T, 1}, roots::Array{T, 1}) where {T <: RingElement}\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots r_0 r_1 ldots r_n-2 to the standard monomial basis. In other words, this evaluates c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) where c_i are the input coefficients given by p.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = deepcopy(f)\n3*x*y^2 + (x + 1)*y + 3\n\njulia> roots = [R(1), R(2), R(3)]\n3-element Array{AbstractAlgebra.Generic.Poly{BigInt},1}:\n 1\n 2\n 3\n\njulia> monomial_to_newton!(g.coeffs, roots)\n\njulia> newton_to_monomial!(g.coeffs, roots)\n","category":"page"},{"location":"polynomial/#Interpolation","page":"Generic univariate polynomials","title":"Interpolation","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"interpolate{T <: RingElem}(::PolyRing, ::Array{T, 1}, ::Array{T, 1})","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.interpolate-Union{Tuple{T}, Tuple{PolyRing,Array{T,1},Array{T,1}}} where T<:RingElem","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.interpolate","text":"interpolate(S::AbstractAlgebra.PolyRing, x::Array{T, 1}, y::Array{T, 1}) where {T <: RingElement}\n\nGiven two arrays of values xs and ys of the same length n, find the polynomial f in the polynomial ring R of length at most n such that f has the value ys at the points xs. The values in the arrays xs and ys must belong to the base ring of the polynomial ring R. If no such polynomial exists, an exception is raised.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> xs = [R(1), R(2), R(3), R(4)]\n4-element Array{AbstractAlgebra.Generic.Poly{BigInt},1}:\n 1\n 2\n 3\n 4\n\njulia> ys = [R(1), R(4), R(9), R(16)]\n4-element Array{AbstractAlgebra.Generic.Poly{BigInt},1}:\n 1\n 4\n 9\n 16\n\njulia> f = interpolate(S, xs, ys)\ny^2\n","category":"page"},{"location":"polynomial/#Special-functions","page":"Generic univariate polynomials","title":"Special functions","text":"","category":"section"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"The following special functions can be computed for any polynomial ring. Typically one uses the generator x of a polynomial ring to get the respective special polynomials expressed in terms of that generator.","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"chebyshev_t(::Int, ::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.chebyshev_t-Tuple{Int64,PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.chebyshev_t","text":"chebyshev_t(n::Int, x::AbstractAlgebra.PolyElem)\n\nReturn the Chebyshev polynomial of the first kind T_n(x), defined by T_n(x) = cos(n cos^-1(x)).\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"chebyshev_u(::Int, ::PolyElem)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.chebyshev_u-Tuple{Int64,PolyElem}","page":"Generic univariate polynomials","title":"AbstractAlgebra.Generic.chebyshev_u","text":"chebyshev_u(n::Int, x::AbstractAlgebra.PolyElem)\n\nReturn the Chebyshev polynomial of the first kind U_n(x), defined by (n+1) U_n(x) = T_n+1(x).\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Generic univariate polynomials","title":"Generic univariate polynomials","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = chebyshev_t(20, y)\n524288*y^20 - 2621440*y^18 + 5570560*y^16 - 6553600*y^14 + 4659200*y^12 - 2050048*y^10 + 549120*y^8 - 84480*y^6 + 6600*y^4 - 200*y^2 + 1\n\njulia> g = chebyshev_u(15, y)\n32768*y^15 - 114688*y^13 + 159744*y^11 - 112640*y^9 + 42240*y^7 - 8064*y^5 + 672*y^3 - 16*y\n","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"real/#Real-field","page":"Real field","title":"Real field","text":"","category":"section"},{"location":"real/","page":"Real field","title":"Real field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Float.jl for making Julia BigFloats conform to the AbstractAlgebra.jl Field interface.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"In addition to providing a parent object RealField for Julia BigFloats, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"Because BigFloat cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigFloats by introducing a type union, called FieldElement, which is a union of AbstractAlgebra.FieldElem and a number of Julia types, including BigFloat. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigFloat type as belonging to AbstractAlgebra.FieldElem.","category":"page"},{"location":"real/#Types-and-parent-objects","page":"Real field","title":"Types and parent objects","text":"","category":"section"},{"location":"real/","page":"Real field","title":"Real field","text":"Reals have type BigFloat, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"The parent objects of such integers has type Floats{BigFloat}.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"For convenience, we also make Float64 a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as RDF) has type Floats{Float64}.","category":"page"},{"location":"real/#Rational-constructors","page":"Real field","title":"Rational constructors","text":"","category":"section"},{"location":"real/","page":"Real field","title":"Real field","text":"In order to construct reals in AbstractAlgebra.jl, one can first construct the real field itself. This is accomplished using the following constructor.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"Floats{BigFloat}()","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"This gives the unique object of type Floats{BigFloat} representing the field of reals in AbstractAlgebra.jl.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"In practice, one simply uses RealField which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"Here are some examples of creating the real field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"Examples","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"julia> RR = RealField\nFloats\n\njulia> f = RR()\n0.0\n\njulia> g = RR(123)\n123.0\n\njulia> h = RR(BigInt(1234))\n1234.0\n\njulia> k = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> m = RR(2.3)\n2.29999999999999982236431605997495353221893310546875\n","category":"page"},{"location":"real/#Basic-field-functionality","page":"Real field","title":"Basic field functionality","text":"","category":"section"},{"location":"real/","page":"Real field","title":"Real field","text":"The real field in AbstractAlgebra.jl implements the full Field interface.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"We give some examples of such functionality.","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"Examples","category":"page"},{"location":"real/","page":"Real field","title":"Real field","text":"julia> RR = RealField\nFloats\n\njulia> f = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> h = zero(RR)\n0.0\n\njulia> k = one(RR)\n1.0\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(RR)\nUnion{}\n\njulia> T = parent(f)\nFloats\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n13.71428571428571428571428571428571428571428571428571428571428571428571428571433\n\njulia> m = inv(g)\n0.07291666666666666666666666666666666666666666666666666666666666666666666666666631\n","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"submodule/#Submodules","page":"Submodules","title":"Submodules","text":"","category":"section"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"AbstractAlgebra allows the construction of submodules/subvector spaces of AbstractAlgebra modules over euclidean domains. These are given as the submodule generated by a finite list of elements in the original module.","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"We define two submodules to be equal if they are (transitively) submodules of the same module M and their generators generate the same set of elements.","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"As well as implementing the entire Module interface, AbstractAlgebra submodules also provide the following interface.","category":"page"},{"location":"submodule/#Constructors","page":"Submodules","title":"Constructors","text":"","category":"section"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"sub(::AbstractAlgebra.FPModule{T}, ::Vector{AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},Array{AbstractAlgebra.FPModuleElem{T},1}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.sub","text":"sub(m::AbstractAlgebra.FPModule{T}, gens::Vector{<:AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement\n\nReturn the submodule of the module m generated by the given generators, given as elements of m.\n\n\n\nsub(m::Module{T}, gens::Vector{<:ModuleElem{T}}) where T <: RingElement\n\nReturn the submodule S of the module m generated by the given generators, given as elements of m, and a map which is the canonical injection from S to m.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"sub(::AbstractAlgebra.FPModule{T}, ::Vector{Generic.Submodule{T}}) where T <: RingElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},Array{AbstractAlgebra.Generic.Submodule{T},1}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.sub","text":"sub(m::Module{T}, subs::Vector{<:Generic.Submodule{T}}) where T <: RingElement\n\nReturn the submodule S of the module m generated by the union of the given submodules of m, and a map which is the canonical injection from S to m.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"Note that the preimage of the canonical injection can be obtained using the preimage function described in the section on module homomorphisms. As the canonical injection is injective, this is unique.","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> n = M([ZZ(2), ZZ(-1)])\n(2, -1)\n\njulia> N, f = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> v = N([ZZ(3), ZZ(4)])\n(3, 4)\n\njulia> v2 = f(v)\n(3, 26)\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> n = V([QQ(2), QQ(-1)])\n(2//1, -1//1)\n\njulia> N, f = sub(V, [m, n])\n(Subspace over Rationals with 2 generators and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 2 generators and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n","category":"page"},{"location":"submodule/#Functionality-for-submodules","page":"Submodules","title":"Functionality for submodules","text":"","category":"section"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"submodule/#Basic-manipulation","page":"Submodules","title":"Basic manipulation","text":"","category":"section"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"supermodule(::AbstractAlgebra.Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.supermodule-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.supermodule","text":"supermodule(M::Submodule{T}) where T <: RingElement\n\nReturn the module that this module is a submodule of.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"issubmodule(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.issubmodule-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.issubmodule","text":"issubmodule(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if N was constructed as a submodule of M. The relation is taken transitively (i.e. subsubmodules are submodules for the purposes of this relation, etc). The module M is also considered a submodule of itself for this relation.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"iscompatible(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.iscompatible-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.iscompatible","text":"iscompatible(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true, P if the given modules are compatible, i.e. that they are (transitively) submodules of the same module, P. Otherwise return false, M.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"dim(N::AbstractAlgebra.Generic.Submodule{T}) where T <: FieldElement","category":"page"},{"location":"submodule/#AbstractAlgebra.Generic.dim-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:Union{FieldElem, AbstractFloat, Rational}","page":"Submodules","title":"AbstractAlgebra.Generic.dim","text":"dim(N::AbstractAlgebra.Generic.Submodule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector subspace.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1, = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> N2, = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> supermodule(N1) == M\ntrue\n\njulia> iscompatible(N1, N2)\n(true, Free module of rank 2 over Integers)\n\njulia> issubmodule(N1, M)\nfalse\n\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(2), QQ(3)])\n(2//1, 3//1)\n\njulia> N, = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> dim(V)\n2\n\njulia> dim(N)\n1\n","category":"page"},{"location":"submodule/#Intersection","page":"Submodules","title":"Intersection","text":"","category":"section"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"Base.intersect(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where\nT <: RingElement","category":"page"},{"location":"submodule/#Base.intersect-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Submodules","title":"Base.intersect","text":"Base.intersect(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn the intersection of the modules M as a submodule of M. Note that M and N must be (constructed as) submodules (transitively) of some common module P.\n\n\n\n","category":"method"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1 = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> N2 = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> I = intersect(N1, N2)\nUnion{AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}, AbstractAlgebra.Generic.Submodule{BigInt}}[]","category":"page"},{"location":"types/#Appendix-A:-Types-in-AbstractAlgebra.jl","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"","category":"section"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"On this page we discuss the abstract type hierarchy in AbstractAlgebra.jl and objects known as parents which contain additional information about groups, rings, fields and modules, etc., that can't be stored in types alone.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"These details are technical and can be skipped or skimmed by new users of Julia/AbstractAlgebra.jl. Types are almost never dealt with directly when scripting AbstractAlgebra.jl to do mathematical computations.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In contrast, AbstractAlgebra.jl developers will want to know how we model mathematical objects and their rings, fields, groups, etc.","category":"page"},{"location":"types/#The-abstract-type-hierarchy-in-AbstractAlgebra.jl","page":"Appendix A: Types in AbstractAlgebra.jl","title":"The abstract type hierarchy in AbstractAlgebra.jl","text":"","category":"section"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Abstract types in Julia can also belong to one another in a hierarchy. We make use of such a hierarchy to organise the kinds of mathematical objects in AbstractAlgebra.jl.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"For example, the AbstractAlgebra.Field abstract type belongs to the AbstractAlgebra.Ring abstract type.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In practice, this means that any generic function in AbstractAlgebra.jl which is designed to work with ring objects will also work with field objects.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In AbstractAlgebra.jl we also distinguish between the elements of a field, say, and the field itself.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"For example, we have an object of type Generic.PolyRing to model a generic polynomial ring, and elements of that polynomial ring would have type Generic.Poly.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"For this purpose, we also have a hierarchy of abstract types, such as FieldElem, that the types of element objects can belong to.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"(Image: alt text)","category":"page"},{"location":"types/#Why-types-aren't-enough","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Why types aren't enough","text":"","category":"section"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Naively, one might have expected that rings in AbstractAlgebra.jl could be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Consider the ring R = mathbbZnmathbbZ for a multiprecision integer n. If we were to model the ring R as a type, then the type would somehow need to contain the modulus n. This is not possible in Julia, and in fact it is not desirable, since the compiler would then recompile all the associated functions every time a different modulus n was used.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"We could attach the modulus n to the objects representing elements of the ring, rather than their type.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"But now we cannot create new elements of the ring mathbbZnmathbbZ given only their type, since the type no longer contains the modulus n.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Instead, the way we get around this in AbstractAlgebra.jl is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called parent objects, can contain extra information, such as the modulus n.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In order to create new elements of mathbbZnmathbbZ as above, we overload the call operator for the parent object.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In the following AbstractAlgebra.jl example, we create the parent object R corresponding to the ring mathbbZ7mathbbZ. We then create a new element a of this ring by calling the parent object R.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"R = ResidueRing(ZZ, 7)\na = R(3)","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Here, R is the parent object, containing the modulus 7. So this example creates the element a = 3 pmod7.","category":"page"},{"location":"types/#More-complex-example-of-parent-objects","page":"Appendix A: Types in AbstractAlgebra.jl","title":"More complex example of parent objects","text":"","category":"section"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Here is some Julia/AbstractAlgebra.jl code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = ZZ[\"x\"]\n\nf = x^2 + 3x + 1\n\ntypeof(R) <: PolyRing\n\ntypeof(f) <: PolyElem\n\nparent(f) == R","category":"page"},{"location":"types/#Concrete-types-in-AbstractAlgebra.jl","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Concrete types in AbstractAlgebra.jl","text":"","category":"section"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Here we give a list of the concrete types in AbstractAlgebra.jl.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"In parentheses we put the types of the corresponding parent objects.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Perm{<:Integer} (SymmetricGroup{<:Integer})\nGFElem{<:Integer} (GFField{<:Integer})","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"We also think of various Julia types as though they were AbstractAlgebra.jl types:","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"BigInt (Integers{BigInt})\nRational{BigInt} (Rationals{BigInt})","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Then there are various types for generic constructions over a base ring. They are all parameterised by a type T which is the type of the elements of the base ring they are defined over.","category":"page"},{"location":"types/","page":"Appendix A: Types in AbstractAlgebra.jl","title":"Appendix A: Types in AbstractAlgebra.jl","text":"Generic.Poly{T} (Generic.PolyRing{T})\nGeneric.MPoly{T} (Generic.MPolyRing{T})\nGeneric.RelSeries{T} (Generic.RelSeriesRing{T})\nGeneric.AbsSeries{T} (Generic.AbsSeriesRing{T})\nGeneric.LaurentSeriesRingElem{T} (Generic.LaurentSeriesRing{T})\nGeneric.LaurentSeriesFieldElem{T} (Generic.LaurentSeriesField{T})\nGeneric.Res{T} (Generic.ResRing{T})\nGeneric.Frac{T} (Generic.FracField{T})\nGeneric.Mat{T} (Generic.MatSpace{T})","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"residue/#Generic-residue-rings","page":"Generic residue rings","title":"Generic residue rings","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/Residue.jl for generic residue rings over any Euclidean domain (in practice most of the functionality is provided for GCD domains that provide a meaningful GCD function) belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"As well as implementing the Residue Ring interface a number of generic algorithms are implemented for residue rings. We describe this generic functionality below.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"residue/#Types-and-parent-objects","page":"Generic residue rings","title":"Types and parent objects","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Residues implemented using the AbstractAlgebra generics have type Generic.Res{T} or in the case of residue rings that are known to be fields, Generic.ResF{T}, where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Parent objects of residue ring elements have type Generic.ResRing{T} and those of residue fields have type GenericResField{T}.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The defining modulus of the residue ring is stored in the parent object.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The residue element types belong to the abstract type AbstractAlgebra.ResElem{T} or AbstractAlgebra.ResFieldElem{T} in the case of residue fields, and the residue ring types belong to the abstract type AbstractAlgebra.ResRing{T} or AbstractAlgebra.ResField{T} respectively. This enables one to write generic functions that can accept any AbstractAlgebra residue type.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Note that both the generic residue ring type Generic.ResRing{T} and the abstract type it belongs to, AbstractAlgebra.ResRing{T} are both called ResRing, and similarly for the residue field types. In each case, the  former is a (parameterised) concrete type for a residue ring over a given base ring whose elements have type T. The latter is an abstract type representing all residue ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"residue/#Residue-ring-constructors","page":"Generic residue rings","title":"Residue ring constructors","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"In order to construct residues in AbstractAlgebra.jl, one must first construct the residue ring itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"ResidueRing(R::AbstractAlgebra.Ring, m::AbstractAlgebra.RingElem; cached::Bool = true)","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"ResidueField(R::AbstractAlgebra.Ring, m::AbstractAlgebra.RingElem; cached::Bool = true)","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Given a base ring R and residue m contained in this ring, return the parent object of the residue ring R(m). By default the parent object S will depend only on R and m and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The ResidueField constructor does the same thing as the ResidueRing constructor, but the resulting object has type belonging to Field rather than Ring, so it can be used anywhere a field is expected in AbstractAlgebra.jl. No check is made for maximality of the ideal generated by m.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Here are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into the residue ring.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"All of the examples here are generic residue rings, but specialised implementations of residue rings provided by external modules will also usually provide a ResidueRing constructor to allow creation of their residue rings.","category":"page"},{"location":"residue/#Basic-ring-functionality","page":"Generic residue rings","title":"Basic ring functionality","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Residue rings in AbstractAlgebra.jl implement the full Ring interface. Of course the entire Residue Ring interface is also implemented.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"We give some examples of such functionality.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> m = modulus(S)\nx^3 + 3*x + 1\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> V = base_ring(f)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> T = parent(f)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f == deepcopy(f)\ntrue\n","category":"page"},{"location":"residue/#Residue-ring-functionality-provided-by-AbstractAlgebra.jl","page":"Generic residue rings","title":"Residue ring functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any residue ring module that implements the full Residue Ring interface. This includes AbstractAlgebra.jl's own generic residue rings.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"But if a C library provides all the functionality documented in the Residue Ring interface, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that residue ring type.","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Of course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"residue/#Basic-functionality","page":"Generic residue rings","title":"Basic functionality","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"modulus(::AbstractAlgebra.ResElem)","category":"page"},{"location":"residue/#AbstractAlgebra.Generic.modulus-Tuple{ResElem}","page":"Generic residue rings","title":"AbstractAlgebra.Generic.modulus","text":"modulus(R::AbstractAlgebra.ResElem)\n\nReturn the modulus a of the residue ring S = R(a) that the supplied residue r belongs to.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"isunit(::AbstractAlgebra.ResElem)","category":"page"},{"location":"residue/#AbstractAlgebra.isunit-Tuple{ResElem}","page":"Generic residue rings","title":"AbstractAlgebra.isunit","text":"isunit(a::AbstractAlgebra.ResElem)\n\nReturn true if the supplied element a is invertible in the residue ring it belongs to, otherwise return false.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> r = S(x + 1)\nx + 1\n\njulia> a = modulus(S)\nx^3 + 3*x + 1\n\njulia> isunit(r)\ntrue\n","category":"page"},{"location":"residue/#Inversion","page":"Generic residue rings","title":"Inversion","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Base.inv(::AbstractAlgebra.ResElem)","category":"page"},{"location":"residue/#Base.inv-Tuple{ResElem}","page":"Generic residue rings","title":"Base.inv","text":"Base.inv(a::AbstractAlgebra.ResElem)\n\nReturn the inverse of the element a in the residue ring. If an impossible inverse is encountered, an exception is raised.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = inv(f)\n1//3*x^2 - 1//3*x + 4//3\n","category":"page"},{"location":"residue/#Greatest-common-divisor","page":"Generic residue rings","title":"Greatest common divisor","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"gcd{T <: RingElem}(::ResElem{T}, ::ResElem{T})","category":"page"},{"location":"residue/#Base.gcd-Union{Tuple{T}, Tuple{ResElem{T},ResElem{T}}} where T<:RingElem","page":"Generic residue rings","title":"Base.gcd","text":"gcd(a::AbstractAlgebra.ResElem{T}, b::AbstractAlgebra.ResElem{T}) where {T <: RingElement}\n\nReturn a greatest common divisor of a and b if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = S(x^2 + 2x + 1)\nx^2 + 2*x + 1\n\njulia> h = gcd(f, g)\n1\n","category":"page"},{"location":"residue/#Square-Root","page":"Generic residue rings","title":"Square Root","text":"","category":"section"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"issquare{T <: Integer}(::ResFieldElem{T})","category":"page"},{"location":"residue/#AbstractAlgebra.Generic.issquare-Union{Tuple{AbstractAlgebra.ResFieldElem{T}}, Tuple{T}} where T<:Integer","page":"Generic residue rings","title":"AbstractAlgebra.Generic.issquare","text":"issquare(a::AbstractAlgebra.ResFieldElem{T}) where T <: Integer\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Base.sqrt{T <: Integer}(::ResFieldElem{T})","category":"page"},{"location":"residue/#Base.sqrt-Union{Tuple{AbstractAlgebra.ResFieldElem{T}}, Tuple{T}} where T<:Integer","page":"Generic residue rings","title":"Base.sqrt","text":"sqrt(a::AbstractAlgebra.ResFieldElem{T}) where T <: Integer\n\nReturn the square root of a if it is a square, otherwise an exception is raised.\n\n\n\n","category":"method"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R = ResidueField(ZZ, 733)\nResidue field of Integers modulo 733\n\njulia> a = R(86)\n86\n\njulia> issquare(a)\ntrue\n\njulia> sqrt(a)\n532","category":"page"},{"location":"rings/#Ring-Interface","page":"Ring Interface","title":"Ring Interface","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their rings.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In addition to the required functions, there are also optional functions which can be provided for certain types of rings, e.g. GCD domains or fields, etc. If implemented, these allow the generic code to provide additional functionality for those rings, or in some cases, to select more efficient algorithms.","category":"page"},{"location":"rings/#Types","page":"Ring Interface","title":"Types","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Most rings must supply two types:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"a type for the parent object (representing the ring itself)\na type for elements of that ring","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For example, the generic univariate polynomial type in AbstractAlgebra.jl provides two types in generic/GenericTypes.jl:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Generic.PolyRing{T} for the parent objects\nGeneric.Poly{T} for the actual polynomials","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"The parent type must belong to AbstractAlgebra.Ring and the element type must belong to AbstractAlgebra.RingElem. Of course, the types may belong to these abstract types transitively, e.g. Poly{T} actually belongs to AbstractAlgebra.PolyElem{T} which in turn belongs to AbstractAlgebra.RingElem.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring (see the function base_ring below for a definition).","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"page"},{"location":"rings/#RingElement-type-union","page":"Ring Interface","title":"RingElement type union","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to AbstractAlgebra.RingElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of rings we define a union type AbstractAlgebra.RingElement in src/julia/JuliaTypes.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"So far, in addition to AbstractAlgebra.RingElem the  union type AbstractAlgebra.RingElement includes the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Most of the generic code in AbstractAlgebra makes use of the union type AbstractAlgebra.RingElement instead of AbstractAlgebra.RingElem so that the generic functions also accept the Julia Base ring types.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"One must be careful when defining ad hoc binary operations for ring element types. It is often necessary to define separate versions of the functions for AbstractAlgebra.RingElem then for each of the Julia types separately in order to avoid ambiguity warnings.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that even though AbstractAlgebra.RingElement is a union type we still have the following inclusion","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra.RingElement <: AbstractAlgebra.NCRingElement","category":"page"},{"location":"rings/#Parent-object-caches","page":"Ring Interface","title":"Parent object caches","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In many cases, it is desirable to have only one object in the system to represent each ring. This means that if the same ring is constructed twice, elements of the two rings will be compatible as far as arithmetic is concerned.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In order to facilitate this, global caches of rings are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.PolyRing parent objects are looked up in a dictionary PolyID to see if they have been previously defined.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two rings are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two rings if they were constructed from identical data.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl for examples of how to construct and handle such caches.","category":"page"},{"location":"rings/#Required-functions-for-all-rings","page":"Ring Interface","title":"Required functions for all rings","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In the following, we list all the functions that are required to be provided for rings in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"We give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for rings that implement that additional functionality, and should be documented as such.","category":"page"},{"location":"rings/#Data-type-and-parent-object-methods","page":"Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"parent_type(::Type{MyElem})","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the type of the corresponding parent object for the given element type. For example, parent_type(Generic.Poly{T}) will return Generic.PolyRing{T}.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"elem_type(::Type{MyParent})","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the type of the elements of the ring whose parent object has the given type. This is the inverse of the parent_type function, i.e. elem_type(Generic.PolyRing{T}) will return Generic.Poly{T}.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"base_ring(R::MyParent)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Given a parent object R, representing a ring, this function returns the parent object of any base ring that parameterises this ring. For example, the base ring of the ring of polynomials over the integers would be the integer ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If the ring is not parameterised by another ring, this function must return Union{}.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that there is a distinction between a base ring and other kinds of parameters. For example, in the ring mathbbZnmathbbZ, the modulus n is a parameter, but the only base ring is mathbbZ. We consider the ring mathbbZnmathbbZ to have been constructed from the base ring mathbbZ by taking its quotient by a (principal) ideal.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"parent(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the parent object of the given element, i.e. return the ring to which the given element belongs.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"This is usually stored in a field parent in each ring element. (If the parent objects have mutable struct types, the internal overhead here is just an additional machine pointer stored in each element of the ring.)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For some element types it isn't necessary to append the parent object as a field of every element. This is the case when the parent object can be reconstructed just given the type of the elements. For example, this is the case for the ring of integers and in fact for any ring element type that isn't parameterised or generic in any way.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isdomain_type(::Type{MyElem})","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if every element of the given element type (which may be parameterised or an abstract type) necessarily has a parent that is an integral domain, otherwise if this cannot be guaranteed, the function returns false.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For example, if MyElem was the type of elements of generic residue rings of a polynomial ring, the answer to the question would depend on the modulus of the residue ring. Therefore isdomain_type would have to return false, since we cannot guarantee that we are dealing with elements of an integral domain in general. But if the given element type was for rational integers, the answer would be true, since every rational integer has as parent the ring of rational integers, which is an integral domain.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that this function depends only on the type of an element and cannot access information about the object itself, or its parent.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isexact_type(::Type{MyElem})","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if every element of the given type is represented exactly. For example, p-adic numbers, real and complex floating point numbers and power series are not exact, as we can only represent them in general with finite truncations. Similarly polynomials and matrices over inexact element types are themselves inexact.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Integers, rationals, finite fields and polynomials and matrices over them are always exact.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that MyElem may be parameterised or an abstract type, in which case every element of every type represented by MyElem must be exact, otherwise the function must return false.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Base.hash(f::MyElem, h::UInt)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return a hash for the object f of type UInt. This is used as a hopefully cheap way to distinguish objects that differ arithmetically.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If the object has components, e.g. the coefficients of a polynomial or elements of a matrix, these should be hashed recursively, passing the same parameter h to all levels. Each component should then be xor'd with h before combining the individual component hashes to give the final hash.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"The hash functions in AbstractAlgebra.jl usually start from some fixed 64 bit hexadecimal  value that has been picked at random by the library author for that type. That is then truncated to fit a UInt (in case the latter is not 64 bits). This ensures that objects that are the same arithmetically (or that have the same components), but have different types (or structures), are unlikely to hash to the same value.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"deepcopy_internal(f::MyElem, dict::ObjectIdDict)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return a copy of the given element, recursively copying all components of the object.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Obviously the parent, if it is stored in the element, should not be copied. The new element should have precisely the same parent as the old object.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For types that cannot self-reference themselves anywhere internally, the dict argument may be ignored.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In the case that internal self-references are possible, please consult the Julia documentation on how to implement deepcopy_internal.","category":"page"},{"location":"rings/#Constructors","page":"Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Outer constructors for most AbstractAlgebra types are provided by overloading the call syntax for parent objects.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If R is a parent object for a given ring we provide the following constructors.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)()","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the zero object of the given ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)(a::Integer)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Coerce the given integer into the given ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)(a::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If a belongs to the given ring, the function returns it (without making a copy). Otherwise an error is thrown.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings we also require a function to coerce from the base ring into the parent ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent{T})(a::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Coerce a into the ring R if a belongs to the base ring of R.","category":"page"},{"location":"rings/#Basic-manipulation-of-rings-and-elements","page":"Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"zero(R::MyParent)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the zero element of the given ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"one(R::MyParent)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the multiplicative identity of the given ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"iszero(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is the zero element of the ring it belongs to.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isone(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is the multiplicative identity of the ring it belongs to.","category":"page"},{"location":"rings/#Canonicalisation","page":"Ring Interface","title":"Canonicalisation","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"canonical_unit(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"When fractions are created with two elements of the given type, it is nice to be able to represent them in some kind of canonical form. This is of course not always possible. But for example, fractions of integers can be canonicalised by first removing any common factors of the numerator and denominator, then making the denominator positive.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In AbstractAlgebra.jl, the denominator would be made positive by dividing both the numerator and denominator by the canonical unit of the denominator. For a negative denominator, this would be -1.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For elements of a field, canonical_unit simply returns the element itself. In general, canonical_unit of an invertible element should be that element. Finally, if a = ub we should have the identity canonical_unit(a) = canonical_unit(u)*canonical_unit(b).","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For some rings, it is completely impractical to implement this function, in which case it may return 1 in the given ring. The function must however always exist, and always return an element of the ring.","category":"page"},{"location":"rings/#String-I/O","page":"Ring Interface","title":"String I/O","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"show(io::IO, R::MyParent)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"This should print an English description of the parent ring (to the given IO object). If the ring is parameterised, it can call the corresponding show function for any rings it depends on.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"show(io::IO, f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"This should print a human readable, textual representation of the object (to the given IO object). It can recursively call the corresponding show functions for any of its components.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"note: Note\nThe functionality of the function needs_parentheses has been replaced by expressify and needs_parentheses will be removed in future versions.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"It may be necessary in some cases to print parentheses around components of f or to print signs of components. For these, the following functions will exist for each component or component type.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"needs_parentheses(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Should return true if parentheses are needed around this object when printed, e.g. as a coefficient of a polynomial. As an example, non-constant polynomials would need such parentheses if used as coefficients of another polynomial.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that since this approach quickly leads to unnecessary parentheses, the expression method below is preferred.","category":"page"},{"location":"rings/#Expressions","page":"Ring Interface","title":"Expressions","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"To obtain best results when printing composed types derived from other types, e.g., polynomials, the following method should be implemented.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"expressify(f::MyElem; context = nothing)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"which must return either Expr, Symbol, Integer or String. In case one implements expressify, one can define the following show methods for MyElem:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"function Base.show(io::IO, a::MyElem)\n  show_via_expressify(io, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/plain\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/latex\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/html\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"As an example, assume that an object f of type MyElem has two components f.a and f.b of integer type, which should be printed as a^b, this can be implemented as","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"expressify(f::MyElem; context = nothing) = Expr(:call, :^, f.a, f.b)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"If f.a and f.b themselves are objects that can be expressified, this can be implemented as","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"function expressify(f::MyElem; context = nothing)\n  return Expr(:call, :^, expressify(f.a, context = context),\n                         expressify(f.b, context = context))\nend","category":"page"},{"location":"rings/#Unary-operations","page":"Ring Interface","title":"Unary operations","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"-(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return -f.","category":"page"},{"location":"rings/#Binary-operations","page":"Ring Interface","title":"Binary operations","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem, g::MyElem)\n-(f::MyElem, g::MyElem)\n*(f::MyElem, g::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return f + g, f - g or fg, respectively.","category":"page"},{"location":"rings/#Comparison","page":"Ring Interface","title":"Comparison","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem, g::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if f and g are arithmetically equal. In the case where the two elements are inexact, the function returns true if they agree to the minimum precision of the two.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isequal(f::MyElem, g::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For exact rings, this should return the same thing as == above. For inexact rings, this returns true only if the two elements are arithmetically equal and have the same precision.","category":"page"},{"location":"rings/#Powering","page":"Ring Interface","title":"Powering","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"^(f::MyElem, e::Int)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return f^e. The function should throw a DomainError() if negative exponents don't make sense but are passed to the function.","category":"page"},{"location":"rings/#Exact-division","page":"Ring Interface","title":"Exact division","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"divexact(f::MyElem, g::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return fg, though note that Julia uses / for floating point division. Here we mean exact division in the ring, i.e. return q such that f = gq. A DivideError() should be thrown if g is zero. If no exact quotient exists or an impossible inverse is unavoidably encountered, an error should be thrown.","category":"page"},{"location":"rings/#Inverse","page":"Ring Interface","title":"Inverse","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"inv(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the inverse of f, i.e. 1f, though note that Julia uses / for floating point division. Here we mean exact division in the ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"A fallback for this function is provided in terms of divexact so an implementation can be omitted if preferred.","category":"page"},{"location":"rings/#Unsafe-operators","page":"Ring Interface","title":"Unsafe operators","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don't have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note the exclamation point is a convention, which indicates that the object may be mutated in-place.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"The results of deepcopy and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Note that R(a) where R is the ring a belongs to, does not create a new value. For this case, use deepcopy(a).","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"zero!(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Set the value f to zero in place. Return the mutated value.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"mul!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Set c to the value ab in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"add!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Set c to the value a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"addeq!(a::MyElem, b::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Set a to a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"rings/#Random-generation","page":"Ring Interface","title":"Random generation","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"The random functions are only used for test code to generate test data. They therefore don't need to provide any guarantees on uniformity, and in fact, test values that are known to be a good source of corner cases can be supplied.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"rand(R::MyParent, v...)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return a random element in the given ring of the specified size.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"There can be as many arguments as is necessary to specify the size of the test example which is being produced.","category":"page"},{"location":"rings/#Promotion-rules","page":"Ring Interface","title":"Promotion rules","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In order for AbstractAlgebra to be able to automatically coerce up towers of rings, certain promotion rules must be defined. For every ring, one wants to be able to coerce integers into the ring. And for any ring constructed over a base ring, one would like to be able to coerce from the base ring into the ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"The promotion rules look a bit different depending on whether the element type is parameterised or not and whether it is built on a base ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem that are neither parameterised nor built over a base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) where {T <: Integer} = MyElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem that aren't parameterised, but which have a base ring with concrete element type T the promotion rules can be defined as follows:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{U}) where U <: Integer = MyElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) = MyElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem{T} that are parameterised by the type of elements of the base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem{T}}, ::Type{MyElem{T}}) where T <: RingElement = MyElem{T}","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"function promote_rule(::Type{MyElem{T}}, ::Type{U}) where {T <: RingElement, U <: RingElement}\n   promote_rule(T, U) == T ? MyElem{T} : Union{}\nend","category":"page"},{"location":"rings/#Required-functionality-for-inexact-rings","page":"Ring Interface","title":"Required functionality for inexact rings","text":"","category":"section"},{"location":"rings/#Approximation-(floating-point-and-ball-arithmetic-only)","page":"Ring Interface","title":"Approximation (floating point and ball arithmetic only)","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::MyElem, g::MyElem; atol::Real=sqrt(eps()))","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"This is used by test code that uses rings involving floating point or ball arithmetic. The function should return true if all components of f and g are equal to within the square root of the Julia epsilon, since numerical noise may make an exact comparison impossible.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings over an inexact ring, we also require the following ad hoc approximation functionality.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::MyElem{T}, g::T; atol::Real=sqrt(eps())) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::T, g::MyElem{T}; atol::Real=sqrt(eps())) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"These notionally coerce the element of the base ring into the parameterised ring and do a full comparison.","category":"page"},{"location":"rings/#Optional-functionality","page":"Ring Interface","title":"Optional functionality","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Some functionality is difficult or impossible to implement for all rings in the system. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can't be relied on by generic functions in the AbstractAlgebra Ring interface.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"It may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn't exist.","category":"page"},{"location":"rings/#Optional-basic-manipulation-functionality","page":"Ring Interface","title":"Optional basic manipulation functionality","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"isunit(f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is a unit in the ring it belongs to.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"characteristic(R::MyParent)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Return the characteristic of the ring. The function should not be defined if it is not possible to unconditionally give the characteristic as the function is used in some generic code for correctness, but will always take the safe path if the function is not defined.","category":"page"},{"location":"rings/#Optional-binary-ad-hoc-operators","page":"Ring Interface","title":"Optional binary ad hoc operators","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"By default, ad hoc operations are handled by AbstractAlgebra.jl if they are not defined explicitly, by coercing both operands into the same ring and then performing the required operation.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In some cases, e.g. for matrices, this leads to very inefficient behaviour. In such cases, it is advised to implement some of these operators explicitly.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"It can occasionally be worth adding a separate set of ad hoc binary operators for the type Int, if this can be done more efficiently than for arbitrary Julia Integer types.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem, c::Integer)\n-(f::MyElem, c::Integer)\n*(f::MyElem, c::Integer)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"+(c::Integer, f::MyElem)\n-(c::Integer, f::MyElem)\n*(c::Integer, f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised types, it is also sometimes more performant to provide explicit ad hoc operators with elements of the base ring.","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem\n-(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem\n*(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"+(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem\n-(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem\n*(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/#Optional-ad-hoc-comparisons","page":"Ring Interface","title":"Optional ad hoc comparisons","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem, c::Integer)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"==(c::Integer, f::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem{T}, c:T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"==(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/#Optional-ad-hoc-exact-division-functions","page":"Ring Interface","title":"Optional ad hoc exact division functions","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"divexact(a::MyElem{T}, b::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"divexact(a::MyElem, b::Integer)","category":"page"},{"location":"rings/#Optional-powering-functions","page":"Ring Interface","title":"Optional powering functions","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"^(f::MyElem, e::BigInt)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"In case f cannot explode in size when powered by a very large integer, and it is practical to do so, one may provide this function to support powering with BigInt exponents (or for external modules, any other big integer type).","category":"page"},{"location":"rings/#Optional-unsafe-operators","page":"Ring Interface","title":"Optional unsafe operators","text":"","category":"section"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"addmul!(c::MyElem, a::MyElem, b::MyElem, t::MyElem)","category":"page"},{"location":"rings/","page":"Ring Interface","title":"Ring Interface","text":"Set c = c + ab in-place. Return the mutated value. The value t should be a temporary of the same type as a, b and c, which can be used arbitrarily by the implementation to speed up the computation. Aliasing between a, b and c is permitted.","category":"page"},{"location":"map/#Map-interface","page":"Map interface","title":"Map interface","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Maps in Nemo model maps on sets f  D to C for some domain D and codomain C, which have no real limitations except that elements of the codomain and domain be represented by element objects in the system.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Maps f  D to C in AbstractAlgebra are modeled by Julia objects that are able to be called on a single element d in D of the domain to yield an element f(d) in C of the codomain. We say that the map is being applied.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Maps can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"In the following, we will always use the word \"function\" to mean a Julia function, and reserve the word \"map\" for a map on sets, whether mathematically, or as an object in the system.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Maps in AbstractAlgebra have a domain and codomain, can be applied, composed and composed with the identity map (assuming its domain is compatible). Various special kinds of map provide more functionality.","category":"page"},{"location":"map/#Parent-objects","page":"Map interface","title":"Parent objects","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Maps in AbstractAlgebra currently don't have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.","category":"page"},{"location":"map/#Map-classes","page":"Map interface","title":"Map classes","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from SetMap at the top of the hierarchy. Other classes that inherit from SetMap are FunctionalMap for maps that are constructed from a Julia function (or closure), and IdentityMap for the class of the identity maps within the system.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Instead, a map type MyMap will belong to an abstract type of the form Map{D, C, T, MyMap}, where D is the type of the object representing the domain of the map type (this can also be an abstract type, such as Group), C is the type of the object representing the codomain of the map type and T is the map class that MyMap belongs to, e.g. SetMap or FunctionalMap.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"If writing a function that accepts any map type, one makes the type of its argument belong to Map. For example f(M::Map) = 1.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"If writing a function that accepts any map from a domain of type D to a codomain of type C, one makes writes for example f(M::Map{D, C}) = 2. Note that D and C can be abstract types, such as Group, but otherwise must be the types of the parent objects representing the domain and codomain.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"A function that accepts any map belonging to a given map class might be written as f(M::Map(FunctionalMap)) = 3 or f(M::Map(FunctionalMap){D, C}) = 4 for example, where D and C are the types of the parent objects for the domain and codomain.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Finally, if a function should only work for a map of a given map type MyMap, say, one writes this f(M::Map(MyMap)) or f(M::Map(MyMap){D, C}, where as usual D and C are the types of the domain and codomain parent objects.","category":"page"},{"location":"map/#Implementing-new-map-types","page":"Map interface","title":"Implementing new map types","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"In the case of fixed domain and codomain, e.g. Integers{BigInt}, we would write it as follows:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"mutable struct MyMap <: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}\n   # some data fields\nend","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"In the case of parameterisation by the type of the domain and codomain:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"mutable struct MyMap{D, C} <: Map{D, C, SetMap, MyMap}\n   # some data fields\nend","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"As mentioned above, to write a function that only accepts maps of type MyMap, one writes the functions as follows:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"function my_fun(M::Map(MyMap))","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"The Map function then computes the correct type to use, which is actually not MyMap if all features of the generic Map infrastructure are required. It is bad practice to write functions for MyMap directly instead of Map(MyMap), since other users will be unable to use generic constructions over the map type MyMap.","category":"page"},{"location":"map/#Getters-and-setters","page":"Map interface","title":"Getters and setters","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Let us suppose that the MyMap type has a field called foo. Rather than access this field by writing M.foo, one must access it using foo(M) (at least until Julia 1.1).","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"If such a getter only needs to access the field foo of M, there is a standard way of defining such a getter and setter when defining a new map type.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"foo(M::Map(MyMap)) = get_field(M, :foo)","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"To set a field of a map, one needs a setter, which can be implemented as follows:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"In general, setters should be used rarely for map types.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Note that by providing getter and setter functions, map types need not even contain fields with the given name. For example, for a MyMap map type for maps between integers, one does not wish to explicitly store the domain and codomain in MyMap. Instead, we can define the getter functions domain and codomain to return JuliaZZ for any MyMap object.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"domain(M::Map(MyMap)) = JuliaZZ\ncodomain(M::Map(MyMap)) = JuliaZZ","category":"page"},{"location":"map/#Required-functionality-for-maps","page":"Map interface","title":"Required functionality for maps","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"All map types must implement a standard interface, which we specify here.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"We will define this interface for a custom map type MyMap belonging to Map(SetMap), SetMap being the map class that all maps types belong to.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Note that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"The required accessors for map types of class SetMap are as follows.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"domain(M::Map(MyMap))\ncodomain(M::Map(MyMap))","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Return the domain and codomain parent objects respectively, for the map M. It is only necessary to define these functions if the map type MyMap does not contain fields domain and codomain containing these parent objects.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"It is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to Map(MyMap).","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"(M::Map(MyMap)(a))","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Apply the map M to the element a of the domain of M. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type elem_type(C) where C is the type of the codomain parent object.","category":"page"},{"location":"map/#Optional-functionality-for-maps","page":"Map interface","title":"Optional functionality for maps","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"However, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"We describe this optional functionality here.","category":"page"},{"location":"map/#Show-method","page":"Map interface","title":"Show method","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Custom map types may like to provide a custom show method if the default of displaying the domain and codomain of the map is not sufficient.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"show(io::IO, M::Map(MyMap))","category":"page"},{"location":"map/#Identity-maps","page":"Map interface","title":"Identity maps","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"There is a concrete map type Generic.IdentityMap{D} for the identity map on a given domain. Here D is the type of the object representing that domain.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Generic.IdentityMap belongs to the supertype Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Note that the map class is also called IdentityMap. It is an abstract type, whereas Generic.IdentityMap is a concrete type in the Generic module.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"We do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"To construct an identity map for a given domain, specified by a parent object R, say, we have the following function.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"identity_map(R::Set)","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Return an identity map on the domain R.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Of course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to AbstractAlgebra.IdentityMap so that composition with other map types still works.","category":"page"},{"location":"map/#Composition-of-maps","page":"Map interface","title":"Composition of maps","text":"","category":"section"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"In order to facilitate this, the Generic module provides a type CompositeMap{D, C}, which contains two maps map1 and map2, corresponding to the two maps to be applied in a composition, in the order they should be applied.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"To construct a composition map from two existing maps, we have the following function:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Compose the two maps f and g, i.e. return the map h such that h(x) = g(f(x)).","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"As a shortcut for this function we have the following operator:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Note the order of composition. If we have maps f  X to Y, g  Y to Z the correct order of the maps in this operator is f*g, so that (f*g)(x) = g(f(x)).","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"This is chosen so that for left R-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Of course, a custom map type or class of maps can implement its own composition type and compose function.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"This is the case with the FunctionalMap class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"By default, compose will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"check_composable(f::Map{D, U}, g::Map{U, C})","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Raise an exception if the codomain of f doesn't match the domain of g.","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Note that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"map1(f::CompositeMap)\nmap2(f::CompositeMap)","category":"page"},{"location":"map/","page":"Map interface","title":"Map interface","text":"Any custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"series_rings/#Series-Ring-Interface","page":"Series Ring Interface","title":"Series Ring Interface","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Univariate power series rings are supported in AbstractAlgebra in a variety of different forms, including absolute and relative precision models and Laurent series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the standard Ring interface, numerous additional functions are required to be present for power series rings.","category":"page"},{"location":"series_rings/#Types-and-parents","page":"Series Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"AbstractAlgebra provides two abstract types for power series rings and their elements:","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"SeriesRing{T} is the abstract type for all power series ring parent types\nSeriesElem{T} is the abstract type for all power series types","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"We have that SeriesRing{T} <: AbstractAlgebra.Ring and SeriesElem{T} <: AbstractAlgebra.RingElem.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the power series ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Within the SeriesElem{T} abstract type is the abstract type RelSeriesElem{T} for relative power series, and AbsSeriesElem{T} for absolute power series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Relative series are typically stored with a valuation and a series that is either zero or that has nonzero constant term. Absolute series are stored starting from the constant term, even if it is zero.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"If the parent object for a relative series ring over the bignum integers has type MySeriesRing and series in that ring have type MySeries then one would have:","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"MySeriesRing <: SeriesRing{BigInt}\nMySeries <: RelSeriesElem{BigInt}","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Series rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Series rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator) and same default precision, they should certainly have the same parent object.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"series_rings/#Required-functionality-for-series","page":"Series Ring Interface","title":"Required functionality for series","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the required functionality for the Ring interface the Series Ring interface has the following required functions.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a series ring over R (e.g. S = Rx) with parent object S of type MySeriesRing{T}. We also assume the series in the ring have type MySeries{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"series_rings/#Constructors","page":"Series Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For relative power series and Laurent series we have:","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Array{T, 1}, len::Int, prec::Int, val::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Create the series in the given ring whose valuation is val, whose absolute precision is given by prec and the coefficients of which are given by A, starting from the first nonzero term. Only len terms of the array are used, the remaining terms being ignored. The value len cannot exceed the length of the supplied array.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It is permitted to have trailing zeros in the array, but it is not needed, even if the precision minus the valuation is bigger than the length of the array.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Examples","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"julia> S, x = PowerSeriesRing(QQ, 10, \"x\"; model=:capped_relative)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> T, y = LaurentSeriesRing(ZZ, 10, \"y\")\n(Laurent series ring in y over Integers, y + O(y^11))\n\njulia> U, z = LaurentSeriesField(QQ, 10, \"z\")\n(Laurent series field in z over Rationals, z + O(z^11))","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For absolute power series we have:","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Array{T, 1}, len::Int, prec::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Create the series in the given ring whose absolute precision is given by prec and the coefficients of which are given by A, starting from the constant term. Only len terms of the array are used, the remaining terms being ignored.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that len is usually maintained separately of any polynomial that is underlying the power series. This allows for easy trucation of a power series without actually modifying the polynomial underlying it.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It is permitted to have trailing zeros in the array, but it is not needed, even if the precision is bigger than the length of the array.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Examples","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"julia> S, x = PowerSeriesRing(QQ, 10, \"x\"; model=:capped_absolute)\n(Univariate power series ring in x over Rationals, x + O(x^10))\n\njulia> f = S(Rational{BigInt}[0, 2, 3, 1], 4, 6)\n2*x + 3*x^2 + x^3 + O(x^6)\n","category":"page"},{"location":"series_rings/#Data-type-and-parent-object-methods","page":"Series Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"var(S::MySeriesRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return a Symbol representing the variable (generator) of the series ring. Note that this is a Symbol not a String, though its string value will usually be used when printing series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"max_precision(S::MySeriesRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the (default) maximum precision of the power series ring. This is the precision that the output of an operation will be if it cannot be represented to full precision (e.g. because it mathematically has infinite precision).","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This value is usually supplied upon creation of the series ring and stored in the ring. It is independent of the precision which each series in the ring actually has. Those are stored on a per element basis in the actual series elements.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Examples","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"julia> S, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> vsym = var(S)\n:x\n\njulia> max_precision(S) == 10\ntrue\n","category":"page"},{"location":"series_rings/#Basic-manipulation-of-rings-and-elements","page":"Series Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"pol_length(f::MySeries{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the length of the polynomial underlying the given power series. This is not generally useful to the user, but is used internally.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_length!(f::MySeries{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function sets the effective length of the polynomial underlying the given series. The function doesn't modify the actual polynomial, but simply changes the number of terms of the polynomial which are considered to belong to the power series. The remaining terms are ignored.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function cannot set the length to a value greater than the length of any underlying polynomial.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"The function mutates the series in-place but does not return the mutated series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"precision(f::MySeries{T})","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the absolute precision of f.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_precision!(f::MySeries{T}, prec::Int)","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Set the absolute precision of the given series to the given value.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This return the updated series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"valuation(f::MySeries{T})","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the valuation of the given series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_valuation!(f::MySeries{T}, val::Int)","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For relative series and Laurent series only, this function alters the valuation of the given series to the given value.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function returns the updated series.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"polcoeff(f::MySeries{T}, n::Int)","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the coefficient of degree n of the polynomial underlying the series. If n is larger than the degree of this polynomial, zero is returned. This function is not generally of use to the user but is used internally.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"setcoeff!(f::MySeries{T}, n::Int, a::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Set the degree n coefficient of the polynomial underlying f to a. This mutates the polynomial in-place if possible and returns the mutated series (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that this function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"normalise(f::MySeries{T}, n::Int)","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Given a series f represented by a polynomial of at least the given length, return the normalised length of the underlying polynomial assuming it has length at most n. This function does not actually normalise the polynomial and is not particularly useful to the user. It is used internally.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"renormalize!(f::MySeries{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Given a relative series or Laurent series whose underlying polynomial has zero constant term, say as the result of some internal computation, renormalise the series so that the polynomial has nonzero constant term. The precision and valuation of the series are adjusted to compensate. This function is not intended to be useful to the user, but is used internally.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"fit!(f::MySeries{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Ensure that the polynomial underlying f internally has space for n coefficients. This function must mutate the series in-place if it is mutable. It does not return the mutated series. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Some interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"gen(R::MySeriesRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the generator x of the series ring.","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Examples","category":"page"},{"location":"series_rings/","page":"Series Ring Interface","title":"Series Ring Interface","text":"julia> S, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^5)\n1 + 3*x + x^3 + O(x^5)\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0], 4, 10, 3);\n\njulia> n = pol_length(f)\n4\n\njulia> c = polcoeff(f, 1)\n3\n\njulia> set_length!(g, 3)\nx^3 + 2*x^4 + O(x^10)\n\njulia> g = setcoeff!(g, 2, BigInt(11))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)\n\njulia> fit!(g, 8)\n\njulia> g = setcoeff!(g, 7, BigInt(4))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)\n\njulia> w = gen(S)\nx + O(x^11)\n\njulia> isgen(w)\ntrue\n","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend\nDocTestFilters = r\"[0-9\\.]+ seconds \\(.*\\)\"","category":"page"},{"location":"ytabs/#Partitions-and-Young-tableaux","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"AbstractAlgebra.jl provides basic support for computations with Young tableaux, skew diagrams and the characters of permutation groups (implemented src/generic/YoungTabs.jl). All functionality of permutations is accesible in the Generic submodule.","category":"page"},{"location":"ytabs/#Partitions","page":"Partitions and Young tableaux","title":"Partitions","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The basic underlying object for those concepts is Partition of a number n, i.e. a sequence of positive integers n_1 ldots n_k which sum to n. Partitions in AbstractAlgebra.jl are represented internally by non-increasing Vectors of Ints. Partitions are printed using the standard notation, i.e. 9 = 4 + 2 + 1 + 1 + 1 is shown as 4_1 2_1 1_3 with the subscript indicating the count of a summand in the partition.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.Partition","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.Partition","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.Partition","text":"Partition(part::Vector{<:Integer}[, check::Bool=true]) <: AbstractVector{Int}\n\nRepresent integer partition in the non-increasing order.\n\npart will be sorted, if necessary. Checks for validity of input can be skipped by calling the (inner) constructor with false as the second argument.\n\nFunctionally Partition is a thin wrapper over Vector{Int}.\n\nFieldnames:\n\nn::Int - the partitioned number\npart::Vector{Int} - a non-increasing sequence of summands of n.\n\nExamples:\n\njulia> p = Partition([4,2,1,1,1])\n421\n\njulia> p.n == sum(p.part)\ntrue\n\n\n\n","category":"type"},{"location":"ytabs/#Array-interface","page":"Partitions and Young tableaux","title":"Array interface","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Partition is a concrete (immutable) subtype of AbstractVector{Integer} and implements the standard Array interface.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(::Generic.Partition)\ngetindex(::Generic.Partition, i::Integer)","category":"page"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(p::Partition)\n\nReturn the size of the vector which represents the partition.\n\nExamples:\n\njulia> p = Partition([4,3,1]); size(p)\n(3,)\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.Partition,Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(p::Partition, i::Integer)\n\nReturn the i-th part (in non-increasing order) of the partition.\n\n\n\n","category":"method"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"These functions work on the level of p.part vector.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"One can easily iterate over all partitions of n using the Generic.partitions function.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.partitions","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.partitions","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.partitions","text":"partitions(n::Integer)\n\nReturn the vector of all permutations of n. For an unsafe generator version see partitions!.\n\nExamples:\n\n```jldoctest; setup = :(using AbstractAlgebra) julia> Generic.partitions(5) 7-element Array{AbstractAlgebra.Generic.Partition{Int64},1}:  1  21  31  21  41  32  5\n\n\n\n","category":"function"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"You may also have a look at JuLie.jl package for more utilities related to partitions.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The number of all partitions can be computed by the hidden function _numpart. Much faster implementation is available in Nemo.jl.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic._numpart","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic._numpart","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic._numpart","text":"_numpart(n::Integer)\n\nReturn the number of all distinct integer partitions of n. The function uses Euler pentagonal number theorem for recursive formula. For more details see OEIS sequence A000041. Note that _numpart(0) = 1 by convention.\n\n\n\n","category":"function"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Since Partition is a subtype of AbstractVector generic functions which operate on vectors should work in general. However the meaning of conj has been changed to agree with the traditional understanding of conjugation of Partitions:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"conj(::Generic.Partition)\nconj(::Generic.Partition, v::Vector)","category":"page"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(part::Partition)\n\nReturn the conjugated partition of part, i.e. the partition corresponding to the Young diagram of part reflected through the main diagonal.\n\nExamples:\n\njulia> p = Partition([4,2,1,1,1])\n421\n\njulia> conj(p)\n521\n\n\n\n","category":"method"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.Partition,Array{T,1} where T}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(part::Partition, v::Vector)\n\nReturn the conjugated partition of part together with permuted vector v.\n\n\n\n","category":"method"},{"location":"ytabs/#Young-Diagrams-and-Young-Tableaux","page":"Partitions and Young tableaux","title":"Young Diagrams and Young Tableaux","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Mathematicaly speaking Young diagram is a diagram which consists of rows of square boxes such that the number of boxes in each row is no less than the number of boxes in the previous row. For example partition 4_1 3_2 1 represents the following diagram.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"\n            \n\n         \n\n         \n\n   \n","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Young Tableau is formally a bijection between the set of boxes of a Young Diagram and the set 1 ldots n. If a bijection is increasing along rows and columns of the diagram it is referred to as standard. For example","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"\n 1  2  3  4 \n\n 5  6  7 \n\n 8  9 10 \n\n11 \n","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"is a standard Young tableau of 4_1 3_2 1 where the bijection assigns consecutive natural numbers to consecutive (row-major) cells.","category":"page"},{"location":"ytabs/#Constructors","page":"Partitions and Young tableaux","title":"Constructors","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"In AbstractAlgebra.jl Young tableau are implemented as essentially row-major sparse matrices, i.e. YoungTableau <: AbstractArray{Int,2} but only the defining Partition and the (row-major) fill-vector is stored.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.YoungTableau","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.YoungTableau","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.YoungTableau","text":"YoungTableau(part::Partition[, fill::Vector{Int}=collect(1:sum(part))])  <: AbstractArray{Int, 2}\n\nReturn the Young tableaux of partition part, filled linearly by fill vector. Note that fill vector is in row-major format.\n\nFields:\n\npart - the partition defining Young diagram\nfill - the row-major fill vector: the entries of the diagram.\n\nExamples:\n\njulia> p = Partition([4,3,1]); y = YoungTableau(p)\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> y.part\n431\n\njulia> y.fill\n8-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n\n\n\n","category":"type"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"For convenience there exists an alternative constructor of YoungTableau, which accepts a vector of integers and constructs Partition internally.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"YoungTableau(p::Vector{Integer}[, fill=collect(1:sum(p))])","category":"page"},{"location":"ytabs/#Array-interface-2","page":"Partitions and Young tableaux","title":"Array interface","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"To make YoungTableaux array-like we implement the following functions:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(::Generic.YoungTableau)\ngetindex(::Generic.YoungTableau, n::Integer)","category":"page"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(Y::YoungTableau)\n\nReturn size of the smallest array containing Y, i.e. the tuple of the number of rows and the number of columns of Y.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]); size(y)\n(3, 4)\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.YoungTableau,Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(Y::YoungTableau, n::Integer)\n\nReturn the column-major linear index into the size(Y)-array. If a box is outside of the array return 0.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> y[1]\n1\n\njulia> y[2]\n5\n\njulia> y[4]\n2\n\njulia> y[6]\n0\n\n\n\n","category":"method"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Also the double-indexing corresponds to (row, column) access to an abstract array.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"julia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> y[1,2]\n2\n\njulia> y[2,3]\n7\n\njulia> y[3,2]\n0","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Functions defined for AbstractArray type based on those (e.g. length) should work. Again, as in the case of Partition the meaning of conj is altered to reflect the usual meaning for Young tableaux:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"conj(::Generic.YoungTableau)","category":"page"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(Y::YoungTableau)\n\nReturn the conjugated tableau, i.e. the tableau reflected through the main diagonal.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> conj(y)\n\n 1  5  8 \n\n 2  6 \n\n 3  7 \n\n 4 \n\n\n\n\n","category":"method"},{"location":"ytabs/#Pretty-printing","page":"Partitions and Young tableaux","title":"Pretty-printing","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Similarly to permutations we have two methods of displaying Young Diagrams:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.setyoungtabstyle","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.setyoungtabstyle","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.setyoungtabstyle","text":"setyoungtabstyle(format::Symbol)\n\nSelect the style in which Young tableaux are displayed (in REPL or in general as string). This can be either\n\n:array - as matrices of integers, or\n:diagram - as filled Young diagrams (the default).\n\nThe difference is purely esthetical.\n\nExamples:\n\njulia> Generic.setyoungtabstyle(:array)\n:array\n\njulia> p = Partition([4,3,1]); YoungTableau(p)\n 1  2  3  4\n 5  6  7\n 8\n\njulia> Generic.setyoungtabstyle(:diagram)\n:diagram\n\njulia> YoungTableau(p)\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\n\n\n","category":"function"},{"location":"ytabs/#Ulitility-functions","page":"Partitions and Young tableaux","title":"Ulitility functions","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"matrix_repr(::Generic.YoungTableau)\nfill!(::Generic.YoungTableau, ::AbstractVector{<:Integer})","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(a::Perm)\n\nReturn the permutation matrix as a sparse matrix representing a via natural embedding of the permutation group into the general linear group over mathbbZ.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> matrix_repr(p)\n33 SparseArrays.SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [3, 1]  =  1\n  [1, 2]  =  1\n  [2, 3]  =  1\n\njulia> Array(ans)\n33 Array{Int64,2}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\nmatrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n34 SparseArrays.SparseMatrixCSC{Int64,Int64} with 8 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  5\n  [3, 1]  =  8\n  [1, 2]  =  2\n  [2, 2]  =  6\n  [1, 3]  =  3\n  [2, 3]  =  7\n  [1, 4]  =  4\n\n\n\n","category":"method"},{"location":"ytabs/#Base.fill!-Tuple{AbstractAlgebra.Generic.YoungTableau,AbstractArray{var\"#s4\",1} where var\"#s4\"<:Integer}","page":"Partitions and Young tableaux","title":"Base.fill!","text":"fill!(Y::YoungTableaux, V::Vector{<:Integer})\n\nReplace the fill vector Y.fill by V. No check if the resulting tableau is standard (i.e. increasing along rows and columns) is performed.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> fill!(y, [2:9...])\n\n 2  3  4  5 \n\n 6  7  8 \n\n 9 \n\n\n\n\n","category":"method"},{"location":"ytabs/#Characters-of-permutation-groups","page":"Partitions and Young tableaux","title":"Characters of permutation groups","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Irreducible characters (at least over field of characteristic 0) of the full group of permutations S_n correspond via Specht modules to partitions of n.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"character(::Generic.Partition)\ncharacter(lambda::Generic.Partition, p::Generic.Perm)\ncharacter(lambda::Generic.Partition, mu::Generic.Partition)","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition)\n\nReturn the lambda-th irreducible character of permutation group on sum(lambda) symbols. The returned character function is of the following signature:\n\nchi(p::Perm[, check::Bool=true]) -> BigInt\n\nThe function checks (if p belongs to the appropriate group) can be switched off by calling chi(p, false). The values computed by chi are cached in look-up table.\n\nThe computation follows the Murnaghan-Nakayama formula: chi_lambda(sigma) = sum_textrimhook xisubset lambda(-1)^ll(lambdabackslashxi) chi_lambda backslashxi(tildesigma) where lambdabackslashxi denotes the skew diagram of lambda with xi removed, ll denotes the leg-length (i.e. number of rows - 1) and tildesigma is permutation obtained from sigma by the removal of the longest cycle.\n\nFor more details see e.g. Chapter 2.8 of Group Theory and Physics by S.Sternberg.\n\nExamples\n\njulia> G = SymmetricGroup(4)\nFull symmetric group over 4 elements\n\njulia> chi = character(Partition([3,1])); # character of the regular representation\n\n\njulia> chi(one(G))\n3\n\njulia> chi(perm\"(1,3)(2,4)\")\n-1\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition,Perm}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition, p::Perm, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character of the permutation group on permutation p.\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition,AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition, mu::Partition, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character on the conjugacy class represented by partition mu.\n\n\n\n","category":"method"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The values computed by characters are cached in an internal dictionary Dict{Tuple{BitVector,Vector{Int}}, BigInt}. Note that all of the above functions return BigInts. If you are sure that the computations do not overflow, variants of the last two functions using Int are available:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"character(::Type{Int}, lambda::Partition, p::Perm[, check::Bool=true])\ncharacter(::Type{Int}, lambda::Partition, mu::Partition[, check::Bool=true])","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The dimension dim lambda of the irreducible module corresponding to partition lambda can be computed using Hook length formula","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.rowlength\nGeneric.collength\nhooklength\ndim(::Generic.YoungTableau)","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.rowlength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.rowlength","text":"rowlength(Y::YoungTableau, i, j)\n\nReturn the row length of Y at box (i,j), i.e. the number of boxes in the i-th row of the diagram of Y located to the right of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> Generic.rowlength(y, 1,2)\n2\n\njulia> Generic.rowlength(y, 2,3)\n0\n\njulia> Generic.rowlength(y, 3,3)\n0\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.collength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.collength","text":"collength(Y::YoungTableau, i, j)\n\nReturn the column length of Y at box (i,j), i.e. the number of boxes in the j-th column of the diagram of Y located below of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> Generic.collength(y, 1,1)\n2\n\njulia> Generic.collength(y, 1,3)\n1\n\njulia> Generic.collength(y, 2,4)\n0\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.hooklength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.hooklength","text":"hooklength(Y::YoungTableau, i, j)\n\nReturn the hook-length of an element in Y at position (i,j), i.e the number of cells in the i-th row to the right of (i,j)-th box, plus the number of cells in the j-th column below the (i,j)-th box, plus 1.\n\nReturn 0 for (i,j) not in the tableau Y.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n\n 1  2  3  4 \n\n 5  6  7 \n\n 8 \n\n\njulia> hooklength(y, 1,1)\n6\n\njulia> hooklength(y, 1,3)\n3\n\njulia> hooklength(y, 2,4)\n0\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.dim-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.dim","text":"dim(Y::YoungTableau) -> BigInt\n\nReturn the dimension (using hook-length formula) of the irreducible representation of permutation group S_n associated the partition Y.part.\n\nSince the computation overflows easily BigInt is returned. You may perform the computation of the dimension in different type by calling dim(Int, Y).\n\nExamples\n\njulia> dim(YoungTableau([4,3,1]))\n70\n\njulia> dim(YoungTableau([3,1])) # the regular representation of S_4\n3\n\n\n\n","category":"method"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The character associated with Y.part can also be used to compute the dimension, but as it is expected the Murnaghan-Nakayama is much slower even though (due to caching) consecutive calls are fast:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"julia>  = Partition(collect(12:-1:1))\n121110987654321\n\njulia> @time dim(YoungTableau())\n  0.224430 seconds (155.77 k allocations: 7.990 MiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time dim(YoungTableau())\n  0.000038 seconds (335 allocations: 10.734 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> G = SymmetricGroup(sum())\nFull symmetric group over 78 elements\n\njulia> @time character(, one(G))\n  0.000046 seconds (115 allocations: 16.391 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time character(, one(G))\n  0.001439 seconds (195 allocations: 24.453 KiB)\n9079590132732747656880081324531330222983622187548672000","category":"page"},{"location":"ytabs/#Low-level-functions-and-characters","page":"Partitions and Young tableaux","title":"Low-level functions and characters","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"As mentioned above character functions use the Murnaghan-Nakayama rule for evaluation. The implementation follows","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Dan Bernstein, The computational complexity of rules for the character table of S_n Journal of Symbolic Computation, 37 (6), 2004, p. 727-748,","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"implementing the following functions. For precise definitions and meaning please consult the paper cited.","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.partitionseq\nisrimhook(::BitVector, ::Int, ::Int)\nGeneric.MN1inner","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.partitionseq","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.partitionseq","text":"partitionseq(lambda::Partition)\n\nReturn a sequence (as BitVector) of falses and trues constructed from lambda: tracing the lower contour of the Young Diagram associated to lambda from left to right a true is inserted for every horizontal and false for every vertical step. The sequence always starts with true and ends with false.\n\n\n\npartitionseq(seq::BitVector)\n\nReturn the essential part of the sequence seq, i.e. a subsequence starting at first true and ending at last false.\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.isrimhook-Tuple{BitArray{1},Int64,Int64}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.isrimhook","text":"isrimhook(R::BitVector, idx::Integer, len::Integer)\n\nR[idx:idx+len] forms a rim hook in the Young Diagram of partition corresponding to R iff R[idx] == true and R[idx+len] == false.\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.MN1inner","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.MN1inner","text":"MN1inner(R::BitVector, mu::Partition, t::Integer, charvals)\n\nReturn the value of lambda-th irreducible character on conjugacy class of permutations represented by partition mu, where R is the (binary) partition sequence representing lambda. Values already computed are stored in charvals::Dict{Tuple{BitVector,Vector{Int}}, Int}. This is an implementation (with slight modifications) of the Murnaghan-Nakayama formula as described in\n\nDan Bernstein,\n\"The computational complexity of rules for the character table of Sn\"\n_Journal of Symbolic Computation_, 37(6), 2004, p. 727-748.\n\n\n\n","category":"function"},{"location":"ytabs/#Skew-Diagrams","page":"Partitions and Young tableaux","title":"Skew Diagrams","text":"","category":"section"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Skew diagrams are formally differences of two Young diagrams. Given lambda and mu, two partitions of n+m and m (respectively). Suppose that each of cells of mu is a cell of lambda (i.e. parts of mu are no greater than the corresponding parts of lambda). Then the skew diagram denoted by lambdamu is the set theoretic difference the of sets of boxes, i.e. is a diagram with exactly n boxes:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.SkewDiagram","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.SkewDiagram","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.SkewDiagram","text":"SkewDiagram(lambda::Partition, mu::Partition) <: AbstractArray{Int, 2}\n\nImplements a skew diagram, i.e. a difference of two Young diagrams represented by partitions lambda and mu. (below dots symbolise the removed entries)\n\nExamples\n\njulia> l = Partition([4,3,2])\n432\n\njulia> m = Partition([3,1,1])\n31\n\njulia> xi = SkewDiagram(l,m)\n34 AbstractAlgebra.Generic.SkewDiagram{Int64}:\n       1\n   1  1\n   1\n\n\n\n\n","category":"type"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"SkewDiagram implements array interface with the following functions:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(xi::Generic.SkewDiagram)\nin(t::Tuple{Integer,Integer}, xi::Generic.SkewDiagram)\ngetindex(xi::Generic.SkewDiagram, n::Integer)","category":"page"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(xi::SkewDiagram)\n\nReturn the size of array where xi is minimally contained. See size(Y::YoungTableau) for more details.\n\n\n\n","category":"method"},{"location":"ytabs/#Base.in-Tuple{Tuple{Integer,Integer},AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"Base.in","text":"in(t::Tuple{Integer,Integer}, xi::SkewDiagram)\n\nCheck if box at position (i,j) belongs to the skew diagram xi.\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.SkewDiagram,Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(xi::SkewDiagram, n::Integer)\n\nReturn 1 if linear index n corresponds to (column-major) entry in xi.lam which is not contained in xi.mu. Otherwise return 0.\n\n\n\n","category":"method"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The support for skew diagrams is very rudimentary. The following functions are available:","category":"page"},{"location":"ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"isrimhook(::Generic.SkewDiagram)\nleglength\nmatrix_repr(::Generic.SkewDiagram)","category":"page"},{"location":"ytabs/#AbstractAlgebra.Generic.isrimhook-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.isrimhook","text":"isrimhook(xi::SkewDiagram)\n\nCheck if xi represents a rim-hook diagram, i.e. its diagram is edge-connected and contains no 2times 2 squares.\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.leglength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.leglength","text":"leglength(xi::SkewDiagram[, check::Bool=true])\n\nCompute the leglength of a rim-hook xi, i.e. the number of rows with non-zero entries minus one. If check is false function will not check whether xi is actually a rim-hook.\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(xi::SkewDiagram)\n\nReturn a sparse representation of the diagram xi, i.e. a sparse array A where A[i,j] == 1 if and only if (i,j) is in xi.lam but not in xi.mu.\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"module_homomorphism/#Module-Homomorphisms","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Abstract Algebra provides homomorphisms of finitely presented modules.","category":"page"},{"location":"module_homomorphism/#Generic-functionality","page":"Module Homomorphisms","title":"Generic functionality","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"The following generic functionality is provided for module homomorphisms.","category":"page"},{"location":"module_homomorphism/#Constructors","page":"Module Homomorphisms","title":"Constructors","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Homomorphisms of AbstractAlgebra modules, f  R^s to R^t, can be represented by stimes t matrices over R.","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Generic.ModuleHomomorphism(M1::AbstractAlgebra.FPModule{T}, M2::AbstractAlgebra.FPModule{T}, m::AbstractAlgebra.MatElem{T}) where T <: RingElement","category":"page"},{"location":"module_homomorphism/#AbstractAlgebra.Generic.ModuleHomomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T},MatElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Homomorphisms","title":"AbstractAlgebra.Generic.ModuleHomomorphism","text":"ModuleHomomorphism(M1::AbstractAlgebra.FPModule{T},\n M2::AbstractAlgebra.FPModule{T}, m::AbstractAlgebra.MatElem{T})\n        where T <: RingElement\n\nCreate the homomorphism f  M_1 to M_2 represented by the matrix m.\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Generic.ModuleIsomorphism(M1::AbstractAlgebra.FPModule{T}, M2::AbstractAlgebra.FPModule{T}, m::AbstractAlgebra.MatElem{T}) where T <: RingElement","category":"page"},{"location":"module_homomorphism/#AbstractAlgebra.Generic.ModuleIsomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T},MatElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Homomorphisms","title":"AbstractAlgebra.Generic.ModuleIsomorphism","text":"ModuleIsomorphism(M1::AbstractAlgebra.FPModule{T},\n    M2::AbstractAlgebra.FPModule{T}, M::AbstractAlgebra.MatElem{T},\n   minv::AbstractAlgebra.MatElem{T}) where T <: RingElement\n\nCreate the isomorphism f  M_1 to M_2 represented by the matrix M. The inverse morphism is automatically computed.\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> f = ModuleHomomorphism(M, M, matrix(ZZ, 2, 2, [1, 2, 3, 4]))\nModule homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Free module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> f(m)\n(7, 10)\n","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"They can also be created by giving images (in the codomain) of the generators of the domain:","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Generic.ModuleHomomorphism(M1::AbstractAlgebra.FPModule{T}, M2::AbstractAlgebra.FPModule{T}, v::Vector{<:AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"module_homomorphism/#Kernels","page":"Module Homomorphisms","title":"Kernels","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"kernel(f::Map(AbstractAlgebra.FPModuleHomomorphism))","category":"page"},{"location":"module_homomorphism/#AbstractAlgebra.Generic.kernel-Tuple{Map{D,C,var\"#s90\",T} where var\"#s90\"<:AbstractAlgebra.FPModuleHomomorphism where T where C where D}","page":"Module Homomorphisms","title":"AbstractAlgebra.Generic.kernel","text":"kernel(f::ModuleHomomorphism{T}) where T <: RingElement\n\nReturn a pair K, g consisting of the kernel object K of the given module homomorphism f (as a submodule of its domain) and the canonical injection from the kernel into the domain of f\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m = M([ZZ(1), ZZ(2), ZZ(3)])\n(1, 2, 3)\n\njulia> S, f = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> Q, g = quo(M, S)\n(Quotient module over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Free module of rank 3 over Integers\nCodomain: Quotient module over Integers with 2 generators and no relations\n)\n\njulia> kernel(g)\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 3 over Integers)\n","category":"page"},{"location":"module_homomorphism/#Images","page":"Module Homomorphisms","title":"Images","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"image(::Map(AbstractAlgebra.FPModuleHomomorphism))","category":"page"},{"location":"module_homomorphism/#AbstractAlgebra.Generic.image-Tuple{Map{D,C,var\"#s90\",T} where var\"#s90\"<:AbstractAlgebra.FPModuleHomomorphism where T where C where D}","page":"Module Homomorphisms","title":"AbstractAlgebra.Generic.image","text":"image(f::Map(AbstractAlgebra.FPModuleHomomorphism))\n\nReturn a pair I, g consisting of the image object I of the given module homomorphism f (as a submodule of its codomain) and the canonical injection from the image into the codomain of f\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\nK, k = kernel(g)\n\nimage(compose(k, g))","category":"page"},{"location":"module_homomorphism/#Preimages","page":"Module Homomorphisms","title":"Preimages","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"preimage(::Map(AbstractAlgebra.FPModuleHomomorphism), ::AbstractAlgebra.FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"module_homomorphism/#AbstractAlgebra.Generic.preimage-Union{Tuple{T}, Tuple{Map{D,C,var\"#s90\",T} where var\"#s90\"<:AbstractAlgebra.FPModuleHomomorphism where T where C where D,AbstractAlgebra.FPModuleElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Homomorphisms","title":"AbstractAlgebra.Generic.preimage","text":"preimage(f::Map(AbstractAlgebra.FPModuleHomomorphism),\n      v::AbstractAlgebra.FPModuleElem{T}) where T <: RingElement\n\nReturn a preimage of v under the homomorphism f, i.e. an element of the domain of f that maps to v under f. Note that this has no special mathematical properties. It is an element of the set theoretical preimage of the map f as a map of sets, if one exists. The preimage is neither unique nor chosen in a canonical way in general. When no such element exists, an exception is raised.\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\n\nm = rand(M, -10:10)\nn = g(m)\n\np = preimage(g, n)","category":"page"},{"location":"module_homomorphism/#Inverses","page":"Module Homomorphisms","title":"Inverses","text":"","category":"section"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Module isomorphisms can be cheaply inverted.","category":"page"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Base.inv(::Map(Generic.ModuleIsomorphism))","category":"page"},{"location":"module_homomorphism/#Base.inv-Tuple{Map{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModuleHomomorphism,AbstractAlgebra.Generic.ModuleIsomorphism} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Module Homomorphisms","title":"Base.inv","text":"Base.inv(f::Map(ModuleIsomorphism))\n\nReturn the inverse map of the given module isomorphism. This is computed cheaply.\n\n\n\n","category":"method"},{"location":"module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 2)\nN = matrix(ZZ, 2, 2, BigInt[1, 0, 0, 1])\nf = ModuleIsomorphism(M, M, N)\n\ng = inv(f)","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"mseries/#Generic-multivariate-series","page":"Generic multivariate series","title":"Generic multivariate series","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"AbstractAlgebra.jl provides generic multivariate series over a commutative ring, implemented in src/generic/AbsMSeries.jl.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Currently only series with capped absolute precision are provided. The precision in each variable can be set, but is capped at some maximum precision which is set when defining the ring.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"As well as implementing the Ring interface, there are numerous additional generic algorithms provided. We describe this generic functionality below.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Only lex ordering is provided at present, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.","category":"page"},{"location":"mseries/#Types-and-parent-objects","page":"Generic multivariate series","title":"Types and parent objects","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Capped absolute generic series implemented using the AbstractAlgebra generics have type Generic.AbsMSeries{T} where T is the type of elements of the coefficient ring. Internally they consist of a multivariate polynomial and a vector of precisions, one for each variable. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Parent objects of such series have type Generic.AbsMSeriesRing{T}.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The series element types belong to the abstract type AbstractAlgebra.MSeriesElem{T} and the series ring types belong to the abstract type AbstractAlgebra.MSeriesRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.","category":"page"},{"location":"mseries/#Multivariate-series-ring-constructors","page":"Generic multivariate series","title":"Multivariate series ring constructors","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"PowerSeriesRing(R::AbstractAlgebra.Ring, prec::Vector{Int}, s::Vector{U}; cached::Bool = true) where U <: AbstractString","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Given a base ring R and vector of strings s specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple U, (x, y, ...) representing the new series ring S and the generators x y ldots of the ring as a tuple. By default the parent object S will depend only on R and the variable names x, y, ... and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Here are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Note that one can also use the function call O(x^n) to specify the precision in the variable x of a given series expression should be precision n.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Note that it is not possible to use x^0 in this function, since there is no distinction between x^0 and y^0 as far as the system is concerned. If one wishes to set the precision of a variable to precision 0, one must use the set_precision! function described below.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"If one wants a series with the same precision in all variables, one can use O(R, n) where R is the series ring and n is the desired precision.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"If all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Examples","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"julia> R, (x, y) = PowerSeriesRing(ZZ, [2, 3], [\"x\", \"y\"])\n(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])\n\njulia> f = R()\nO(y^3) + O(x^2)\n\njulia> g = R(123)\n123 + O(y^3) + O(x^2)\n\njulia> h = R(BigInt(1234))\n1234 + O(y^3) + O(x^2)\n\njulia> k = R(x + 1)\n1 + x + O(y^3) + O(x^2)\n\njulia> m = x + y + O(y^2)\ny + x + O(y^2) + O(x^2)\n\njulia> R, (x, y) = PowerSeriesRing(ZZ, 3, [\"x\", \"y\"])\n(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])\n\njulia> n = x + y + O(R, 2)\ny + x + O(y^2) + O(x^2)","category":"page"},{"location":"mseries/#Basic-ring-functionality","page":"Generic multivariate series","title":"Basic ring functionality","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Once a multivariate series ring is constructed, there are various ways to construct series in that ring.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The easiest way is simply using the generators returned by the PowerSeriesRing constructor and build up the power series using basic arithmetic, as described in the Ring interface.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The power series rings in AbstractAlgebra.jl implement the full Ring interface.","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"We give some examples of such functionality. Note that divexact can currently only divide by unit series (i.e. whose constant coefficient is invertible).","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Examples","category":"page"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"julia> R, (x,) = PowerSeriesRing(ZZ, [5], [\"x\"])\n(Multivariate power series ring in x over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt,AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])\n\njulia> f = x^3 + 3x + 21\n21 + 3*x + x^3 + O(x^5)\n\njulia> h = zero(R)\nO(x^5)\n\njulia> k = one(R)\n1 + O(x^5)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(f)\n3\n\njulia> U = base_ring(R)\nIntegers\n\njulia> v = symbols(R)\n1-element Array{Symbol,1}:\n :x\n\njulia> T = parent(x + 1)\nMultivariate power series ring in x over Integers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> t = divexact(f*x, 1 + x)\n21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)","category":"page"},{"location":"mseries/#Power-series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic multivariate series","title":"Power series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.","category":"page"},{"location":"mseries/#Basic-functionality","page":"Generic multivariate series","title":"Basic functionality","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"nvars(::Generic.AbsMSeriesRing)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.nvars","text":"nvars(R::AbsMSeriesRing)\n\nReturn the number of variables in the series ring.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"symbols(::AbstractAlgebra.MSeriesRing)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.symbols-Tuple{AbstractAlgebra.MSeriesRing}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.symbols","text":"symbols(R::AbstractAlgebra.MSeriesRing)\n\nReturn a vector of symbols, one for each of the variables of the series ring R.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"precision(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"Base.precision","text":"precision(a::AbsMSeries)\n\nReturn a vector of precisions, one for each variable in the series ring.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"max_precision(::Generic.AbsMSeriesRing)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.max_precision","text":"max_precision(R::AbsMSeriesRing)\n\nReturn a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"valuation(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.valuation","text":"valuation(a::AbsMSeries)\n\nReturn the valuation of a as a vector of integers, one for each variable.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"coeff(::Generic.AbsMSeries, ::Int)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries,Int64}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.coeff","text":"coeff(a::AbsMSeries, n::Int)\n\nReturn the coefficient of the n-th nonzero term of the series (or zero if there are fewer than n nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"characteristic(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.characteristic","text":"characteristic(R::AbstractAlgebra.FracField{T}) where T <: RingElem\n\nReturn the characteristic of the given field.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"gen(::Generic.AbsMSeriesRing, ::Int)","category":"page"},{"location":"mseries/#AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing,Int64}","page":"Generic multivariate series","title":"AbstractAlgebra.gen","text":"gen(R::AbsMSeriesRing, i::Int)\n\nReturn the i-th generator (variable) of the series ring R. Numbering starts from 1 for the most significant variable.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"gens(::Generic.AbsMSeriesRing)","category":"page"},{"location":"mseries/#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Generic multivariate series","title":"AbstractAlgebra.gens","text":"gens(R::AbsMSeriesRing)\n\nReturn a vector of the generators (variables) of the series ring R, starting with the most significant.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"isgen(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.isgen","text":"isgen(a::AbsMSeries)\n\nReturn true if the series a is a generator of its parent series ring.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"isunit(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.isunit","text":"isunit(a::AbsMSeries)\n\nReturn true if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"length(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"Base.length","text":"length(a::AbsMSeries)\n\nReturn the number of nonzero terms in the series a.\n\n\n\n","category":"method"},{"location":"mseries/#Iteration","page":"Generic multivariate series","title":"Iteration","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"coefficients(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.coefficients","text":"coefficients(a::AbsMSeries)\n\nReturn an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"exponent_vectors(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.exponent_vectors","text":"exponent_vectors(a::AbsMSeries)\n\nReturn an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n","category":"method"},{"location":"mseries/#Truncation","page":"Generic multivariate series","title":"Truncation","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"truncate(::Generic.AbsMSeries, ::Vector{Int})","category":"page"},{"location":"mseries/#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries,Array{Int64,1}}","page":"Generic multivariate series","title":"Base.truncate","text":"truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})\n\nReturn a truncated to (absolute) precisions given by the vector prec.\n\n\n\n","category":"method"},{"location":"mseries/#Inversion","page":"Generic multivariate series","title":"Inversion","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"Base.inv(::Generic.AbsMSeries)","category":"page"},{"location":"mseries/#Base.inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Generic multivariate series","title":"Base.inv","text":"Base.inv(x::AbsMSeries)\n\nReturn the inverse of the series x. An exception is raised if the series is not a unit.\n\n\n\n","category":"method"},{"location":"mseries/#Exact-division","page":"Generic multivariate series","title":"Exact division","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"divexact(::Generic.AbsMSeries{T}, ::Generic.AbsMSeries{T}) where T <: RingElem","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T,S} where S,AbstractAlgebra.Generic.AbsMSeries{T,S} where S}} where T<:RingElem","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.divexact","text":"divexact(x::AbsMSeries{T}, y::AbsMSeries{T}) where T <: RingElement\n\nReturn the exact quotient of the series x by the series y. This function currently assumes y is an invertible series.\n\n\n\n","category":"method"},{"location":"mseries/#Evaluation","page":"Generic multivariate series","title":"Evaluation","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"evaluate(::U, ::Vector{Int}, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{Int64,1},Array{U,1}}} where U<:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"evaluate(::U, ::Vector{U}, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1},Array{U,1}}} where U<:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables given by the array vars. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"evaluate(::U, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"mseries/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U,Array{U,1}}} where U<:(AbstractAlgebra.Generic.AbsMSeries{T,S} where S) where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic multivariate series","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::U, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the variables the series ring to which a belongs. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"mseries/#Random-generation","page":"Generic multivariate series","title":"Random generation","text":"","category":"section"},{"location":"mseries/","page":"Generic multivariate series","title":"Generic multivariate series","text":"rand(::AbstractAlgebra.MSeriesRing, term_range, v...)","category":"page"},{"location":"mseries/#Base.rand-Tuple{AbstractAlgebra.MSeriesRing,Any,Vararg{Any,N} where N}","page":"Generic multivariate series","title":"Base.rand","text":"rand(S::AbstractAlgebra.MSeriesRing, term_range, v...)\n\nReturn a random element of the series ring S with number of terms in the range given by term_range and where coefficients of the series are randomly generated in the base ring using the data given by v. The exponents of the variable in the terms will be less than the precision caps for the Ring S when it was created.\n\n\n\n","category":"method"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"free_module/#Free-Modules-and-Vector-Spaces","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"","category":"section"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra allows the construction of the free module of any rank over any Euclidean ring and the vector space of any dimension over a field. By default the system considers the free module of a given rank over a given ring or vector space of given dimension over a field to be unique.","category":"page"},{"location":"free_module/#Types-and-parents","page":"Free Modules and Vector Spaces","title":"Types and parents","text":"","category":"section"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra provides the type FreeModule{T} for free modules, where T is the type of the elements of the ring R over which the module is built. The type FreeModule{T} belongs to AbstractAlgebra.FPModule{T}.","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Vector spaces are simply free modules over a field.","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The free module of a given rank over a given ring is made unique on the system by caching them (unless an optional cache parameter is set to false).","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"free_module/#Functionality-for-free-modules","page":"Free Modules and Vector Spaces","title":"Functionality for free modules","text":"","category":"section"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"As well as implementing the entire module interface, free modules provide the following functionality.","category":"page"},{"location":"free_module/#Constructors","page":"Free Modules and Vector Spaces","title":"Constructors","text":"","category":"section"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"FreeModule(R::AbstractAlgebra.Ring, rank::Int)\nVectorSpace(F::AbstractAlgebra.Field, dim::Int)","category":"page"},{"location":"free_module/#AbstractAlgebra.FreeModule-Tuple{AbstractAlgebra.Ring,Int64}","page":"Free Modules and Vector Spaces","title":"AbstractAlgebra.FreeModule","text":"FreeModule(R::NCRing, rank::Int; cached::Bool = true)\n\nReturn the free module over the ring R with the given rank.\n\n\n\n","category":"method"},{"location":"free_module/#AbstractAlgebra.VectorSpace-Tuple{AbstractAlgebra.Field,Int64}","page":"Free Modules and Vector Spaces","title":"AbstractAlgebra.VectorSpace","text":"VectorSpace(R::Field, dim::Int; cached::Bool = true)\n\nReturn the vector space over the field R with the given dimension.\n\n\n\n","category":"method"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Construct the free module/vector space of given rank/dimension.","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n","category":"page"},{"location":"free_module/#Basic-manipulation","page":"Free Modules and Vector Spaces","title":"Basic manipulation","text":"","category":"section"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"rank(M::Generic.FreeModule{T}) where T <: AbstractAlgebra.RingElem\ndim(V::Generic.FreeModule{T}) where T <: AbstractAlgebra.FieldElem\nbasis(V::Generic.FreeModule{T}) where T <: AbstractAlgebra.FieldElem","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> rank(M)\n3\n\njulia> dim(V)\n2\n\njulia> basis(V)\n2-element Array{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}},1}:\n (1//1, 0//1)\n (0//1, 1//1)","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"ncpolynomial/#Generic-univariate-polynomials-over-a-noncommutative-ring","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/NCPoly.jl for generic polynomials over any noncommutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"As well as implementing the Univariate Polynomial interface, there are many additional generic algorithms implemented for such polynomial rings. We describe this generic functionality below.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"ncpolynomial/#Types-and-parent-objects","page":"Generic univariate polynomials over a noncommutative ring","title":"Types and parent objects","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Polynomials implemented using the AbstractAlgebra generics have type Generic.NCPoly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Parent objects of such polynomials have type Generic.NCPolyRing{T}.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object. ","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The polynomial element types belong to the abstract type AbstractAlgebra.NCPolyElem{T} and the polynomial ring types belong to the abstract type AbstractAlgebra.NCPolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Note that both the generic polynomial ring type Generic.NCPolyRing{T} and the abstract type it belongs to, AbstractAlgebra.NCPolyRing{T} are both called NCPolyRing. The  former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"ncpolynomial/#Polynomial-ring-constructors","page":"Generic univariate polynomials over a noncommutative ring","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"PolynomialRing(R::AbstractAlgebra.NCRing, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Given a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring. By default the parent object S will depend only on R and  x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"A shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"R[\"x\"]","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> U, z = R[\"z\"]\n(Univariate Polynomial Ring in z over Matrix Algebra of degree 2 over Integers, z)\n\njulia> f = S()\n0\n\njulia> g = S(123)\n[123 0; 0 123]\n\njulia> h = T(BigInt(1234))\n[1234 0; 0 1234]\n\njulia> k = T(x + 1)\nx + 1\n\njulia> m = U(z + 1)\nz + 1\n","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a PolynomialRing constructor to allow creation of their polynomial rings.","category":"page"},{"location":"ncpolynomial/#Basic-ring-functionality","page":"Generic univariate polynomials over a noncommutative ring","title":"Basic ring functionality","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The easiest way is simply using the generator returned by the PolynomialRing constructor and build up the polynomial using basic arithmetic, as described in the Ring interface. ","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The Julia language also has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The polynomial rings in AbstractAlgebra.jl implement the full Ring interface. Of course the entire Univariate Polynomial Ring interface is also implemented.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"We give some examples of such functionality.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + [3 0; 0 3]*x + [21 0; 0 21]\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + [2 0; 0 2]*x + 1\n\njulia> h = zero(T)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(g)\n3\n\njulia> U = base_ring(T)\nUnivariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> V = base_ring(y + 1)\nUnivariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> v = var(T)\n:y\n\njulia> U = parent(y + 1)\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> g == deepcopy(g)\ntrue","category":"page"},{"location":"ncpolynomial/#Polynomial-functionality-provided-by-AbstractAlgebra.jl","page":"Generic univariate polynomials over a noncommutative ring","title":"Polynomial functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any polynomial module that implements the full Univariate Polynomial Ring interface over a noncommutative ring. This includes AbstractAlgebra.jl's own generic polynomial rings.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"But if a C library provides all the functionality documented in the Univariate Polynomial Ring interface over a noncommutative ring, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that polynomial type.","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Of course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"ncpolynomial/#Basic-functionality","page":"Generic univariate polynomials over a noncommutative ring","title":"Basic functionality","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"leading_coefficient(::NCPolyElem)\ntrailing_coefficient(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.leading_coefficient-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(a::Generic.PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.trailing_coefficient-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.trailing_coefficient","text":"trailing_coefficient(a::Generic.PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"gen(::NCPolyRing)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.gen-Tuple{AbstractAlgebra.NCPolyRing}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.gen","text":"gen(R::AbstractAlgebra.NCPolyRing)\n\nReturn the generator of the given polynomial ring.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"isgen(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.isgen-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.isgen","text":"isgen(a::Generic.PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"isunit(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.isunit-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.isunit","text":"isunit(a::Generic.PolynomialElem)\n\nReturn true if the given polynomial is a unit in its polynomial ring, otherwise return false.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"ismonomial(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.ismonomial-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.ismonomial","text":"ismonomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"isterm(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.isterm-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.isterm","text":"isterm(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> a = zero(T)\n0\n\njulia> b = one(T)\n1\n\njulia> c = BigInt(1)*y^2 + BigInt(1)\ny^2 + 1\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(T)\ny\n\njulia> g = isgen(y)\ntrue\n\njulia> m = isunit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> isterm(2y^2)\ntrue\n\njulia> ismonomial(y^2)\ntrue\n","category":"page"},{"location":"ncpolynomial/#Truncation","page":"Generic univariate polynomials over a noncommutative ring","title":"Truncation","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"truncate(::NCPolyElem, ::Int)","category":"page"},{"location":"ncpolynomial/#Base.truncate-Tuple{NCPolyElem,Int64}","page":"Generic univariate polynomials over a noncommutative ring","title":"Base.truncate","text":"truncate(a::Generic.PolynomialElem, n::Int)\n\nReturn a truncated to n terms.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"mullow(::NCPolyElem{T}, ::NCPolyElem{T}, ::Int) where T <: NCRingElem","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.mullow-Union{Tuple{T}, Tuple{NCPolyElem{T},NCPolyElem{T},Int64}} where T<:NCRingElem","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.mullow","text":"mullow(a::AbstractAlgebra.NCPolyElem{T}, b::AbstractAlgebra.NCPolyElem{T}, n::Int) where {T <: NCRingElem}\n\nReturn atimes b truncated to n terms.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + [2 0; 0 2]*x + [2 0; 0 2]\n\njulia> h = truncate(f, 1)\n[3 0; 0 3]\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + [3 0; 0 3]*x^2 + [4 0; 0 4]*x + 1)*y^2 + (x^4 + x^3 + [2 0; 0 2]*x^2 + [7 0; 0 7]*x + [5 0; 0 5])*y + [3 0; 0 3]*x^3 + [6 0; 0 6]*x + [6 0; 0 6]\n","category":"page"},{"location":"ncpolynomial/#Reversal","page":"Generic univariate polynomials over a noncommutative ring","title":"Reversal","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"reverse(::NCPolyElem, ::Int)\nreverse(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#Base.reverse-Tuple{NCPolyElem,Int64}","page":"Generic univariate polynomials over a noncommutative ring","title":"Base.reverse","text":"reverse(x::Generic.PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n","category":"method"},{"location":"ncpolynomial/#Base.reverse-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"Base.reverse","text":"reverse(x::Generic.PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = reverse(f, 7)\n[3 0; 0 3]*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n[3 0; 0 3]*y^2 + (x + 1)*y + x\n","category":"page"},{"location":"ncpolynomial/#Shifting","page":"Generic univariate polynomials over a noncommutative ring","title":"Shifting","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"shift_left(::NCPolyElem, ::Int)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.shift_left-Tuple{NCPolyElem,Int64}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.shift_left","text":"shift_left(f::Generic.PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"shift_right(::NCPolyElem, ::Int)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.shift_right-Tuple{NCPolyElem,Int64}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.shift_right","text":"shift_right(f::Generic.PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + [3 0; 0 3]*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"page"},{"location":"ncpolynomial/#Evaluation","page":"Generic univariate polynomials over a noncommutative ring","title":"Evaluation","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"evaluate{T <: NCRingElem}(::NCPolyElem{T}, ::T)\nevaluate(::NCPolyElem, ::Integer)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{T}, Tuple{NCPolyElem{T},T}} where T<:NCRingElem","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.NCPolyElem, b::T) where {T <: NCRingElem}\n\nEvaluate the polynomial a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.evaluate-Tuple{NCPolyElem,Integer}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.NCPolyElem, b::Union{Integer, Rational, AbstractFloat})\n\nEvaluate the polynomial a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a). ","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> k = evaluate(f, 3)\n[12 0; 0 12]*x + [6 0; 0 6]\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + [4 0; 0 4]*x^4 + [7 0; 0 7]*x^3 + [7 0; 0 7]*x^2 + [4 0; 0 4]*x + [4 0; 0 4]\n\njulia> r = f(23)\n[552 0; 0 552]*x + [26 0; 0 26]\n","category":"page"},{"location":"ncpolynomial/#Derivative","page":"Generic univariate polynomials over a noncommutative ring","title":"Derivative","text":"","category":"section"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"derivative(::NCPolyElem)","category":"page"},{"location":"ncpolynomial/#AbstractAlgebra.Generic.derivative-Tuple{NCPolyElem}","page":"Generic univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.Generic.derivative","text":"derivative(a::Generic.PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\n","category":"method"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"ncpolynomial/","page":"Generic univariate polynomials over a noncommutative ring","title":"Generic univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> h = derivative(f)\n[2 0; 0 2]*x*y + x + 1\n","category":"page"},{"location":"constructors/#Constructing-mathematical-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"","category":"section"},{"location":"constructors/#Constructing-objects-in-Julia","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing objects in Julia","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a BigInt object from an Int in Julia, we simply call the BigInt constructor:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"n = BigInt(123)","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Note that a number literal too big to fit in an Int or Int128 automatically creates a BigInt:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"julia> typeof(12345678765456787654567890987654567898765678909876567890)\nBigInt","category":"page"},{"location":"constructors/#How-we-construct-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"How we construct objects in AbstractAlgebra.jl","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"As we explain in Appendix A, Julia types don't contain enough information to properly model groups, rings, fields, etc. Instead of using types to construct objects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Consider the following simple example, to create a multiprecision integer:","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"n = ZZ(12345678765456787654567890987654567898765678909876567890)","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Here ZZ is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object as though it were a type.","category":"page"},{"location":"constructors/#Constructing-parent-objects","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing parent objects","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"AbstractAlgebra.jl provides a set of functions for constructing such parent objects. For example, to create a parent object for univariate polynomials over the integers, we use the PolynomialRing parent object constructor.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"R, x = PolynomialRing(ZZ, \"x\")\nf = x^3 + 3x + 1\ng = R(12)","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"In this example, R is the parent object and we use it to convert the Int value 12 to an element of the polynomial ring mathbbZx.","category":"page"},{"location":"constructors/#List-of-parent-object-constructors","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"List of parent object constructors","text":"","category":"section"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"For convenience, we provide a list of all the parent object constructors in AbstractAlgebra.jl and explain what mathematical domains they represent.","category":"page"},{"location":"constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Mathematics AbstractAlgebra.jl constructor\nR = mathbbZ R = ZZ\nR = mathbbQ R = QQ\nR = mathbbF_p R = GF(p)\nR = mathbbZnmathbbZ R = ResidueRing(ZZ, n)\nS = Rx S, x = PolynomialRing(R, \"x\")\nS = Rx y S, (x, y) = PolynomialRing(R, [\"x\", \"y\"])\nS = Rx (to precision n) S, x = PowerSeriesRing(R, n, \"x\")\nS = R((x)) (to precision n) S, x = LaurentSeriesRing(R, n, \"x\")\nS = K((x)) (to precision n) S, x = LaurentSeriesField(K, n, \"x\")\nS = mathrmFrac_R S = FractionField(R)\nS = R(f) S = ResidueRing(R, f)\nS = R(f) (with (f) maximal) S = ResidueField(R, f)\nS = mathrmMat_mtimes n(R) S = MatrixSpace(R, m, n)\nS = mathbbQx(f) S, a = NumberField(f, \"a\")","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"matrix/#Generic-matrices","page":"Generic matrices","title":"Generic matrices","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"AbstractAlgebra.jl allows the creation of dense matrices over any computable commutative ring R. Generic matrices over a commutative ring are implemented in src/generic/Matrix.jl. Much of the functionality there covers both matrix spaces and matrix algebras.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Functions specific to generic matrix algebras of mtimes m matrices are implemented in src/generic/MatrixAlgebra.jl.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"As well as implementing the entire Matrix interface, including the optional functionality, there are many additional generic algorithms implemented for matrix spaces. We describe this functionality below.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"All of this generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default, so it is not necessary to qualify names of functions.","category":"page"},{"location":"matrix/#Types-and-parent-objects","page":"Generic matrices","title":"Types and parent objects","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatSpaceElem{T} for matrices in a matrix space, or Generic.MatAlgElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"For the most part, one doesn't want to work directly with the MatSpaceElem type though, but with an abstract type called Generic.Mat which includes MatSpaceElem and views thereof.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Parents of generic matrices (matrix spaces) have type Generic.MatSpace{T}. Parents of matrices in a matrix algebra have type Generic.MatAlgebra{T}.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"The generic matrix types (matrix spaces) belong to the abstract type AbstractAlgebra.MatElem{T} and the matrix space parent types belong to AbstractAlgebra.MatSpace{T}. Similarly the generic matrix algebra matrix types belong to the abstract type AbstractAlgebra.MatAlgElem{T} and the parent types belong to  AbstractAlgebra.MatAlgebra{T} Note that both the concrete type of a matrix space parent object and the abstract class it belongs to have the name MatElem, therefore disambiguation is required to specify which is intended. The same is true for the abstract types for matrix spaces and their elements.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"The dimensions and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"matrix/#Matrix-space-constructors","page":"Generic matrices","title":"Matrix space constructors","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"A matrix space in AbstractAlgebra.jl represents a collection of all matrices with given dimensions and base ring.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"In order to construct matrices in AbstractAlgebra.jl, one can first construct the matrix space itself. This is accomplished with the following constructor. We discuss creation of matrix algebras separately in a dedicated section elsewhere in the documentation.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"MatrixSpace(R::Ring, rows::Int, cols::Int; cache::Bool=true)","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Construct the space of matrices with the given number of rows and columns over the given base ring. By default such matrix spaces are cached based on the base ring and numbers of rows and columns. If the optional named parameter cached is set to false, no caching occurs.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Here are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"We also allow matrices over a given base ring to be constructed directly (see the Matrix interface).","category":"page"},{"location":"matrix/#Matrix-element-constructors","page":"Generic matrices","title":"Matrix element constructors","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"In addition to coercing elements into a matrix space as above, we provide the following syntax for constructing literal matrices (similar to how Julia arrays can be be constructed).","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"R[a b c...;...]","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Create the matrix over the base ring R consisting of the given rows (separated by semicolons). Each entry is coerced into R  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. R[1 2; 2 (- 3)].","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Also see the Matrix interface for a list of other ways to create matrices.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> M = R[t + 1 1; t^2 0]\n[t + 1   1]\n[  t^2   0]\n\njulia> N = R[t + 1 2 t] # create a row vector\n[t + 1   2   t]\n\njulia> P = R[1; 2; t] # create a column vector\n[1]\n[2]\n[t]","category":"page"},{"location":"matrix/#Conversion-to-Julia-matrices-and-iteration","page":"Generic matrices","title":"Conversion to Julia matrices and iteration","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"While AbstractAlgebra matrices are not instances of AbstractArray, they are closely related to Julia matrices. For convenience, a Matrix and an Array constructors taking an AbstractAlgebra matrix as input are provided:","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Matrix(::MatrixElem)\nArray(::MatrixElem)","category":"page"},{"location":"matrix/#Base.Matrix-Tuple{Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"Base.Matrix","text":"Matrix(A::MatrixElem)\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> Matrix(A)\n23 Array{BigInt,2}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Core.Array-Tuple{Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"Core.Array","text":"Array(A::MatrixElem)\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> R, x = ZZ[\"x\"]; A = R[x^0 x^1; x^2 x^3]\n[  1     x]\n[x^2   x^3]\n\njulia> Array(A)\n22 Array{AbstractAlgebra.Generic.Poly{BigInt},2}:\n 1    x\n x^2  x^3\n\n\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Matrices also support iteration, and therefore functions accepting an iterator can be called on them, e.g.:","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> M = MatrixSpace(ZZ, 2, 3); x = M(1:6)\n[1   2   3]\n[4   5   6]\n\njulia> collect(x)\n23 Array{BigInt,2}:\n 1  2  3\n 4  5  6\n\njulia> Set(x)\nSet{BigInt} with 6 elements:\n  4\n  2\n  3\n  5\n  6\n  1","category":"page"},{"location":"matrix/#Matrix-functionality-provided-by-AbstractAlgebra.jl","page":"Generic matrices","title":"Matrix functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Most of the following generic functionality is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve, kernel, and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"For details on functionality that is provided for matrix algebras only, see the dedicated section of the documentation.","category":"page"},{"location":"matrix/#Basic-matrix-functionality","page":"Generic matrices","title":"Basic matrix functionality","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices and to set and retrieve entries and other basic data associated with the matrices.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"dense_matrix_type(::Ring)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.dense_matrix_type-Tuple{AbstractAlgebra.Ring}","page":"Generic matrices","title":"AbstractAlgebra.Generic.dense_matrix_type","text":"dense_matrix_type(R::Ring)\n\nReturn the type of matrices over the given ring.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"nrows(::Generic.MatrixElem)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.nrows-Tuple{Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"AbstractAlgebra.Generic.nrows","text":"nrows(a::Generic.MatrixElem)\n\nReturn the number of rows of the given matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"ncols(::Generic.MatrixElem)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.ncols-Tuple{Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"AbstractAlgebra.Generic.ncols","text":"ncols(a::Generic.MatrixElem)\n\nReturn the number of columns of the given matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"length(::MatElem)","category":"page"},{"location":"matrix/#Base.length-Tuple{MatElem}","page":"Generic matrices","title":"Base.length","text":"length(a::Generic.MatrixElem)\n\nReturn the number of entries in the given matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"isempty(::MatElem)","category":"page"},{"location":"matrix/#Base.isempty-Tuple{MatElem}","page":"Generic matrices","title":"Base.isempty","text":"isempty(a::Generic.MatrixElem)\n\nReturn true if a does not contain any entry (i.e. length(a) == 0), and false otherwise.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"identity_matrix(::Ring, ::Int)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.identity_matrix-Tuple{AbstractAlgebra.Ring,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.identity_matrix","text":"identity_matrix(R::Ring, n::Int) -> MatElem\n\nReturn the n times n identity matrix over R.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"identity_matrix(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: RingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"diagonal_matrix(::RingElement, ::Int, ::Int)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.diagonal_matrix-Tuple{Union{RingElem, AbstractFloat, Integer, Rational},Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.diagonal_matrix","text":"diagonal_matrix(x::RingElement, m::Int, [n::Int])\n\nReturn the m times n matrix over R with x along the main diagonal and zeroes elsewhere. If n is not specified, it defaults to m.\n\nExamples\n\njulia> diagonal_matrix(ZZ(2), 2, 3)\n[2   0   0]\n[0   2   0]\n\njulia> diagonal_matrix(QQ(-1), 3)\n[-1//1    0//1    0//1]\n[ 0//1   -1//1    0//1]\n[ 0//1    0//1   -1//1]\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"zero(::AbstractAlgebra.MatSpace)\nzero(::Generic.MatrixElem)","category":"page"},{"location":"matrix/#Base.zero-Tuple{MatSpace}","page":"Generic matrices","title":"Base.zero","text":"zero(a::AbstractAlgebra.MatSpace)\n\nConstruct the zero matrix in the given matrix space.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"one(::AbstractAlgebra.MatSpace)\none(::MatElem)","category":"page"},{"location":"matrix/#Base.one-Tuple{MatSpace}","page":"Generic matrices","title":"Base.one","text":"one(a::AbstractAlgebra.MatSpace)\n\nConstruct the matrix in the given matrix space with ones down the diagonal and zeroes elsewhere. The matrix space must contain square matrices.\n\n\n\n","category":"method"},{"location":"matrix/#Base.one-Tuple{MatElem}","page":"Generic matrices","title":"Base.one","text":"one(a::MatElem)\n\nConstruct the identity matrix in the same matrix space as a, i.e. with ones down the diagonal and zeroes elsewhere. a must be square.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"istriu(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"matrix/#LinearAlgebra.istriu-Union{Tuple{Union{MatAlgElem{T}, MatElem{T}}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"LinearAlgebra.istriu","text":"function istriu(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is an upper triangular matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"change_base_ring(::AbstractAlgebra.Ring, ::AbstractAlgebra.MatElem)","category":"page"},{"location":"matrix/#AbstractAlgebra.change_base_ring-Tuple{AbstractAlgebra.Ring,MatElem}","page":"Generic matrices","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, M::MatrixElem)\n\nReturn the matrix obtained by coercing each entry into R.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Base.map(f, ::Generic.MatrixElem)","category":"page"},{"location":"matrix/#Base.map-Tuple{Any,Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"Base.map","text":"map(f, a::MatrixElem)\n\nTransform matrix a by applying f on each element. This is equivalent to map_entries(f, a).\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Base.map!(f, ::Generic.MatrixElem, ::Generic.MatrixElem)","category":"page"},{"location":"matrix/#Base.map!-Tuple{Any,Union{MatAlgElem{T}, MatElem{T}} where T,Union{MatAlgElem{T}, MatElem{T}} where T}","page":"Generic matrices","title":"Base.map!","text":"map!(f, dst::MatrixElem, src::MatrixElem)\n\nLike map, but stores the result in dst rather than a new matrix. This is equivalent to map_entries!(f, dst, src).\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n[ 2       3       1]\n[ t   t + 1   t + 2]\n[-1     t^2     t^3]\n\njulia> T = dense_matrix_type(R)\nAbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}\n\njulia> r = nrows(B)\n3\n\njulia> c = ncols(B)\n3\n\njulia> length(B)\n9\n\njulia> isempty(B)\nfalse\n\njulia> M = A + B\n[  t + 3         t + 3                   2]\n[t^2 + t       2*t + 1             2*t + 2]\n[     -3   t^2 + t + 2   t^3 + t^2 + t + 1]\n\njulia> N = 2 + A\n[t + 3       t             1]\n[  t^2   t + 2             t]\n[   -2   t + 2   t^2 + t + 3]\n\njulia> M1 = deepcopy(A)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> A != B\ntrue\n\njulia> isone(one(S))\ntrue\n\njulia> V = A[1:2, :]\n[t + 1   t   1]\n[  t^2   t   t]\n\njulia> W = A^3\n[    3*t^4 + 4*t^3 + t^2 - 3*t - 5            t^4 + 5*t^3 + 10*t^2 + 7*t + 4                 2*t^4 + 7*t^3 + 9*t^2 + 8*t + 1]\n[t^5 + 4*t^4 + 3*t^3 - 7*t^2 - 4*t               4*t^4 + 8*t^3 + 7*t^2 + 2*t                 t^5 + 5*t^4 + 9*t^3 + 7*t^2 - t]\n[  t^5 + 3*t^4 - 10*t^2 - 16*t - 2   t^5 + 6*t^4 + 12*t^3 + 11*t^2 + 5*t - 2   t^6 + 3*t^5 + 8*t^4 + 15*t^3 + 10*t^2 + t - 5]\n\njulia> Z = divexact(2*A, 2)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n","category":"page"},{"location":"matrix/#Elementary-row-and-column-operations","page":"Generic matrices","title":"Elementary row and column operations","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"add_column(::MatElem, ::Int, ::Int, ::Int)\nadd_column!(::MatElem, ::Int, ::Int, ::Int)\nadd_row(::MatElem, ::Int, ::Int, ::Int)\nadd_row!(::MatElem, ::Int, ::Int, ::Int)\nmultiply_column(::MatElem, ::Int, ::Int)\nmultiply_column!(::MatElem, ::Int, ::Int)\nmultiply_row(::MatElem, ::Int, ::Int)\nmultiply_row!(::MatElem, ::Int, ::Int)\n","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.add_column-Tuple{MatElem,Int64,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.add_column","text":"add_column(a::MatrixElem, s::RingElement, i::Int, j::Int, rows = 1:nrows(a))\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.add_column!-Tuple{MatElem,Int64,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.add_column!","text":"add_column!(a::MatrixElem, s::RingElement, i::Int, j::Int, rows = 1:nrows(a))\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.add_row-Tuple{MatElem,Int64,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.add_row","text":"add_row(a::MatrixElem, s::RingElement, i::Int, j::Int, cols = 1:ncols(a))\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.add_row!-Tuple{MatElem,Int64,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.add_row!","text":"add_row!(a::MatrixElem, s::RingElement, i::Int, j::Int, cols = 1:ncols(a))\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.multiply_column-Tuple{MatElem,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.multiply_column","text":"multiply_column(a::MatrixElem, s::RingElement, i::Int, rows = 1:nrows(a))\n\nCreate a copy of a and multiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.multiply_column!-Tuple{MatElem,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.multiply_column!","text":"multiply_column!(a::MatrixElem, s::RingElement, i::Int, rows = 1:nrows(a))\n\nMultiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.multiply_row-Tuple{MatElem,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.multiply_row","text":"multiply_row(a::MatrixElem, s::RingElement, i::Int, cols = 1:ncols(a))\n\nCreate a copy of a and multiply  the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.multiply_row!-Tuple{MatElem,Int64,Int64}","page":"Generic matrices","title":"AbstractAlgebra.Generic.multiply_row!","text":"multiply_row!(a::MatrixElem, s::RingElement, i::Int, cols = 1:ncols(a))\n\nMultiply the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> add_column(M, 2, 3, 1)\n[ 7   2   3]\n[10   3   4]\n[14   5   5]\n\njulia> add_row(M, 1, 2, 3)\n[1   2   3]\n[2   3   4]\n[6   8   9]\n\njulia> multiply_column(M, 2, 3)\n[1   2    6]\n[2   3    8]\n[4   5   10]\n\njulia> multiply_row(M, 2, 3)\n[1    2    3]\n[2    3    4]\n[8   10   10]","category":"page"},{"location":"matrix/#Powering","page":"Generic matrices","title":"Powering","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"powers(::MatElem, ::Int)","category":"page"},{"location":"matrix/#AbstractAlgebra.powers-Tuple{MatElem,Int64}","page":"Generic matrices","title":"AbstractAlgebra.powers","text":"powers(a::Union{NCRingElement, MatElem}, d::Int)\n\nReturn an array M of \"powers\" of a where Mi + 1 = a^i for i = 0d\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> A = powers(M, 4)\n5-element Array{AbstractAlgebra.Generic.MatSpaceElem{BigInt},1}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 2 3; 2 3 4; 4 5 5]\n [17 23 26; 24 33 38; 34 48 57]\n [167 233 273; 242 337 394; 358 497 579]\n [1725 2398 2798; 2492 3465 4044; 3668 5102 5957]\n","category":"page"},{"location":"matrix/#Gram-matrix","page":"Generic matrices","title":"Gram matrix","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"gram(::MatElem)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.gram-Tuple{MatElem}","page":"Generic matrices","title":"AbstractAlgebra.Generic.gram","text":"gram(x::AbstractAlgebra.MatElem)\n\nReturn the Gram matrix of x, i.e. if x is an rtimes c matrix return the rtimes r matrix whose entries i j are the dot products of the i-th and j-th rows, respectively.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = gram(A)\n[2*t^2 + 2*t + 2   t^3 + 2*t^2 + t                   2*t^2 + t - 1]\n[t^3 + 2*t^2 + t       t^4 + 2*t^2                       t^3 + 3*t]\n[  2*t^2 + t - 1         t^3 + 3*t   t^4 + 2*t^3 + 4*t^2 + 6*t + 9]\n","category":"page"},{"location":"matrix/#Trace","page":"Generic matrices","title":"Trace","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"tr(::MatElem)","category":"page"},{"location":"matrix/#LinearAlgebra.tr-Tuple{MatElem}","page":"Generic matrices","title":"LinearAlgebra.tr","text":"tr(x::Generic.MatrixElem)\n\nReturn the trace of the matrix a, i.e. the sum of the diagonal elements. We require the matrix to be square.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = tr(A)\nt^2 + 3*t + 2\n","category":"page"},{"location":"matrix/#Content","page":"Generic matrices","title":"Content","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"content(::MatElem)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.content-Tuple{MatElem}","page":"Generic matrices","title":"AbstractAlgebra.Generic.content","text":"content(x::Generic.MatrixElem)\n\nReturn the content of the matrix a, i.e. the greatest common divisor of all its entries, assuming it exists.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = content(A)\n1\n","category":"page"},{"location":"matrix/#Permutation","page":"Generic matrices","title":"Permutation","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"*(::Perm, ::MatElem)","category":"page"},{"location":"matrix/#Base.:*-Tuple{Perm,MatElem}","page":"Generic matrices","title":"Base.:*","text":"*(P::Generic.perm, x::Generic.MatrixElem)\n\nApply the pemutation P to the rows of the matrix x and return the result.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> G = SymmetricGroup(3)\nFull symmetric group over 3 elements\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> P = G([1, 3, 2])\n(2,3)\n\njulia> B = P*A\n[t + 1       t             1]\n[   -2   t + 2   t^2 + t + 1]\n[  t^2       t             t]\n","category":"page"},{"location":"matrix/#LU-factorisation","page":"Generic matrices","title":"LU factorisation","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"lu{T <: FieldElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"matrix/#LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T},AbstractAlgebra.SymmetricGroup}} where T<:FieldElem","page":"Generic matrices","title":"LinearAlgebra.lu","text":"lu(A::Generic.MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: FieldElement}\n\nReturn a tuple r p L U consisting of the rank of A, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"fflu{T <: RingElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.fflu-Union{Tuple{T}, Tuple{MatElem{T},AbstractAlgebra.SymmetricGroup}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.fflu","text":"fflu(A::Generic.MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: RingElement}\n\nReturn a tuple r d p L U consisting of the rank of A, a denominator d, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LDU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A and such that D is the diagonal matrix diag(p_1 p_1p_2 ldots p_n-2p_n-1 p_n-1p_n) where the p_i are the inverses of the diagonal entries of L. The denominator d is set to pm mathrmdet(S) where S is an appropriate submatrix of A (S = A if A is square and nonsingular) and the sign is decided by the parity of the permutation.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n[      0   2*x + 3   x^2 + 1]\n[x^2 - 2     x - 1       2*x]\n[x^2 - 2     x - 1       2*x]\n\njulia> r, P, L, U = lu(A)\n(2, (1,2), [1 0 0; 0 1 0; 1 0 1], [x^2-2 x-1 2*x; 0 2*x+3 x^2+1; 0 0 0])\n\njulia> r, d, P, L, U = fflu(A)\n(2, 3*x^2 - 10*x - 8, (1,2), [x^2-2 0 0; 0 3*x^2-10*x-8 0; x^2-2 0 1], [x^2-2 x-1 2*x; 0 3*x^2-10*x-8 -4*x^2-x-2; 0 0 0])\n","category":"page"},{"location":"matrix/#Reduced-row-echelon-form","page":"Generic matrices","title":"Reduced row-echelon form","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"rref_rational{T <: RingElem}(::MatElem{T})\nrref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.rref_rational","text":"rref_rational(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn a tuple (r A d) consisting of the rank r of M and a denominator d in the base ring of M and a matrix A such that Ad is the reduced row echelon form of M. Note that the denominator is not usually minimal.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.rref","text":"rref(M::Generic.MatrixElem{T}) where {T <: FieldElement}\n\nReturn a tuple (r A) consisting of the rank r of M and a reduced row echelon form A of M.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"isrref{T <: RingElem}(::MatElem{T})\nisrref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.isrref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.isrref","text":"isrref(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.isrref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.isrref","text":"isrref(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\nisrref(M::Generic.MatrixElem{T}) where {T <: FieldElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> M = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A = rref(M)\n(3, [1 0 0; 0 1 0; 0 0 1])\n\njulia> isrref(A)\ntrue\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> M = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A, d = rref_rational(M)\n(3, [-x^5-2*x^4-15*x^3-18*x^2-8*x-7 0 0; 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7 0; 0 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n\njulia> isrref(A)\ntrue","category":"page"},{"location":"matrix/#Determinant","page":"Generic matrices","title":"Determinant","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"det{T <: RingElem}(::MatElem{T})\ndet{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"matrix/#LinearAlgebra.det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"LinearAlgebra.det","text":"det(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Generic matrices","title":"LinearAlgebra.det","text":"det(M::Generic.MatrixElem{T}) where {T <: FieldElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\ndet(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> d = det(A)\n11*x^2 - 30*x - 5\n","category":"page"},{"location":"matrix/#Rank","page":"Generic matrices","title":"Rank","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"rank{T <: RingElem}(::MatElem{T})\nrank{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"matrix/#LinearAlgebra.rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"LinearAlgebra.rank","text":"rank(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Generic matrices","title":"LinearAlgebra.rank","text":"rank(M::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\n\n\nrank(M::Generic.MatrixElem{T}) where {T <: FieldElement}\n\nReturn the rank of the matrix M.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> d = rank(A)\n3\n","category":"page"},{"location":"matrix/#Linear-solving","page":"Generic matrices","title":"Linear solving","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"solve{T <: FieldElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.solve-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:FieldElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.solve","text":"solve(a::AbstractAlgebra.MatElem{S}, b::AbstractAlgebra.MatElem{S}) where {S <: RingElement}\n\nGiven an mtimes r matrix a over a ring and an mtimes n matrix b over the same ring, return an rtimes n matrix x such that ax = b. If no such matrix exists, an exception is raised. See also solve_left.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"solve_rational{T <: RingElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.solve_rational-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.solve_rational","text":"solve_rational(M::AbstractAlgebra.MatElem{T}, b::AbstractAlgebra.MatElem{T}) where T <: RingElement\n\nGiven a non-singular ntimes n matrix over a ring and an ntimes m matrix over the same ring, return a tuple x d consisting of an ntimes m matrix x and a denominator d such that Ax = db. The denominator will be the determinant of A up to sign. If A is singular an exception is raised.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"can_solve_with_solution{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.can_solve_with_solution-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.can_solve_with_solution","text":"can_solve_with_solution(a::AbstractAlgebra.MatElem{S}, b::AbstractAlgebra.MatElem{S}; side::Symbol = :right) where S <: RingElement\n\nGiven two matrices a and b over the same ring, try to solve ax = b if side is :right or xa = b if side is :left. In either case, return a tuple (flag, x). If a solution exists, flag is set to true and x is a solution. If no solution exists, flag is set to false and x is arbitrary. If the dimensions of a and b are incompatible, an exception is raised.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"can_solve{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.can_solve-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.can_solve","text":"can_solve(a::AbstractAlgebra.MatElem{S}, b::AbstractAlgebra.MatElem{S}; side::Symbol = :right) where S <: RingElement\n\nGiven two matrices a and b over the same ring, check the solubility of ax = b if side is :right or xa = b if side is :left. Return true if a solution exists, false otherwise. If the dimensions of a and b are incompatible, an exception is raised. If a solution should be computed as well, use can_solve_with_solution instead.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"solve_left{T <: RingElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.solve_left-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.solve_left","text":"solve_left(a::AbstractAlgebra.MatElem{S}, b::AbstractAlgebra.MatElem{S}) where S <: RingElement\n\nGiven an rtimes n matrix a over a ring and an mtimes n matrix b over the same ring, return an mtimes r matrix x such that xa = b. If no such matrix exists, an exception is raised. See also solve.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"solve_triu{T <: FieldElem}(::MatElem{T}, ::MatElem{T}, ::Bool)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.solve_triu-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T},Bool}} where T<:FieldElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.solve_triu","text":"solve_triu(U::AbstractAlgebra.MatElem{T}, b::AbstractAlgebra.MatElem{T}, unit::Bool = false) where {T <: FieldElement}\n\nGiven a non-singular ntimes n matrix over a field which is upper triangular, and an ntimes m matrix over the same field, return an ntimes m matrix x such that Ax = b. If A is singular an exception is raised. If unit is true then U is assumed to have ones on its diagonal, and the diagonal will not be read.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"can_solve_left_reduced_triu{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.can_solve_left_reduced_triu-Union{Tuple{T}, Tuple{MatElem{T},MatElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.can_solve_left_reduced_triu","text":"can_solve_left_reduced_triu(r::AbstractAlgebra.MatElem{T},\n                      M::AbstractAlgebra.MatElem{T}) where T <: RingElement\n\nReturn a tuple flag, x where flag is set to true if xM = r has a solution, where M is an mtimes n matrix in (upper triangular) Hermite normal form or reduced row echelon form and r and x are row vectors with m columns. If there is no solution, flag is set to false and x is set to the zero row.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> U = MatrixSpace(K, 3, 1)\nMatrix Space of 3 rows and 1 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> b = U([2a a + 1 (-a - 1)]')\n[   2*x]\n[ x + 1]\n[-x - 1]\n\njulia> x = solve(A, b)\n[  1984//7817*x^2 + 1573//7817*x - 937//7817]\n[ -2085//7817*x^2 + 1692//7817*x + 965//7817]\n[-3198//7817*x^2 + 3540//7817*x - 3525//7817]\n\njulia> A = matrix(ZZ, 2, 2, [1, 2, 0, 2])\n[1   2]\n[0   2]\n\njulia> b = matrix(ZZ, 2, 1, [2, 1])\n[2]\n[1]\n\njulia> can_solve(A, b, side = :right)\nfalse\n\njulia> A = matrix(QQ, 2, 2, [3, 4, 5, 6])\n[3//1   4//1]\n[5//1   6//1]\n\njulia> b = matrix(QQ, 1, 2, [2, 1])\n[2//1   1//1]\n\njulia> can_solve_with_solution(A, b; side = :left)\n(true, [-7//2 5//2])\n\njulia> A = S([a + 1 2a + 3 a^2 + 1; K(0) a^2 - 1 2a; K(0) K(0) a])\n[x + 1   2*x + 3   x^2 + 1]\n[    0   x^2 - 1       2*x]\n[    0         0         x]\n\njulia> bb = U([2a a + 1 (-a - 1)]')\n[   2*x]\n[ x + 1]\n[-x - 1]\n\njulia> x = solve_triu(A, bb, false)\n[ 1//3*x^2 + 8//3*x + 13//3]\n[-3//5*x^2 - 3//5*x - 12//5]\n[                   x^2 + 2]\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> U = MatrixSpace(R, 3, 2)\nMatrix Space of 3 rows and 2 columns over Univariate Polynomial Ring in x over Integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> bbb = U([2x x + 1 (-x - 1); x + 1 (-x) x^2]')\n[   2*x   x + 1]\n[ x + 1      -x]\n[-x - 1     x^2]\n\njulia> x, d = solve_rational(A, bbb)\n([3*x^4-10*x^3-8*x^2-11*x-4 -x^5+3*x^4+x^3-2*x^2+3*x-1; -2*x^5-x^4+6*x^3+2*x+1 x^6+x^5+4*x^4+9*x^3+8*x^2+5*x+2; 6*x^4+12*x^3+15*x^2+6*x-3 -2*x^5-4*x^4-6*x^3-9*x^2-4*x+1], x^5 + 2*x^4 + 15*x^3 + 18*x^2 + 8*x + 7)\n\njulia> S = MatrixSpace(ZZ, 3, 3)\nMatrix Space of 3 rows and 3 columns over Integers\n\njulia> T = MatrixSpace(ZZ, 3, 1)\nMatrix Space of 3 rows and 1 columns over Integers\n\njulia> A = S([BigInt(2) 3 5; 1 4 7; 9 2 2])\n[2   3   5]\n[1   4   7]\n[9   2   2]\n\njulia> B = T([BigInt(4), 5, 7])\n[4]\n[5]\n[7]","category":"page"},{"location":"matrix/#Inverse","page":"Generic matrices","title":"Inverse","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Base.inv{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"matrix/#Base.inv-Union{Tuple{Union{MatAlgElem{T}, MatElem{T}}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"Base.inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"isinvertible_with_inverse{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.isinvertible_with_inverse-Union{Tuple{Union{MatAlgElem{T}, MatElem{T}}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.isinvertible_with_inverse","text":"isinvertible_with_inverse(A::Generic.MatrixElem{T}; side::Symbol = :left) where {T <: RingElement}\n\nGiven an ntimes m matrix A over a ring, return a tuple (flag, B). If side is :right and flag is true, B is the right inverse of A i.e. AB is the ntimes n unit matrix. If side is :left and flag is true, B is the left inverse of A i.e. BA is the mtimes m unit matrix. If flag is false, no right or left inverse exists.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"isinvertible{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.isinvertible-Union{Tuple{Union{MatAlgElem{T}, MatElem{T}}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.isinvertible","text":"isinvertible(A::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use isinvertible_with_inverse.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X = inv(A)\n[-343//7817*x^2 + 717//7817*x - 2072//7817   -4964//23451*x^2 + 2195//23451*x - 11162//23451    -232//23451*x^2 - 4187//23451*x - 1561//23451]\n[ 128//7817*x^2 - 655//7817*x + 2209//7817      599//23451*x^2 - 2027//23451*x - 1327//23451   -1805//23451*x^2 + 2702//23451*x - 7394//23451]\n[ 545//7817*x^2 + 570//7817*x + 2016//7817     -1297//23451*x^2 - 5516//23451*x - 337//23451   8254//23451*x^2 - 2053//23451*x + 16519//23451]\n\njulia> isinvertible(A)\ntrue\n\njulia> isinvertible_with_inverse(A)\n(true, [-343//7817*x^2+717//7817*x-2072//7817 -4964//23451*x^2+2195//23451*x-11162//23451 -232//23451*x^2-4187//23451*x-1561//23451; 128//7817*x^2-655//7817*x+2209//7817 599//23451*x^2-2027//23451*x-1327//23451 -1805//23451*x^2+2702//23451*x-7394//23451; 545//7817*x^2+570//7817*x+2016//7817 -1297//23451*x^2-5516//23451*x-337//23451 8254//23451*x^2-2053//23451*x+16519//23451])\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X, d = pseudo_inv(A)\n([4*x^2-x+1 -2*x^3+3 x^3-5*x^2-5*x-1; -2*x^3-5*x^2-2*x-2 x^4+3*x^3+2*x^2+3*x+1 -x^4+x^2+2; -x^3+2*x^2+2*x-1 -2*x^3-9*x^2-11*x-3 2*x^3+3*x^2-4*x-6], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n","category":"page"},{"location":"matrix/#Nullspace","page":"Generic matrices","title":"Nullspace","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"nullspace{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"matrix/#LinearAlgebra.nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Generic matrices","title":"LinearAlgebra.nullspace","text":"nullspace(M::AbstractAlgebra.MatElem{T}) where {T <: RingElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name \"kernel\" for a function to compute an integral kernel.\n\n\n\nnullspace(M::AbstractAlgebra.MatElem{T}) where {T <: FieldElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Univariate Polynomial Ring in x over Integers\n\njulia> M = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n              -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n              -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n              -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n[  -6*x^2 + 6*x + 12   -12*x^2 - 21*x - 15    -15*x^2 + 21*x + 33     -21*x^2 - 9*x - 9]\n[  -8*x^2 + 8*x + 16   -16*x^2 + 38*x - 20     90*x^2 - 82*x - 44    60*x^2 + 54*x - 34]\n[   -4*x^2 + 4*x + 8    -8*x^2 + 13*x - 10     35*x^2 - 31*x - 14    22*x^2 + 21*x - 15]\n[-10*x^2 + 10*x + 20   -20*x^2 + 70*x - 25   150*x^2 - 140*x - 85   105*x^2 + 90*x - 50]\n\njulia> n, N = nullspace(M)\n(2, [1320*x^4-330*x^2-1320*x-1320 1056*x^4+1254*x^3+1848*x^2-66*x-330; -660*x^4+1320*x^3+1188*x^2-1848*x-1056 -528*x^4+132*x^3+1584*x^2+660*x-264; 396*x^3-396*x^2-792*x 0; 0 396*x^3-396*x^2-792*x])","category":"page"},{"location":"matrix/#Kernel","page":"Generic matrices","title":"Kernel","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"kernel{T <: RingElem}(::MatElem{T})\nleft_kernel{T <: RingElem}(::MatElem{T})\nright_kernel{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.kernel","text":"kernel(a::MatElem{T}; side::Symbol = :right) where T <: RingElement\n\nReturn a tuple (n M), where n is the rank of the kernel and M is a basis for it. If side is right or not specified, the right kernel is computed, i.e. the matrix of columns whose span gives the right kernel space. If side is left, the left kernel is computed, i.e. the matrix of rows whose span is the left kernel space.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.left_kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.left_kernel","text":"left_kernel(a::AbstractAlgebra.MatElem{T}) where T <: RingElement\n\nReturn a tuple n, M where M is a matrix whose rows generate the kernel of M and n is the rank of the kernel. The transpose of the output of this function is guaranteed to be in flipped upper triangular format (i.e. upper triangular format if columns and rows are reversed).\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.right_kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.right_kernel","text":"right_kernel(a::AbstractAlgebra.MatElem{T}) where T <: RingElement\n\nReturn a tuple n, M where M is a matrix whose columns generate the kernel of M and n is the rank of the kernel.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> S = MatrixSpace(ZZ, 4, 4)\nMatrix Space of 4 rows and 4 columns over Integers\n\njulia> M = S([1 2 0 4;\n              2 0 1 1;\n              0 1 1 -1;\n              2 -1 0 2])\n[1    2   0    4]\n[2    0   1    1]\n[0    1   1   -1]\n[2   -1   0    2]\n\njulia> nr, Nr = kernel(M)\n(1, [-8; -6; 11; 5])\n\njulia> nl, Nl = left_kernel(M)\n(1, [0 -1 1 1])\n","category":"page"},{"location":"matrix/#Hessenberg-form","page":"Generic matrices","title":"Hessenberg form","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"hessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"LinearAlgebra.hessenberg","text":"hessenberg(A::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the Hessenberg form of M, i.e. an upper Hessenberg matrix which is similar to M. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"ishessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.ishessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.ishessenberg","text":"ishessenberg(A::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in Hessenberg form, otherwise returns false.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = hessenberg(M)\n[1   5   5   3]\n[2   1   1   0]\n[0   1   3   2]\n[0   0   2   2]\n\njulia> ishessenberg(A)\ntrue\n","category":"page"},{"location":"matrix/#Characteristic-polynomial","page":"Generic matrices","title":"Characteristic polynomial","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"charpoly{T <: RingElem}(::Ring, ::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.charpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,MatElem{T}}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.charpoly","text":"charpoly(V::Ring, Y::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the matrix M. The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> T, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Residue ring of Integers modulo 7, x)\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = charpoly(T, M)\nx^4 + 2*x^2 + 6*x + 2\n","category":"page"},{"location":"matrix/#Minimal-polynomial","page":"Generic matrices","title":"Minimal polynomial","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"minpoly{T <: RingElem}(::Ring, ::MatElem{T}, ::Bool)\nminpoly{T <: FieldElem}(::Ring, ::MatElem{T}, ::Bool)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.minpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,MatElem{T},Bool}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.minpoly","text":"minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.minpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,MatElem{T},Bool}} where T<:FieldElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.minpoly","text":"minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: FieldElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\nminpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R = GF(13)\nFinite field F_13\n\njulia> T, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Finite field F_13, y)\n\njulia> M = R[7 6 1;\n             7 7 5;\n             8 12 5]\n[7    6   1]\n[7    7   5]\n[8   12   5]\n\njulia> A = minpoly(T, M)\ny^2 + 10*y\n","category":"page"},{"location":"matrix/#Transforms","page":"Generic matrices","title":"Transforms","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"similarity!{T <: RingElem}(::MatElem{T}, ::Int, ::T)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.similarity!-Union{Tuple{T}, Tuple{MatElem{T},Int64,T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.similarity!","text":"similarity!(A::Generic.MatrixElem{T}, r::Int, d::T) where {T <: RingElement}\n\nApplies a similarity transform to the ntimes n matrix M in-place. Let P be the ntimes n identity matrix that has had all zero entries of row r replaced with d, then the transform applied is equivalent to M = P^-1MP. We require M to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> similarity!(M, 1, R(3))\n","category":"page"},{"location":"matrix/#Hermite-normal-form","page":"Generic matrices","title":"Hermite normal form","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"hnf{T <: RingElem}(::MatElem{T})\nhnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.hnf","text":"hnf(A::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the upper right row Hermite normal form of A.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.hnf_with_transform","text":"hnf_with_transform(A)\n\nReturn the tuple H U consisting of the upper right row Hermite normal form H of A together with invertible matrix U such that UA = H.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"ishnf{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.ishnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.ishnf","text":"ishnf(M::Generic.MatrixElem{T}) where T <: RingElement\n\nReturn true if the matrix is in Hermite normal form.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> H = hnf(A)\n[1   0   255]\n[0   1    17]\n[0   0   281]\n\njulia> ishnf(H)\ntrue\n\njulia> H, U = hnf_with_transform(A)\n([1 0 255; 0 1 17; 0 0 281], [-47 28 1; -3 2 0; -52 31 1])\n\njulia> U*A\n[1   0   255]\n[0   1    17]\n[0   0   281]","category":"page"},{"location":"matrix/#Smith-normal-form","page":"Generic matrices","title":"Smith normal form","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"issnf(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.issnf-Union{Tuple{Union{MatAlgElem{T}, MatElem{T}}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrices","title":"AbstractAlgebra.Generic.issnf","text":"issnf(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is in Smith Normal Form.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"snf{T <: RingElem}(::MatElem{T})\nsnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.snf","text":"snf(A::Generic.MatrixElem{T}) where {T <: RingElement}\n\nReturn the Smith normal form of A.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.snf_with_transform","text":"snf_with_transform(A)\n\nReturn the tuple S T U consisting of the Smith normal form S of A together with invertible matrices T and U such that TAU = S.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> S = snf(A)\n[1   0     0]\n[0   1     0]\n[0   0   281]\n\njulia> S, T, U = snf_with_transform(A)\n([1 0 0; 0 1 0; 0 0 281], [1 0 0; 7 1 0; 229 31 1], [0 -3 26; 0 2 -17; -1 0 1])\n\njulia> T*A*U\n[1   0     0]\n[0   1     0]\n[0   0   281]","category":"page"},{"location":"matrix/#(Weak)-Popov-form","page":"Generic matrices","title":"(Weak) Popov form","text":"","category":"section"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"AbstractAlgebra.jl provides algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"isweak_popov(P::MatrixElem{T}, rank::Int) where T <: Generic.Poly","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.isweak_popov-Union{Tuple{T}, Tuple{Union{MatAlgElem{T}, MatElem{T}},Int64}} where T<:AbstractAlgebra.Generic.Poly","page":"Generic matrices","title":"AbstractAlgebra.Generic.isweak_popov","text":"isweak_popov(P::MatrixElem{T}, rank::Int) where T <: Generic.Poly\n\nReturn true if P is a matrix in weak Popov form of the given rank.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"weak_popov{T <: PolyElem}(::Generic.Mat{T})\nweak_popov_with_transform{T <: PolyElem}(::Generic.Mat{T})\npopov{T <: PolyElem}(::Generic.Mat{T})\npopov_with_transform{T <: PolyElem}(::Generic.Mat{T})","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.weak_popov-Union{Tuple{AbstractAlgebra.Generic.Mat{T}}, Tuple{T}} where T<:PolyElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.weak_popov","text":"weak_popov(A::Mat{T}) where {T <: PolyElem}\n\nReturn the weak Popov form of A.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.weak_popov_with_transform-Union{Tuple{AbstractAlgebra.Generic.Mat{T}}, Tuple{T}} where T<:PolyElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.weak_popov_with_transform","text":"weak_popov_with_transform(A::Mat{T}) where {T <: PolyElem}\n\nCompute a tuple (P U) where P is the weak Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.popov-Union{Tuple{AbstractAlgebra.Generic.Mat{T}}, Tuple{T}} where T<:PolyElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.popov","text":"popov(A::Mat{T}) where {T <: PolyElem}\n\nReturn the Popov form of A.\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.Generic.popov_with_transform-Union{Tuple{AbstractAlgebra.Generic.Mat{T}}, Tuple{T}} where T<:PolyElem","page":"Generic matrices","title":"AbstractAlgebra.Generic.popov_with_transform","text":"popov_with_transform(A::Mat{T}) where {T <: PolyElem}\n\nCompute a tuple (P U) where P is the Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Generic matrices","title":"Generic matrices","text":"julia> R, x = PolynomialRing(QQ, \"x\");\n\njulia> A = matrix(R, map(R, Any[1 2 3 x; x 2*x 3*x x^2; x x^2+1 x^3+x^2 x^4+x^2+1]))\n[1         2           3               x]\n[x       2*x         3*x             x^2]\n[x   x^2 + 1   x^3 + x^2   x^4 + x^2 + 1]\n\njulia> P = weak_popov(A)\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]\n\njulia> P, U = weak_popov_with_transform(A)\n([1 2 3 x; 0 0 0 0; -x^3 -2*x^3+x^2-2*x+1 -2*x^3+x^2-3*x 1], [1 0 0; -x 1 0; -x^3-x 0 1])\n\njulia> U*A\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]","category":"page"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"laurent_polynomial/#Generic-Laurent-polynomials","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"","category":"section"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Laurent polynomials are similar to polynomials but can have terms of negative degrees, and form a ring denoted by Rx x^-1 where R is the coefficient ring. AbstractAlgebra.jl provides a generic implementation of Laurent polynomials, built in terms of regular polynomials.","category":"page"},{"location":"laurent_polynomial/#Types-and-parent-objects","page":"Generic Laurent polynomials","title":"Types and parent objects","text":"","category":"section"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Two abstract types LaurentPolyElem{T} and LaurentPolynomialRing{T} are defined to represent Laurent polynomials and rings thereof, parameterized on a base ring T.","category":"page"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"The type LaurentPolyWrap{T, ...} <: LaurentPolyElem{T} implements generic Laurent polynomials by wrapping regular polynomials: a Laurent polynomial l wraps a polynomial p and an integer n such that l = x^-n * p.","category":"page"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"The corresponding parent type is LaurentPolyWrapRing{T, ...} <: LaurentPolynomialRing{T}.","category":"page"},{"location":"laurent_polynomial/#Laurent-polynomials-ring-constructor","page":"Generic Laurent polynomials","title":"Laurent polynomials ring constructor","text":"","category":"section"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"In order to instantiate Laurent polynomials, one must first construct the parent ring:","category":"page"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"LaurentPolynomialRing","category":"page"},{"location":"laurent_polynomial/#AbstractAlgebra.LaurentPolynomialRing","page":"Generic Laurent polynomials","title":"AbstractAlgebra.LaurentPolynomialRing","text":"LaurentPolynomialRing(R::AbstractAlgebra.Ring, s::AbstractString)\n\nGiven a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new Laurent polynomial ring S = Rx 1x and the generator x of the ring.\n\nExamples\n\njulia> R, x = LaurentPolynomialRing(ZZ, \"x\")\n(Univariate Laurent Polynomial Ring in x over Integers, x)\n\njulia> 2x^-3 + x^2\nx^2 + 2*x^-3\n\njulia> rand(R, -3:3 ,-9:9)\n-3*x^2 - 8*x + 4 + 3*x^-1 - 6*x^-2 + 9*x^-3\n\n\n\n\n\n","category":"type"},{"location":"laurent_polynomial/#Basic-functionality","page":"Generic Laurent polynomials","title":"Basic functionality","text":"","category":"section"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Laurent polynomials implement the ring interface (except for divexact), and some methods from the polynomial interface, for example:","category":"page"},{"location":"laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"julia> R, x = LaurentPolynomialRing(ZZ, \"x\")\n(Univariate Laurent Polynomial Ring in x over Integers, x)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Array{Symbol,1}:\n :x\n\njulia> nvars(R)\n1\n\njulia> f = x^-2 + 2x\n2*x + x^-2\n\njulia> coeff.(f, -2:2)\n5-element Array{BigInt,1}:\n 1\n 0\n 0\n 2\n 0\n\njulia> setcoeff!(f, 3, big(5))\n5*x^3 + 2*x + x^-2\n\njulia> isgen(f)\nfalse\n\njulia> shift_left(f,2)\n5*x^5 + 2*x^3 + 1\n\njulia> map_coeffs(x->2x, f)\n10*x^3 + 4*x + 2*x^-2\n\njulia> change_base_ring(RealField, f)\n5.0*x^3 + 2.0*x + x^-2\n\njulia> lead(f), trail(f)\n(5, 1)","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"quotient_module/#Quotient-modules","page":"Quotient modules","title":"Quotient modules","text":"","category":"section"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra allows the construction of quotient modules/spaces of AbstractAlgebra modules over euclidean domains. These are given as the quotient of a module by a submodule of that module.","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"We define two quotient modules to be equal if they are quotients of the same module M by two equal submodules.","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"As well as implementing the entire Module interface, AbstractAlgebra submodules also provide the following interface.","category":"page"},{"location":"quotient_module/#Constructors","page":"Quotient modules","title":"Constructors","text":"","category":"section"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"quo(M::AbstractAlgebra.FPModule{T}, v::Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"quotient_module/#AbstractAlgebra.quo-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.Generic.Submodule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Quotient modules","title":"AbstractAlgebra.quo","text":"quo(m::Module{T}, N::Module{T}) where T <: RingElement\n\nReturn the quotient Q of the module m by the submodule N of m, and a map which is a lift of elements of Q to m.\n\n\n\n","category":"method"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Note that a preimage of the canonical projection can be obtained using the preimage function described in the section on module homomorphisms. Note that a preimage element of the canonical projection is not unique and has no special properties.","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> N, f = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> Q, g = quo(M, N)\n(Quotient module over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Quotient module over Integers with 1 generator and no relations\n)\n\njulia> p = M([ZZ(3), ZZ(1)])\n(3, 1)\n\njulia> v2 = g(p)\n(-5)\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> Q, g = quo(V, N)\n(Quotient space over:\nRationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: Quotient space over:\nRationals with 1 generator and no relations\n)\n","category":"page"},{"location":"quotient_module/#Functionality-for-submodules","page":"Quotient modules","title":"Functionality for submodules","text":"","category":"section"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"quotient_module/#Basic-manipulation","page":"Quotient modules","title":"Basic manipulation","text":"","category":"section"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"supermodule(M::AbstractAlgebra.Generic.QuotientModule{T}) where T <: RingElement\n\ndim(N::AbstractAlgebra.Generic.QuotientModule{T}) where T <: FieldElement","category":"page"},{"location":"quotient_module/#AbstractAlgebra.Generic.supermodule-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Quotient modules","title":"AbstractAlgebra.Generic.supermodule","text":"supermodule(M::QuotientModule{T}) where T <: RingElement\n\nReturn the module that this module is a quotient of.\n\n\n\n","category":"method"},{"location":"quotient_module/#AbstractAlgebra.Generic.dim-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:Union{FieldElem, AbstractFloat, Rational}","page":"Quotient modules","title":"AbstractAlgebra.Generic.dim","text":"dim(N::AbstractAlgebra.Generic.QuotientModule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector quotient space.\n\n\n\n","category":"method"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> N, g = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> Q, h = quo(M, N)\n(Quotient module over Integers with 2 generators and relations:\n[2 3], Module homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Quotient module over Integers with 2 generators and relations:\n[2 3])\n\njulia> supermodule(Q) == M\ntrue\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> Q, g = quo(V, N)\n(Quotient space over:\nRationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: Quotient space over:\nRationals with 1 generator and no relations\n)\n\njulia> dim(V)\n2\n\njulia> dim(Q)\n1\n","category":"page"},{"location":"euclidean/#Euclidean-Ring-Interface","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"","category":"section"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"If a ring provides a meaningful Euclidean structure such that a useful Euclidean remainder can be computed practically, various additional functionality is provided by AbstractAlgebra.jl for those rings. This functionality depends on the following functions existing.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"mod(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return the Euclidean remainder of f by g. A DivideError() should be thrown if g is zero. An error should be thrown if an impossible inverse is encountered.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"divrem(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a pair q, r consisting of the Euclidean quotient and remainder of f by g. A DivideError should be thrown if g is zero. An error should be thrown if an impossible inverse is encountered.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"div(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return the Euclidean quotient of f by g. A DivideError should be thrown if g is zero. An error should be thrown if an impossible inverse is encountered.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"mulmod(f::MyElem, g::MyElem, m::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return fg pmodm.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"powermod(f::MyElem, e::Int, m::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return f^e pmodm.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"invmod(f::MyElem, m::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return the inverse of f modulo m. If such an inverse doesn't exist, an impossible inverse error should be thrown.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"divides(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a pair, flag, q, where flag is set to true if g divides f, in which case the quotient is set to the quotient or flag is set to false and the quotient is set to zero in the same ring as f and g.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"remove(f::MyElem, p::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a pair v, q where p^v is the highest power of p dividing f and q is the cofactor after f is divided by this power.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"valuation(f::MyElem, p::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return v where p^v is the highest power of p dividing f.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"gcd(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a greatest common divisor of f and g.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"lcm(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return fggcd(f g) if either f or g is not zero, otherwise it throws a DivideError().","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"gcdx(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a triple d, s, t such that d = gcd(f g) and d = sf + tg, with s reduced modulo g and t reduced modulo f.","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"gcdinv(f::MyElem, g::MyElem)","category":"page"},{"location":"euclidean/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"Return a tuple d, s such that d = gcd(f g) and s = (fd)^-1 pmodgd. Note that d = 1 iff f is invertible modulo g, in which case s = f^-1 pmodg.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"matrix_spaces/#Matrix-Interface","page":"Matrix Interface","title":"Matrix Interface","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Generic matrices are supported in AbstractAlgebra.jl. Both the space of mtimes n matrices and the algebra (ring) of mtimes m matrices are supported.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"As the space of mtimes n matrices over a commutative ring is not itself a commutative ring, not all of the Ring interface needs to be implemented for such matrices in.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"In particular, the following functions do not need to be implemented: isdomain_type, and divexact. The canonical_unit function should be implemented, but simply needs to return the corresponding value for entry 1 1 (the function is never called on empty matrices).","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"For matrix algebras, all of the ring interface must be implemented.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that AbstractAlgebra.jl matrices are not the same as Julia matrices. We store a base ring in our matrix and matrices are row major instead of column major in order to support the numerous large C libraries that use this convention.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"All AbstractAlgebra.jl matrices are assumed to be mutable. This is usually critical to performance.","category":"page"},{"location":"matrix_spaces/#Types-and-parents","page":"Matrix Interface","title":"Types and parents","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"AbstractAlgebra provides two abstract types for matrix spaces and their elements:","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"MatSpace{T} is the abstract type for matrix space parent types\nMatElem{T} is the abstract type for matrix types belonging to a matrix space","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"It also provides two abstract types for matrix algebras and their elements:","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"MatAlgebra{T} is the abstract type for matrix algebra parent types\nMatAlgElem{T} is the abstract type for matrix types belonging to a matrix algebra","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that these abstract types are parameterised. The type T should usually be the type of elements of the matrices.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Matrix spaces and matrix algebras should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Matrix spaces and algebras should at least be distinguished based on their base (coefficient) ring and the dimensions of the matrices in the space.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"matrix_spaces/#Required-functionality-for-matrices","page":"Matrix Interface","title":"Required functionality for matrices","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"In addition to the required (relevant) functionality for the Ring interface (see above), the following functionality is required for the Matrix interface.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a space of mtimes n matrices over R, or algebra of mtimes m matrices with parent object S of type MyMatSpace{T} or MyMatAlgebra{T}, respectively. We also assume the matrices in the space have type MyMat{T}, where T is the type of elements of the base (element) ring.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Currently only matrices over commutative rings are supported.","category":"page"},{"location":"matrix_spaces/#Constructors","page":"Matrix Interface","title":"Constructors","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"In addition to the standard constructors, the following constructors, taking an array of elements, must be available.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Array{T, 2}) where T <: AbstractAlgebra.RingElem\n(S::MyMatAlgebra{T})(A::Array{T, 2}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j].","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Array{S, 2}) where {S <: AbstractAlgebra.RingElem, T <: AbstractAlgebra.RingElem}\n(S::MyMatAlgebra{T})(A::Array{S, 2}) where {S <: AbstractAlgebra.RingElem, T <: AbstractAlgebra.RingElem}","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Array{S, 1}) where {S <: AbstractAlgebra.RingElem, T <: AbstractAlgebra.RingElem}\n(S::MyMatAlgebra{T})(A::Array{S, 1}) where {S <: AbstractAlgebra.RingElem, T <: AbstractAlgebra.RingElem}","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> S = MatrixSpace(QQ, 2, 3)\nMatrix Space of 2 rows and 3 columns over Rationals\n\njulia> T = MatrixAlgebra(QQ, 2)\nMatrix Algebra of degree 2 over Rationals\n\njulia> M1 = S(Rational{BigInt}[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M2 = S(BigInt[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M3 = S(BigInt[2, 3, 1, 1, 0, 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> N1 = T(Rational{BigInt}[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N2 = T(BigInt[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N3 = T(BigInt[2, 3, 1, 1])\n[2//1   3//1]\n[1//1   1//1]\n","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"It is also possible to create matrices (in a matrix space only) directly, without first creating the corresponding matrix space (the inner constructor being called directly). Note that to support this, matrix space parent objects don't contain a reference to their parent. Instead, parents are constructed on-the-fly if requested. (The same strategy is used for matrix algebras.)","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"matrix(R::Ring, arr::Array{T, 2}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Given an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"matrix(R::Ring, r::Int, c::Int, A::Array{T, 1}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"zero_matrix(R::Ring, r::Int, c::Int)","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> N = matrix(ZZ, 3, 2, BigInt[3, 1, 2, 2, 0, 1])\n[3   1]\n[2   2]\n[0   1]\n\njulia> P = zero_matrix(ZZ, 3, 2)\n[0   0]\n[0   0]\n[0   0]\n\njulia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> M = R()\n[0   0]\n[0   0]","category":"page"},{"location":"matrix_spaces/#Views","page":"Matrix Interface","title":"Views","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Just as Julia supports views of matrices, AbstractAlgebra requires all matrix types to support views. These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that deepcopy of a view type must return the same type, but it should return a view into a deepcopy of the original matrix. Julia enforces this for consistency.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"To support views, generic matrices in AbstractAlgebra of type Generic.MatSpaceElem have an associated Generic.MatSpaceView type. Both belong to the Generic.Mat abstract type, so that one can work with that in functions that can accept both views and actual matrices.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The syntax for views is as for Julia's own views.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that the parent_type function returns the same type for a view as for the original matrix type. This could potentially cause a problem if the elem_type function is applied to the return value of parent_type and then used in a type assertion. For this reason, there may be some limitations on the use of views.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The similar function also returns a matrix of type MatSpaceElem when applied to a view, rather than another view.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"M = matrix(ZZ, 3, 3, BigInt[1, 2, 3, 2, 3, 4, 3, 4, 5])\n\nN1 = @view M[1:2, :]\nN2 = @view M[:, 1:2]\n\nR = N1*N2","category":"page"},{"location":"matrix_spaces/#Basic-manipulation-of-matrices","page":"Matrix Interface","title":"Basic manipulation of matrices","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"dense_matrix_type(::Type{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the type of dense matrices whose entries have the given type. E.g. in Nemo, which depends on AbstractAlgebra, we define dense_matrix_type(::Type{fmpz}) = fmpz_mat.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"nrows(f::MyMat{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of rows of the given matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"ncols(f::MyMat{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of columns of the given matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"getindex(M::MyMat{T}, r::Int, c::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the (i j)-th entry of the matrix M.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"setindex!(M::MyMat{T}, d::T, r::Int, c::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Set the (i j)-th entry of the matrix M to d, which is assumed to be in the base ring of the matrix. The matrix must have such an entry and the matrix is mutated in place and not returned from the function.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, BigInt[2 3 0; 1 1 1])\n[2   3   0]\n[1   1   1]\n\njulia> m = nrows(M)\n2\n\njulia> n = ncols(M)\n3\n\njulia> M[1, 2] = BigInt(4)\n4\n\njulia> c = M[1, 1]\n2\n","category":"page"},{"location":"matrix_spaces/#Transpose","page":"Matrix Interface","title":"Transpose","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"transpose(::MyMat{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the transpose of the given matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The standard Julia tick notation can also be used for transposing a matrix.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = transpose(A)\n[t + 1   t^2            -2]\n[    t     t         t + 2]\n[    1     t   t^2 + t + 1]\n\njulia> C = A'\n[t + 1   t^2            -2]\n[    t     t         t + 2]\n[    1     t   t^2 + t + 1]\n","category":"page"},{"location":"matrix_spaces/#Optional-functionality-for-matrices","page":"Matrix Interface","title":"Optional functionality for matrices","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Especially when wrapping C libraries, some functions are best implemented directly, rather than relying on the generic functionality. The following are all provided by the AbstractAlgebra.jl generic code, but can optionally be implemented directly for performance reasons.","category":"page"},{"location":"matrix_spaces/#Optional-submatrices","page":"Matrix Interface","title":"Optional submatrices","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Base.getindex(M::MyMat, rows::AbstractVector{Int}, cols::AbstractVector{Int})","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return a new matrix with the same entries as the submatrix with the given range of rows and columns.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = M[:, :]\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N3 = M[2:3, 2:3]\n[3   4]\n[4   5]\n","category":"page"},{"location":"matrix_spaces/#Optional-row-swapping","page":"Matrix Interface","title":"Optional row swapping","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"swap_rows!(M::MyMat{T}, i::Int, j::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Swap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows!(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n","category":"page"},{"location":"matrix_spaces/#Optional-concatenation","page":"Matrix Interface","title":"Optional concatenation","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"hcat(M::MyMat{T}, N::MyMat{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"vcat(M::MyMat{T}, N::MyMat{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N = matrix(ZZ, BigInt[1 0 1; 0 1 0; 1 0 1])\n[1   0   1]\n[0   1   0]\n[1   0   1]\n\njulia> P = hcat(M, N)\n[1   2   3   1   0   1]\n[2   3   4   0   1   0]\n[3   4   5   1   0   1]\n\njulia> Q = vcat(M, N)\n[1   2   3]\n[2   3   4]\n[3   4   5]\n[1   0   1]\n[0   1   0]\n[1   0   1]\n","category":"page"},{"location":"matrix_spaces/#Optional-similar-and-zero","page":"Matrix Interface","title":"Optional similar and zero","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"The following functions are available for matrices in both matrix algebras and matrix spaces. Both similar and zero construct new matrices, with the same methods, but the entries are either undefined with similar or zero-initialized with zero.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"similar(x::MyMat{T}, R::Ring=base_ring(x)) where T <: AbstractAlgebra.RingElem\nzero(x::MyMat{T}, R::Ring=base_ring(x)) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"similar(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: AbstractAlgebra.RingElem\nsimilar(x::MyMat{T}, r::Int, c::Int) where T <: AbstractAlgebra.RingElem\nzero(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: AbstractAlgebra.RingElem\nzero(x::MyMat{T}, r::Int, c::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Custom matrices and rings may choose which specific matrix type is best-suited to return for the given ring and dimensionality. If they do not specialize these functions, the default is a Generic.MatSpaceElem matrix, or Generic.MatAlgElem for matrix algebras. The default implementation of zero calls out to similar, so it's generally sufficient to specialize only similar. For both similar and zero, only the most general method has to be implemented (e.g. similar(x::MyMat, R::Ring, r::Int, c::Int), as all other methods (which have defaults) call out to this more general method.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Base.isassigned(M::MyMat, i, j)","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Test whether the given matrix has a value associated with indices i and j. It is recommended to overload this method for custom matrices.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> isassigned(M, 1, 2)\ntrue\n\njulia> isassigned(M, 4, 4)\nfalse\n\njulia> A = similar(M)\n[#undef   #undef   #undef]\n[#undef   #undef   #undef]\n\njulia> isassigned(A, 1, 2)\nfalse\n\njulia> B = zero(M)\n[0   0   0]\n[0   0   0]\n\njulia> C = similar(M, 4, 5)\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n\njulia> base_ring(B)\nIntegers\n\njulia> D = zero(M, QQ, 2, 2)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> base_ring(D)\nRationals","category":"page"},{"location":"matrix_spaces/#Optional-symmetry-test","page":"Matrix Interface","title":"Optional symmetry test","text":"","category":"section"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"LinearAlgebra.issymmetric(a::MatrixElem)","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Return true if the given matrix is symmetric with respect to its main diagonal, otherwise return false.","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"Examples","category":"page"},{"location":"matrix_spaces/","page":"Matrix Interface","title":"Matrix Interface","text":"julia> M = matrix(ZZ, [1 2 3; 2 4 5; 3 5 6])\n[1   2   3]\n[2   4   5]\n[3   5   6]\n\njulia> issymmetric(M)\ntrue\n\njulia> N = matrix(ZZ, [1 2 3; 4 5 6; 7 8 9])\n[1   2   3]\n[4   5   6]\n[7   8   9]\n\njulia> issymmetric(N)\nfalse","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"rational/#Rational-field","page":"Rational field","title":"Rational field","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Rational.jl for making Julia Rational{BigInt}s conform to the AbstractAlgebra.jl Field interface.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"In addition to providing a parent object QQ for Julia Rational{BigInt}s, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Because Rational{BigInt} cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia Rational{BigInt}s by introducing a type union, called FieldElement, which is a union of AbstractAlgebra.FieldElem and a number of Julia types, including Rational{BigInt}. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia Rational{BigInt} type as belonging to AbstractAlgebra.FieldElem.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"One other technicality is that Julia defines certain functions for Rational{BigInt}, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"To access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"page"},{"location":"rational/#Types-and-parent-objects","page":"Rational field","title":"Types and parent objects","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Rationals have type Rational{BigInt}, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The parent objects of such integers has type Rationals{BigInt}.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"For convenience, we also make Rational{Int} a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as qq) has type Rationals{Int}. But we caution that this type is not particularly useful as a model of the rationals and may not function as expected within AbstractAlgebra.jl.","category":"page"},{"location":"rational/#Rational-constructors","page":"Rational field","title":"Rational constructors","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"In order to construct rationals in AbstractAlgebra.jl, one can first construct the rational field itself. This is accomplished using either of the following constructors.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"FractionField(R::Integers{BigInt})","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Rationals{BigInt}()","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"This gives the unique object of type Rationals{BigInt} representing the field of rationals in AbstractAlgebra.jl.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"In practice, one simply uses QQ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Here are some examples of creating the rational field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"julia> f = QQ()\n0//1\n\njulia> g = QQ(123)\n123//1\n\njulia> h = QQ(BigInt(1234))\n1234//1\n\njulia> k = QQ(BigInt(12), BigInt(7))\n12//7\n\njulia> QQ == FractionField(ZZ)\ntrue\n","category":"page"},{"location":"rational/#Basic-field-functionality","page":"Rational field","title":"Basic field functionality","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The rational field in AbstractAlgebra.jl implements the full Field and Fraction Field interfaces.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"We give some examples of such functionality.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"julia> f = QQ(12, 7)\n12//7\n\njulia> h = zero(QQ)\n0//1\n\njulia> k = one(QQ)\n1//1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(QQ)\nIntegers\n\njulia> V = base_ring(f)\nIntegers\n\njulia> T = parent(f)\nRationals\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n96//7\n\njulia> r = ZZ(12)//ZZ(7)\n12//7\n\njulia> n = numerator(r)\n12\n","category":"page"},{"location":"rational/#Rational-functionality-provided-by-AbstractAlgebra.jl","page":"Rational field","title":"Rational functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The functionality below supplements that provided by Julia itself for its Rational{BigInt} type.","category":"page"},{"location":"rational/#Square-root","page":"Rational field","title":"Square root","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"AbstractAlgebra.sqrt(a::Rational{BigInt})","category":"page"},{"location":"rational/#AbstractAlgebra.sqrt-Tuple{Rational{BigInt}}","page":"Rational field","title":"AbstractAlgebra.sqrt","text":"sqrt(a::Rational{T}) where T <: Integer\n\nReturn the square root of a if it is the square of a rational, otherwise throw an error.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"issquare(a::Rational{BigInt})","category":"page"},{"location":"rational/#AbstractAlgebra.Generic.issquare-Tuple{Rational{BigInt}}","page":"Rational field","title":"AbstractAlgebra.Generic.issquare","text":"issquare(f::AbstractAlgebra.PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::Rational{T}) where T <: Integer\n\nReturn true if a is the square of a rational.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"AbstractAlgebra.exp(a::Rational{BigInt})","category":"page"},{"location":"rational/#AbstractAlgebra.exp-Tuple{Rational{BigInt}}","page":"Rational field","title":"AbstractAlgebra.exp","text":"exp(a::Rational{T}) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"julia> d = AbstractAlgebra.sqrt(ZZ(36)//ZZ(25))\n6//5\n\njulia> issquare(ZZ(9)//ZZ(16))\ntrue\n\njulia> m = AbstractAlgebra.exp(ZZ(0)//ZZ(1))\n1//1","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"residue_rings/#Residue-Ring-Interface","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"","category":"section"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Residue rings (currently a quotient ring modulo a principal ideal) are supported in AbstractAlgebra.jl, at least for Euclidean base rings. In addition to the standard Ring interface, some additional functions are required to be present for residue rings.","category":"page"},{"location":"residue_rings/#Types-and-parents","page":"Residue Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"AbstractAlgebra provides four abstract types for residue rings and their elements:","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"ResRing{T} is the abstract type for residue ring parent types\nResField{T} is the abstract type for residue rings known to be fields\nResElem{T} is the abstract type for types of elements of residue rings (residues)\nResFieldElem{T} is the abstract type for types of elements of residue fields","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"We have that ResRing{T} <: AbstractAlgebra.Ring and  ResElem{T} <: AbstractAlgebra.RingElem.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Note that these abstract types are parameterised. The type T should usually be the type of elements of the base ring of the residue ring/field.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"If the parent object for a residue ring has type MyResRing and residues in that ring have type MyRes then one would have:","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"MyResRing <: ResRing{BigInt}\nMyRes <: ResElem{BigInt}","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Residue rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Residue rings should at least be distinguished based on their base ring and modulus (the principal ideal one is taking a quotient of the base ring by).","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"residue_rings/#Required-functionality-for-residue-rings","page":"Residue Ring Interface","title":"Required functionality for residue rings","text":"","category":"section"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"In addition to the required functionality for the Ring interface the Residue Ring interface has the following required functions.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"We suppose that R is a fictitious base ring, m is an element of that ring, and that S is the residue ring (quotient ring) R(m) with parent object S of type MyResRing{T}. We also assume the residues r pmodm in the residue ring have type MyRes{T}, where T is the type of elements of the base ring.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"residue_rings/#Data-type-and-parent-object-methods","page":"Residue Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"modulus(S::MyResRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Return the modulus of the given residue ring, i.e. if the residue ring S was specified to be R(m), return m.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Examples","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> m = modulus(S)\nx^3 + 3*x + 1\n","category":"page"},{"location":"residue_rings/#Basic-manipulation-of-rings-and-elements","page":"Residue Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"data(f::MyRes{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Given a residue r pmodm, represented as such, return r.","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Examples","category":"page"},{"location":"residue_rings/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x^2 + 2)\nx^2 + 2\n\njulia> d = data(f)\nx^2 + 2\n","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"mpolynomial_rings/#Multivariate-Polynomial-Ring-Interface","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Multivariate polynomial rings are supported in AbstractAlgebra.jl, and in addition to the standard Ring interface, numerous additional functions are provided.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Unlike other kinds of rings, even complex operations such as GCD depend heavily on the multivariate representation. Therefore AbstractAlgebra.jl cannot provide much in the way of additional functionality to external multivariate implementations.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"This means that external libraries must be able to implement their multivariate formats in whatever way they see fit. The required interface here should be implemented, even if it is not optimal. But it can be extended, either by implementing one of the optional interfaces, or by extending the required interface in some other way.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Naturally, any multivariate polynomial ring implementation provides the full Ring interface, in order to be treated as a ring for the sake of AbstractAlgebra.jl.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Considerations which make it impossible for AbstractAlgebra.jl to provide generic functionality on top of an arbitrary multivariate module include:","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"orderings (lexical, degree, weighted, block, arbitrary)\nsparse or dense representation\ndistributed or recursive representation\npacked or unpacked exponents\nexponent bounds (and whether adaptive or not)\nrandom access or iterators\nwhether monomials and polynomials have the same type\nwhether special cache aware data structures such as Geobuckets are used","category":"page"},{"location":"mpolynomial_rings/#Types-and-parents","page":"Multivariate Polynomial Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"AbstractAlgebra.jl provides two abstract types for multivariate polynomial rings and their elements:","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"MPolyRing{T} is the abstract type for multivariate polynomial ring parent types\nMPolyElem{T} is the abstract type for multivariate polynomial types","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"We have that MPolyRing{T} <: AbstractAlgebra.Ring and MPolyElem{T} <: AbstractAlgebra.RingElem.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx y the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Multivariate polynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Multivariate polynomial rings should at least be distinguished based on their base (coefficient) ring and number of variables. But if they have the same base ring, symbols (for their variables/generators) and ordering, they should certainly have the same parent object.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"mpolynomial_rings/#Required-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Required functionality for multivariate polynomials","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In addition to the required functionality for the Ring interface, the Multivariate Polynomial interface has the following required functions.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a multivariate polynomial ring over R (i.e. S = Rx y ldots) with parent object S of type MyMPolyRing{T}. We also assume the polynomials in the ring have type MyMPoly{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem or more generally the union type RingElement which includes the Julia integer, rational and floating point types.","category":"page"},{"location":"mpolynomial_rings/#Constructors","page":"Multivariate Polynomial Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"To construct a multivariate polynomial ring, there is the following constructor.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"PolynomialRing(R::Ring, s::Vector{AbstractString}; ordering=:lex, cached=true)","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple, S, vars consisting of a polynomial ring S and an array of generators (variables) which print according to the strings in the supplied vector s. The ordering can at present be :lex, :deglex or :degrevlex. By default, the polynomial ring is cached, and creating a polynomial ring with the same data will return the same ring object S. If this caching is not desired, it can be switched off by setting cached=false.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Polynomials in a given ring can be constructed using the generators and basic polynomial arithmetic. However, this is inefficient and the following build context is provided for building polynomials term-by-term. It assumes the polynomial data type is random access, and so the constructor functions must be reimplemented for all other types of polynomials.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"MPolyBuildCtx(R::MPolyRing)","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a build context for creating polynomials in the given polynomial ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Add the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"finish(M::MPolyBuildCtx)","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Finish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for a polynomial in Multivariate Polynomial Ring in x, y over Integers\n\njulia> push_term!(C, ZZ(3), [1, 2])\nBuilder for a polynomial in Multivariate Polynomial Ring in x, y over Integers\n\njulia> finish(C)\n3*x*y^2\n\njulia> push_term!(C, ZZ(2), [1, 1]); finish(C)\n3*x*y^2 + 2*x*y\n\njulia> push_term!(C, ZZ(4), [0, 0]); finish(C)\n3*x*y^2 + 2*x*y + 4","category":"page"},{"location":"mpolynomial_rings/#Data-type-and-parent-object-methods","page":"Multivariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"symbols(S::MyMPolyRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of Symbols representing the variables (generators) of the polynomial ring. Note that these are Symbols not Strings, though their string values will usually be used when printing polynomials.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"nvars(f::MyMPolyRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the number of variables of the polynomial ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gens(S::MyMPolyRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of all the generators (variables) of the given polynomial ring (as polynomials).","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The first entry in the array will be the variable with most significance with respect to the ordering.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gen(S::MyMPolyRing{T}, i::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the i-th generator (variable) of the given polynomial ring (as a polynomial).","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"ordering(S::MyMPolyRing{T})","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the ordering of the given polynomial ring as a symbol. Supported values currently include :lex, :deglex and :degrevlex.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> S, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:deglex)\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> V = symbols(S)\n2-element Array{Symbol,1}:\n :x\n :y\n\njulia> X = gens(S)\n2-element Array{AbstractAlgebra.Generic.MPoly{Rational{BigInt}},1}:\n x\n y\n\njulia> ord = ordering(S)\n:deglex\n","category":"page"},{"location":"mpolynomial_rings/#Basic-manipulation-of-rings-and-elements","page":"Multivariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"length(f::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the number of nonzero terms of the given polynomial. The length of the zero polynomial is defined to be 0. The return value should be of type Int.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of the degrees of the polynomial f in each of the variables.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"total_degree(f::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the total degree of the polynomial f, i.e. the highest sum of exponents occuring in any term of f.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"isgen(x::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return true if x is a generator of the polynomial ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coefficients(p::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the coefficients of the polynomial p, starting with the coefficient of the most significant term with respect to the ordering. Generic code will provide this function automatically for random access polynomials that implement the coeff function.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"monomials(p::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the monomials of the polynomial p, starting with the monomial of the most significant term with respect to the ordering. Monomials in AbstractAlgebra are defined to have coefficient 1. See the function terms if you also require the coefficients, however note that only monomials can be compared. Generic code will provide this function automatically for random access polynomials that implement the monomial function.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"terms(p::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the terms of the polynomial p, starting with the most significant term with respect to the ordering. Terms in AbstractAlgebra include the coefficient. Generic code will provide this function automatically for random access polynomials that implement the term function.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent_vectors(a::MyMPoly{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the exponent vectors for each of the terms of the polynomial starting with the most significant term with respect to the ordering. Each exponent vector is an array of Ints, one for each variable, in the order given when the polynomial ring was created. Generic code will provide this function automatically for random access polynomials that implement the exponent_vector function.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> n = length(f)\n3\n\njulia> isgen(y)\ntrue\n\njulia> nvars(S) == 2\ntrue\n\njulia> C = collect(coefficients(f))\n3-element Array{BigInt,1}:\n 1\n 3\n 1\n\njulia> M = collect(monomials(f))\n3-element Array{AbstractAlgebra.Generic.MPoly{BigInt},1}:\n x^3*y\n x*y^2\n 1\n\njulia> T = collect(terms(f))\n3-element Array{AbstractAlgebra.Generic.MPoly{BigInt},1}:\n x^3*y\n 3*x*y^2\n 1\n\njulia> V = collect(exponent_vectors(f))\n3-element Array{Array{Int64,1},1}:\n [3, 1]\n [1, 2]\n [0, 0]\n\njulia> d = total_degree(f)\n4\n","category":"page"},{"location":"mpolynomial_rings/#Exact-division","page":"Multivariate Polynomial Ring Interface","title":"Exact division","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"For any ring that implements exact division, the following can be implemented.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divexact(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the exact quotient of f by g if it exists, otherwise throw an error.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divides(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (flag, q) where flag is true if g divides f, in which case q will be the exact quotient, or flag is false and q is set to zero.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"remove(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (v q) such that the highest power of g that divides f is g^v and the cofactor is q.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"valuation(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return v such that the highest power of g that divides f is g^v.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x^2*y^2 + 1\nx^2*y^2 + 1\n\njulia> flag, q = divides(f*g, f)\n(true, x^2*y^2 + 1)\n\njulia> d = divexact(f*g, f)\nx^2*y^2 + 1\n\njulia> v, q = remove(f*g^3, g)\n(3, 2*x^2*y + 2*x + y + 1)\n\njulia> n = valuation(f*g^3, g)\n3\n","category":"page"},{"location":"mpolynomial_rings/#Ad-hoc-exact-division","page":"Multivariate Polynomial Ring Interface","title":"Ad hoc exact division","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"For any ring that implements exact division, the following can be implemented.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divexact(f::MyMPoly{T}, c::Integer) where T <: AbstractAlgebra.RingElem\ndivexact(f::MyMPoly{T}, c::Rational) where T <: AbstractAlgebra.RingElem\ndivexact(f::MyMPoly{T}, c::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Divide the polynomial exactly by the constant c.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 3x^2*y^2 + 2x + 1\n3*x^2*y^2 + 2*x + 1\n\njulia> f1 = divexact(f, 5)\n3//5*x^2*y^2 + 2//5*x + 1//5\n\njulia> f2 = divexact(f, QQ(2, 3))\n9//2*x^2*y^2 + 3*x + 3//2\n","category":"page"},{"location":"mpolynomial_rings/#Euclidean-division","page":"Multivariate Polynomial Ring Interface","title":"Euclidean division","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Although multivariate polynomial rings are not in general Euclidean, it is possible to define a quotient with remainder function that depends on the polynomial ordering in the case that the quotient ring is a field or a Euclidean domain. In the case that a polynomial g divides a polynomial f, the result no longer depends on the ordering and the remainder is zero, with the quotient agreeing with the exact quotient.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divrem(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients).","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that the result of this function depends on the ordering of the polynomial ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"div(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"As per the divrem function, but returning the quotient only. Especially when the quotient happens to be exact, this function can be exceedingly fast.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x + y\nx + y\n\njulia> q = div(f, g)\n2*x*y - 2*y^2 + 2\n\njulia> q, r = divrem(f, g)\n(2*x*y - 2*y^2 + 2, 2*y^3 - y + 1)\n","category":"page"},{"location":"mpolynomial_rings/#GCD","page":"Multivariate Polynomial Ring Interface","title":"GCD","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In cases where there is a meaningful Euclidean structure on the coefficient ring, it is possible to compute the GCD of multivariate polynomials.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gcd(f::MyMPoly{T}, g::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a greatest common divisor of f and g.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x^2*y^2 + 1\nx^2*y^2 + 1\n\njulia> d = gcd(f*g^2, f^2*g)\n2*x^4*y^3 + 2*x^3*y^2 + x^2*y^3 + x^2*y^2 + 2*x^2*y + 2*x + y + 1\n","category":"page"},{"location":"mpolynomial_rings/#Square-root","page":"Multivariate Polynomial Ring Interface","title":"Square root","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"sqrt(f::MyMPoly{T}, check::bool=true) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the square root of the polynomial f and raise an exception if it is not a square. If check is set to false, the input is assumed to be a perfect square and this assumption is not fully checked. This can be significantly faster.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"issquare(::MyMPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return true if f is a square.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = -4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n-4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n\njulia> sqrt(f^2)\n4*x^5*y^4 - 5*x^5*y^3 - 4*x^4 + x^3*y^4\n\njulia> issquare(f)\nfalse","category":"page"},{"location":"mpolynomial_rings/#Interface-for-sparse-distributed,-random-access-multivariates","page":"Multivariate Polynomial Ring Interface","title":"Interface for sparse distributed, random access multivariates","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following additional functions should be implemented by libraries that provide a sparse distributed polynomial format, stored in a representation for which terms can be accessed in constant time (e.g. where arrays are used to store coefficients and exponent vectors).","category":"page"},{"location":"mpolynomial_rings/#Sparse-distributed,-random-access-constructors","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access constructors","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In addition to the standard constructors, the following constructor, taking arrays of coefficients and exponent vectors, should be provided.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"(S::MyMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Create the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"There is no assumption about coefficients being nonzero or terms being in order or unique. Zero terms are removed by the function, duplicate terms are combined (added) and the terms are sorted so that they are in the correct order.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Each exponent vector uses a separate integer for each exponent field, the first of which should be the exponent for the most significant variable with respect to the ordering. All exponents must be non-negative.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"A library may also optionally provide an interface that makes use of BigInt (or any other big integer type) for exponents instead of Int.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> S, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = S(Rational{BigInt}[2, 3, 1], [[3, 2], [1, 0], [0, 1]])\n2*x^3*y^2 + 3*x + y\n","category":"page"},{"location":"mpolynomial_rings/#Sparse-distributed,-random-access-basic-manipulation","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access basic manipulation","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coeff(f::MyMPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the coefficient of the n-th term of f. The first term should be the most significant term with respect to the ordering.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coeff(a::MyMPoly{T}, exps::Vector{Int}) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the coefficient of the term with the given exponent vector, or zero if there is no such term.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"monomial(f::MyMPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem\nmonomial!(m::MyMPoly{T}, f::MyMPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the n-th monomial of f or set m to the n-th monomial of f, respectively. The first monomial should be the most significant term with respect to the ordering. Monomials have coefficient 1 in AbstractAlgebra. See the function term if you also require the coefficient, however, note that only monomials can be compared.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"term(f::MyMPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the n-th term of f. The first term should be the one whose monomial is most significant with respect to the ordering.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent(f::MyMPoly{T}, i::Int, j::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the exponent of the j-th variable in the n-th term of the polynomial f. The first term is the one with whose monomial is most significant with respect to the ordering.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent_vector(a::MyMPoly{T}, i::Int) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a vector of exponents, corresponding to the exponent vector of the i-th term of the polynomial. Term numbering begins at 1 and the exponents are given in the order of the variables for the ring, as supplied when the ring was created.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"setcoeff!(a::MyMPoly, exps::Vector{Int}, c::S) where S <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the coefficient of the term with the given exponent vector to the given value c. If no such term exists (and c neq 0), one will be inserted. This function takes O(log n) operations if a term with the given exponent already exists and c neq 0, or if the term is inserted at the end of the polynomial. Otherwise it can take O(n) operations in the worst case. This function must return the modified polynomial.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> c1 = coeff(f, 1)\n1\n\njulia> c2 = coeff(f, x^3*y)\n1\n\njulia> m = monomial(f, 2)\nx*y^2\n\njulia> e1 = exponent(f, 1, 1)\n3\n\njulia> v1 = exponent_vector(f, 1)\n2-element Array{Int64,1}:\n 3\n 1\n\njulia> t1 = term(f, 1)\nx^3*y\n\njulia> setcoeff!(f, [3, 1], 12)\n12*x^3*y + 3*x*y^2 + 1\n","category":"page"},{"location":"mpolynomial_rings/#Unsafe-functions","page":"Multivariate Polynomial Ring Interface","title":"Unsafe functions","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following functions must be provided, but are considered unsafe, as they may leave the polynomials in an inconsistent state and they mutate their inputs. As usual, such functions should only be applied on polynomials that have no references elsewhere in the system and are mainly intended to be used in carefully written library code, rather than by users.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Users should instead build polynomials using the constructors described above.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"fit!(f::MyMPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Ensure that the polynomial f internally has space for n nonzero terms. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"setcoeff!(a::MyMPoly{T}, i::Int, c::T) where T <: RingElement\nsetcoeff!(a::MyMPoly{T}, i::Int, c::U) where {T <: RingElement, U <: Integer}","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the i-th coefficient of the polynomial a to c. No check is performed on the index i or for c = 0. It may be necessary to call combine_like_terms after calls to this function, to remove zero terms. The function must return the modified polynomial.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"combine_like_terms!(a::MyMPoly{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Remove zero terms and combine any adjacent terms with the same exponent vector (by adding them). It is assumed that all the exponent vectors are already in the correct order with respect to the ordering. The function must return the resulting polynomial.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"set_exponent_vector!(a::MyMPoly{T}, i::Int, exps::Vector{Int}) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the i-th exponent vector to the given exponent vector. No check is performed on the index i, which is assumed to be valid (or that the polynomial has enough space allocated). No sorting of exponents is performed by this function. To sort the terms after setting any number of exponents with this function, run the sort_terms! function. The function must return the modified polynomial.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"sort_terms!(a::MyMPoly{T}) where {T <: RingElement}","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Sort the terms of the given polynomial according to the polynomial ring ordering. Zero terms and duplicate exponents are ignored. To deal with those call combine_like_terms. The sorted polynomial must be returned by the function.","category":"page"},{"location":"mpolynomial_rings/#Optional-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Optional functionality for multivariate polynomials","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following functions can optionally be implemented for multivariate polynomial types.","category":"page"},{"location":"mpolynomial_rings/#Reduction-by-an-ideal","page":"Multivariate Polynomial Ring Interface","title":"Reduction by an ideal","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divrem(f::MyMPoly{T}, G::Array{MyMPoly{T}, 1}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"As per the divrem function above, except that each term of r starting with the most significant term, is reduced modulo the leading terms of each of the polynomials in the array G for which the leading monomial is a divisor.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"A tuple (Q r) is returned from the function, where Q is an array of polynomials of the same length as G, and such that f = r + sum QiGi.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The result is again dependent on the ordering in general, but if the polynomials in G are over a field and the reduced generators of a Groebner basis, then the result is unique.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x + y\nx + y\n\njulia> h = y + 1\ny + 1\n\njulia> Q, r = divrem(f, [g, h])\n(AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[2*x*y - 2*y^2 + 2, 2*y^2 - 2*y + 1], 0)\n","category":"page"},{"location":"mpolynomial_rings/#Evaluation","page":"Multivariate Polynomial Ring Interface","title":"Evaluation","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"evaluate(a::MyMPoly{T}, A::Vector{T}) where T <: RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial at the given values in the coefficient ring of the polynomial. The result should be an element of the coefficient ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"evaluate(f::MyMPoly{T}, A::Vector{U}) where {T <: AbstractAlgebra.RingElem, U <: Intege\nr}","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial f at the values specified by the entries of the array A.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"(a::MyMPoly{T})(vals::Union{NCRingElem, RingElement}...) where T <: RingElement","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial at the given arguments. This provides functional notation for polynomial evaluation, i.e. f(a b c). It must be defined for each supported polynomial type (Julia does not allow functional notation to be defined for an abstract type).","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The code for this function in MPoly.jl can be used when implementing this as it provides the most general possible evaluation, which is much more general than the case of evaluation at elements of the same ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The evaluation should succeed for any set of values for which a multiplication is defined with the product of a coefficient and all the values before it.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that the values may be in non-commutative rings. Products are performed in the order of the variables in the polynomial ring that the polynomial belongs to, preceded by a multiplication by the coefficient on the left.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = AbstractAlgebra.PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> evaluate(f, [ZZ(1), ZZ(2)])\n6\n\njulia> evaluate(f, [2, 3])\n12\n\njulia> f(1, 2)\n6\n\njulia> f(ZZ(1), ZZ(2))\n6\n\njulia> f(x - y, x + y)\nx^2 + 2*x - y^2 + 1\n\njulia> M1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> M2 = S([2 4; 1 -1])\n[2    4]\n[1   -1]\n\njulia> M3 = S([1 -1; 1 1])\n[1   -1]\n[1    1]\n\njulia> f(M1, M2)\n[ 8    8]\n[14   12]\n\njulia> f(M1, ZZ(2))\n[6    6]\n[9   15]\n","category":"page"},{"location":"mpolynomial_rings/#Derivations","page":"Multivariate Polynomial Ring Interface","title":"Derivations","text":"","category":"section"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following function allows to compute derivations of multivariate polynomials of type MPoly.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"derivative(f::MyMPoly{T}, j::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Compute the derivative of f with respect to the j-th variable of the polynomial ring.","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"mpolynomial_rings/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"julia> R, (x, y) = AbstractAlgebra.PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> derivative(f, 1)\ny + 1\n\njulia> derivative(f, 2)\nx + 1\n","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"polynomial_rings/#Univariate-Polynomial-Ring-Interface","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings are supported in AbstractAlgebra, and in addition to the standard Ring interface, numerous additional functions are required to be present for univariate polynomial rings.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings can be built over both commutative and noncommutative rings.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings over a field are also Euclidean and therefore such rings must implement the Euclidean interface.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Since a sparse distributed multivariate format can generally also handle sparse univariate polynomials, the univariate polynomial interface is designed around the assumption that they are dense. This is not a requirement, but it may be easier to use the multivariate interface for sparse univariate types.","category":"page"},{"location":"polynomial_rings/#Types-and-parents","page":"Univariate Polynomial Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"AbstractAlgebra provides two abstract types for polynomial rings and their elements over a commutative ring:","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"PolyRing{T} is the abstract type for univariate polynomial ring parent types\nPolyElem{T} is the abstract type for univariate polynomial types","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Similarly there are two abstract types for polynomial rings and their elements over a noncommutative ring:","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"NCPolyRing{T} is the abstract type for univariate polynomial ring parent types\nNCPolyElem{T} is the abstract type for univariate polynomial types","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We have that PolyRing{T} <: AbstractAlgebra.Ring and PolyElem{T} <: AbstractAlgebra.RingElem. Similarly we have that NCPolyRing{T} <: AbstractAlgebra.NCRing and  NCPolyElem{T} <: AbstractAlgebra.NCRingElem.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"If the parent object for such a ring has type MyZX and polynomials in that ring have type MyZXPoly then one would have:","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"MyZX <: PolyRing{BigInt}\nMyZXPoly <: PolyElem{BigInt}","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Polynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Polynomial rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator), they should certainly have the same parent object.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"polynomial_rings/#Required-functionality-for-univariate-polynomials","page":"Univariate Polynomial Ring Interface","title":"Required functionality for univariate polynomials","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"In addition to the required functionality for the Ring/NCRing interface (and in the case of polynomials over a field, the Euclidean Ring interface), the Polynomial Ring interface has the following required functions.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a univariate polynomial ring over R (i.e. S = Rx) with parent object S of type MyPolyRing{T}. We also assume the polynomials in the ring have type MyPoly{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem or NCRingElem.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We describe the functionality below for polynomials over commutative rings, i.e. with element type belonging to RingElem, however similar constructors should be available for element types belonging to NCRingElem instead, if the coefficient ring is noncommutative.","category":"page"},{"location":"polynomial_rings/#Constructors","page":"Univariate Polynomial Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"(S::MyPolyRing{T})(A::Array{T, 1}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Create the polynomial in the given ring whose degree i coefficient is given by A[i].","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"(S::MyPolyRing{T})(A::Array{U, 1}) where T <: AbstractAlgebra.RingElem, U <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Create the polynomial in the given ring whose degree i coefficient is given by A[i]. The elements of the array are assumed to be able to be coerced into the base ring R.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"(S::MyPolyRing{T})(A::Array{U, 1}) where T <: AbstractAlgebra.RingElem, U <: Integer","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Create the polynomial in the given ring whose degree i coefficient is given by A[i].","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"It may be desirable to have a additional version of the function that accepts an array of Julia Int values  if this can be done more efficiently.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"julia> S, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> f = S(Rational{BigInt}[2, 3, 1])\nx^2 + 3*x + 2\n\njulia> g = S(BigInt[1, 0, 4])\n4*x^2 + 1\n\njulia> h = S([4, 7, 2, 9])\n9*x^3 + 2*x^2 + 7*x + 4\n","category":"page"},{"location":"polynomial_rings/#Data-type-and-parent-object-methods","page":"Univariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"var(S::MyPolyRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return a Symbol representing the variable (generator) of the polynomial ring. Note that this is a Symbol not a String, though its string value will usually be used when printing polynomials.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"symbols(S::MyPolyRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the array [s] where s is a Symbol representing the variable of the given polynomial ring. This is provided for uniformity with the multivariate interface, where there is more than one variable and hence an array of symbols.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"julia> S, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> vsym = var(S)\n:x\n\njulia> V = symbols(S)\n1-element Array{Symbol,1}:\n :x\n","category":"page"},{"location":"polynomial_rings/#Basic-manipulation-of-rings-and-elements","page":"Univariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"length(f::MyPoly{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the length of the given polynomial. The length of the zero polynomial is defined to be 0, otherwise the length is the degree plus 1. The return value should be of type Int.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"set_length!(f::MyPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"This function must zero any coefficients beyond the requested length n and then set the length of the polynomial to n. This function does not need to normalise the polynomial and is not useful to the user, but is used extensively by the AbstractAlgebra generic functionality.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"This function returns the resulting polynomial.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"coeff(f::MyPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the coefficient of the polynomial f of degree n. If n is larger than the degree of the polynomial, it should return zero in the coefficient ring. ","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"setcoeff!(f::MyPoly{T}, n::Int, a::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Set the degree n coefficient of f to a. This mutates the polynomial in-place if possible and returns the mutated polynomial (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that this function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"normalise(f::MyPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Given a polynomial whose length is currently n, including any leading zero coefficients, return the length of the normalised polynomial (either zero or the length of the polynomial with nonzero leading coefficient). Note that the function does not actually perform the normalisation.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"fit!(f::MyPoly{T}, n::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Ensure that the polynomial f internally has space for n coefficients. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Some interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Examples","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"julia> S, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = x^3 + 3x + 1\nx^3 + 3*x + 1\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0]);\n\njulia> n = length(f)\n4\n\njulia> c = coeff(f, 1)\n3\n\njulia> g = set_length!(g, normalise(g, 7))\nx^3 + 2*x + 1\n\njulia> g = setcoeff!(g, 2, BigInt(11))\nx^3 + 11*x^2 + 2*x + 1\n\njulia> fit!(g, 8)\n\njulia> g = setcoeff!(g, 7, BigInt(4))\n4*x^7 + x^3 + 11*x^2 + 2*x + 1","category":"page"},{"location":"polynomial_rings/#Optional-functionality-for-polynomial-rings","page":"Univariate Polynomial Ring Interface","title":"Optional functionality for polynomial rings","text":"","category":"section"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Sometimes parts of the Euclidean Ring interface can and should be implemented for polynomials over a ring that is not necessarily a field.","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"When divisibility testing can be implemented for a polynomial ring over a field, it  should be possible to implement the following functions from the Euclidean Ring interface:","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"divides\nremove\nvaluation","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"When the given polynomial ring is a GCD domain, with an effective GCD algorithm, it may be possible to implement the following functions:","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"gcd\nlcm","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Polynomial rings can optionally implement any part of the generic univariate polynomial functionality provided by AbstractAlgebra.jl, using the same interface. ","category":"page"},{"location":"polynomial_rings/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Obviously additional functionality can also be added to that provided by AbstractAlgebra.jl on an ad hoc basis.","category":"page"},{"location":"fields/#Field-Interface","page":"Field Interface","title":"Field Interface","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all fields. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their fields.","category":"page"},{"location":"fields/#Types","page":"Field Interface","title":"Types","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Most fields must supply two types:","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"a type for the parent object (representing the field itself)\na type for elements of that field","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"For example, the generic fraction field type in AbstractAlgebra.jl provides two  types in generic/GenericTypes.jl: ","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Generic.FracField{T} for the parent objects\nGeneric.Frac{T} for the actual fractions","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"The parent type must belong to AbstractAlgebra.Field and the element type must belong to AbstractAlgebra.FieldElem. Of course, the types may belong to these abstract types transitively.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"For parameterised fields, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"page"},{"location":"fields/#FieldElement-type-union","page":"Field Interface","title":"FieldElement type union","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to AbstractAlgebra.FieldElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of fields we define a union type AbstractAlgebra.FieldElement in src/julia/JuliaTypes.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"So far, in addition to AbstractAlgebra.FieldElem the  union type AbstractAlgebra.FieldElement includes the Julia types Rational and AbstractFloat.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Most of the generic code in AbstractAlgebra makes use of the union type AbstractAlgebra.FieldElement instead of AbstractAlgebra.FieldElem so that the generic functions also accept the Julia Base field types.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"One must be careful when defining ad hoc binary operations for field element types. It is often necessary to define separate versions of the functions for AbstractAlgebra.FieldElem then for each of the Julia types separately in order to avoid ambiguity warnings.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Note that even though AbstractAlgebra.FieldElement is a union type we still have the following inclusion","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"AbstractAlgebra.FieldElement <: AbstractAlgebra.RingElement","category":"page"},{"location":"fields/#Parent-object-caches","page":"Field Interface","title":"Parent object caches","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"In many cases, it is desirable to have only one object in the system to represent each field. This means that if the same field is constructed twice, elements of the two fields will be compatible as far as arithmetic is concerned.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"In order to facilitate this, global caches of fields are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.FracField parent objects are looked up in a dictionary FracDict to see if they have been previously defined.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two fields are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two fields if they were constructed from identical data.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl` for examples of how to construct and handle such caches.","category":"page"},{"location":"fields/#Required-functions-for-all-fields","page":"Field Interface","title":"Required functions for all fields","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"In the following, we list all the functions that are required to be provided for fields in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"We give this interface for fictitious types MyParent for the type of the field parent object R and MyElem for the type of the elements of the field.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Note that generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for fields that implement that additional functionality, and should be documented as such.","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"In the first place, all fields are rings and therefore any field type must implement all of the Ring interface. The functionality below is in addition to this basic functionality.","category":"page"},{"location":"fields/#Data-type-and-parent-object-methods","page":"Field Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"characteristic(R::MyParent)","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Return the characteristic of the field.","category":"page"},{"location":"fields/#Basic-manipulation-of-rings-and-elements","page":"Field Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"isunit(f::MyElem)","category":"page"},{"location":"fields/","page":"Field Interface","title":"Field Interface","text":"Return true if the given element is invertible, i.e. nonzero in the field.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"perm/#Permutations-and-Symmetric-groups","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in src/generic/PermGroups.jl). All functionality of permutations is accesible in the Generic submodule.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Permutations are represented internally via vector of integers, wrapped in type Perm{T}, where T<:Integer carries the information on the type of elements of a permutation. Symmetric groups are singleton parent objects of type SymmetricGroup{T} and are used mostly to store the length of a permutation, since it is not included in the permutation type.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Symmetric groups are created using the SymmetricGroup (inner) constructor.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Both SymmetricGroup and Perm and can be parametrized by any type T<:Integer . By default the parameter is the Int-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as Int32, UInt16, or even Int8), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"All the permutation group types belong to the Group abstract type and the corresponding permutation element types belong to the GroupElem abstract type.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.setpermstyle","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.setpermstyle","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.setpermstyle","text":"setpermstyle(format::Symbol)\n\nSelect the style in which permutations are displayed (in the REPL or in general as strings). This can be either\n\n:array - as vector of integers whose n-th position represents the value at n), or\n:cycles - as, more familiar for mathematicians, decomposition into disjoint cycles, where the value at n is represented by the entry immediately following n in a cycle (the default).\n\nThe difference is purely esthetical.\n\nExamples:\n\njulia> setpermstyle(:array)\n:array\n\njulia> Perm([2,3,1,5,4])\n[2, 3, 1, 5, 4]\n\njulia> setpermstyle(:cycles)\n:cycles\n\njulia> Perm([2,3,1,5,4])\n(1,2,3)(4,5)\n\n\n\n","category":"function"},{"location":"perm/#Permutations-constructors","page":"Permutations and Symmetric groups","title":"Permutations constructors","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"There are several methods to construct permutations in AbstractAlgebra.jl.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The easiest way is to directly call to the Perm (inner) constructor:","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.Perm","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.Perm","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.Perm","text":"Perm{T<:Integer}\n\nThe type of permutations. Fieldnames:\n\nd::Vector{T} - vector representing the permutation\nmodified::Bool - bit to check the validity of cycle decomposition\ncycles::CycleDec{T} - (cached) cycle decomposition\n\nA permutation p consists of a vector (p.d) of n integers from 1 to n. If the i-th entry of the vector is j, this corresponds to p sending i to j. The cycle decomposition (p.cycles) is computed on demand and should never be accessed directly. Use cycles(p) instead.\n\nThere are two inner constructors of Perm:\n\nPerm(n::T) constructs the trivial Perm{T}-permutation of length n.\nPerm(v::AbstractVector{<:Integer} [,check=true]) constructs a permutation represented by v. By default Perm constructor checks if the vector constitutes a valid permutation. To skip the check call Perm(v, false).\n\nExamples:\n\njulia> Perm([1,2,3])\n()\n\njulia> g = Perm(Int32[2,3,1])\n(1,2,3)\n\njulia> typeof(g)\nPerm{Int32}\n\n\n\n","category":"type"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Since the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitly constructing the parent object.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor SymmetricGroup(n::Integer) which constructs the permutation group on n symbols and returns the parent object representing the group.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.SymmetricGroup","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.SymmetricGroup","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.SymmetricGroup","text":"SymmetricGroup{T<:Integer}\n\nThe full symmetric group singleton type. SymmetricGroup(n) constructs the full symmetric group S_n on n-symbols. The type of elements of the group is inferred from the type of n.\n\nExamples:\n\njulia> G = SymmetricGroup(5)\nFull symmetric group over 5 elements\n\njulia> elem_type(G)\nPerm{Int64}\n\njulia> H = SymmetricGroup(UInt16(5))\nFull symmetric group over 5 elements\n\njulia> elem_type(H)\nPerm{UInt16}\n\n\n\n","category":"type"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"A vector of integers can be then coerced to a permutation by calling a parent permutation group on it.   The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Examples:","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"julia> G = SymmetricGroup(BigInt(5)); p = G([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(p)\nPerm{BigInt}\n\njulia> H = SymmetricGroup(UInt16(5)); r = H([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(r)\nPerm{UInt16}\n\njulia> one(H)\n()","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"By default the coercion checks for non-unique values in the vector, but this can be switched off with G([2,3,1,5,4], false).","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Finally there is a perm\"...\" string macro to construct a permutation from a string input.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"@perm_str","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.@perm_str","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.@perm_str","text":"perm\"...\"\n\nString macro to parse disjoint cycles into Perm{Int}.\n\nStrings for the output of GAP could be copied directly into perm\"...\". Cycles of length 1 are not necessary, but can be included. A permutation of the minimal support is constructed, i.e. the maximal n in the decomposition determines the parent group S_n.\n\nExamples:\n\njulia> p = perm\"(1,3)(2,4)\"\n(1,3)(2,4)\n\njulia> typeof(p)\nPerm{Int64}\n\njulia> parent(p) == SymmetricGroup(4)\ntrue\n\njulia> p = perm\"(1,3)(2,4)(10)\"\n(1,3)(2,4)\n\njulia> parent(p) == SymmetricGroup(10)\ntrue\n\n\n\n","category":"macro"},{"location":"perm/#Permutation-interface","page":"Permutations and Symmetric groups","title":"Permutation interface","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide these functions along with the usual group element arithmetic and comparison.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"parent(::Perm)\nelem_type(::SymmetricGroup)\nparent_type(::Perm)","category":"page"},{"location":"perm/#Base.parent-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"Base.parent","text":"parent(g::Perm)\n\nReturn the parent of the permutation g.\n\njulia> G = SymmetricGroup(5); g = Perm([3,4,5,2,1])\n(1,3,5)(2,4)\n\njulia> parent(g) == G\ntrue\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.elem_type-Tuple{AbstractAlgebra.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.elem_type","text":"elem_type(parent)\nelem_type(parent_type)\n\nGiven a parent object (or its type), return the type of its elements.\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.parent_type-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.parent_type","text":"parent_type(element)\nparent_type(element_type)\n\nGiven an element (or its type), return the type of its parent object.\n\n\n\n","category":"method"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"A custom implementation also needs to implement hash(::Perm, ::UInt) and (possibly) deepcopy_internal(::Perm, ::ObjectIdDict).","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nPermutation group elements are mutable and so returning shallow copies is not sufficient.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"getindex(a::Perm, n::Integer)","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Allow access to entry n of the given permutation via the syntax a[n]. Note that entries are 1-indexed.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"setindex!(a::Perm, d::Integer, n::Integer)","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Set the n-th entry of the given permutation to d. This allows Julia to provide the syntax a[n] = d for setting entries of a permutation. Entries are 1-indexed.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nUsing setindex! invalidates the cycle decomposition cached in a permutation, which will be computed the next time it is needed.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Given the parent object G for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"one(G)","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Return the identity permutation.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"G(A::Vector{<:Integer})","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Return the permutation whose entries are given by the elements of the supplied vector.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"G(p::Perm)","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.","category":"page"},{"location":"perm/#Basic-manipulation","page":"Permutations and Symmetric groups","title":"Basic manipulation","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Numerous functions are provided to manipulate permutation group elements.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"cycles(::Perm)","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.cycles-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.cycles","text":"cycles(g::Perm)\n\nDecompose permutation g into disjoint cycles.\n\nReturn a CycleDec object which iterates over disjoint cycles of g. The ordering of cycles is not guaranteed, and the order within each cycle is computed up to a cyclic permutation. The cycle decomposition is cached in g and used in future computation of permtype, parity, sign, order and ^ (powering).\n\nExamples:\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> collect(cycles(g))\n3-element Array{Array{Int64,1},1}:\n [1, 3, 5]\n [2, 4]\n [6]\n\n\n\n","category":"method"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Cycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"parity(::Perm)\nsign(::Perm)\npermtype(::Perm)\norder(::Perm)\norder(::Generic.SymmetricGroup)","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.parity-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.parity","text":"parity(g::Perm)\n\nReturn the parity of the given permutation, i.e. the parity of the number of transpositions in any decomposition of g into transpositions.\n\nparity returns 1 if the number is odd and 0 otherwise. parity uses cycle decomposition of g if already available, but will not compute it on demand. Since cycle structure is cached in g you may call cycles(g) before calling parity.\n\nExamples:\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> parity(g)\n0\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> parity(g)\n1\n\n\n\n","category":"method"},{"location":"perm/#Base.sign-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"Base.sign","text":"sign(g::Perm)\n\nReturn the sign of a permutation.\n\nsign returns 1 if g is even and -1 if g is odd. sign represents the homomorphism from the permutation group to the unit group of mathbbZ whose kernel is the alternating group.\n\nExamples:\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> sign(g)\n1\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> sign(g)\n-1\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.permtype-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.permtype","text":"permtype(g::Perm)\n\nReturn the type of permutation g, i.e. lengths of disjoint cycles in cycle decomposition of g.\n\nThe lengths are sorted in decreasing order by default. permtype(g) fully determines the conjugacy class of g.\n\nExamples:\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> permtype(g)\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia> e = one(g)\n()\n\njulia> permtype(e)\n6-element Array{Int64,1}:\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.order-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.order","text":"order(a::Perm) -> BigInt\n\nReturn the order of permutation a as BigInt.\n\nIf you are sure that computation over T (or its Int promotion) will not overflow you may use the method order(T::Type, a::Perm) which bypasses computation with BigInts and returns promote(T, Int).\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.order-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.order","text":"order(G::SymmetricGroup) -> BigInt\n\nReturn the order of the full permutation group as BigInt.\n\n\n\n","category":"method"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Note that even an Int64 can be easily overflowed when computing with permutation groups. Thus, by default, order returns (always correct) BigInts. If you are sure that the computation will not overflow, you may use order(::Type{T}, ...) to perform computations with machine integers. Julia's standard promotion rules apply for the returned value.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Since SymmetricGroup implements the iterator protocol, you may iterate over all permutations via a simple loop:","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"for p in SymmetricGroup(n)\n   ...\nend","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Iteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when n  13.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"You may also use the non-allocating Generic.elements! function for n  14 (or even 15 if you are patient enough), which is an order of magnitude faster.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.elements!(::Generic.SymmetricGroup)","category":"page"},{"location":"perm/#AbstractAlgebra.Generic.elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.elements!","text":"Generic.elements!(G::SymmetricGroup)\n\nReturn an unsafe iterator over all permutations in G. Only one permutation is allocated and then modified in-place using the non-recursive Heaps algorithm.\n\nNote: you need to explicitely copy permutations intended to be stored or modified.\n\nExamples:\n\njulia> elts = Generic.elements!(SymmetricGroup(5));\n\n\njulia> length(elts)\n120\n\njulia> for p in Generic.elements!(SymmetricGroup(3))\n         println(p)\n       end\n()\n(1,2)\n(1,3,2)\n(2,3)\n(1,2,3)\n(1,3)\n\njulia> A = collect(Generic.elements!(SymmetricGroup(3))); A\n6-element Array{Perm{Int64},1}:\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n\njulia> unique(A)\n1-element Array{Perm{Int64},1}:\n (1,3)\n\n\n\n","category":"method"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"However, since all permutations yielded by elements! are aliased (modified \"in-place\"), collect(Generic.elements!(SymmetricGroup(n))) returns a vector of identical permutations.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nIf you intend to use or store elements yielded by elements! you need to deepcopy them explicitly.","category":"page"},{"location":"perm/#Arithmetic-operators","page":"Permutations and Symmetric groups","title":"Arithmetic operators","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"*(::Perm{T}, ::Perm{T}) where T\n^(::Perm, n::Integer)\nBase.inv(::Perm)","category":"page"},{"location":"perm/#Base.:*-Union{Tuple{T}, Tuple{Perm{T},Perm{T}}} where T","page":"Permutations and Symmetric groups","title":"Base.:*","text":"*(g::Perm, h::Perm)\n\nReturn the composition h  g of two permutations.\n\nThis corresponds to the action of permutation group on the set [1..n] on the right and follows the convention of GAP.\n\nIf g and h are parametrized by different types, the result is promoted accordingly.\n\nExamples:\n\njulia> Perm([2,3,1,4])*Perm([1,3,4,2]) # (1,2,3)*(2,3,4)\n(1,3)(2,4)\n\n\n\n","category":"method"},{"location":"perm/#Base.:^-Tuple{Perm,Integer}","page":"Permutations and Symmetric groups","title":"Base.:^","text":"^(g::Perm, n::Integer)\n\nReturn the n-th power of a permutation g.\n\nBy default g^n is computed by cycle decomposition of g if n > 3. Generic.power_by_squaring provides a different method for powering which may or may not be faster, depending on the particular case. Due to caching of the cycle structure, repeated powering of g will be faster with the default method.\n\nExamples:\n\njulia> g = Perm([2,3,4,5,1])\n(1,2,3,4,5)\n\njulia> g^3\n(1,4,2,5,3)\n\njulia> g^5\n()\n\n\n\n","category":"method"},{"location":"perm/#Base.inv-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"Base.inv","text":"Base.inv(g::Perm)\n\nReturn the inverse of the given permutation, i.e. the permuation g^-1 such that g  g^-1 = g^-1  g is the identity permutation.\n\n\n\n","category":"method"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"g = rand(SymmetricGroup(Int8(5)));\nh = rand(SymmetricGroup(UInt32(5)));\ntypeof(g*h)\n\n# output\nPerm{UInt32}","category":"page"},{"location":"perm/#Coercion","page":"Permutations and Symmetric groups","title":"Coercion","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The following coercions are available for G::SymmetricGroup parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Examples","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::AbstractVector{<:Integer}[, check=true])","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Turn a vector of integers into a permutation (performing conversion, if necessary).","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::Perm[, check=true])","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Coerce a permutation p into group G (performing the conversion, if necessary). If p is already an element of G no copy is performed.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::String[, check=true])","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Parse the string input e.g. copied from the output of GAP. The method uses the same logic as the perm\"...\" macro. The string is sanitized and checked for disjoint cycles. Both string(p::Perm) (if setpermstyle(:cycles)) and string(cycles(p::Perm)) are valid input for this method.","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup{T})(::CycleDec{T}[, check=true]) where T","category":"page"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Turn a cycle decomposition object into a permutation.","category":"page"},{"location":"perm/#Comparison","page":"Permutations and Symmetric groups","title":"Comparison","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"==(::Perm, ::Perm)\n==(::Generic.SymmetricGroup, ::Generic.SymmetricGroup)","category":"page"},{"location":"perm/#Base.:==-Tuple{Perm,Perm}","page":"Permutations and Symmetric groups","title":"Base.:==","text":"==(g::Perm, h::Perm)\n\nReturn true if permutations are equal, otherwise return false.\n\nPermutations parametrized by different integer types are considered equal if they define the same permutation in the abstract permutation group.\n\nExamples:\n\njulia> g = Perm(Int8[2,3,1])\n(1,2,3)\n\njulia> h = perm\"(3,1,2)\"\n(1,2,3)\n\njulia> g == h\ntrue\n\n\n\n","category":"method"},{"location":"perm/#Base.:==-Tuple{AbstractAlgebra.Generic.SymmetricGroup,AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"Base.:==","text":"==(G::SymmetricGroup, H::SymmetricGroup)\n\nReturn true if permutation groups are equal, otherwise return false.\n\nPermutation groups on the same number of letters, but parametrized by different integer types are considered different.\n\nExamples:\n\njulia> G = SymmetricGroup(UInt(5))\nPermutation group over 5 elements\n\njulia> H = SymmetricGroup(5)\nPermutation group over 5 elements\n\njulia> G == H\nfalse\n\n\n\n","category":"method"},{"location":"perm/#Misc","page":"Permutations and Symmetric groups","title":"Misc","text":"","category":"section"},{"location":"perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"rand(::Generic.SymmetricGroup)\nGeneric.matrix_repr(::Perm)\nGeneric.emb(::Generic.SymmetricGroup, ::Vector{Int}, ::Bool)\nGeneric.emb!(::Perm, ::Perm, V)","category":"page"},{"location":"perm/#Base.rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"Base.rand","text":"rand([rng=GLOBAL_RNG,] G::SymmetricGroup)\n\nReturn a random permutation from G.\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.matrix_repr-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(a::Perm)\n\nReturn the permutation matrix as a sparse matrix representing a via natural embedding of the permutation group into the general linear group over mathbbZ.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> matrix_repr(p)\n33 SparseArrays.SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [3, 1]  =  1\n  [1, 2]  =  1\n  [2, 3]  =  1\n\njulia> Array(ans)\n33 Array{Int64,2}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\nmatrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n34 SparseArrays.SparseMatrixCSC{Int64,Int64} with 8 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  5\n  [3, 1]  =  8\n  [1, 2]  =  2\n  [2, 2]  =  6\n  [1, 3]  =  3\n  [2, 3]  =  7\n  [1, 4]  =  4\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup,Array{Int64,1},Bool}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.emb","text":"emb(G::SymmetricGroup, V::Vector{Int}, check::Bool=true)\n\nReturn the natural embedding of a permutation group into G as the subgroup permuting points indexed by V.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> f = Generic.emb(SymmetricGroup(5), [3,2,5]);\n\n\njulia> f(p)\n(2,5,3)\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.emb!-Tuple{Perm,Perm,Any}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.emb!","text":"emb!(result::Perm, p::Perm, V)\n\nEmbed permutation p into permutation result on the indices given by V.\n\nThis corresponds to the natural embedding of S_k into S_n as the subgroup permuting points indexed by V.\n\nExamples:\n\njulia> p = Perm([2,1,4,3])\n(1,2)(3,4)\n\njulia> Generic.emb!(Perm(collect(1:5)), p, [3,1,4,5])\n(1,3)(4,5)\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"fraction/#Generic-fraction-fields","page":"Generic fraction fields","title":"Generic fraction fields","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/Fraction.jl for generic fraction fields over any gcd domain belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"As well as implementing the Fraction Field interface a number of generic algorithms are implemented for fraction fields. We describe this generic functionality below.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"fraction/#Types-and-parent-objects","page":"Generic fraction fields","title":"Types and parent objects","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fractions implemented using the AbstractAlgebra generics have type Generic.Frac{T} where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Parent objects of such fraction elements have type Generic.FracField{T}.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The fraction element types belong to the abstract type AbstractAlgebra.FracElem{T} and the fraction field types belong to the abstract type AbstractAlgebra.FracRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra fraction type.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Note that both the generic fraction field type Generic.FracField{T} and the abstract type it belongs to, AbstractAlgebra.FracField{T} are both called FracField. The former is a (parameterised) concrete type for a fraction field over a given base ring whose elements have type T. The latter is an abstract type representing all fraction field types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"fraction/#Fraction-field-constructors","page":"Generic fraction fields","title":"Fraction field constructors","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"In order to construct fractions in AbstractAlgebra.jl, one can first construct the fraction field itself. This is accomplished with the following constructor.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"FractionField(R::AbstractAlgebra.Ring; cached::Bool = true)","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Given a base ring R return the parent object of the fraction field of R. By default the parent object S will depend only on R and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Here are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into the fraction field.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Integers\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"All of the examples here are generic fraction fields, but specialised implementations of fraction fields provided by external modules will also usually provide a FractionField constructor to allow creation of the fraction fields they provide.","category":"page"},{"location":"fraction/#Basic-field-functionality","page":"Generic fraction fields","title":"Basic field functionality","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fraction fields in AbstractAlgebra.jl implement the full Field interface. Of course the entire Fraction Field interface is also implemented.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"We give some examples of such functionality.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> m = characteristic(S)\n0\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> V = base_ring(f)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> T = parent(f)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1\n","category":"page"},{"location":"fraction/#Fraction-field-functionality-provided-by-AbstractAlgebra.jl","page":"Generic fraction fields","title":"Fraction field functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any fraction field module that implements the full Fraction Field interface. This includes AbstractAlgebra.jl's own generic fraction fields.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"But if a C library provides all the functionality documented in the Fraction Field interface, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that fraction field type.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Of course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"fraction/#Greatest-common-divisor","page":"Generic fraction fields","title":"Greatest common divisor","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"gcd{T <: RingElem}(::FracElem{T}, ::FracElem{T})","category":"page"},{"location":"fraction/#Base.gcd-Union{Tuple{T}, Tuple{FracElem{T},FracElem{T}}} where T<:RingElem","page":"Generic fraction fields","title":"Base.gcd","text":"gcd(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T}) where {T <: RingElem}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"page"},{"location":"fraction/#Square-root","page":"Generic fraction fields","title":"Square root","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"issquare{T <: RingElem}(::FracElem{T})","category":"page"},{"location":"fraction/#AbstractAlgebra.Generic.issquare-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"AbstractAlgebra.Generic.issquare","text":"issquare(a::AbstractAlgebra.FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Base.sqrt(::FracElem{T}) where {T <: RingElem}","category":"page"},{"location":"fraction/#Base.sqrt-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"Base.sqrt","text":"Base.sqrt(a::AbstractAlgebra.FracElem{T}) where T <: RingElem\n\nReturn the square root of a if it is a square, otherwise raise an exception.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> issquare(a^2)\ntrue","category":"page"},{"location":"fraction/#Remove-and-valuation","page":"Generic fraction fields","title":"Remove and valuation","text":"","category":"section"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"When working over a Euclidean domain, it is convenient to extend valuations to the fraction field. To facilitate this, we define the following functions.","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"remove{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"fraction/#AbstractAlgebra.Generic.remove-Union{Tuple{T}, Tuple{FracElem{T},T}} where T<:RingElem","page":"Generic fraction fields","title":"AbstractAlgebra.Generic.remove","text":"remove(z::AbstractAlgebra.FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the tuple n x such that z = p^nx where x has valuation 0 at p.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"valuation{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"fraction/#AbstractAlgebra.Generic.valuation-Union{Tuple{T}, Tuple{FracElem{T},T}} where T<:RingElem","page":"Generic fraction fields","title":"AbstractAlgebra.Generic.valuation","text":"valuation(z::AbstractAlgebra.FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the valuation of z at p.\n\n\n\n","category":"method"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 1)//(x^2 + x + 1)\n(x^2 + 1)//(x^2 + x + 1)\n\njulia> v, q = remove(f^3*g, x + 1)\n(3, (x^2 + 1)//(x^11 + x^10 + 10*x^9 + 12*x^8 + 39*x^7 + 48*x^6 + 75*x^5 + 75*x^4 + 66*x^3 + 37*x^2 + 10*x + 1))\n\njulia> v = valuation(f^3*g, x + 1)\n3\n","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"map_with_inverse/#Map-with-inverse","page":"Map with inverse","title":"Map with inverse","text":"","category":"section"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"It is not possible to provide generic functionality to invert a map. However, sometimes one knows an inverse map explicitly and would like to keep track of this.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Recall that as map composition is not commutative, there is a notion of a left inverse and a right inverse for maps.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To keep track of such inverse maps, AbstractAlgebra provides data types Generic.MapWithRetraction and Generic.MapWithSection.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Given a map f  X to Y, a retraction of f is a map g  Y to X such that g(f(x)) = x for all x in X.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Given a map f  X to Y, a section of f is a map g  Y to X such that f(g(x)) = x for all y in Y.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"In AbstractAlgebra, a map with retraction/section is an object containing a pair of maps, the second of which is a retraction/section of the first.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Maps with retraction/section can be composed, and we also define the inverse of such a pair to be the map with the pair swapped. Thus the inverse of a map with retraction is a map with section.","category":"page"},{"location":"map_with_inverse/#Map-with-inverse-constructors","page":"Map with inverse","title":"Map with inverse constructors","text":"","category":"section"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To construct a map with retraction/section from a pair of maps, we have the following functions:","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"map_with_retraction(m::Map{D, C}, r::Map{C, D}) where {D, C}\nmap_with_section(m::Map{D, C}, s::Map{C, D}) where {D, C}","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Construct the map with retraction/section given a known retraction/section r or s respectively, of m.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"For convenience we allow construction of maps with retraction/section from a pair of Julia functions/closures.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"map_with_retraction_from_func(f::Function, r::Function, R, S)\nmap_with_section_from_func(f::Function, s::Function, R, S)","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Construct the map with retraction/section such that the map is given by the function f and the retraction/section is given by the function r or s respectively. Here R is the parent object representing the domain and S is the parent object representing the codomain of f.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Examples","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"julia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> a = f(ZZ(1))\n2","category":"page"},{"location":"map_with_inverse/#Functionality-for-maps-with-inverses","page":"Map with inverse","title":"Functionality for maps with inverses","text":"","category":"section"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"The following functionality is provided for maps with inverses.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"inv(M::MapWithRetraction)\ninv(M::MapWithSection)","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Return the map with the two maps contained in M swapped. In the first case, a MapWithSection is returned. In the second case a MapWithRetraction is returned.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To access the two maps stored in a map with retraction/section, we have the following:","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"image_map(M::MapWithRetraction)\nimage_map(M::MapWithSection)\nretraction_map(M::MapWithRetraction)\nsection_map(M::MapWithSection)","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"The first two of these functions return the first map in a map with retraction/section, the second two functions return the corresponding second maps.","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Examples","category":"page"},{"location":"map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"julia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> g = inv(f)\nMap with section with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> h = f*g\nComposite map consisting of the following\n\nIntegers -> Integers\nthen\nIntegers -> Integers\n\njulia> a = h(ZZ(1))\n1\n","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"finfield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/GF.jl for finite fields. The module is a naive implementation that supports only fields of degree 1 (prime fields). They are modelled as mathbbZpmathbbZ for p a prime.","category":"page"},{"location":"finfield/#Types-and-parent-objects","page":"Finite fields","title":"Types and parent objects","text":"","category":"section"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Finite fields have type GFField{T} where T is either Int or BigInt.","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Elements of such a finite field have type GFElem{T}.","category":"page"},{"location":"finfield/#Finite-field-constructors","page":"Finite fields","title":"Finite field constructors","text":"","category":"section"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"In order to construct finite fields in AbstractAlgebra.jl, one must first construct the field itself. This is accomplished with the following constructors.","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"GF(p::T) where T <: Integer","category":"page"},{"location":"finfield/#AbstractAlgebra.GF-Tuple{T} where T<:Integer","page":"Finite fields","title":"AbstractAlgebra.GF","text":"GF(p::T; check::Bool=true) where T <: Integer\n\nReturn the finite field mathbbF_p, where p is a prime. By default, the integer p is checked with a probabilistic algorithm for primality. When check == false, no check is made, but the behaviour of the resulting object is undefined if p is composite.\n\n\n\n","category":"method"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Here are some examples of creating a finite field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> g = F(3)\n3\n\njulia> h = F(g)\n3\n\njulia> GF(4)\nERROR: DomainError with 4:\nCharacteristic is not prime in GF(p)\nStacktrace:\n[...]","category":"page"},{"location":"finfield/#Basic-field-functionality","page":"Finite fields","title":"Basic field functionality","text":"","category":"section"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"The finite field module in AbstractAlgebra.jl implements the full Field interface.","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"We give some examples of such functionality.","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> f = F(7)\n7\n\njulia> h = zero(F)\n0\n\njulia> k = one(F)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(h)\ntrue\n\njulia> T = parent(h)\nFinite field F_13\n\njulia> h == deepcopy(h)\ntrue\n\njulia> h = h + 2\n2\n\njulia> m = inv(k)\n1\n","category":"page"},{"location":"finfield/#Basic-manipulation-of-fields-and-elements","page":"Finite fields","title":"Basic manipulation of fields and elements","text":"","category":"section"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"gen{T <: Integer}(F::GFField{T})","category":"page"},{"location":"finfield/#AbstractAlgebra.gen-Union{Tuple{AbstractAlgebra.GFField{T}}, Tuple{T}} where T<:Integer","page":"Finite fields","title":"AbstractAlgebra.gen","text":"gen(R::GFField{T}) where T <: Integer\n\nReturn a generator of the field. Currently this returns 1.\n\n\n\n","category":"method"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"order(F::GFField)","category":"page"},{"location":"finfield/#AbstractAlgebra.Generic.order-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"AbstractAlgebra.Generic.order","text":"order(R::GFField)\n\nReturn the order, i.e. the number of element in the given finite field.\n\n\n\n","category":"method"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"degree(F::GFField)","category":"page"},{"location":"finfield/#AbstractAlgebra.Generic.degree-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"AbstractAlgebra.Generic.degree","text":"degree(R::GFField)\n\nReturn the degree of the given finite field.\n\n\n\n","category":"method"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> d = degree(F)\n1\n\njulia> n = order(F)\n13\n\njulia> g = gen(F)\n1\n","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"functional_map/#Functional-maps","page":"Functional maps","title":"Functional maps","text":"","category":"section"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"A functional map in AbstractAlgebra is a map which can be applied by evaluating a Julia function or closure. It is represented by a map object that contains such a function/closure, usually in a field called image_fn.","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"All functional maps belong to the map class AbstractAlgebra.FunctionalMap.","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"A generic concrete type Generic.FunctionalMap is provided by the Generic module to implement a generic functional map type. This allows for functional maps that contain no extra data, other than a Julia function/closure.","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Custom map types can also be defined which have map class AbstractAlgebra.FunctionalMap.","category":"page"},{"location":"functional_map/#Functional-map-interface","page":"Functional maps","title":"Functional map interface","text":"","category":"section"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"All functional map types must define their supertypes as in the following example:","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"mutable struct MyFunctionalMap{D, C} <: Map{D, C, FunctionalMap, MyFunctionalMap}\n   # some fields\n   image_fn::Function\nend","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Of course MyFunctionalMap need not be parameterised if the types D and C of the domain and codomain objects are known.","category":"page"},{"location":"functional_map/#Required-functions-for-functional-maps","page":"Functional maps","title":"Required functions for functional maps","text":"","category":"section"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"The following functions must be defined for all functional map types or classes:","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"image_fn(M::Map(MyFunctionalMap))","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Return the Julia function or closure that corresponds to application of the map M. This function only needs to be provided if this function is not stored in an image_fn field of the MyFunctionalMap type.","category":"page"},{"location":"functional_map/#Generic-functional-maps","page":"Functional maps","title":"Generic functional maps","text":"","category":"section"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"The Generic module provides a concrete type FunctionalMap which merely keeps track of a Julia function/closure implementing the map.","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Such maps can be constructed using the following function:","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"map_from_func(f::Function, R, S)","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Construct the generic functional map with domain and codomain given by the parent objects R and S corresponding to the Julia function f.","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"Examples","category":"page"},{"location":"functional_map/","page":"Functional maps","title":"Functional maps","text":"julia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> f(ZZ(2))\n3","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"series/#Generic-power-series","page":"Generic power series","title":"Generic power series","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"AbstractAlgebra.jl allows the creation of capped relative and absolute power series over any computable commutative ring R.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where a_j in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"There are two implementations of relative series: relative power series, implemented in src/generic/RelSeries.jl for which j  0 in the above description, and Laurent series where j can be negative, implemented in src/generic/Laurent.jl. Note that there are two implementations for Laurent series, one over rings and one over fields, though in practice most of the implementation uses the same code in both cases.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"There is a single implementation of absolute series: absolute power series, implemented in src/generic/AbsSeries.jl.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"As well as implementing the Series Ring interface, the series modules in AbstractAlgebra.jl implement the generic algorithms described below.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.","category":"page"},{"location":"series/#Types-and-parent-objects","page":"Generic power series","title":"Types and parent objects","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The types of generic series implemented by AbstractAlgebra.jl are Generic.RelSeries{T}, Generic.AbsSeries{T}, Generic.LaurentSeriesRingElem{T} and Generic.LaurentSeriesFieldElem{T}.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Relative power series elements belong to the abstract type AbstractAlgebra.RelSeriesElem.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Laurent series elements belong directly to either AbstractAlgebra.RingElem or AbstractAlgebra.FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are relative series.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Absolute power series elements belong to AbstractAlgebra.AbsSeriesElem.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The parent types for relative and absolute power series, Generic.RelSeriesRing{T} and Generic.AbsSeriesRing{T} respectively, belong to AbstractAlgebra.SeriesRing{T}.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The parent types for Laurent series rings and fields, Generic.LaurentSeriesRing{T} and Generic.LaurentSeriesField{T} respectively, belong directly to AbstractAlgebra.Ring and AbstractAlgebra.Field respectively.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The default precision, string representation of the variable and base ring R of a generic power series are stored in its parent object.","category":"page"},{"location":"series/#Series-ring-constructors","page":"Generic power series","title":"Series ring constructors","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"In order to construct series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"PowerSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true, model=:capped_relative)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"LaurentSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"LaurentSeriesRing(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Given a base ring R, a maximum precision (relative or absolute, depending on the model) and a string s specifying how the generator (variable) should be printed, return a typle S, x representing the series ring and its generator.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"In the case of power series, the optional argument model can be set to either :capped_absolute or capped_relative, depending on which power series model is required.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Here are some examples of constructing various kinds of series rings and coercing various elements into those rings.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> S, y = PowerSeriesRing(ZZ, 10, \"y\"; model=:capped_absolute)\n(Univariate power series ring in y over Integers, y + O(y^10))\n\njulia> T, z = LaurentSeriesRing(ZZ, 10, \"z\")\n(Laurent series ring in z over Integers, z + O(z^11))\n\njulia> U, w = LaurentSeriesField(QQ, 10, \"w\")\n(Laurent series field in w over Rationals, w + O(w^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = U(BigInt(1234))\n1234 + O(w^10)\n\njulia> k = T(z + 1)\n1 + z + O(z^10)\n","category":"page"},{"location":"series/#Big-oh-notation","page":"Generic power series","title":"Big-oh notation","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"O(x::SeriesElem)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> S, y = LaurentSeriesRing(ZZ, 10, \"y\")\n(Laurent series ring in y over Integers, y + O(y^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2y + 7y^2 + O(y^7)\n2*y + 7*y^2 + O(y^7)\n","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"series/#Power-series-models","page":"Generic power series","title":"Power series models","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Similar comments apply to Laurent series.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"On the other hand, capped absolute power series have their absolute precision capped. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form c_ax^a + c_a+1x^a+1 + ldots + O(x^b).","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Capped absolute series are additively stable, but not necessarily multiplicatively stable.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"For all models, the maximum precision is also used as a default precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"In all models we say that two power series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"An absolute power series ring over a ring R with precision p behaves very much like the quotient Rx(x^p) of the polynomial ring over R. Therefore one can often treat absolute power series rings as though they were rings. However, this depends on all series being given a precision equal to the specified maximum precision and not a lower precision.","category":"page"},{"location":"series/#Basic-ring-functionality","page":"Generic power series","title":"Basic ring functionality","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"All power series models provide the functionality described in the Ring and Series Ring interfaces.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> S, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x + x^2 + O(x^10)\n1 + 2*x + x^2 + O(x^10)\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = pol_length(f)\n4\n\njulia> c = polcoeff(f, 3)\n1\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> T = parent(x + 1)\nUnivariate power series ring in x over Integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x + x^2 + O(x^10)\n\njulia> p = precision(f)\n10\n","category":"page"},{"location":"series/#Series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic power series","title":"Series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"The functionality below is automatically provided by AbstractAlgebra.jl for any series module that implements the full Series Ring interface. This includes AbstractAlgebra's own generic series rings.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Unless otherwise noted, the functions are available for all series models, including Laurent series. We denote this by using the abstract type AbstractAlgebra.RelSeriesElem, even though absolute series and Laurent series types do not belong to this abstract type.","category":"page"},{"location":"series/#Basic-functionality","page":"Generic power series","title":"Basic functionality","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"coeff(a::AbstractAlgebra.SeriesElem, n::Int)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Return the degree n coefficient of the given power series. Note coefficients are numbered from n = 0 for the constant coefficient. If n exceeds the current precision of the power series, the function returns a zero coefficient.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"For power series types, n must be non-negative. Laurent series do not have this restriction.","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"modulus{T <: ResElem}(::SeriesElem{T})","category":"page"},{"location":"series/#AbstractAlgebra.Generic.modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:ResElem","page":"Generic power series","title":"AbstractAlgebra.Generic.modulus","text":"modulus(a::AbstractAlgebra.SeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given power series.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"isgen(::RelSeriesElem)","category":"page"},{"location":"series/#AbstractAlgebra.isgen-Tuple{RelSeriesElem}","page":"Generic power series","title":"AbstractAlgebra.isgen","text":"isgen(a::AbstractAlgebra.RelSeriesElem)\n\nReturn true if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return false.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"isunit(::RelSeriesElem)","category":"page"},{"location":"series/#AbstractAlgebra.isunit-Tuple{RelSeriesElem}","page":"Generic power series","title":"AbstractAlgebra.isunit","text":"isunit(a::AbstractAlgebra.RelSeriesElem)\n\nReturn true if the given power series is arithmetically equal to a unit, i.e. is invertible, otherwise return false.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, t = PowerSeriesRing(QQ, 10, \"t\")\n(Univariate power series ring in t over Rationals, t + O(t^11))\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate power series ring in t over Rationals, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = isgen(gen(R))\ntrue\n\njulia> m = isunit(-1 + x + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4\n\njulia> p = valuation(b)\n1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n","category":"page"},{"location":"series/#Shifting","page":"Generic power series","title":"Shifting","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"shift_left{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"series/#AbstractAlgebra.Generic.shift_left-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T<:RingElem","page":"Generic power series","title":"AbstractAlgebra.Generic.shift_left","text":"shift_left(x::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T <: RingElement}\n\nReturn the power series x shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"shift_right{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"series/#AbstractAlgebra.Generic.shift_right-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T<:RingElem","page":"Generic power series","title":"AbstractAlgebra.Generic.shift_right","text":"shift_right(x::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T <: RingElement}\n\nReturn the power series x shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = shift_left(a, 2)\n2*x^3 + x^5 + O(x^33)\n\njulia> g = shift_left(b, 2)\nO(x^6)\n\njulia> h = shift_right(c, 1)\n1 + 2*x + O(x^4)\n\njulia> k = shift_right(d, 3)\n1 + O(x^1)\n","category":"page"},{"location":"series/#Truncation","page":"Generic power series","title":"Truncation","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"truncate{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"series/#Base.truncate-Union{Tuple{T}, Tuple{RelSeriesElem{T},Int64}} where T<:RingElem","page":"Generic power series","title":"Base.truncate","text":"truncate(a::AbstractAlgebra.RelSeriesElem{T}, n::Int) where {T <: RingElement}\n\nReturn a truncated to (absolute) precision n.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = truncate(a, 3)\n2*x + O(x^3)\n\njulia> g = truncate(b, 2)\nO(x^2)\n\njulia> h = truncate(c, 7)\n1 + x + 2*x^2 + O(x^5)\n\njulia> k = truncate(d, 5)\n2*x + x^3 + O(x^4)\n","category":"page"},{"location":"series/#Division","page":"Generic power series","title":"Division","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Base.inv(::RelSeriesElem)","category":"page"},{"location":"series/#Base.inv-Tuple{RelSeriesElem}","page":"Generic power series","title":"Base.inv","text":"Base.inv(a::AbstractAlgebra.RelSeriesElem)\n\nReturn the inverse of the power series a, i.e. 1a.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = S(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"series/#Derivative-and-integral","page":"Generic power series","title":"Derivative and integral","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"derivative(a::RelSeriesElem)","category":"page"},{"location":"series/#AbstractAlgebra.Generic.derivative-Tuple{RelSeriesElem}","page":"Generic power series","title":"AbstractAlgebra.Generic.derivative","text":"derivative(f::AbstractAlgebra.MPolyElem{T}, x::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\nderivative(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the derivative of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\nderivative(f::AbsSeriesElem{T}) -> AbsSeriesElem\n\nReturn the derivative of the power series f.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"integral(a::RelSeriesElem)","category":"page"},{"location":"series/#AbstractAlgebra.Generic.integral-Tuple{RelSeriesElem}","page":"Generic power series","title":"AbstractAlgebra.Generic.integral","text":"integral(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the integral of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\nintegral(f::AbsSeriesElem{T}) -> AbsSeriesElem\n\nReturn the integral of the power series f.\n\n\n\n","category":"method"},{"location":"series/#Special-functions","page":"Generic power series","title":"Special functions","text":"","category":"section"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Base.log(a::SeriesElem)","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Base.exp(a::RelSeriesElem)","category":"page"},{"location":"series/#Base.exp-Tuple{RelSeriesElem}","page":"Generic power series","title":"Base.exp","text":"exp(a::AbstractAlgebra.RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::AbstractAlgebra.AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Base.sqrt(a::RelSeriesElem)","category":"page"},{"location":"series/#Base.sqrt-Tuple{RelSeriesElem}","page":"Generic power series","title":"Base.sqrt","text":"sqrt(a::AbstractAlgebra.RelSeriesElem)\n\nReturn the square root of the power series a.\n\n\n\n","category":"method"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"Examples","category":"page"},{"location":"series/","page":"Generic power series","title":"Generic power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> T, z = PowerSeriesRing(QQ, 30, \"z\")\n(Univariate power series ring in z over Rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> log(exp(b)) == b\ntrue\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"matrix_algebras/#Generic-matrix-algebras","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"AbstractAlgebra.jl allows the creation of an algebra (ring) of mtimes m matrices over a computable, commutative ring.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Functions specific to generic matrix algebras of mtimes m matrices are implemented in src/generic/MatrixAlgebra.jl. The remaining functionality is in the file src/generic/Matrix.jl.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as implementing the entire Matrix interface, including the optional functionality, there are many additional generic algorithms implemented for matrix algebras.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Almost all of the functionality specified for generic matrices is available for matrix algebras. The exceptions are functions such as solve and nullspace which may return non-square matrices, or which don't accept square matrices.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default, so it is not necessary to qualify names of functions.","category":"page"},{"location":"matrix_algebras/#Types-and-parent-objects","page":"Generic matrix algebras","title":"Types and parent objects","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatAlgElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Parents of generic matrices in a matrix algebra have type Generic.MatAlgebra{T}.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Note that matrix algebras are noncommutative rings. Thus their types belong to NCRing and NCRingElem. They cannot be used in constructions which require a commutative ring (Ring and RingElem respectively).","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The generic matrix algebra matrix types belong to the abstract type AbstractAlgebra.MatAlgElem{T} and the parent types belong to  AbstractAlgebra.MatAlgebra{T} Note that both of these require disambiguation from the concrete types in Generic of the same name.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The degree and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"matrix_algebras/#Matrix-algebra-constructors","page":"Generic matrix algebras","title":"Matrix algebra constructors","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"A matrix algebra in AbstractAlgebra.jl represents a collection of all matrices with given degree and base ring.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In order to construct matrices in AbstractAlgebra.jl, one must construct the matrix algebra itself. This is accomplished with the following constructor.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"MatrixAlgebra(R::Ring, degree::Int; cache::Bool=true)","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Construct the algebra of matrices with the given degree over the given base ring. By default such matrix spaces are cached based on the base ring and degree. If the optional named parameter cached is set to false, no caching occurs.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Here are some examples of creating matrix algebras and making use of the resulting parent objects to coerce various elements into the matrix algebra.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixAlgebra(R, 3)\nMatrix Algebra of degree 3 over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"matrix_algebras/#Matrix-algebra-element-constructors","page":"Generic matrix algebras","title":"Matrix algebra element constructors","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The following additional constructors are provided for constructing various kinds of matrices in a matrix algebra.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"zero(::MatAlgebra)","category":"page"},{"location":"matrix_algebras/#Base.zero-Tuple{MatAlgebra}","page":"Generic matrix algebras","title":"Base.zero","text":"zero(a::AbstractAlgebra.MatAlgebra)\n\nConstruct the zero matrix in the given matrix algebra.\n\n\n\n","category":"method"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"identity_matrix(::Generic.MatAlgElem{T}) where T <: RingElement","category":"page"},{"location":"matrix_algebras/#AbstractAlgebra.Generic.identity_matrix-Union{Tuple{AbstractAlgebra.Generic.MatAlgElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic matrix algebras","title":"AbstractAlgebra.Generic.identity_matrix","text":"identity_matrix(M::MatAlgElem{T}) where T <: RingElement\n\nReturn the identity matrix over the same base ring as M and with the same dimensions.\n\n\n\n","category":"method"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"S = MatrixAlgebra(ZZ, 2)\nM = zero(S)\n\nP = identity_matrix(M)","category":"page"},{"location":"matrix_algebras/#Matrix-algebra-functionality-provided-by-AbstractAlgebra.jl","page":"Generic matrix algebras","title":"Matrix algebra functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Most of the generic matrix functionality described in the generic matrix section of the documentation is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In addition to the functionality described for matrix spaces, matrix algebras support all noncommutative ring operations, and matrix algebras can be used as a base ring for other generic constructs that accept a noncommutative base ring (NCRing).","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In this section we describe functionality provided for matrix algebras only.","category":"page"},{"location":"matrix_algebras/#Basic-matrix-functionality","page":"Generic matrix algebras","title":"Basic matrix functionality","text":"","category":"section"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices.","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"degree(::Generic.MatAlgElem)","category":"page"},{"location":"matrix_algebras/#AbstractAlgebra.Generic.degree-Tuple{AbstractAlgebra.Generic.MatAlgElem}","page":"Generic matrix algebras","title":"AbstractAlgebra.Generic.degree","text":"degree(a::Generic.MatAlgElem)\n\nReturn the degree n of the ntimes n matrix a..\n\n\n\n","category":"method"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixAlgebra(R, 3)\nMatrix Algebra of degree 3 over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> n = degree(A)\n3\n","category":"page"},{"location":"ncrings/#Noncommutative-ring-Interface","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all noncommutative rings. Here we document this interface.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their noncommutative rings.","category":"page"},{"location":"ncrings/#Types","page":"Noncommutative ring Interface","title":"Types","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Most noncommutative rings must supply two types:","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"a type for the parent object (representing the ring itself)\na type for elements of that ring","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The parent type must belong to AbstractAlgebra.NCRing and the element type must belong to AbstractAlgebra.NCRingElem. Of course, the types may belong to these abstract types transitively via an intermediate abstract type.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For parameterised rings, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring (see the function base_ring below for a definition).","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"page"},{"location":"ncrings/#NCRingElement-type-union","page":"Noncommutative ring Interface","title":"NCRingElement type union","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to AbstractAlgebra.NCRingElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of rings we define a union type AbstractAlgebra.NCRingElement in src/julia/JuliaTypes.jl.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"So far, in addition to AbstractAlgebra.NCRingElem the  union type AbstractAlgebra.NCRingElement includes the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Most of the generic code in AbstractAlgebra for general rings makes use of the union type AbstractAlgebra.NCRingElement instead of AbstractAlgebra.NCRingElem so that the generic functions also accept the Julia Base ring types.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"One must be careful when defining ad hoc binary operations for ring element types. It is often necessary to define separate versions of the functions for AbstractAlgebra.NCRingElem then for each of the Julia types separately in order to avoid ambiguity warnings.","category":"page"},{"location":"ncrings/#Parent-object-caches","page":"Noncommutative ring Interface","title":"Parent object caches","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In many cases, it is desirable to have only one object in the system to represent each ring. This means that if the same ring is constructed twice, elements of the two rings will be compatible as far as arithmetic is concerned.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In order to facilitate this, global caches of rings are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.PolyRing parent objects are looked up in a dictionary PolyID to see if they have been previously defined.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two rings are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two rings if they were constructed from identical data.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl` for examples of how to construct and handle such caches.","category":"page"},{"location":"ncrings/#Required-functions-for-all-rings","page":"Noncommutative ring Interface","title":"Required functions for all rings","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In the following, we list all the functions that are required to be provided for noncommutative rings in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"We give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Note that generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for rings that implement that additional functionality, and should be documented as such.","category":"page"},{"location":"ncrings/#Data-type-and-parent-object-methods","page":"Noncommutative ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"parent_type(::Type{MyElem})","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the type of the corresponding parent object for the given element type. For example, parent_type(Generic.Poly{T}) will return Generic.PolyRing{T}.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"elem_type(::Type{MyParent})","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the type of the elements of the ring whose parent object has the given type. This is the inverse of the parent_type function, i.e. elem_type(Generic.PolyRing{T}) will return Generic.Poly{T}.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"base_ring(R::MyParent)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Given a parent object R, representing a ring, this function returns the parent object of any base ring that parameterises this ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If the ring is not parameterised by another ring, this function must return Union{}.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"parent(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the parent object of the given element, i.e. return the ring to which the given element belongs.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"This is usually stored in a field parent in each ring element. (If the parent objects have mutable struct types, the internal overhead here is just an additional machine pointer stored in each element of the ring.)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For some element types it isn't necessary to append the parent object as a field of every element. This is the case when the parent object can be reconstructed just given the type of the elements. For example, this is the case for the ring of integers and in fact for any ring element type that isn't parameterised or generic in any way.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isexact_type(::Type{MyElem})","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return true if every element of the given type is represented exactly.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Note that MyElem may be parameterised or an abstract type, in which case every element of every type represented by MyElem must be exact, otherwise the function must return false.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Base.hash(f::MyElem, h::UInt)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return a hash for the object f of type UInt. This is used as a hopefully cheap way to distinguish objects that differ arithmetically.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If the object has components, e.g. the coefficients of a polynomial or elements of a matrix, these should be hashed recursively, passing the same parameter h to all levels. Each component should then be xor'd with h before combining the individual component hashes to give the final hash.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The hash functions in AbstractAlgebra.jl usually start from some fixed 64 bit hexadecimal  value that has been picked at random by the library author for that type. That is then truncated to fit a UInt (in case the latter is not 64 bits). This ensures that objects that are the same arithmetically (or that have the same components), but have different types (or structures), are unlikely to hash to the same value.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"deepcopy_internal(f::MyElem, dict::ObjectIdDict)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return a copy of the given element, recursively copying all components of the object.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Obviously the parent, if it is stored in the element, should not be copied. The new element should have precisely the same parent as the old object.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For types that cannot self-reference themselves anywhere internally, the dict argument may be ignored.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In the case that internal self-references are possible, please consult the Julia documentation on how to implement deepcopy_internal.","category":"page"},{"location":"ncrings/#Constructors","page":"Noncommutative ring Interface","title":"Constructors","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Outer constructors for most AbstractAlgebra types are provided by overloading the call syntax for parent objects.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If R is a parent object for a given ring we provide the following constructors.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"(R::MyParent)()","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the zero object of the given ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"(R::MyParent)(a::Integer)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Coerce the given integer into the given ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"(R::MyParent)(a::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If a belongs to the given ring, the function returns it (without making a copy). Otherwise an error is thrown.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For parameterised rings we also require a function to coerce from the base ring into the parent ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"(R::MyParent{T})(a::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Coerce a into the ring R if a belongs to the base ring of R.","category":"page"},{"location":"ncrings/#Basic-manipulation-of-rings-and-elements","page":"Noncommutative ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"zero(R::MyParent)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the zero element of the given ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"one(R::MyParent)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the multiplicative identity of the given ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"iszero(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return true if the given element is the zero element of the ring it belongs to.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isone(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return true if the given element is the multiplicative identity of the ring it belongs to.","category":"page"},{"location":"ncrings/#String-I/O","page":"Noncommutative ring Interface","title":"String I/O","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"show(io::IO, R::MyParent)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"This should print (to the given IO object), an English description of the parent ring. If the ring is parameterised, it can call the corresponding show function for any rings it depends on.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"show(io::IO, f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"This should print a human readable, textual representation of the object (to the given IO object). It can recursively call the corresponding show functions for any of its components.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"note: Note\nThe functionality of the function needs_parentheses has been replaced by expressify and needs_parentheses will be removed in future versions.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"It may be necessary in some cases to print parentheses around components of f or to print signs of components. For these, the following functions will exist for each component or component type.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"needs_parentheses(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Should returns true if parentheses are needed around this object when printed, e.g. as a coefficient of a polynomial. As an example, non-constant polynomials would need such parentheses if used as coefficients of another polynomial.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Note that since this approach quickly leads to unnecessary parentheses, the expression method below is preferred.","category":"page"},{"location":"ncrings/#Expressions","page":"Noncommutative ring Interface","title":"Expressions","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"To obtain best results when printing composed types derived from other types, e.g., polynomials, the following method should be implemented.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"expressify(f::MyElem; context = nothing)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For more information about expressify, please refer to the \"Ring Interface\" section.","category":"page"},{"location":"ncrings/#Unary-operations","page":"Noncommutative ring Interface","title":"Unary operations","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"-(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return -f.","category":"page"},{"location":"ncrings/#Binary-operations","page":"Noncommutative ring Interface","title":"Binary operations","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"+(f::MyElem, g::MyElem)\n-(f::MyElem, g::MyElem)\n*(f::MyElem, g::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return f + g, f - g or fg, respectively.","category":"page"},{"location":"ncrings/#Comparison","page":"Noncommutative ring Interface","title":"Comparison","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"==(f::MyElem, g::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return true if f and g are arithmetically equal. In the case where the two elements are inexact, the function returns true if they agree to the minimum precision of the two.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isequal(f::MyElem, g::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For exact rings, this should return the same thing as == above. For inexact rings, this returns true only if the two elements are arithmetically equal and have the same precision.","category":"page"},{"location":"ncrings/#Powering","page":"Noncommutative ring Interface","title":"Powering","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"^(f::MyElem, e::Int)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return f^e. The function should throw a DomainError() if negative exponents don't make sense but are passed to the function.","category":"page"},{"location":"ncrings/#Exact-division","page":"Noncommutative ring Interface","title":"Exact division","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"divexact_left(f::MyElem, g::MyElem)\ndivexact_right(f::MyElem, g::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If f = ga for some a in the ring, the function divexact_left(f, g) returns a. If f = ag then divexact_right(f, g) returns a. A DivideError() should be thrown if division is by zero. If no exact quotient exists or an impossible inverse is unavoidably encountered, an error should be thrown.","category":"page"},{"location":"ncrings/#Unsafe-operators","page":"Noncommutative ring Interface","title":"Unsafe operators","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"To speed up arithmetic of objects built over a given ring, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don't have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Note the exclamation point is a convention, which indicates that the object may be mutated in-place.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The results of deepcopy and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Note that R(a) where R is the ring a belongs to, does not create a new value. For this case, use deepcopy(a).","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"zero!(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Set the value f to zero in place. Return the mutated value.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"mul!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Set c to the value ab in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"add!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Set c to the value a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"addeq!(a::MyElem, b::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Set a to a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"ncrings/#Random-generation","page":"Noncommutative ring Interface","title":"Random generation","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The random functions are only used for test code to generate test data. They therefore don't need to provide any guarantees on uniformity, and in fact, test values that are known to be a good source of corner cases can be supplied.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"rand(R::MyParent, v...)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return a random element in the given ring of the specified size.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"There can be as many arguments as is necessary to specify the size of the test example which is being produced.","category":"page"},{"location":"ncrings/#Promotion-rules","page":"Noncommutative ring Interface","title":"Promotion rules","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In order for AbstractAlgebra to be able to automatically coerce up towers of rings, certain promotion rules must be defined. For every ring, one wants to be able to coerce integers into the ring. And for any ring constructed over a base ring, one would like to be able to coerce from the base ring into the ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The promotion rules look a bit different depending on whether the element type is parameterised or not and whether it is built on a base ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For ring element types MyElem that are neither parameterised nor built over a base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) where {T <: Integer} = MyElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For ring element types MyType that aren't parameterised, but which have a base ring with concrete element type T the promotion rules can be defined as follows:","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{U}) where U <: Integer = MyElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) = MyElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For ring element types MyElem{T} that are parameterised by the type of elements of the base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"promote_rule(::Type{MyElem{T}}, ::Type{MyElem{T}}) where T <: RingElement = MyElem{T}","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"function promote_rule(::Type{MyElem{T}}, ::Type{U}) where {T <: RingElement, U <: RingEle\nment}\n   promote_rule(T, U) == T ? MyElem{T} : Union{}\nend","category":"page"},{"location":"ncrings/#Required-functionality-for-inexact-rings","page":"Noncommutative ring Interface","title":"Required functionality for inexact rings","text":"","category":"section"},{"location":"ncrings/#Approximation-(floating-point-and-ball-arithmetic-only)","page":"Noncommutative ring Interface","title":"Approximation (floating point and ball arithmetic only)","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isapprox(f::MyElem, g::MyElem; atol::Real=sqrt(eps()))","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"This is used by test code that uses rings involving floating point or ball arithmetic. The function should return true if all components of f and g are equal to within the square root of the Julia epsilon, since numerical noise may make an exact comparison impossible.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For parameterised rings over an inexact ring, we also require the following ad hoc approximation functionality.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isapprox(f::MyElem{T}, g::T; atol::Real=sqrt(eps())) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isapprox(f::T, g::MyElem{T}; atol::Real=sqrt(eps())) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"These notionally coerce the element of the base ring into the parameterised ring and do a full comparison.","category":"page"},{"location":"ncrings/#Optional-functionality","page":"Noncommutative ring Interface","title":"Optional functionality","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Some functionality is difficult or impossible to implement for all rings in the system. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can't be relied on by generic functions in the AbstractAlgebra Ring interface.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"It may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn't exist.","category":"page"},{"location":"ncrings/#Optional-basic-manipulation-functionality","page":"Noncommutative ring Interface","title":"Optional basic manipulation functionality","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"isunit(f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return true if the given element is a unit in the ring it belongs to.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"characteristic(R::MyParent)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Return the characteristic of the ring R or -1 if this is unknown or cannot be computed efficiently. Defining this function may speed up some code paths, as more efficient algorithms exist for certain characteristics but are invalid for others.","category":"page"},{"location":"ncrings/#Optional-binary-ad-hoc-operators","page":"Noncommutative ring Interface","title":"Optional binary ad hoc operators","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"By default, ad hoc operations are handled by AbstractAlgebra.jl if they are not defined explicitly, by coercing both operands into the same ring and then performing the required operation.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In some cases, e.g. for matrices, this leads to very inefficient behaviour. In such cases, it is advised to implement some of these operators explicitly.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"It can occasionally be worth adding a separate set of ad hoc binary operators for the type Int, if this can be done more efficiently than for arbitrary Julia Integer types.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"+(f::MyElem, c::Integer)\n-(f::MyElem, c::Integer)\n*(f::MyElem, c::Integer)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"+(c::Integer, f::MyElem)\n-(c::Integer, f::MyElem)\n*(c::Integer, f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"For parameterised types, it is also sometimes more performant to provide explicit ad hoc operators with elements of the base ring.","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"+(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem\n-(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem\n*(f::MyElem{T}, c::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"+(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem\n-(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem\n*(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/#Optional-ad-hoc-comparisons","page":"Noncommutative ring Interface","title":"Optional ad hoc comparisons","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"==(f::MyElem, c::Integer)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"==(c::Integer, f::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"==(f::MyElem{T}, c:T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"==(c::T, f::MyElem{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"ncrings/#Optional-powering-functions","page":"Noncommutative ring Interface","title":"Optional powering functions","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"^(f::MyElem, e::BigInt)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"In case f cannot explode in size when powered by a very large integer, and it is practical to do so, one may provide this function to support powering with BigInt exponents (or for external modules, any other big integer type).","category":"page"},{"location":"ncrings/#Optional-unsafe-operators","page":"Noncommutative ring Interface","title":"Optional unsafe operators","text":"","category":"section"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"addmul!(c::MyElem, a::MyElem, b::MyElem, t::MyElem)","category":"page"},{"location":"ncrings/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Set c = c + ab in-place. Return the mutated value. The value t should be a temporary of the same type as a, b and c, which can be used arbitrarily by the implementation to speed up the computation. Aliasing between a, b and c is permitted.","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"numberfield/#Number-fields","page":"Number fields","title":"Number fields","text":"","category":"section"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"AbstractAlgebra.jl provides a very naive implementation of number fields. This allows arithmetic in algebraic number fields, which are currently modeled as mathbbQx modulo an irreducible polynomial, i.e. as a residue field.","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"In fact, the definition of the number field constructor is currently given in src/generic/ResidueField.jl and no type is defined for a number field. The definition mainly exists for testing purposes. It may later be replaced by a more standard implementation. For a more fully fleshed out number field implementation (based on a very high performance C library), see Nemo.jl.","category":"page"},{"location":"numberfield/#Number-field-constructors","page":"Number fields","title":"Number field constructors","text":"","category":"section"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"In order to construct number fields in AbstractAlgebra.jl, one must first construct the field itself. This is accomplished with the following constructor.","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"NumberField(f::AbstractAlgebra.Generic.Poly{Rational{BigInt}}, s::AbstractString, t = \"\\$\"; cached = true)","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"Given an irreducible defining polynomial f in mathbbQx, return a tuple (K x) consisting of the number field defined by that polynomial and a generator. The string fields are currently ignored, but are reserved for future use.","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"Currently the generator of the number field prints the same way as the variable in mathbbQx.","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"Examples","category":"page"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> f = a^2 + 2a + 7\nx^2 + 2*x + 7\n","category":"page"},{"location":"numberfield/#Basic-field-functionality","page":"Number fields","title":"Basic field functionality","text":"","category":"section"},{"location":"numberfield/","page":"Number fields","title":"Number fields","text":"The number field module in AbstractAlgebra.jl implements the full Field and ResidueRing interfaces.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"puiseux/#Generic-Puiseux-series","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring R.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series are power series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) for some integer m  0 where i geq 0, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The generic Puiseux series module is implemented in src/generic/PuiseuxSeries.jl.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"As well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.","category":"page"},{"location":"puiseux/#Types-and-parent-objects","page":"Generic Puiseux series","title":"Types and parent objects","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The types of generic Puiseux series implemented by AbstractAlgebra.jl are Generic.PuiseuxSeriesRingElem{T} and Generic.PuiseuxSeriesFieldElem{T}.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Both series element types belong to the union type Generic.PuiseuxSeriesElem.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series elements belong directly to either AbstractAlgebra.RingElem or AbstractAlgebra.FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The parent types for Puiseux series, Generic.PuiseuxSeriesRing{T} and Generic.PuiseuxSeriesField{T} respectively, belong to AbstractAlgebra.Ring and AbstractAlgebra.Field respectively.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The default precision, string representation of the variable and base ring R of a generic Puiseux series are stored in its parent object.","category":"page"},{"location":"puiseux/#Puiseux-series-ring-constructors","page":"Generic Puiseux series","title":"Puiseux series ring constructors","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesRing(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesField(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Given a base ring R, a maximum relative precision and a string s specifying how the generator (variable) should be printed, return a typle S, x representing the Puiseux series ring and its generator.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Here are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> S, y = PuiseuxSeriesField(QQ, 10, \"y\")\n(Puiseux series field in y over Rationals, y + O(y^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = R(BigInt(1234))\n1234 + O(x^10)\n\njulia> k = S(y + 1)\n1 + y + O(y^10)\n","category":"page"},{"location":"puiseux/#Big-oh-notation","page":"Generic Puiseux series","title":"Big-oh notation","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"O(x::SeriesElem)","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2x^(1//3) + 7x^(2//3) + O(x^(7//3))\n2*x^(1//3) + 7*x^(2//3) + O(x^(7//3))","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"puiseux/#Puiseux-series-implementation","page":"Generic Puiseux series","title":"Puiseux series implementation","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The Puiseux series type stores such a Laurent series and a scale or denominator for the exponents. For example, f(x) = 1 + x^13 + 2x^23 + O(x^73) would be stored as a Laurent series 1 + x + 2x^2 + O(x^7) and a scale of 3..","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In all models we say that two Puiseux series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Sometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"There are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.","category":"page"},{"location":"puiseux/#Basic-ring-functionality","page":"Generic Puiseux series","title":"Basic ring functionality","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the pol_length and polcoeff functions.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> S, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> T = parent(x + 1)\nPuiseux series ring in x over Integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> p = precision(f)\n10//1\n","category":"page"},{"location":"puiseux/#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic Puiseux series","title":"Puiseux series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"puiseux/#Basic-functionality","page":"Generic Puiseux series","title":"Basic functionality","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Int)","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Return the coefficient of the term of exponent n of the given power series. If n exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"modulus{T <: ResElem}(::Generic.PuiseuxSeriesElem{T})","category":"page"},{"location":"puiseux/#AbstractAlgebra.Generic.modulus-Union{Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T<:ResElem","page":"Generic Puiseux series","title":"AbstractAlgebra.Generic.modulus","text":"modulus(a::Generic.PuiseuxSeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given Puiseux series.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"isgen(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"puiseux/#AbstractAlgebra.isgen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic Puiseux series","title":"AbstractAlgebra.isgen","text":"isgen(a::Generic.PuiseuxSeriesElem)\n\nReturn true if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return false.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"isunit(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"puiseux/#AbstractAlgebra.isunit-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic Puiseux series","title":"AbstractAlgebra.isunit","text":"isunit(a::Generic.PuiseuxSeriesElem)\n\nReturn true if the given Puiseux series is arithmetically equal to a unit, i.e. is invertible, otherwise return false.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = PuiseuxSeriesRing(QQ, 10, \"t\")\n(Puiseux series field in t over Rationals, t + O(t^11))\n\njulia> S, x = PuiseuxSeriesRing(R, 30, \"x\")\n(Puiseux series field in x over Puiseux series field in t over Rationals, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = isgen(gen(R))\ntrue\n\njulia> m = isunit(-1 + x^(1//3) + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4//1\n\njulia> p = valuation(b)\n1//1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n","category":"page"},{"location":"puiseux/#Division","page":"Generic Puiseux series","title":"Division","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.inv(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"puiseux/#Base.inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic Puiseux series","title":"Base.inv","text":"Base.inv(a::PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the inverse of the power series a, i.e. 1a, if it exists. Otherwise an exception is raised.\n\n\n\ninv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n inv(a::LocElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(QQ, 30, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = R(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"puiseux/#Special-functions","page":"Generic Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.exp(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"puiseux/#Base.exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic Puiseux series","title":"Base.exp","text":"exp(a::AbstractAlgebra.RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::AbstractAlgebra.AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.sqrt(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"puiseux/#Base.sqrt-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}}","page":"Generic Puiseux series","title":"Base.sqrt","text":"Base.sqrt(f::AbstractAlgebra.PolyElem{T}, check::Bool=true) where T <: RingElement\n\nReturn the square root of f if it is a perfect square, otherwise an exception is raised. If check is set to false the function assumes the input is square and may not fully check this.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the square root of the given Puiseux series a.\n\n\n\nBase.sqrt(a::AbstractAlgebra.FracElem{T}) where T <: RingElem\n\nReturn the square root of a if it is a square, otherwise raise an exception.\n\n\n\n","category":"method"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PuiseuxSeriesRing(R, 30, \"x\")\n(Puiseux series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> T, z = PuiseuxSeriesRing(QQ, 30, \"z\")\n(Puiseux series field in z over Rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"integer/#Integer-ring","page":"Integer ring","title":"Integer ring","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Integer.jl for making Julia BigInts conform to the AbstractAlgebra.jl Ring interface.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"In addition to providing a parent object ZZ for Julia BigInts, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Because BigInt cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigInts by introducing a type union, called RingElement, which is a union of AbstractAlgebra.RingElem and a number of Julia types, including BigInt. Everywhere that RingElem is notionally used in AbstractAlgebra.jl, we are in fact using RingElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigInt type as belonging to AbstractAlgebra.RingElem.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"One other technicality is that Julia defines certain functions for BigInt, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"To access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"page"},{"location":"integer/#Types-and-parent-objects","page":"Integer ring","title":"Types and parent objects","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Integers have type BigInt, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"The parent objects of such integers has type Integers{BigInt}.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"For convenience, we also make Int a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as zz) has type Integers{Int}. But we caution that this type is not particularly useful as a model of the integers and may not function as expected within AbstractAlgebra.jl.","category":"page"},{"location":"integer/#Integer-constructors","page":"Integer ring","title":"Integer constructors","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"In order to construct integers in AbstractAlgebra.jl, one can first construct the integer ring itself. This is accomplished using the following constructor.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Integers{BigInt}()","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"This gives the unique object of type Integers{BigInt} representing the ring of integers in AbstractAlgebra.jl.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"In practice, one simply uses ZZ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Here are some examples of creating the integer ring and making use of the resulting parent object to coerce various elements into the ring.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"julia> f = ZZ()\n0\n\njulia> g = ZZ(123)\n123\n\njulia> h = ZZ(BigInt(1234))\n1234\n","category":"page"},{"location":"integer/#Basic-ring-functionality","page":"Integer ring","title":"Basic ring functionality","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"The integer ring in AbstractAlgebra.jl implements the full Ring interface and the  Euclidean Ring interface.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"We give some examples of such functionality.","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"julia> f = ZZ(12)\n12\n\njulia> h = zero(ZZ)\n0\n\njulia> k = one(ZZ)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> T = parent(f)\nIntegers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n24\n\njulia> h = powermod(f, 12, ZZ(17))\n4\n\njulia> flag, q = divides(f, ZZ(3))\n(true, 4)\n","category":"page"},{"location":"integer/#Integer-functionality-provided-by-AbstractAlgebra.jl","page":"Integer ring","title":"Integer functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"The functionality below supplements that provided by Julia itself for its BigInt type.","category":"page"},{"location":"integer/#Basic-functionality","page":"Integer ring","title":"Basic functionality","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"isunit(::Integer)","category":"page"},{"location":"integer/#AbstractAlgebra.isunit-Tuple{Integer}","page":"Integer ring","title":"AbstractAlgebra.isunit","text":"isunit(a::Integer)\n\nReturn true if a is 1 or -1.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"julia> r = ZZ(-1)\n-1\n\njulia> isunit(r)\ntrue\n","category":"page"},{"location":"integer/#Square-root","page":"Integer ring","title":"Square root","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.sqrt(a::BigInt)","category":"page"},{"location":"integer/#AbstractAlgebra.sqrt-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.sqrt","text":"sqrt(a::T) where T <: Integer\n\nReturn the integer square root of a. If a is not a perfect square an exception is thrown. If check is set to false this check is not performed.\n\n\n\nsqrt(a::Rational{T}) where T <: Integer\n\nReturn the square root of a if it is the square of a rational, otherwise throw an error.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"issquare(a::BigInt)","category":"page"},{"location":"integer/#AbstractAlgebra.Generic.issquare-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.Generic.issquare","text":"issquare(a::AbstractAlgebra.ResFieldElem{T}) where T <: Integer\n\nReturn true if a is a square.\n\n\n\nissquare(f::AbstractAlgebra.PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::T) where T <: Integer\n\nReturn true if a is a square.\n\n\n\nissquare(a::Rational{T}) where T <: Integer\n\nReturn true if a is the square of a rational.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.exp(a::BigInt)","category":"page"},{"location":"integer/#AbstractAlgebra.exp-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.exp","text":"exp(a::T) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception. This function is not generally of use to the user, but is used internally in AbstractAlgebra.jl.\n\n\n\nexp(a::Rational{T}) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"julia> d = AbstractAlgebra.sqrt(ZZ(36))\n6\n\njulia> issquare(ZZ(9))\ntrue\n\njulia> m = AbstractAlgebra.exp(ZZ(0))\n1","category":"page"},{"location":"integer/#Coprime-bases","page":"Integer ring","title":"Coprime bases","text":"","category":"section"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"ppio(a::BigInt, b::BigInt)","category":"page"},{"location":"integer/#AbstractAlgebra.ppio-Tuple{BigInt,BigInt}","page":"Integer ring","title":"AbstractAlgebra.ppio","text":"ppio(a::T, b::T)\n\nSplit a into c*d where c = gcd(a b^infty).\n\n\n\n","category":"method"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"integer/","page":"Integer ring","title":"Integer ring","text":"julia> c, n = ppio(ZZ(12), ZZ(26))\n(4, 3)\n","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"fraction_fields/#Fraction-Field-Interface","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"","category":"section"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Fraction fields are supported in AbstractAlgebra.jl, at least for gcd domains. In addition to the standard Ring interface, some additional functions are required to be present for fraction fields.","category":"page"},{"location":"fraction_fields/#Types-and-parents","page":"Fraction Field Interface","title":"Types and parents","text":"","category":"section"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"AbstractAlgebra provides two abstract types for fraction fields and their elements:","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"FracField{T} is the abstract type for fraction field parent types\nFracElem{T} is the abstract type for types of fractions","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"We have that FracField{T} <: AbstractAlgebra.Field and  FracElem{T} <: AbstractAlgebra.FieldElem.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the base ring of the fraction field.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Fraction fields should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Fraction fields should at least be distinguished based on their base ring.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"fraction_fields/#Required-functionality-for-fraction-fields","page":"Fraction Field Interface","title":"Required functionality for fraction fields","text":"","category":"section"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"In addition to the required functionality for the Field interface the Fraction Field interface has the following required functions.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"We suppose that R is a fictitious base ring, and that S is the fraction field with  parent object S of type MyFracField{T}. We also assume the fractions in the field  have type MyFrac{T}, where T is the type of elements of the base ring.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"fraction_fields/#Constructors","page":"Fraction Field Interface","title":"Constructors","text":"","category":"section"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"We provide the following constructors. Note that these constructors don't require construction of the parent object first. This is easier to achieve if the fraction element type doesn't contain a reference to the parent object, but merely contains a reference to the base ring. The parent object can then be constructed on demand.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::T, y::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return the fraction xy.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::T, y::AbstractAlgebra.FracElem{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return xy where x is in the base ring of y.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::AbstractAlgebra.FracElem{T}, y::T) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return xy where y is in the base ring of x.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Examples","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> g = f//x\n(x^2 + x + 1)//(x^4 + 3*x^2 + x)\n\njulia> h = x//f\n(x^4 + 3*x^2 + x)//(x^2 + x + 1)\n","category":"page"},{"location":"fraction_fields/#Basic-manipulation-of-fields-and-elements","page":"Fraction Field Interface","title":"Basic manipulation of fields and elements","text":"","category":"section"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"numerator(d::MyFrac{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Given a fraction d = ab return a, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"denominator(d::MyFrac{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Given a fraction d = ab return b, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Examples","category":"page"},{"location":"fraction_fields/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> f = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> n = numerator(f)\nx^2 + x + 1\n\njulia> d = denominator(f)\nx^3 + 3*x + 1\n","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"mpolynomial/#Generic-sparse-distributed-multivariate-polynomials","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/MPoly.jl for generic sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"This modules implements the Multivariate Polynomial interface, including the sparse distributed, random access part of the interface.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"All of the generic functionality is part of a submodule of AbstractAlgebra called Generic. This is exported by default so that it is not necessary to qualify the function names with the submodule name.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Multivariates are implemented in this module using a Julia array of coefficients and a 2-dimensional Julia array of UInts for the exponent vectors. Note that exponent n is represented by the n-th column of the exponent array, not the n-th row. This is because Julia uses a column major representation.","category":"page"},{"location":"mpolynomial/#Types-and-parent-objects","page":"Generic sparse distributed multivariate polynomials","title":"Types and parent objects","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Multivariate polynomials implemented in AbstractAlgebra.jl have type Generic.MPoly{T} where T is the type of elements of the coefficient ring.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of UInts for the exponent vectors. Note that exponent n is represented by the n-th column of the exponent array, not the n-th row. This is because Julia uses a column major representation. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The top bit of each UInt is reserved for overflow detection.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Parent objects of such polynomials have type Generic.MPolyRing{T}.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The string representation of the variables of the polynomial ring and the base/coefficient ring R and the ordering are stored in the parent object.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The polynomial element types belong to the abstract type AbstractAlgebra.MPolyElem{T} and the polynomial ring types belong to the abstract type AbstractAlgebra.MPolyRing{T}.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Note that both the generic polynomial ring type Generic.MPolyRing{T} and the abstract type it belongs to, AbstractAlgebra.MPolyRing{T} are both called MPolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"mpolynomial/#Polynomial-ring-constructors","page":"Generic sparse distributed multivariate polynomials","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"PolynomialRing(R::AbstractAlgebra.Ring, S::Array{String, 1}; cached::Bool = true, ordering::Symbol=:lex)","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Given a base ring R and and array S of strings specifying how the generators (variables) should be printed, return a tuple S, (x, ...) representing the new polynomial ring S = Rx ldots and a tuple of the generators (x ) of the ring. By default the parent object S will depend only on R and  (x, ...) and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The optional named argument ordering can be used to specify an ordering. The currently supported options are :lex, :deglex and :degrevlex.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Like for univariate polynomials, a shorthand version of this function is provided when the number of generators is greater than 1: given a base ring R, we abbreviate the constructor as follows:","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"R[\"x\", \"y\", ...]","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]; ordering=:deglex)\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> T, (z, t) = QQ[\"z\", \"t\"]\n(Multivariate Polynomial Ring in z, t over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[z, t])\n\njulia> f = R()\n0\n\njulia> g = R(123)\n123\n\njulia> h = R(BigInt(1234))\n1234\n\njulia> k = R(x + 1)\nx + 1\n\njulia> m = R(x + y + 1)\nx + y + 1\n\njulia> derivative(k, 1)\n1\n\njulia> derivative(k, 2)\n0\n","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a PolynomialRing constructor to allow creation of their polynomial rings.","category":"page"},{"location":"mpolynomial/#Polynomial-functionality-provided-by-AbstractAlgebra.jl","page":"Generic sparse distributed multivariate polynomials","title":"Polynomial functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"mpolynomial/#Basic-manipulation","page":"Generic sparse distributed multivariate polynomials","title":"Basic manipulation","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"vars(p::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.vars-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.vars","text":"vars(p::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the variables actually occuring in p.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"var_index(::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.var_index-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.var_index","text":"var_index(p::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the index of the given variable x. If x is not a variable in a multivariate polynomial ring, an exception is raised.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"degree(::AbstractAlgebra.MPolyElem{T}, ::Int) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},Int64}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.degree","text":"degree(f::AbstractAlgebra.MPolyElem{T}, i::Int) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the i-th variable.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"degree(::AbstractAlgebra.MPolyElem{T}, ::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.degree","text":"degree(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the variable x.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"degrees(::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.degrees-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.degrees","text":"degrees(f::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn an array of the degrees of the polynomial f in terms of each variable.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"isconstant(::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.isconstant-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.isconstant","text":"isconstant(x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn true if x is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"isterm(::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.isterm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.isterm","text":"isterm(x::MPoly)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"ismonomial(::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.ismonomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.ismonomial","text":"ismonomial(x::AbstractAlgebra.MPolyElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"coeff(::AbstractAlgebra.MPolyElem{T}, ::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.coeff","text":"coeff(f::AbstractAlgebra.MPolyElem{T}, m::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the coefficient of the monomial m of the polynomial f. If there is no such monomial, zero is returned.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^2 + 2x + 1\nx^2 + 2*x + 1\n\njulia> V = vars(f)\n1-element Array{AbstractAlgebra.Generic.MPoly{BigInt},1}:\n x\n\njulia> var_index(y) == 2\ntrue\n\njulia> degree(f, x) == 2\ntrue\n\njulia> degree(f, 2) == 0\ntrue\n\njulia> d = degrees(f)\n2-element Array{Int64,1}:\n 2\n 0\n\njulia> isconstant(R(1))\ntrue\n\njulia> isterm(2x)\ntrue\n\njulia> ismonomial(y)\ntrue\n\njulia> isunit(R(1))\ntrue\n\njulia> c = coeff(f, x^2)\n1\n","category":"page"},{"location":"mpolynomial/#Changing-base-(coefficient)-rings","page":"Generic sparse distributed multivariate polynomials","title":"Changing base (coefficient) rings","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"In order to substitute the variables of a polynomial f over a ring T by elements in a T-algebra S, you first have to change the base ring of f using the following function, where g is a function representing the structure homomorphism of the T-algebra S.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"change_base_ring(::Ring, p::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\nmap_coeffs(::Any, p::AbstractAlgebra.MPolyElem)","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, p::MPolyElem{<: RingElement}; parent::MPolyRing, cached::Bool)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.Generic.map_coeffs-Tuple{Any,MPolyElem}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.map_coeffs","text":"map_coeffs(f, p::MPolyElem{<: RingElement}; parent::MPolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> fz = x^2*y^2 + x + 1\nx^2*y^2 + x + 1\n\njulia> fq = change_base_ring(QQ, fz)\nx^2*y^2 + x + 1\n","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"In case a specific parent ring is constructed, it can also be passed to the function.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S,  = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> fz = x^5 + y^3 + 1\nx^5 + y^3 + 1\n\njulia> fq = change_base_ring(QQ, fz, parent=S)\nx^5 + y^3 + 1","category":"page"},{"location":"mpolynomial/#Multivariate-coefficients","page":"Generic sparse distributed multivariate polynomials","title":"Multivariate coefficients","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"In order to return the \"coefficient\" (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"coeff(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\ncoeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: AbstractAlgebra.MPolyElem","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.coeff","text":"coeff(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [1, 3], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f (assuming variables x y z in that order).\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{T,Array{T,1},Array{Int64,1}}} where T<:MPolyElem","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.coeff","text":"coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: AbstractAlgebra.MPolyElem\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [x, z], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1\nx^4*y^2*z^2 - 2*x^4*y*z^2 + 4*x^4*z^2 + 2*x^2*y^2 + x + 1\n\njulia> coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])\ntrue\n","category":"page"},{"location":"mpolynomial/#Inflation/deflation","page":"Generic sparse distributed multivariate polynomials","title":"Inflation/deflation","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"deflation(f::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.deflation-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.deflation","text":"deflation(f::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nCompute deflation parameters for the exponents of the polynomial f. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"deflate(f::AbstractAlgebra.MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.deflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.deflate","text":"deflate(f::AbstractAlgebra.MPolyElem{T}, v::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been shifted down by the given shifts (supplied as an array of shifts, one for each variable, then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"inflate(f::AbstractAlgebra.MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.inflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.inflate","text":"inflate(f::AbstractAlgebra.MPolyElem{T}, v::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then shifted by the given shifts (again supplied as an array of shifts, one for each variable).\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> def, shift = deflation(f)\n([1, 2], [3, 3])\n\njulia> f1 = deflate(f, def, shift)\nx^2*y^2 + 3*x*y^2 - x + 5*y - 1\n\njulia> f2 = inflate(f1, def, shift)\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> f2 == f\ntrue\n","category":"page"},{"location":"mpolynomial/#Conversions","page":"Generic sparse distributed multivariate polynomials","title":"Conversions","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"to_univariate(R::AbstractAlgebra.PolyRing{T}, p::AbstractAlgebra.MPolyElem{T}) where T <: AbstractAlgebra.RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T},MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.to_univariate","text":"to_univariate(R::AbstractAlgebra.PolyRing{T}, p::AbstractAlgebra.MPolyElem{T}) where T <: AbstractAlgebra.RingElement\n\nAssuming the polynomial p is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring R. An exception is raised if the polynomial p involves more than one variable.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S, z = PolynomialRing(ZZ, \"z\")\n(Univariate Polynomial Ring in z over Integers, z)\n\njulia> f = 2x^5 + 3x^4 - 2x^2 - 1\n2*x^5 + 3*x^4 - 2*x^2 - 1\n\njulia> g = to_univariate(S, f)\n2*z^5 + 3*z^4 - 2*z^2 - 1\n","category":"page"},{"location":"mpolynomial/#Evaluation","page":"Generic sparse distributed multivariate polynomials","title":"Evaluation","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"evaluate(::AbstractAlgebra.MPolyElem{T}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U<:Union{RingElem, AbstractFloat, Integer, Rational} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of the supplied vector.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"evaluate(::AbstractAlgebra.MPolyElem{T}, ::Vector{Int}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{U,1}}} where U<:Union{RingElem, AbstractFloat, Integer, Rational} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"evaluate(::S, ::Vector{S}, ::Vector{U}) where {S <: AbstractAlgebra.MPolyElem{T}, U <: RingElement} where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S,Array{S,1},Array{U,1}}} where U<:Union{RingElem, AbstractFloat, Integer, Rational} where S<:MPolyElem{T} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S <: AbstractAlgebra.MPolyElem{T}, U <: RingElement} where T <: RingElement\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables (supplied as polynomials) given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"evaluate(::AbstractAlgebra.MPolyElem{T}, ::Vector{U}) where {T <: RingElement, U <: NCRingElem}","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U<:NCRingElem where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T <: RingElement, U <: NCRingElem}\n\nEvaluate the polynomial expression at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which a belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y^2 + 3x + y + 1\n2*x^2*y^2 + 3*x + y + 1\n\njulia> evaluate(f, BigInt[1, 2])\n14\n\njulia> evaluate(f, [QQ(1), QQ(2)])\n14//1\n\njulia> evaluate(f, [1, 2])\n14\n\njulia> f(1, 2) == 14\ntrue\n\njulia> evaluate(f, [x + y, 2y - x])\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> f(x + y, 2y - x)\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^2*y^2 + 2x*z + 3y*z + z + 1\nx^2*y^2 + 2*x*z + 3*y*z + z + 1\n\njulia> evaluate(f, [1, 3], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [x, z], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [1, 2], [x + z, x - z])\nx^4 - 2*x^2*z^2 + 5*x*z + z^4 - z^2 + z + 1\n\njulia> S = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> M1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> M2 = S([2 3; 1 -1])\n[2    3]\n[1   -1]\n\njulia> M3 = S([-1 1; 1 1])\n[-1   1]\n[ 1   1]\n\njulia> evaluate(f, [M1, M2, M3])\n[ 64    83]\n[124   149]","category":"page"},{"location":"mpolynomial/#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms","page":"Generic sparse distributed multivariate polynomials","title":"Leading and constant coefficients, leading monomials and leading terms","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The leading coefficient, constant coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"leading_coefficient(p::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.leading_coefficient-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(p::MPolyElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"leading_monomial(p::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.leading_monomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.leading_monomial","text":"leading_monomial(p::MPolyElem)\n\nReturn the leading monomial of the polynomial p.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"leading_term(p::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.leading_term-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.leading_term","text":"leading_term(p::MPolyElem)\n\nReturn the leading term of the polynomial p.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"constant_coefficient(p::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.constant_coefficient-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.constant_coefficient","text":"constant_coefficient(p::MPolyElem)\n\nReturn the constant coefficient of the polynomial p or zero if it doesn't have one.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"using AbstractAlgebra\nR,(x,y) = PolynomialRing(ZZ, [\"x\", \"y\"], ordering=:deglex)\np = 2*x*y + 3*y^3\nleading_term(p)\nleading_monomial(p)\nleading_coefficient(p)\nleading_term(p) == leading_coefficient(p) * leading_monomial(p)\nconstant_coefficient(p)","category":"page"},{"location":"mpolynomial/#Least-common-multiple,-greatest-common-divisor","page":"Generic sparse distributed multivariate polynomials","title":"Least common multiple, greatest common divisor","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"The greated common divisor of two polynomials a and b is returned by","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"gcd(a::AbstractAlgebra.Generic.MPoly{T}, b::AbstractAlgebra.Generic.MPoly{T}) where {T <: RingElement}","category":"page"},{"location":"mpolynomial/#Base.gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T},AbstractAlgebra.Generic.MPoly{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"Base.gcd","text":"gcd(a::AbstractAlgebra.Generic.MPoly{T}, a::AbstractAlgebra.Generic.MPoly{T}) where {T <: RingElement}\n\nReturn the greatest common divisor of a and b in parent(a).\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Note that this functionality is currently only provided for AbstractAlgebra generic polynomials. It is not automatically provided for all multivariate rings that implement the multivariate interface.","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"However, if such a gcd is provided, the least common multiple of two polynomials a and b is returned by","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"lcm(a::AbstractAlgebra.MPolyElem{T}, b::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}","category":"page"},{"location":"mpolynomial/#Base.lcm-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"Base.lcm","text":"lcm(a::AbstractAlgebra.MPolyElem{T}, a::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the least common multiple of a and b in parent(a).\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> using AbstractAlgebra\n\njulia> R,(x,y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> a = x*y + 2*y\nx*y + 2*y\n\njulia> b = x^3*y + y\nx^3*y + y\n\njulia> gcd(a,b)\ny\n\njulia> lcm(a,b)\nx^4*y + 2*x^3*y + x*y + 2*y\n\njulia> lcm(a,b) == a * b // gcd(a,b)\ntrue\n","category":"page"},{"location":"mpolynomial/#Derivations","page":"Generic sparse distributed multivariate polynomials","title":"Derivations","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"derivative(::AbstractAlgebra.MPolyElem{T}, ::AbstractAlgebra.MPolyElem{T}) where T <: AbstractAlgebra.RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.derivative-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.derivative","text":"derivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n","category":"method"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"julia> R, (x, y) = AbstractAlgebra.PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> derivative(f, x)\ny + 1\n\njulia> derivative(f, y)\nx + 1\n","category":"page"},{"location":"mpolynomial/#Homogeneous-polynomials","page":"Generic sparse distributed multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"It is possible to test whether a polynomial is homogeneous with respect to the standard grading using the function","category":"page"},{"location":"mpolynomial/","page":"Generic sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariate polynomials","text":"ishomogeneous(x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"mpolynomial/#AbstractAlgebra.Generic.ishomogeneous-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Generic sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.ishomogeneous","text":"ishomogeneous(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is homogeneous with respect to the standard grading and false otherwise.\n\n\n\n","category":"method"},{"location":"#AbstractAlgebra.jl","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"","category":"section"},{"location":"#Introduction","page":"AbstractAlgebra.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl is a computer algebra package for the Julia programming language, maintained by William Hart, Tommy Hofmann, Claus Fieker and Fredrik Johansson and other interested contributors.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Source code","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl grew out of the Nemo project after a number of requests from the community for the pure Julia part of Nemo to be split off into a separate project. See the Nemo website for more details about Nemo.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Nemo website","category":"page"},{"location":"#Features","page":"AbstractAlgebra.jl","title":"Features","text":"","category":"section"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"The features of AbstractAlgebra.jl include:","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Use of Julia multiprecision integers and rationals\nFinite fields (prime order, naive implementation only)\nNumber fields (naive implementation only)\nUnivariate polynomials\nMultivariate polynomials\nRelative and absolute power series\nLaurent series\nFraction fields\nResidue rings, including mathbbZnmathbbZ\nMatrices and linear algebra","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"All implementations are fully recursive and generic, so that one can build matrices over polynomial rings, over a finite field, for example.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl also provides a set of abstract types for Groups, Rings, Fields, Modules and elements thereof, which allow external types to be made part of the AbstractAlgebra.jl type hierarchy.","category":"page"},{"location":"#Installation","page":"AbstractAlgebra.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"To use AbstractAlgebra we require Julia 1.0 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"julia> Pkg.add(\"AbstractAlgebra\")","category":"page"},{"location":"#Quick-start","page":"AbstractAlgebra.jl","title":"Quick start","text":"","category":"section"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here are some examples of using AbstractAlgebra.jl.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"This example makes use of multivariate polynomials.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n\nf = x + y + z + 1\n\np = f^20;\n\n@time q = p*(p+1);","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here is an example using generic recursive ring constructions.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR = GF(7)\n\nS, y = PolynomialRing(R, \"y\")\n\nT = ResidueRing(S, y^3 + 3y + 1)\n\nU, z = PolynomialRing(T, \"z\")\n\nf = (3y^2 + y + 2)*z^2 + (2*y^2 + 1)*z + 4y + 3;\n\ng = (7y^2 - y + 7)*z^2 + (3y^2 + 1)*z + 2y + 1;\n\ns = f^4;\n\nt = (s + g)^4;\n\n@time resultant(s, t)","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here is an example using matrices.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = PolynomialRing(ZZ, \"x\")\n\nS = MatrixSpace(R, 10, 10)\n\nM = rand(S, 0:3, -10:10);\n\n@time det(M)","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"And here is an example with power series.","category":"page"},{"location":"","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = QQ[\"x\"]\n\nS, t = PowerSeriesRing(R, 30, \"t\")\n\nu = t + O(t^100)\n\n@time divexact((u*exp(x*u)), (exp(u)-1));","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"module/#Module-Interface","page":"Module Interface","title":"Module Interface","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Note: the module infrastructure in AbstractAlgebra should be considered experimental at this stage. This means that the interface may change in the future.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"AbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules. The generic code provided by AbstractAlgebra will only work for modules over euclidean domains, however there is nothing preventing a library from implementing more general modules using the same interface.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"All finitely presented module types in AbstractAlgebra follow the following interface.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Free modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"page"},{"location":"module/#Types-and-parents","page":"Module Interface","title":"Types and parents","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"FPModule{T} is the abstract type for finitely presented module parent","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"types","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"FPModuleElem{T} is the abstract type for finitely presented module","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"element types","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"page"},{"location":"module/#Required-functionality-for-modules","page":"Module Interface","title":"Required functionality for modules","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"We suppose that R is a fictitious base ring and that S is a module over R with parent object S of type MyModule{T}. We also assume the elements in the module have type MyModuleElem{T}, where T is the type of elements of the ring the module is over.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElement or NCRingElem.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"We describe the functionality below for modules over commutative rings, i.e. with element type belonging to RingElement, however similar constructors should be available for element types belonging to NCRingElem instead, for free modules over a noncommutative ring.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Although not part of the module interface, implementations of modules that wish to follow our interface should use the same function names for submodules, quotient modules, direct sums and module homomorphisms if they wish to remain compatible with our module generics in the future.","category":"page"},{"location":"module/#Basic-manipulation","page":"Module Interface","title":"Basic manipulation","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"iszero(m::MyModuleElem{T}) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Return true if the given module element is zero.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"ngens(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Return the number of generators of the module M in its current representation.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"gen(M::MyModule{T}, i::Int) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Return the i-th generator (indexed from 1) of the module M.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"gens(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Return a Julia array of the generators of the module M.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"rels(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Return a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> n = ngens(M)\n2\n\njulia> G = gens(M)\n2-element Array{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}},1}:\n (1//1, 0//1)\n (0//1, 1//1)\n\njulia> R = rels(M)\nAbstractAlgebra.Generic.MatSpaceElem{Rational{BigInt}}[]\n\njulia> g1 = gen(M, 1)\n(1//1, 0//1)\n\njulia> !iszero(g1)\ntrue\n","category":"page"},{"location":"module/#Element-constructors","page":"Module Interface","title":"Element constructors","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"(M::AbstractAlgebra.Module{T})(v::Vector{T}) where T <: RingElement","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Construct the element of the module M corrsponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"page"},{"location":"module/#Coercions","page":"Module Interface","title":"Coercions","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"In particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"F = FreeModule(ZZ, 3)\n\nS1, f = sub(F, [rand(F, -10:10)])\n\nS, g = sub(F, [rand(F, -10:10)])\nQ, h = quo(F, S)\n\nm = rand(S1, -10:10)\nn = Q(m)","category":"page"},{"location":"module/#Arithmetic-operators","page":"Module Interface","title":"Arithmetic operators","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"In the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"page"},{"location":"module/#Generic-functionality-provided","page":"Module Interface","title":"Generic functionality provided","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"AbstractAlgebra provides the following functionality for all module types that implement the interface above. Of course, this functionality can also be provided by special implementations if desired.","category":"page"},{"location":"module/#Basic-manipulation-2","page":"Module Interface","title":"Basic manipulation","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"zero(M::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"module/#Base.zero-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"Base.zero","text":"zero(M::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn the zero element of the module M.\n\n\n\n","category":"method"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> z = zero(M)\n(0//1, 0//1)","category":"page"},{"location":"module/#Element-indexing","page":"Module Interface","title":"Element indexing","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Base.getindex(m::AbstractAlgebra.FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"module/#Base.getindex-Union{Tuple{AbstractAlgebra.FPModuleElem{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"Base.getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n","category":"method"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> F = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m = F(BigInt[2, -5, 4])\n(2, -5, 4)\n\njulia> m[1]\n2","category":"page"},{"location":"module/#Comparison","page":"Module Interface","title":"Comparison","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"==(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"module/#Base.:==-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"Base.:==","text":"==(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if the modules are (constructed to be) the same module elementwise. This is not object equality and it is not isomorphism. In fact, each method of constructing modules (submodules, quotient modules, products, etc.) must extend this notion of equality to the modules they create.\n\n\n\n","category":"method"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> M == M\ntrue\n","category":"page"},{"location":"module/#Isomorphism","page":"Module Interface","title":"Isomorphism","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"isisomorphic(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"module/#AbstractAlgebra.Generic.isisomorphic-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T},AbstractAlgebra.FPModule{T}}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"AbstractAlgebra.Generic.isisomorphic","text":"isisomorphic(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if the modules M and N are isomorphic.\n\n\n\n","category":"method"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Note that this function relies on the Smith normal form over the base ring of the modules being able to be made unique. This is true for Euclidean domains for which divrem has a fixed choice of quotient and remainder, but it will not in general be true for Euclidean rings that are not domains.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m1 = rand(M, -10:10)\n(0, -8, -8)\n\njulia> m2 = rand(M, -10:10)\n(-7, -5, -10)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> I, g = image(f)\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> isisomorphic(S, I)\ntrue\n","category":"page"},{"location":"module/#Invariant-Factor-Decomposition","page":"Module Interface","title":"Invariant Factor Decomposition","text":"","category":"section"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"For modules over a euclidean domain one can take the invariant factor decomposition to determine the structure of the module. The invariant factors are unique up to multiplication by a unit, and even unique if a  canonical_unit is available for the ring that canonicalises elements.","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"snf(::AbstractAlgebra.FPModule{T}) where T <: RingElement\ninvariant_factors(::AbstractAlgebra.FPModule{T}) where T <: RingElement","category":"page"},{"location":"module/#AbstractAlgebra.Generic.snf-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"AbstractAlgebra.Generic.snf","text":"snf(m::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn a pair M, f consisting of the invariant factor decomposition M of the module m and a module homomorphism (isomorphisms) f  M to m. The module M is itself a module which can be manipulated as any other module in the system.\n\n\n\n","category":"method"},{"location":"module/#AbstractAlgebra.Generic.invariant_factors-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Module Interface","title":"AbstractAlgebra.Generic.invariant_factors","text":"invariant_factors(m::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn a vector of the invariant factors of the module M.\n\n\n\n","category":"method"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"Examples","category":"page"},{"location":"module/","page":"Module Interface","title":"Module Interface","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m1 = rand(M, -10:10)\n(9, 7, 7)\n\njulia> m2 = rand(M, -10:10)\n(-6, 2, -8)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> Q, g = quo(M, S)\n(Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10], Module homomorphism with\nDomain: Free module of rank 3 over Integers\nCodomain: Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10])\n\njulia> I, f = snf(Q)\n(Invariant factor decomposed module over Integers with invariant factors BigInt[10, 0], Module homomorphism with\nDomain: Invariant factor decomposed module over Integers with invariant factors BigInt[10, 0]\nCodomain: Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10])\n\njulia> invs = invariant_factors(Q)\n2-element Array{BigInt,1}:\n 10\n  0\n","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"direct_sum/#Direct-Sums","page":"Direct Sums","title":"Direct Sums","text":"","category":"section"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra allows the construction of the external direct sum of any nonempty vector of finitely presented modules.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"As well as implementing the entire Module interface, AbstractAlgebra direct sums also provide the following interface.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Note that external direct sums are considered equal iff they are the same object.","category":"page"},{"location":"direct_sum/#Constructors","page":"Direct Sums","title":"Constructors","text":"","category":"section"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"DirectSum(::Vector{<:AbstractAlgebra.FPModule{T}}) where T <: RingElement\nDirectSum(::AbstractAlgebra.FPModule{T}...) where T <: RingElement","category":"page"},{"location":"direct_sum/#AbstractAlgebra.DirectSum-Union{Tuple{Array{var\"#s4\",1} where var\"#s4\"<:AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Direct Sums","title":"AbstractAlgebra.DirectSum","text":"DirectSum(m::Vector{<:Module{T}}) where T <: RingElement\n\nReturn a tuple M f g consisting of M the direct sum of the modules m (supplied as a vector of modules), a vector f of the canonical injections of the mi into M and a vector g of the canonical projections from M onto the mi.\n\n\n\n","category":"method"},{"location":"direct_sum/#AbstractAlgebra.DirectSum-Union{Tuple{Vararg{AbstractAlgebra.FPModule{T},N} where N}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Direct Sums","title":"AbstractAlgebra.DirectSum","text":"DirectSum(m::Module{T}...) where T <: RingElement\n\nReturn a tuple M f g consisting of M the direct sum of the given modules, a vector f of the canonical injections of the mi into M and a vector g of the canonical projections from M onto the mi.\n\n\n\n","category":"method"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = FreeModule(ZZ, 5)\nFree module of rank 5 over Integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> D, f = DirectSum(S1, S2, S3)\n(DirectSumModule over Integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n])","category":"page"},{"location":"direct_sum/#Functionality-for-direct-sums","page":"Direct Sums","title":"Functionality for direct sums","text":"","category":"section"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"In addition to the Module interface, AbstractAlgebra direct sums implement the following functionality.","category":"page"},{"location":"direct_sum/#Basic-manipulation","page":"Direct Sums","title":"Basic manipulation","text":"","category":"section"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"summands(::AbstractAlgebra.Generic.DirectSumModule{T}) where T <: RingElement","category":"page"},{"location":"direct_sum/#AbstractAlgebra.Generic.summands-Union{Tuple{AbstractAlgebra.Generic.DirectSumModule{T}}, Tuple{T}} where T<:Union{RingElem, AbstractFloat, Integer, Rational}","page":"Direct Sums","title":"AbstractAlgebra.Generic.summands","text":"summands(M::DirectSumModule{T}) where T <: RingElement\n\nReturn the modules that this module is a direct sum of.\n\n\n\n","category":"method"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = FreeModule(ZZ, 5)\nFree module of rank 5 over Integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> D, f = DirectSum(S1, S2, S3)\n(DirectSumModule over Integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n])\n\njulia> summands(D)\n3-element Array{AbstractAlgebra.Generic.Submodule{BigInt},1}:\n Submodule over Integers with 2 generators and no relations\n\n Submodule over Integers with 2 generators and no relations\n\n Submodule over Integers with 2 generators and no relations","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"    (D::DirectSumModule{T}(::Vector{<:AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a vector (or 1-dim array) of module elements, where the i-th entry has to be an element of the i-summand of D, create the corresponding element in D.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = FreeModule(QQ, 2);\n\njulia> M = FreeModule(QQ, 1);\n\njulia> D, _ = DirectSum(M, N, M);\n\njulia> D([gen(M, 1), gen(N, 1), gen(M, 2)])\n(1//1, 1//1, 0//1, 0//1)","category":"page"},{"location":"direct_sum/#Special-Homomorphisms","page":"Direct Sums","title":"Special Homomorphisms","text":"","category":"section"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Due to the special structure as direct sums, homomorphisms can be created by specifying homomorphisms for all summands. In case of the codmain being a direct sum as well, any homomorphism may be thought of as a matrix containing maps from the i-th source summand to the j-th target module:","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::DirectSumModule{T}, m::Array{Any, 2}) where T <: RingElement","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::FPModuleElem{T}, m::Array{ModuleHomomorphism, 1})","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given an array a of ModuleHomomorphism such that a_i, the i-th entry of a is a ModuleHomomorphism from the i-th summand of D into S, construct the direct sum of the components.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = FreeModule(QQ, 2);\n\njulia> D, _ = DirectSum(N, N);\n\njulia> p = ModuleHomomorphism(N, N, [3,4] .* basis(N));\n\njulia> q = ModuleHomomorphism(N, N, [5,7] .* basis(N));\n\njulia> phi = ModuleHomomorphism(D, D, [p 0; 0 q])\nModule homomorphism with\nDomain: DirectSumModule over Rationals\nCodomain: DirectSumModule over Rationals\n\njulia> r = ModuleHomomorphism(N, D, [2,3] .* gens(D)[1:2])\nModule homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: DirectSumModule over Rationals\n\njulia> psi = ModuleHomomorphism(D, D, [r, r])\nModule homomorphism with\nDomain: DirectSumModule over Rationals\nCodomain: DirectSumModule over Rationals","category":"page"}]
}
