var documenterSearchIndex = {"docs":
[{"location":"field_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"A number of basic fields are provided, such as the rationals, finite fields, the real field, etc.\n\nVarious generic field constructions can then be made recursively on top of these basic fields. For example, fraction fields, residue fields, function fields, etc.\n\nFrom the point of view of the system, all fields are rings and whether an object is a ring/field or an element thereof can be determined at the type level. There are abstract types for all field and for all field element types.\n\nThe field hierarchy can be extended by implementing new fields to follow one or more field interfaces, including the interface that all fields must follow. Once an interface is satisfied, all the corresponding generic functionality will work over the new field.\n\nImplementations of new fields can either be generic or can be specialised implementations provided by, for example, a C library.","category":"section"},{"location":"map_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"Maps in AbstractAlgebra model maps on sets f  D to C for some domain D and codomain C, which have no real limitations except that elements of the codomain and domain be represented by element objects in the system.\n\nMaps f  D to C in AbstractAlgebra are modeled by Julia objects that are able to be called on a single element d in D of the domain to yield an element f(d) in C of the codomain. We say that the map is being applied.\n\nMaps can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.\n\nMaps in AbstractAlgebra have a domain and codomain, can be applied, composed with other maps. Various special kinds of map provide more functionality.\n\nFor details please refer to the Map Interface documentation.\n\nFor example, there are functional maps which wrap a Julia function, cached maps which cache values so they do not have to be recomputed each time they are applied to the same inputs and various kinds of maps with inverses, e.g. maps with sections, retractions and full inverses.\n\nThe map system uses a complex four parameter Map type, however various helper functions are provided to make it easier to work with.","category":"section"},{"location":"visualizing_types/#Visualization-of-the-types-of-AbstractAlgebra.jl","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"AbstractAlgebra.jl implements a couple of abstract types which can be extended.","category":"section"},{"location":"visualizing_types/#Abstract-parents","page":"Visualization of the types of AbstractAlgebra.jl","title":"Abstract parents","text":"The following diagram shows a complete list of all abstract types in AbstractAlgebra.jl.\n\n(Image: Diagram of parent types)","category":"section"},{"location":"visualizing_types/#Abstract-elements","page":"Visualization of the types of AbstractAlgebra.jl","title":"Abstract elements","text":"Similarly the following diagram shows a complete list of all abstract types in AbstractAlgebra.jl.\n\n(Image: Diagram of element types)","category":"section"},{"location":"visualizing_types/#Concrete-types-in-AbstractAlgebra.jl","page":"Visualization of the types of AbstractAlgebra.jl","title":"Concrete types in AbstractAlgebra.jl","text":"Until now we have discussed the abstract types of AbstractAlgebra.jl. Under this subsection we will instead give some examples of concrete types in AbstractAlgebra.jl.\n\nIn parentheses we put the types of the corresponding parent objects.\n\nPerm{<:Integer} (SymmetricGroup{<:Integer})\nGFElem{<:Integer} (GFField{<:Integer})\n\nWe also think of various Julia types as though they were AbstractAlgebra.jl types:\n\nBigInt (Integers{BigInt})\nRational{BigInt} (Rationals{BigInt})\n\nThen there are various types for generic constructions over a base ring. They are all parameterised by a type T which is the type of the elements of the base ring they are defined over.\n\nGeneric.Poly{T} (Generic.PolyRing{T})\nGeneric.MPoly{T} (Generic.MPolyRing{T})\nGeneric.RelSeries{T} (Generic.RelPowerSeriesRing{T})\nGeneric.AbsSeries{T} (Generic.AbsPowerSeriesRing{T})\nGeneric.LaurentSeriesRingElem{T} (Generic.LaurentSeriesRing{T})\nGeneric.LaurentSeriesFieldElem{T} (Generic.LaurentSeriesField{T})\nGeneric.EuclideanRingResidueRingElem{T} (Generic.EuclideanRingResidueRing{T})\nGeneric.FracFieldElem{T} (Generic.FracField{T})\nGeneric.Mat{T} (MatSpace{T})","category":"section"},{"location":"ytabs/#Partitions-and-Young-tableaux","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"AbstractAlgebra.jl provides basic support for computations with Young tableaux, skew diagrams and the characters of permutation groups (implemented src/generic/YoungTabs.jl). All functionality of permutations is accessible in the Generic submodule.","category":"section"},{"location":"ytabs/#Partitions","page":"Partitions and Young tableaux","title":"Partitions","text":"The basic underlying object for those concepts is Partition of a number n, i.e. a sequence of positive integers n_1 ldots n_k which sum to n. Partitions in AbstractAlgebra.jl are represented internally by non-increasing Vectors of Ints. Partitions are printed using the standard notation, i.e. 9 = 4 + 2 + 1 + 1 + 1 is shown as 4_1 2_1 1_3 with the subscript indicating the count of a summand in the partition.","category":"section"},{"location":"ytabs/#Array-interface","page":"Partitions and Young tableaux","title":"Array interface","text":"Partition is a concrete (immutable) subtype of AbstractVector{Integer} and implements the standard Array interface.\n\nThese functions work on the level of p.part vector.\n\nOne can easily iterate over all partitions of n using the Generic.partitions function.\n\nYou may also have a look at JuLie.jl package for more utilities related to partitions.\n\nThe number of all partitions can be computed by the hidden function _numpart. Much faster implementation is available in Nemo.jl.\n\nSince Partition is a subtype of AbstractVector generic functions which operate on vectors should work in general. However the meaning of conj has been changed to agree with the traditional understanding of conjugation of Partitions:","category":"section"},{"location":"ytabs/#Young-Diagrams-and-Young-Tableaux","page":"Partitions and Young tableaux","title":"Young Diagrams and Young Tableaux","text":"Mathematically speaking Young diagram is a diagram which consists of rows of square boxes such that the number of boxes in each row is no less than the number of boxes in the previous row. For example partition 4_1 3_2 1 represents the following diagram.\n\n┌───┬───┬───┬───┐\n│   │   │   │   │\n├───┼───┼───┼───┘\n│   │   │   │\n├───┼───┼───┤\n│   │   │   │\n├───┼───┴───┘\n│   │\n└───┘\n\nYoung Tableau is formally a bijection between the set of boxes of a Young Diagram and the set 1 ldots n. If a bijection is increasing along rows and columns of the diagram it is referred to as standard. For example\n\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┼───┤\n│ 8 │ 9 │10 │\n├───┼───┴───┘\n│11 │\n└───┘\n\nis a standard Young tableau of 4_1 3_2 1 where the bijection assigns consecutive natural numbers to consecutive (row-major) cells.","category":"section"},{"location":"ytabs/#Constructors","page":"Partitions and Young tableaux","title":"Constructors","text":"In AbstractAlgebra.jl Young tableau are implemented as essentially row-major sparse matrices, i.e. YoungTableau <: AbstractMatrix{Int} but only the defining Partition and the (row-major) fill-vector is stored.\n\nFor convenience there exists an alternative constructor of YoungTableau, which accepts a vector of integers and constructs Partition internally.\n\nYoungTableau(p::Vector{Integer}[, fill=collect(1:sum(p))])","category":"section"},{"location":"ytabs/#Array-interface-2","page":"Partitions and Young tableaux","title":"Array interface","text":"To make YoungTableaux array-like we implement the following functions:\n\nAlso the double-indexing corresponds to (row, column) access to an abstract array.\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y[1,2]\n2\n\njulia> y[2,3]\n7\n\njulia> y[3,2]\n0\n\nFunctions defined for AbstractArray type based on those (e.g. length) should work. Again, as in the case of Partition the meaning of conj is altered to reflect the usual meaning for Young tableaux:","category":"section"},{"location":"ytabs/#Pretty-printing","page":"Partitions and Young tableaux","title":"Pretty-printing","text":"Similarly to permutations we have two methods of displaying Young Diagrams:","category":"section"},{"location":"ytabs/#Ulitility-functions","page":"Partitions and Young tableaux","title":"Ulitility functions","text":"","category":"section"},{"location":"ytabs/#Characters-of-permutation-groups","page":"Partitions and Young tableaux","title":"Characters of permutation groups","text":"Irreducible characters (at least over field of characteristic 0) of the full group of permutations S_n correspond via Specht modules to partitions of n.\n\nThe values computed by characters are cached in an internal dictionary Dict{Tuple{BitVector,Vector{Int}}, BigInt}. Note that all of the above functions return BigInts. If you are sure that the computations do not overflow, variants of the last two functions using Int are available:\n\ncharacter(::Type{Int}, lambda::Partition, p::Perm[, check::Bool=true])\ncharacter(::Type{Int}, lambda::Partition, mu::Partition[, check::Bool=true])\n\nThe dimension dim lambda of the irreducible module corresponding to partition lambda can be computed using Hook length formula\n\nThe character associated with Y.part can also be used to compute the dimension, but as it is expected the Murnaghan-Nakayama is much slower even though (due to caching) consecutive calls are fast:\n\njulia> λ = Partition(collect(12:-1:1))\n12₁11₁10₁9₁8₁7₁6₁5₁4₁3₁2₁1₁\n\njulia> @time dim(YoungTableau(λ))\n  0.224430 seconds (155.77 k allocations: 7.990 MiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time dim(YoungTableau(λ))\n  0.000038 seconds (335 allocations: 10.734 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> G = SymmetricGroup(sum(λ))\nFull symmetric group over 78 elements\n\njulia> @time character(λ, one(G))\n  0.000046 seconds (115 allocations: 16.391 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time character(λ, one(G))\n  0.001439 seconds (195 allocations: 24.453 KiB)\n9079590132732747656880081324531330222983622187548672000","category":"section"},{"location":"ytabs/#Low-level-functions-and-characters","page":"Partitions and Young tableaux","title":"Low-level functions and characters","text":"As mentioned above character functions use the Murnaghan-Nakayama rule for evaluation. The implementation follows\n\nDan Bernstein, The computational complexity of rules for the character table of S_n Journal of Symbolic Computation, 37 (6), 2004, p. 727-748,\n\nimplementing the following functions. For precise definitions and meaning please consult the paper cited.","category":"section"},{"location":"ytabs/#Skew-Diagrams","page":"Partitions and Young tableaux","title":"Skew Diagrams","text":"Skew diagrams are formally differences of two Young diagrams. Given lambda and mu, two partitions of n+m and m (respectively). Suppose that each of cells of mu is a cell of lambda (i.e. parts of mu are no greater than the corresponding parts of lambda). Then the skew diagram denoted by lambdamu is the set theoretic difference the of sets of boxes, i.e. is a diagram with exactly n boxes:\n\nSkewDiagram implements array interface with the following functions:\n\nThe support for skew diagrams is very rudimentary. The following functions are available:","category":"section"},{"location":"ytabs/#AbstractAlgebra.Generic.Partition","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.Partition","text":"Partition(part::Vector{<:Integer}[, check::Bool=true]) <: AbstractVector{Int}\n\nRepresent integer partition in the non-increasing order.\n\npart will be sorted, if necessary. Checks for validity of input can be skipped by calling the (inner) constructor with false as the second argument.\n\nFunctionally Partition is a thin wrapper over Vector{Int}.\n\nFieldnames:\n\nn::Int - the partitioned number\npart::Vector{Int} - a non-increasing sequence of summands of n.\n\nExamples\n\njulia> p = Partition([4,2,1,1,1])\n4₁2₁1₃\n\njulia> p.n == sum(p.part)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(p::Partition)\n\nReturn the size of the vector which represents the partition.\n\nExamples\n\njulia> p = Partition([4,3,1]); size(p)\n(3,)\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.Partition, Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(p::Partition, i::Integer)\n\nReturn the i-th part (in non-increasing order) of the partition.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.partitions","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.partitions","text":"partitions(n::Integer)\n\nReturn the vector of all permutations of n. For an unsafe generator version see partitions!.\n\nExamples\n\njulia> Generic.partitions(5)\n7-element Vector{AbstractAlgebra.Generic.Partition{Int64}}:\n 1₅\n 2₁1₃\n 3₁1₂\n 2₂1₁\n 4₁1₁\n 3₁2₁\n 5₁\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic._numpart","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic._numpart","text":"_numpart(n::Integer)\n\nReturn the number of all distinct integer partitions of n. The function uses Euler pentagonal number theorem for recursive formula. For more details see OEIS sequence A000041. Note that _numpart(0) = 1 by convention.\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(part::Partition)\n\nReturn the conjugated partition of part, i.e. the partition corresponding to the Young diagram of part reflected through the main diagonal.\n\nExamples\n\njulia> p = Partition([4,2,1,1,1])\n4₁2₁1₃\n\njulia> conj(p)\n5₁2₁1₂\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.Partition, Vector}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(part::Partition, v::Vector)\n\nReturn the conjugated partition of part together with permuted vector v.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.YoungTableau","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.YoungTableau","text":"YoungTableau(part::Partition[, fill::Vector{Int}=collect(1:sum(part))])  <: AbstractMatrix{Int}\n\nReturn the Young tableaux of partition part, filled linearly by fill vector. Note that fill vector is in row-major format.\n\nFields:\n\npart - the partition defining Young diagram\nfill - the row-major fill vector: the entries of the diagram.\n\nExamples\n\njulia> p = Partition([4,3,1]); y = YoungTableau(p)\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y.part\n4₁3₁1₁\n\njulia> y.fill\n8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n\n\n\n\n\n","category":"type"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(Y::YoungTableau)\n\nReturn size of the smallest array containing Y, i.e. the tuple of the number of rows and the number of columns of Y.\n\nExamples\n\njulia> y = YoungTableau([4,3,1]); size(y)\n(3, 4)\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.YoungTableau, Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(Y::YoungTableau, n::Integer)\n\nReturn the column-major linear index into the size(Y)-array. If a box is outside of the array return 0.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y[1]\n1\n\njulia> y[2]\n5\n\njulia> y[4]\n2\n\njulia> y[6]\n0\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.conj-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"Base.conj","text":"conj(Y::YoungTableau)\n\nReturn the conjugated tableau, i.e. the tableau reflected through the main diagonal.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> conj(y)\n┌───┬───┬───┐\n│ 1 │ 5 │ 8 │\n├───┼───┼───┘\n│ 2 │ 6 │\n├───┼───┤\n│ 3 │ 7 │\n├───┼───┘\n│ 4 │\n└───┘\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.setyoungtabstyle","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.setyoungtabstyle","text":"setyoungtabstyle(format::Symbol)\n\nSelect the style in which Young tableaux are displayed (in REPL or in general as string). This can be either\n\n:array - as matrices of integers, or\n:diagram - as filled Young diagrams (the default).\n\nThe difference is purely esthetical.\n\nExamples\n\njulia> Generic.setyoungtabstyle(:array)\n:array\n\njulia> p = Partition([4,3,1]); YoungTableau(p)\n 1  2  3  4\n 5  6  7\n 8\n\njulia> Generic.setyoungtabstyle(:diagram)\n:diagram\n\njulia> YoungTableau(p)\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n 1  2  3  4\n 5  6  7  ⋅\n 8  ⋅  ⋅  ⋅\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.fill!-Tuple{AbstractAlgebra.Generic.YoungTableau, AbstractVector{<:Integer}}","page":"Partitions and Young tableaux","title":"Base.fill!","text":"fill!(Y::YoungTableaux, V::Vector{<:Integer})\n\nReplace the fill vector Y.fill by V. No check if the resulting tableau is standard (i.e. increasing along rows and columns) is performed.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> fill!(y, [2:9...])\n┌───┬───┬───┬───┐\n│ 2 │ 3 │ 4 │ 5 │\n├───┼───┼───┼───┘\n│ 6 │ 7 │ 8 │\n├───┼───┴───┘\n│ 9 │\n└───┘\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition)\n\nReturn the lambda-th irreducible character of permutation group on sum(lambda) symbols. The returned character function is of the following signature:\n\nchi(p::Perm[, check::Bool=true]) -> BigInt\n\nThe function checks (if p belongs to the appropriate group) can be switched off by calling chi(p, false). The values computed by chi are cached in look-up table.\n\nThe computation follows the Murnaghan-Nakayama formula: chi_lambda(sigma) = sum_textrimhook xisubset lambda(-1)^ll(lambdabackslashxi) chi_lambda backslashxi(tildesigma) where lambdabackslashxi denotes the skew diagram of lambda with xi removed, ll denotes the leg-length (i.e. number of rows - 1) and tildesigma is permutation obtained from sigma by the removal of the longest cycle.\n\nFor more details see e.g. Chapter 2.8 of Group Theory and Physics by S.Sternberg.\n\nExamples\n\njulia> G = SymmetricGroup(4)\nFull symmetric group over 4 elements\n\njulia> chi = character(Partition([3,1])); # character of the regular representation\n\n\njulia> chi(one(G))\n3\n\njulia> chi(perm\"(1,3)(2,4)\")\n-1\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, Perm}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition, p::Perm, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character of the permutation group on permutation p.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.character","text":"character(lambda::Partition, mu::Partition, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character on the conjugacy class represented by partition mu.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.rowlength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.rowlength","text":"rowlength(Y::YoungTableau, i, j)\n\nReturn the row length of Y at box (i,j), i.e. the number of boxes in the i-th row of the diagram of Y located to the right of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> Generic.rowlength(y, 1,2)\n2\n\njulia> Generic.rowlength(y, 2,3)\n0\n\njulia> Generic.rowlength(y, 3,3)\n0\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.collength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.collength","text":"collength(Y::YoungTableau, i, j)\n\nReturn the column length of Y at box (i,j), i.e. the number of boxes in the j-th column of the diagram of Y located below of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> Generic.collength(y, 1,1)\n2\n\njulia> Generic.collength(y, 1,3)\n1\n\njulia> Generic.collength(y, 2,4)\n0\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.hooklength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.hooklength","text":"hooklength(Y::YoungTableau, i, j)\n\nReturn the hook-length of an element in Y at position (i,j), i.e the number of cells in the i-th row to the right of (i,j)-th box, plus the number of cells in the j-th column below the (i,j)-th box, plus 1.\n\nReturn 0 for (i,j) not in the tableau Y.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> hooklength(y, 1,1)\n6\n\njulia> hooklength(y, 1,3)\n3\n\njulia> hooklength(y, 2,4)\n0\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.dim-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.dim","text":"dim(Y::YoungTableau) -> BigInt\n\nReturn the dimension (using hook-length formula) of the irreducible representation of permutation group S_n associated the partition Y.part.\n\nSince the computation overflows easily BigInt is returned. You may perform the computation of the dimension in different type by calling dim(Int, Y).\n\nExamples\n\njulia> dim(YoungTableau([4,3,1]))\n70\n\njulia> dim(YoungTableau([3,1])) # the regular representation of S_4\n3\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.partitionseq","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.partitionseq","text":"partitionseq(lambda::Partition)\n\nReturn a sequence (as BitVector) of falses and trues constructed from lambda: tracing the lower contour of the Young Diagram associated to lambda from left to right a true is inserted for every horizontal and false for every vertical step. The sequence always starts with true and ends with false.\n\n\n\n\n\npartitionseq(seq::BitVector)\n\nReturn the essential part of the sequence seq, i.e. a subsequence starting at first true and ending at last false.\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.is_rimhook-Tuple{BitVector, Int64, Int64}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.is_rimhook","text":"is_rimhook(R::BitVector, idx::Integer, len::Integer)\n\nR[idx:idx+len] forms a rim hook in the Young Diagram of partition corresponding to R iff R[idx] == true and R[idx+len] == false.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.MN1inner","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.MN1inner","text":"MN1inner(R::BitVector, mu::Partition, t::Integer, charvals)\n\nReturn the value of lambda-th irreducible character on conjugacy class of permutations represented by partition mu, where R is the (binary) partition sequence representing lambda. Values already computed are stored in charvals::Dict{Tuple{BitVector,Vector{Int}}, Int}. This is an implementation (with slight modifications) of the Murnaghan-Nakayama formula as described in\n\nDan Bernstein,\n\"The computational complexity of rules for the character table of Sn\"\n_Journal of Symbolic Computation_, 37(6), 2004, p. 727-748.\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.SkewDiagram","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.SkewDiagram","text":"SkewDiagram(lambda::Partition, mu::Partition) <: AbstractMatrix{Int}\n\nImplements a skew diagram, i.e. a difference of two Young diagrams represented by partitions lambda and mu. (below dots symbolise the removed entries)\n\nExamples\n\njulia> l = Partition([4,3,2])\n4₁3₁2₁\n\njulia> m = Partition([3,1,1])\n3₁1₂\n\njulia> xi = SkewDiagram(l,m)\n3×4 AbstractAlgebra.Generic.SkewDiagram{Int64}:\n ⋅  ⋅  ⋅  1\n ⋅  1  1\n ⋅  1\n\n\n\n\n\n\n","category":"type"},{"location":"ytabs/#Base.size-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"Base.size","text":"size(xi::SkewDiagram)\n\nReturn the size of array where xi is minimally contained. See size(Y::YoungTableau) for more details.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.in-Tuple{Tuple{Integer, Integer}, AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"Base.in","text":"in(t::Tuple{Integer,Integer}, xi::SkewDiagram)\n\nCheck if box at position (i,j) belongs to the skew diagram xi.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#Base.getindex-Tuple{AbstractAlgebra.Generic.SkewDiagram, Integer}","page":"Partitions and Young tableaux","title":"Base.getindex","text":"getindex(xi::SkewDiagram, n::Integer)\n\nReturn 1 if linear index n corresponds to (column-major) entry in xi.lam which is not contained in xi.mu. Otherwise return 0.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.is_rimhook-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.is_rimhook","text":"is_rimhook(xi::SkewDiagram)\n\nCheck if xi represents a rim-hook diagram, i.e. its diagram is edge-connected and contains no 2times 2 squares.\n\n\n\n\n\n","category":"method"},{"location":"ytabs/#AbstractAlgebra.Generic.leglength","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.leglength","text":"leglength(xi::SkewDiagram[, check::Bool=true])\n\nCompute the leglength of a rim-hook xi, i.e. the number of rows with non-zero entries minus one. If check is false function will not check whether xi is actually a rim-hook.\n\n\n\n\n\n","category":"function"},{"location":"ytabs/#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(xi::SkewDiagram)\n\nReturn a sparse representation of the diagram xi, i.e. a sparse array A where A[i,j] == 1 if and only if (i,j) is in xi.lam but not in xi.mu.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#Univariate-polynomials-over-a-noncommutative-ring","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"AbstractAlgebra.jl provides a module, implemented in src/NCPoly.jl for univariate polynomials over any noncommutative ring in the AbstractAlgebra type hierarchy.","category":"section"},{"location":"ncpolynomial/#Generic-type-for-univariate-polynomials-over-a-noncommutative-ring","page":"Univariate polynomials over a noncommutative ring","title":"Generic type for univariate polynomials over a noncommutative ring","text":"AbstractAlgebra.jl implements a generic univariate polynomial type over noncommutative rings in src/generic/NCPoly.jl.\n\nThese generic polynomials have type Generic.NCPoly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of such polynomials have type Generic.NCPolyRing{T}.\n\nThe string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"section"},{"location":"ncpolynomial/#Abstract-types","page":"Univariate polynomials over a noncommutative ring","title":"Abstract types","text":"The polynomial element types belong to the abstract type NCPolyRingElem{T} and the polynomial ring types belong to the abstract type NCPolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.\n\nnote: Note\nNote that both the generic polynomial ring type Generic.NCPolyRing{T} and the abstract type it belongs to, NCPolyRing{T} are both called NCPolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"section"},{"location":"ncpolynomial/#Polynomial-ring-constructors","page":"Univariate polynomials over a noncommutative ring","title":"Polynomial ring constructors","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.\n\nA shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.\n\nR[:x]\n\nHere are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.\n\nExamples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> U, z = R[:z]\n(Univariate polynomial ring in z over matrix ring, z)\n\njulia> f = S()\n0\n\njulia> g = S(123)\n[123 0; 0 123]\n\njulia> h = T(BigInt(1234))\n[1234 0; 0 1234]\n\njulia> k = T(x + 1)\nx + 1\n\njulia> m = U(z + 1)\nz + 1\n\n\nAll of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a polynomial_ring constructor to allow creation of their polynomial rings.","category":"section"},{"location":"ncpolynomial/#Basic-ring-functionality","page":"Univariate polynomials over a noncommutative ring","title":"Basic ring functionality","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.\n\nThe easiest way is simply using the generator returned by the polynomial_ring constructor and build up the polynomial using basic arithmetic, as described in the Ring interface.\n\nThe Julia language also has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.\n\nThe polynomial rings in AbstractAlgebra.jl implement the full Ring interface. Of course the entire Univariate Polynomial Ring interface is also implemented.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + [3 0; 0 3]*x + [21 0; 0 21]\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + [2 0; 0 2]*x + 1\n\njulia> h = zero(T)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(g)\n3\n\njulia> U = base_ring(T)\nUnivariate polynomial ring in x over matrix ring\n\njulia> V = base_ring(y + 1)\nUnivariate polynomial ring in x over matrix ring\n\njulia> v = var(T)\n:y\n\njulia> U = parent(y + 1)\nUnivariate polynomial ring in y over S\n\njulia> g == deepcopy(g)\ntrue","category":"section"},{"location":"ncpolynomial/#Polynomial-functionality-provided-by-AbstractAlgebra.jl","page":"Univariate polynomials over a noncommutative ring","title":"Polynomial functionality provided by AbstractAlgebra.jl","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any polynomial module that implements the full Univariate Polynomial Ring interface over a noncommutative ring. This includes AbstractAlgebra.jl's own generic polynomial rings.\n\nBut if a C library provides all the functionality documented in the Univariate Polynomial Ring interface over a noncommutative ring, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that polynomial type.\n\nOf course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"section"},{"location":"ncpolynomial/#Basic-functionality","page":"Univariate polynomials over a noncommutative ring","title":"Basic functionality","text":"Examples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> a = zero(T)\n0\n\njulia> b = one(T)\n1\n\njulia> c = BigInt(1)*y^2 + BigInt(1)\ny^2 + 1\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(T)\ny\n\njulia> g = is_gen(y)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> is_term(2y^2)\ntrue\n\njulia> is_monomial(y^2)\ntrue\n","category":"section"},{"location":"ncpolynomial/#Truncation","page":"Univariate polynomials over a noncommutative ring","title":"Truncation","text":"Examples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + [2 0; 0 2]*x + [2 0; 0 2]\n\njulia> h = truncate(f, 1)\n[3 0; 0 3]\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + [3 0; 0 3]*x^2 + [4 0; 0 4]*x + 1)*y^2 + (x^4 + x^3 + [2 0; 0 2]*x^2 + [7 0; 0 7]*x + [5 0; 0 5])*y + [3 0; 0 3]*x^3 + [6 0; 0 6]*x + [6 0; 0 6]\n","category":"section"},{"location":"ncpolynomial/#Reversal","page":"Univariate polynomials over a noncommutative ring","title":"Reversal","text":"Examples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = reverse(f, 7)\n[3 0; 0 3]*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n[3 0; 0 3]*y^2 + (x + 1)*y + x\n","category":"section"},{"location":"ncpolynomial/#Shifting","page":"Univariate polynomials over a noncommutative ring","title":"Shifting","text":"Examples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + [3 0; 0 3]*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"section"},{"location":"ncpolynomial/#Evaluation","page":"Univariate polynomials over a noncommutative ring","title":"Evaluation","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a).\n\nExamples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> k = evaluate(f, 3)\n[12 0; 0 12]*x + [6 0; 0 6]\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + [4 0; 0 4]*x^4 + [7 0; 0 7]*x^3 + [7 0; 0 7]*x^2 + [4 0; 0 4]*x + [4 0; 0 4]\n\njulia> r = f(23)\n[552 0; 0 552]*x + [26 0; 0 26]\n","category":"section"},{"location":"ncpolynomial/#Derivative","page":"Univariate polynomials over a noncommutative ring","title":"Derivative","text":"Examples\n\njulia> R = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> S, x = polynomial_ring(R, :x)\n(Univariate polynomial ring in x over matrix ring, x)\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> h = derivative(f)\n[2 0; 0 2]*x*y + x + 1\n","category":"section"},{"location":"ncpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{NCRing, Union{Char, AbstractString, Symbol}}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::NCRing, s::VarName = :x; cached::Bool=true)\n\nGiven a base ring R and symbol/string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring.\n\nBy default the parent object S depends only on R and x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.leading_coefficient-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(a::PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.trailing_coefficient-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.trailing_coefficient","text":"trailing_coefficient(a::PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.gen-Tuple{AbstractAlgebra.NCPolyRing}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.gen","text":"gen(R::NCPolyRing)\n\nReturn the generator of the given polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.is_gen-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.is_gen","text":"is_gen(a::PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.is_monomial-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.is_monomial","text":"is_monomial(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.is_term-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.is_term","text":"is_term(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#Base.truncate-Tuple{NCPolyRingElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"Base.truncate","text":"truncate(a::PolynomialElem, n::Int)\n\nReturn a truncated to n terms, i.e. the remainder upon division by x^n.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.mullow-Union{Tuple{T}, Tuple{NCPolyRingElem{T}, NCPolyRingElem{T}, Int64}} where T<:NCRingElem","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.mullow","text":"mullow(a::NCPolyRingElem{T}, b::NCPolyRingElem{T}, n::Int) where T <: NCRingElem\n\nReturn atimes b truncated to n terms.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#Base.reverse-Tuple{NCPolyRingElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"Base.reverse","text":"reverse(x::PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#Base.reverse-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"Base.reverse","text":"reverse(x::PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.shift_left-Tuple{NCPolyRingElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.shift_left","text":"shift_left(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.shift_right-Tuple{NCPolyRingElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.shift_right","text":"shift_right(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.evaluate-Tuple{NCPolyRingElem, NCRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.evaluate","text":"evaluate(a::NCPolyRingElem, b::NCRingElement)\n\nEvaluate the polynomial a at the value b and return the result.\n\n\n\n\n\n","category":"method"},{"location":"ncpolynomial/#AbstractAlgebra.derivative-Tuple{NCPolyRingElem}","page":"Univariate polynomials over a noncommutative ring","title":"AbstractAlgebra.derivative","text":"derivative(a::PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#Free-algebras","page":"Free algebras","title":"Free algebras","text":"AbstractAlgebra.jl provides a module, implemented in src/FreeAssociativeAlgebra.jl for free associative algebras over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"section"},{"location":"free_associative_algebra/#Generic-free-algebra-types","page":"Free algebras","title":"Generic free algebra types","text":"AbstractAlgebra provides a generic type Generic.FreeAssociativeAlgebraElem{T} where T is the type of elements of the coefficient ring. The elements are implemented using a Julia array of coefficients and a vector of vectors of Ints for the monomial words. Parent objects of such elements have type Generic.FreeAssociativeAlgebra{T}.\n\nThe element types belong to the abstract type NCRingElem, and the algebra types belong to the abstract type NCRing.\n\nThe following basic functions are implemented.\n\nbase_ring(R::FreeAssociativeAlgebra)\nbase_ring(a::FreeAssociativeAlgebraElem)\nparent(a::FreeAssociativeAlgebraElem)","category":"section"},{"location":"free_associative_algebra/#Free-algebra-constructors","page":"Free algebras","title":"Free algebra constructors","text":"free_associative_algebra(R::Ring, s::AbstractVector{<:VarName}; cached::Bool = true)\nfree_associative_algebra(R::Ring, n::Int, s::VarName; cached::Bool = false)\n\nThe first constructor, given a base ring R and an array s of variables, will return a tuple S, (x, ...) representing the new algebra S = R leftx ldots right and a tuple of generators (x ).\n\nThe second constructor given a string s and a number of variables n will do the same as the first constructor except that the variables will be automatically numbered as, s1, s2, ..., sn.\n\nBy default the parent object S will depend only on R and  (x, ...) and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nExamples\n\njulia> R, (x, y) = free_associative_algebra(ZZ, [:x, :y])\n(Free associative algebra on 2 indeterminates over integers, AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{BigInt}[x, y])\n\njulia> (x + y + 1)^2\nx^2 + x*y + y*x + y^2 + 2*x + 2*y + 1\n\n\njulia> (x*y*x*x)^4\nx*y*x^3*y*x^3*y*x^3*y*x^2","category":"section"},{"location":"free_associative_algebra/#Free-algebra-element-constructors","page":"Free algebras","title":"Free algebra element constructors","text":"Elements of a free algebra can be constructed from the generators in the usual way using arithmetic operations. Also, all of the standard ring element constructors may be used. Finally, the MPolyBuildCtx is overloaded to work with coefficients and monomial words and not exponent vectors.\n\nExamples\n\njulia> R, (x, y, z) = free_associative_algebra(ZZ, [:x, :y, :z])\n(Free associative algebra on 3 indeterminates over integers, AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{BigInt}[x, y, z])\n\njulia> B = MPolyBuildCtx(R)\nBuilder for an element of R\n\njulia> push_term!(B, ZZ(1), [1,2,3,1]); push_term!(B, ZZ(2), [3,3,1]); finish(B)\nx*y*z*x + 2*z^2*x\n\njulia> push_term!(B, ZZ(3), [3,3,3]); push_term!(B, ZZ(4), Int[]); finish(B)\n3*z^3 + 4\n\njulia> [gen(R, 2), R(9)]\n2-element Vector{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{BigInt}}:\n y\n 9","category":"section"},{"location":"free_associative_algebra/#Element-functions","page":"Free algebras","title":"Element functions","text":"","category":"section"},{"location":"free_associative_algebra/#Basic-manipulation","page":"Free algebras","title":"Basic manipulation","text":"The standard ring functions are available. The following functions from the multivariate polynomial interface are provided.\n\nsymbols(S::FreeAssociativeAlgebra)\nnumber_of_variables(f::FreeAssociativeAlgebra)\ngens(S::FreeAssociativeAlgebra)\ngen(S::FreeAssociativeAlgebra, i::Int)\nis_gen(x::FreeAssociativeAlgebraElem)\ntotal_degree(a::FreeAssociativeAlgebraElem)\nlength(f::FreeAssociativeAlgebraElem)\n\nAs with multivariate polynomials, an implementation must provide access to the elements as a sum of individual terms in some order. The length function provides the number of such terms, and the following functions provide the first such term.\n\nleading_coefficient(a::FreeAssociativeAlgebraElem)\nleading_monomial(a::FreeAssociativeAlgebraElem)\nleading_term(a::FreeAssociativeAlgebraElem)\nleading_exponent_word(a::FreeAssociativeAlgebraElem)\n\nFor types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.\n\ncoeff(f::FreeAssociativeAlgebraElem, n::Int)\nmonomial(f::FreeAssociativeAlgebraElem, n::Int)\nterm(f::FreeAssociativeAlgebraElem, n::Int)\n\nIn contrast with the interface for multivariable polynomials, the function exponent_vector is replaced by exponent_word\n\nExamples\n\njulia> R, (x, y, z) = free_associative_algebra(ZZ, [:x, :y, :z])\n(Free associative algebra on 3 indeterminates over integers, AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{BigInt}[x, y, z])\n\njulia> map(total_degree, (R(0), R(1), -x^2*y^2*z^2*x + z*y))\n(-1, 0, 7)\n\njulia> leading_term(-x^2*y^2*z^2*x + z*y)\n-x^2*y^2*z^2*x\n\njulia> leading_monomial(-x^2*y^2*z^2*x + z*y)\nx^2*y^2*z^2*x\n\njulia> leading_coefficient(-x^2*y^2*z^2*x + z*y)\n-1\n\njulia> exponent_word(-x^2*y^2*z^2*x + z*y, 1)\n7-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n 3\n 1","category":"section"},{"location":"free_associative_algebra/#Iterators","page":"Free algebras","title":"Iterators","text":"The following iterators are provided for elements of a free associative algebra, with exponent_words providing the analogous functionality that exponent_vectors provides for multivariate polynomials.\n\nterms(p::FreeAssociativeAlgebraElem)\ncoefficients(p::FreeAssociativeAlgebraElem)\nmonomials(p::FreeAssociativeAlgebraElem)\n\nExamples\n\njulia> R, (a, b, c) = free_associative_algebra(ZZ, [:a, :b, :c])\n(Free associative algebra on 3 indeterminates over integers, AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{BigInt}[a, b, c])\n\njulia> collect(terms(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n 3*b*a*c\n -b\n c\n 2\n\njulia> collect(coefficients(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n  3\n -1\n  1\n  2\n\njulia> collect(monomials(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n b*a*c\n b\n c\n 1\n\njulia> collect(exponent_words(3*b*a*c - b + c + 2))\n4-element Vector{Vector{Int64}}:\n [2, 1, 3]\n [2]\n [3]\n []","category":"section"},{"location":"free_associative_algebra/#Groebner-bases","page":"Free algebras","title":"Groebner bases","text":"The function groebner_basis provides the computation of a Groebner basis of an ideal, given a set of generators of that ideal. Since such a Groebner basis is not necessarily finite, one can additionally pass a reduction_bound to the function, to only compute a partial Groebner basis.\n\nThe implementation uses a non-commutative version of the Buchberger algorithm as described in\n\nXingqiang Xiu, Non-commutative Gröbner Bases and Applications, PhD thesis, 2012.\n\nExamples\n\njulia> R = @free_associative_algebra(GF(2), [:x, :y, :u, :v, :t, :s])\nFree associative algebra on 6 indeterminates x, y, u, v, ..., s\n  over finite field F_2\n\njulia> g = Generic.groebner_basis([u*(x*y)^3 + u*(x*y)^2 + u + v, (y*x)^3*t + (y*x)^2*t + t + s])\n5-element Vector{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{AbstractAlgebra.GFElem{Int64}}}:\n u*x*y*x*y*x*y + u*x*y*x*y + u + v\n y*x*y*x*y*x*t + y*x*y*x*t + t + s\n u*x*s + v*x*t\n u*x*y*x*s + v*x*y*x*t\n u*x*y*x*y*x*s + v*x*y*x*y*x*t\n\nIn order to check whether a given element of the algebra is in the ideal generated by a Groebner basis g, one can compute its normal form.\n\njulia> R = @free_associative_algebra(GF(2), [:x, :y, :u, :v, :t, :s]);\n\njulia> g = Generic.groebner_basis([u*(x*y)^3 + u*(x*y)^2 + u + v, (y*x)^3*t + (y*x)^2*t + t + s]);\n\njulia> normal_form(u*(x*y)^3*s*t + u*(x*y)^2*s*t +u*s*t + v*s*t, g)\n0","category":"section"},{"location":"free_associative_algebra/#AbstractAlgebra.Generic.exponent_word-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, Int64}} where T<:RingElement","page":"Free algebras","title":"AbstractAlgebra.Generic.exponent_word","text":"exponent_word(a::FreeAssociativeAlgebraElem{T}, i::Int) where T <: RingElement\n\nReturn a vector of variable indices corresponding to the monomial of the i-th term of a. Term numbering begins at 1, and the variable indices are given in the order of the variables for the ring.\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{FreeAssociativeAlgebraElem{T}, Vector{U}}} where {T<:RingElement, U<:NCRingElem}","page":"Free algebras","title":"AbstractAlgebra.evaluate","text":"evaluate(a::FreeAssociativeAlgebraElem{T}, vals::Vector{U}) where {T <: RingElement, U <: NCRingElem}\n\nEvaluate a by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\nThe syntax a(vals...) is also supported.\n\nExamples\n\njulia> R, (x, y) = free_associative_algebra(ZZ, [\"x\", \"y\"]);\n\njulia> f = x*y - y*x\nx*y - y*x\n\njulia> S = matrix_ring(ZZ, 2);\n\njulia> m1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> m2 = S([0 1; 1 0])\n[0   1]\n[1   0]\n\njulia> evaluate(f, [m1, m2])\n[-1   -3]\n[ 3    1]\n\njulia> m1*m2 - m2*m1 == evaluate(f, [m1, m2])\ntrue\n\njulia> m1*m2 - m2*m1 == f(m1, m2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#AbstractAlgebra.exponent_words-Union{Tuple{FreeAssociativeAlgebraElem{T}}, Tuple{T}} where T<:RingElement","page":"Free algebras","title":"AbstractAlgebra.exponent_words","text":"exponent_words(a::FreeAssociativeAlgebraElem{T}) where T <: RingElement\n\nReturn an iterator for the exponent words of the given polynomial. To retrieve an array of the exponent words, use collect(exponent_words(a)).\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#AbstractAlgebra.Generic.groebner_basis-Union{Tuple{Array{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, 1}}, Tuple{T}, Tuple{Array{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, 1}, Int64}, Tuple{Array{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, 1}, Int64, Bool}} where T<:FieldElement","page":"Free algebras","title":"AbstractAlgebra.Generic.groebner_basis","text":"groebner_basis(g::Vector{FreeAssociativeAlgebraElem{T}}, reduction_bound::Int = typemax(Int), remove_redundancies::Bool = false; obstruction_free_set::Vector{FreeAssociativeAlgebraElem{T}})\n\nCompute a Groebner basis for the ideal generated by g. Stop when reduction_bound many non-zero entries have been added to the Groebner basis. If the computation stops due to the bound being exceeded, the result is in general not an actual Groebner basis, just a subset of one. However, whenever the normal form with respect to this incomplete Groebner basis is 0, it will also be 0 with respect to the full Groebner basis.\n\nIf remove_redundancies is set to true, some redundant obstructions will be removed during the computation, which might save time, however in practice it seems to inflate the running time regularly.\n\nOne can provide the keyword argument obstruction_free_set with a precomputed partial Groebner basis. It is assumed (but not checked) that all entries of obstruction_free_set are indeed contained in the ideal generated by g.\n\nExample\n\njulia> R, (a, b) = free_associative_algebra(QQ, [\"a\", \"b\"]);\n\njulia> f1 = a^2 -1;\n\njulia> f2 = b^3 -1;\n\njulia> f3 = a*b*a*b^2*a*b*a - b;\n\njulia> g = AbstractAlgebra.groebner_basis([(a*b*a*b^2)^2 - 1]; obstruction_free_set = [f1,f2,f3])\n12-element Vector{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{Rational{BigInt}}}:\n a^2 - 1\n b^3 - 1\n a*b*a*b^2*a*b*a - b\n a*b*a*b^2*a*b*a*b^2 - 1\n -b*a*b^2*a*b*a*b^2 + a\n -b*a*b^2*a*b*a + a*b\n -b*a*b^2*a*b + a*b*a\n -a*b^2*a*b + b^2*a*b*a\n b^2*a*b*a*b^2 - a*b^2*a\n -a*b*a*b^2 + b*a*b^2*a\n b^2*a*b*a*b*a*b - a*b*a*b*a\n -a*b*a*b*a*b + b*a*b*a*b*a\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#AbstractAlgebra.Generic.normal_form-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, Array{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, 1}, AbstractAlgebra.Generic.AhoCorasickAutomaton}} where T","page":"Free algebras","title":"AbstractAlgebra.Generic.normal_form","text":"normal_form(f::FreeAssociativeAlgebraElem{T}, g::Vector{FreeAssociativeAlgebraElem{T}}, aut::AhoCorasickAutomaton)\n\nAssuming g is a Groebner basis and aut an Aho-Corasick automaton for the elements of g, compute the normal form of f with respect to g\n\n\n\n\n\n","category":"method"},{"location":"free_associative_algebra/#AbstractAlgebra.Generic.interreduce!-Union{Tuple{Array{AbstractAlgebra.Generic.FreeAssociativeAlgebraElem{T}, 1}}, Tuple{T}} where T","page":"Free algebras","title":"AbstractAlgebra.Generic.interreduce!","text":"interreduce!(g::Vector{FreeAssociativeAlgebraElem{T}}) where T\n\nInterreduce a given Groebner basis with itself, i.e. compute the normal form of each element of g with respect to the rest of the elements and discard elements with normal form 0 and duplicates.\n\n\n\n\n\n","category":"method"},{"location":"rational/#Rational-field","page":"Rational field","title":"Rational field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Rational.jl for making Julia Rational{BigInt}s conform to the AbstractAlgebra.jl Field interface.\n\nIn addition to providing a parent object QQ for Julia Rational{BigInt}s, we implement any additional functionality required by AbstractAlgebra.jl.\n\nBecause Rational{BigInt} cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia Rational{BigInt}s by introducing a type union, called FieldElement, which is a union of FieldElem and a number of Julia types, including Rational{BigInt}. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.\n\nThe details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia Rational{BigInt} type as belonging to FieldElem.\n\nOne other technicality is that Julia defines certain functions for Rational{BigInt}, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.\n\nTo access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"section"},{"location":"rational/#Types-and-parent-objects","page":"Rational field","title":"Types and parent objects","text":"Rationals have type Rational{BigInt}, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.\n\nThe parent objects of such integers has type Rationals{BigInt}.\n\nFor convenience, we also make Rational{Int} a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as qq) has type Rationals{Int}. But we caution that this type is not particularly useful as a model of the rationals and may not function as expected within AbstractAlgebra.jl.","category":"section"},{"location":"rational/#Rational-constructors","page":"Rational field","title":"Rational constructors","text":"In order to construct rationals in AbstractAlgebra.jl, one can first construct the rational field itself. This is accomplished using either of the following constructors.\n\nfraction_field(R::Integers{BigInt})\n\nRationals{BigInt}()\n\nThis gives the unique object of type Rationals{BigInt} representing the field of rationals in AbstractAlgebra.jl.\n\nIn practice, one simply uses QQ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.\n\nHere are some examples of creating the rational field and making use of the resulting parent object to coerce various elements into the field.\n\nExamples\n\njulia> f = QQ()\n0//1\n\njulia> g = QQ(123)\n123//1\n\njulia> h = QQ(BigInt(1234))\n1234//1\n\njulia> k = QQ(BigInt(12), BigInt(7))\n12//7\n\njulia> QQ == fraction_field(ZZ)\ntrue\n","category":"section"},{"location":"rational/#Basic-field-functionality","page":"Rational field","title":"Basic field functionality","text":"The rational field in AbstractAlgebra.jl implements the full Field and Fraction Field interfaces.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> f = QQ(12, 7)\n12//7\n\njulia> h = zero(QQ)\n0//1\n\njulia> k = one(QQ)\n1//1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(QQ)\nIntegers\n\njulia> V = base_ring(f)\nIntegers\n\njulia> T = parent(f)\nRationals\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n96//7\n\njulia> r = ZZ(12)//ZZ(7)\n12//7\n\njulia> n = numerator(r)\n12\n","category":"section"},{"location":"rational/#Rational-functionality-provided-by-AbstractAlgebra.jl","page":"Rational field","title":"Rational functionality provided by AbstractAlgebra.jl","text":"The functionality below supplements that provided by Julia itself for its Rational{BigInt} type.","category":"section"},{"location":"rational/#Square-and-n-th-root","page":"Rational field","title":"Square and n-th root","text":"The functions sqrt, is_square, is_square_with_sqrt are all provided, as are root and is_power.\n\nExamples\n\njulia> d = AbstractAlgebra.sqrt(ZZ(36)//ZZ(25))\n6//5\n\njulia> is_square(ZZ(9)//ZZ(16))\ntrue\n\njulia> root(ZZ(27)//64, 3)\n3//4","category":"section"},{"location":"matrix/#matrix_functionality_chapter","page":"Matrix functionality","title":"Matrix functionality","text":"","category":"section"},{"location":"matrix/#Basic-matrix-functionality","page":"Matrix functionality","title":"Basic matrix functionality","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices and to set and retrieve entries and other basic data associated with the matrices.\n\nIt is possible to create matrices directly, without first creating a corresponding matrix space. The following constructors are necessary, because unfortunately, Julia's matrices and linear algebra cannot be made to work in our context due to two independent problems:\n\nIn empty matrices (0 rows or columns) all that is known is the type of the matrix entries,\n\nhowever for the complex types used in AbstractAlgebra, this information is not sufficient to create elements, hence zero(T) or friends cannot work\n\nMany functions (e.g. det) assume that all types used embed into the real or complex numbers,\n\nin Julia det(ones(Int, (1,1))) == 1.0, so the fact that this is exactly the integer 1 is lost. Furthermore, more general rings cannot be embedded into the reals at all.\n\nmatrix(R::Ring, arr::Matrix{T}) where T <: RingElement\n\nGiven an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.\n\nmatrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T <: RingElement\n\nConstruct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.\n\nzero_matrix(R::Ring, r::Int, c::Int)\n\nConstruct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.\n\nExamples\n\njulia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> N = matrix(ZZ, 3, 2, BigInt[3, 1, 2, 2, 0, 1])\n[3   1]\n[2   2]\n[0   1]\n\njulia> P = zero_matrix(ZZ, 3, 2)\n[0   0]\n[0   0]\n[0   0]","category":"section"},{"location":"matrix/#Inverse","page":"Matrix functionality","title":"Inverse","text":"Examples\n\njulia> M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])\n[1//1   2//1   3//1]\n[4//1   5//1   6//1]\n[0//1   0//1   1//1]\n\njulia> X = inv(M)\n[-5//3    2//3    1//1]\n[ 4//3   -1//3   -2//1]\n[ 0//1    0//1    1//1]\n\njulia> is_invertible(M)\ntrue\n\njulia> is_invertible_with_inverse(M)\n(true, [-5//3 2//3 1; 4//3 -1//3 -2; 0 0 1])\n\njulia> pseudo_inv(M)\n([5 -2 -3; -4 1 6; 0 0 -3], -3//1)","category":"section"},{"location":"matrix/#Submatrices","page":"Matrix functionality","title":"Submatrices","text":"Submatrices are only available for matrix spaces, not for matrix algebras and generally only available for generic matrices built on Julia arrays.\n\nSubmatrices return a new matrix with the same entries as the submatrix with the given range of rows and columns. They are best illustrated with examples.\n\nExamples\n\njulia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = M[:, :]\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N3 = M[2:3, 2:3]\n[3   4]\n[4   5]\n\nAs per Julia, AbstractAlgebra supports the construction of matrix views. These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.\n\nThe syntax for views is as for Julia's own views.\n\nExamples\n\njulia> M = matrix(ZZ, 3, 3, BigInt[1, 2, 3, 2, 3, 4, 3, 4, 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = @view M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = @view M[:, 1:2]\n[1   2]\n[2   3]\n[3   4]\n\njulia> R = N1*N2\n[14   20]\n[20   29]","category":"section"},{"location":"matrix/#Elementary-row-and-column-operations","page":"Matrix functionality","title":"Elementary row and column operations","text":"Examples\n\njulia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> add_column(M, 2, 3, 1)\n[ 7   2   3]\n[10   3   4]\n[14   5   5]\n\njulia> add_row(M, 1, 2, 3)\n[1   2   3]\n[2   3   4]\n[6   8   9]\n\njulia> multiply_column(M, 2, 3)\n[1   2    6]\n[2   3    8]\n[4   5   10]\n\njulia> multiply_row(M, 2, 3)\n[1    2    3]\n[2    3    4]\n[8   10   10]","category":"section"},{"location":"matrix/#Swapping-rows-and-columns","page":"Matrix functionality","title":"Swapping rows and columns","text":"Swap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"section"},{"location":"matrix/#Concatenation","page":"Matrix functionality","title":"Concatenation","text":"The following are only available for matrix spaces, not for matrix algebras.\n\nhcat(M::T, N::T) where T <: MatElem\n\nReturn the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.\n\nvcat(M::T, N::T) where T <: MatElem\n\nReturn the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.\n\nExamples\n\njulia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N = matrix(ZZ, BigInt[1 0 1; 0 1 0; 1 0 1])\n[1   0   1]\n[0   1   0]\n[1   0   1]\n\njulia> P = hcat(M, N)\n[1   2   3   1   0   1]\n[2   3   4   0   1   0]\n[3   4   5   1   0   1]\n\njulia> Q = vcat(M, N)\n[1   2   3]\n[2   3   4]\n[3   4   5]\n[1   0   1]\n[0   1   0]\n[1   0   1]\n","category":"section"},{"location":"matrix/#Linear-solving","page":"Matrix functionality","title":"Linear solving","text":"See Linear Solving & Kernel","category":"section"},{"location":"matrix/#Block-diagonal-matrix-constructors","page":"Matrix functionality","title":"Block diagonal matrix constructors","text":"It is also possible to create block diagonal matrices from a vector of existing matrices. It is also possible to construct them from Julia matrices if one supplies the base ring.\n\nNote that if the input matrices are not square, the output matrix may not be square.\n\nExamples\n\njulia> block_diagonal_matrix(ZZ, [[1 2; 3 4], [4 5 6; 7 8 9]])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]\n\njulia> M = matrix(ZZ, [1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> N = matrix(ZZ, [4 5 6; 7 8 9])\n[4   5   6]\n[7   8   9]\n\njulia> block_diagonal_matrix([M, N])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]","category":"section"},{"location":"matrix/#Similar-and-zero","page":"Matrix functionality","title":"Similar and zero","text":"Both similar and zero construct new matrices, but the entries are either undefined with similar or zero-initialized with zero.\n\nsimilar(x::MatElem, R::Ring=base_ring(x))\nzero(x::MatElem, R::Ring=base_ring(x))\n\nConstruct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.\n\nsimilar(x::MatElem, R::Ring, r::Int, c::Int)\nsimilar(x::MatElem, r::Int, c::Int)\nzero(x::MatElem, R::Ring, r::Int, c::Int)\nzero(x::MatElem, r::Int, c::Int)\n\nConstruct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).\n\nBase.isassigned(M::MatElem, i, j)\n\nTest whether the given matrix has a value associated with indices i and j.\n\nExamples\n\njulia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> isassigned(M, 1, 2)\ntrue\n\njulia> isassigned(M, 4, 4)\nfalse\n\njulia> A = similar(M)\n[#undef   #undef   #undef]\n[#undef   #undef   #undef]\n\njulia> isassigned(A, 1, 2)\nfalse\n\njulia> B = zero(M)\n[0   0   0]\n[0   0   0]\n\njulia> C = similar(M, 4, 5)\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n\njulia> base_ring(B)\nIntegers\n\njulia> D = zero(M, QQ, 2, 2)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> base_ring(D)\nRationals","category":"section"},{"location":"matrix/#LU-factorisation","page":"Matrix functionality","title":"LU factorisation","text":"Examples\n\njulia> M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])\n[1//1   2//1   3//1]\n[4//1   5//1   6//1]\n[0//1   0//1   1//1]\n\njulia> r, P, L, U = lu(M)\n(3, (), [1 0 0; 4 1 0; 0 0 1], [1 2 3; 0 -3 -6; 0 0 1])\n\njulia> r, d, P, L, U = fflu(M)\n(3, -3//1, (), [1 0 0; 4 -3 0; 0 0 -3], [1 2 3; 0 -3 -6; 0 0 -3])","category":"section"},{"location":"matrix/#Reduced-row-echelon-form","page":"Matrix functionality","title":"Reduced row-echelon form","text":"Examples\n\njulia> M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])\n[1//1   2//1   3//1]\n[4//1   5//1   6//1]\n[0//1   0//1   1//1]\n\njulia> r1, A = rref(M)\n(3, [1 0 0; 0 1 0; 0 0 1])\n\njulia> N = matrix(ZZ, 3, 3, [1 2 3;4 5 6;0 0 1])\n[1   2   3]\n[4   5   6]\n[0   0   1]\n\njulia> r2, B = rref_rational(N)\n(3, [-3 0 0; 0 -3 0; 0 0 -3], -3)\n\njulia> is_rref(A)\ntrue\n\njulia> is_rref(B)\ntrue","category":"section"},{"location":"matrix/#Other-functionality","page":"Matrix functionality","title":"Other functionality","text":"","category":"section"},{"location":"matrix/#Symmetry-testing","page":"Matrix functionality","title":"Symmetry testing","text":"","category":"section"},{"location":"matrix/#Powering","page":"Matrix functionality","title":"Powering","text":"","category":"section"},{"location":"matrix/#Gram-matrix","page":"Matrix functionality","title":"Gram matrix","text":"","category":"section"},{"location":"matrix/#Content","page":"Matrix functionality","title":"Content","text":"","category":"section"},{"location":"matrix/#Permutation","page":"Matrix functionality","title":"Permutation","text":"","category":"section"},{"location":"matrix/#Nilpotency","page":"Matrix functionality","title":"Nilpotency","text":"","category":"section"},{"location":"matrix/#Minors","page":"Matrix functionality","title":"Minors","text":"","category":"section"},{"location":"matrix/#Exterior-power","page":"Matrix functionality","title":"Exterior power","text":"","category":"section"},{"location":"matrix/#Pfaffian","page":"Matrix functionality","title":"Pfaffian","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, [\"x$i\" for i in 1:6])\n(Multivariate polynomial ring in 6 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x1, x2, x3, x4, x5, x6])\n\njulia> M = R[0 x[1] x[2] x[3]; -x[1] 0 x[4] x[5]; -x[2] -x[4] 0 x[6]; -x[3] -x[5] -x[6] 0]\n[  0    x1    x2   x3]\n[-x1     0    x4   x5]\n[-x2   -x4     0   x6]\n[-x3   -x5   -x6    0]\n\njulia> pfaffian(M)\nx1*x6 - x2*x5 + x3*x4\n\njulia> pfaffians(M, 2)\n6-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x1\n x2\n x4\n x3\n x5\n x6","category":"section"},{"location":"matrix/#Nullspace","page":"Matrix functionality","title":"Nullspace","text":"","category":"section"},{"location":"matrix/#Hessenberg-form","page":"Matrix functionality","title":"Hessenberg form","text":"Examples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> M = matrix(R, 4, 4, [1 2 4 3; 2 5 1 0;6 1 3 2; 1 1 3 5])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = hessenberg(M)\n[1   5   5   3]\n[2   1   1   0]\n[0   1   3   2]\n[0   0   2   2]\n\njulia> is_hessenberg(A)\ntrue","category":"section"},{"location":"matrix/#Characteristic-polynomial","page":"Matrix functionality","title":"Characteristic polynomial","text":"","category":"section"},{"location":"matrix/#Minimal-polynomial","page":"Matrix functionality","title":"Minimal polynomial","text":"","category":"section"},{"location":"matrix/#Transforms","page":"Matrix functionality","title":"Transforms","text":"","category":"section"},{"location":"matrix/#Hermite-normal-form","page":"Matrix functionality","title":"Hermite normal form","text":"Examples\n\njulia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> H = hnf(A)\n[1   0   255]\n[0   1    17]\n[0   0   281]\n\njulia> is_hnf(H)\ntrue\n\njulia> H, U = hnf_with_transform(A)\n([1 0 255; 0 1 17; 0 0 281], [-47 28 1; -3 2 0; -52 31 1])\n\njulia> U*A\n[1   0   255]\n[0   1    17]\n[0   0   281]","category":"section"},{"location":"matrix/#Smith-normal-form","page":"Matrix functionality","title":"Smith normal form","text":"Examples\n\njulia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> S = snf(A)\n[1   0     0]\n[0   1     0]\n[0   0   281]\n\njulia> S, T, U = snf_with_transform(A)\n([1 0 0; 0 1 0; 0 0 281], [1 0 0; 7 1 0; 229 31 1], [0 -3 26; 0 2 -17; -1 0 1])\n\njulia> T*A*U\n[1   0     0]\n[0   1     0]\n[0   0   281]","category":"section"},{"location":"matrix/#(Weak)-Popov-form","page":"Matrix functionality","title":"(Weak) Popov form","text":"AbstractAlgebra.jl provides algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x);\n\njulia> A = matrix(R, map(R, Any[1 2 3 x; x 2*x 3*x x^2; x x^2+1 x^3+x^2 x^4+x^2+1]))\n[1         2           3               x]\n[x       2*x         3*x             x^2]\n[x   x^2 + 1   x^3 + x^2   x^4 + x^2 + 1]\n\njulia> P = weak_popov(A)\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]\n\njulia> P, U = weak_popov_with_transform(A)\n([1 2 3 x; 0 0 0 0; -x^3 -2*x^3+x^2-2*x+1 -2*x^3+x^2-3*x 1], [1 0 0; -x 1 0; -x^3-x 0 1])\n\njulia> U*A\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]","category":"section"},{"location":"matrix/#AbstractAlgebra.number_of_rows-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.number_of_rows","text":"number_of_rows(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of rows of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.number_of_columns-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.number_of_columns","text":"number_of_columns(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of columns of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.length-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"Base.length","text":"length(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the number of entries in the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.isempty-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"Base.isempty","text":"isempty(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn true if a does not contain any entry (i.e. length(a) == 0), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.identity_matrix-Tuple{Ring, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.identity_matrix","text":"identity_matrix(R::NCRing, n::Int)\n\nReturn the n times n identity matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: NCRingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.ones_matrix-Tuple{Ring, Int64, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.ones_matrix","text":"ones_matrix(R::Ring, r::Int, c::Int)\n\nReturn the r times c ones matrix over R.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.scalar_matrix-Tuple{Ring, Int64, RingElement}","page":"Matrix functionality","title":"AbstractAlgebra.scalar_matrix","text":"scalar_matrix(R::NCRing, n::Int, a::NCRingElement)\nscalar_matrix(n::Int, a::NCRingElement)\n\nReturn the n times n matrix over R with a along the main diagonal and zeroes elsewhere. If R is not specified, it defaults to parent(a).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.diagonal_matrix-Tuple{RingElement, Int64, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.diagonal_matrix","text":"diagonal_matrix(x::NCRingElement, m::Int, [n::Int])\n\nReturn the m times n matrix over R with x along the main diagonal and zeroes elsewhere. If n is not specified, it defaults to m.\n\nExamples\n\njulia> diagonal_matrix(ZZ(2), 2, 3)\n[2   0   0]\n[0   2   0]\n\njulia> diagonal_matrix(QQ(-1), 3)\n[-1//1    0//1    0//1]\n[ 0//1   -1//1    0//1]\n[ 0//1    0//1   -1//1]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.zero-Union{Tuple{T}, Tuple{MatElem{T}, Ring}} where T<:RingElement","page":"Matrix functionality","title":"Base.zero","text":"zero(x::MatElem{T}, R::NCRing, r::Int, c::Int) where T <: NCRingElement\nzero(x::MatElem{T}, r::Int, c::Int) where T <: NCRingElement\nzero(x::MatElem{T}, R::NCRing) where T <: NCRingElement\nzero(x::MatElem{T}) where T <: NCRingElement\n\nCreate an zero matrix over the given ring and dimensions, with defaults based upon the given source matrix x.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.one-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"Base.one","text":"one(a::MatrixElem{T}) where T <: NCRingElement\n\nReturn the identity matrix in the same matrix space as a. If the matrix space does not comprise square matrices, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.transpose-Tuple{MatElem}","page":"Matrix functionality","title":"Base.transpose","text":"transpose(x::MatElem)\ntranspose(x::MatRingElem)\n\nReturn the transpose of x.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> A = matrix(R, [t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = transpose(A)\n[t + 1   t^2            -2]\n[    t     t         t + 2]\n[    1     t   t^2 + t + 1]\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.transpose!-Tuple{MatElem}","page":"Matrix functionality","title":"LinearAlgebra.transpose!","text":"transpose!(x::MatElem)\ntranspose!(x::MatRingElem)\ntranspose!(z::T, x::T) where T <: MatElem\ntranspose!(z::T, x::T) where T <: MatRingElem\n\nReturn the transpose of x, possibly modifying the object z in the process. Aliasing is permitted.\n\nThe unary version only is supported if x is a square matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.tr-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"LinearAlgebra.tr","text":"tr(x::MatrixElem{T}) where T <: NCRingElement\n\nReturn the trace of the matrix a, i.e. the sum of the diagonal elements. We require the matrix to be square.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = tr(A)\nt^2 + 3*t + 2\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"LinearAlgebra.det","text":"det(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> A = R[x 1; 1 x^2];\n\njulia> d = det(A)\nx^3 - 1\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"LinearAlgebra.rank","text":"rank(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\nExamples\n\njulia> A = QQ[1 2; 3 4];\n\njulia> d = rank(A)\n2\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.lower_triangular_matrix","text":"lower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and below the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> lower_triangular_matrix([1, 2, 3])\n[1   0]\n[2   3]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.upper_triangular_matrix","text":"upper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries on and above the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length n(n+1)2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> upper_triangular_matrix([1, 2, 3])\n[1   2]\n[0   3]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.strictly_lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.strictly_lower_triangular_matrix","text":"strictly_lower_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries below the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length (n-1)n2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> strictly_lower_triangular_matrix([1, 2, 3])\n[0   0   0]\n[1   0   0]\n[2   3   0]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.strictly_upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.strictly_upper_triangular_matrix","text":"strictly_upper_triangular_matrix(L::AbstractVector{T}) where {T <: NCRingElement}\n\nReturn the n by n matrix whose entries above the main diagonal are the elements of L, and which has zeroes elsewhere. The value of n is determined by the condition that L has length (n-1)n2.\n\nAn exception is thrown if there is no integer n with this property.\n\nExamples\n\njulia> strictly_upper_triangular_matrix([1, 2, 3])\n[0   1   2]\n[0   0   3]\n[0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_lower_triangular-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_lower_triangular","text":"is_lower_triangular(A::MatrixElem)\n\nReturn true if A is an lower triangular matrix, that is, all entries above the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.istril.\n\nExamples\n\njulia> is_lower_triangular(QQ[1 2 ; 0 4])\nfalse\n\njulia> is_lower_triangular(QQ[1 0 ; 3 4])\ntrue\n\njulia> is_lower_triangular(QQ[1 2 ;])\nfalse\n\njulia> is_lower_triangular(QQ[1 ; 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_upper_triangular-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_upper_triangular","text":"is_upper_triangular(A::MatrixElem)\n\nReturn true if A is an upper triangular matrix, that is, all entries below the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.istriu.\n\nExamples\n\njulia> is_upper_triangular(QQ[1 2 ; 0 4])\ntrue\n\njulia> is_upper_triangular(QQ[1 0 ; 3 4])\nfalse\n\njulia> is_upper_triangular(QQ[1 2 ;])\ntrue\n\njulia> is_upper_triangular(QQ[1 ; 2])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_diagonal-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_diagonal","text":"is_diagonal(A::MatrixElem)\n\nReturn true if A is a diagonal matrix, that is, all entries off the main diagonal are zero. Note that this definition also applies to non-square matrices.\n\nAlias for LinearAlgebra.isdiag.\n\nExamples\n\njulia> is_diagonal(QQ[1 0 ; 0 4])\ntrue\n\njulia> is_diagonal(QQ[1 2 ; 3 4])\nfalse\n\njulia> is_diagonal(QQ[1 0 ;])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::NCRing, M::MatrixElem{T}) where T <: NCRingElement\n\nReturn the matrix obtained by coercing each entry into R.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.map-Union{Tuple{T}, Tuple{Any, MatrixElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"Base.map","text":"map(f, a::MatrixElem{T}) where T <: NCRingElement\n\nTransform matrix a by applying f to each element. This is equivalent to map_entries(f, a).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.map!-Union{Tuple{T}, Tuple{S}, Tuple{Any, MatrixElem{S}, MatrixElem{T}}} where {S<:RingElement, T<:RingElement}","page":"Matrix functionality","title":"Base.map!","text":"map!(f, dst::MatrixElem{T}, src::MatrixElem{U}) where {T <: NCRingElement, U <: NCRingElement}\n\nLike map, but stores the result in dst rather than a new matrix. This is equivalent to map_entries!(f, dst, src).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement-matrix","page":"Matrix functionality","title":"Base.inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement-matrix","page":"Matrix functionality","title":"AbstractAlgebra.is_invertible","text":"is_invertible(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use is_invertible_with_inverse.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement-matrix","page":"Matrix functionality","title":"AbstractAlgebra.is_invertible_with_inverse","text":"is_invertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T <: RingElement}\n\nGiven an n times m matrix A over a ring, return a tuple (flag, B). If side is :right and flag is true, B is a right inverse of A i.e. A B is the n times n unit matrix. If side is :left and flag is true, B is a left inverse of A i.e. B A is the m times m unit matrix. If flag is false, no right or left inverse exists.\n\nTo get the space of all inverses, note that if B and C are both right inverses, then A (B - C) = 0, and similar for left inverses. Hence from one inverse one can find all by making suitable use of kernel.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement-matrix","page":"Matrix functionality","title":"AbstractAlgebra.pseudo_inv","text":"pseudo_inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix M over a ring return a tuple X d consisting of an ntimes n matrix X and a denominator d such that MX = dI_n, where I_n is the ntimes n identity matrix. The denominator will be the determinant of M up to sign. If M is singular an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.add_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.add_column","text":"add_column(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T <: RingElement\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.add_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.add_column!","text":"add_column!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T <: RingElement\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.add_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.add_row","text":"add_row(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T <: RingElement\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.add_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.add_row!","text":"add_row!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T <: RingElement\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.multiply_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.multiply_column","text":"multiply_column(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T <: RingElement\n\nCreate a copy of a and multiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.multiply_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.multiply_column!","text":"multiply_column!(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T <: RingElement\n\nMultiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.multiply_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.multiply_row","text":"multiply_row(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T <: RingElement\n\nCreate a copy of a and multiply  the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.multiply_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.multiply_row!","text":"multiply_row!(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T <: RingElement\n\nMultiply the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.swap_rows-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.swap_rows","text":"swap_rows(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nReturn a matrix b with the entries of a, where the ith and jth row are swapped.\n\nExamples\n\njulia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\njulia> M  # was not modified\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.swap_rows!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.swap_rows!","text":"swap_rows!(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nSwap the ith and jth row of a in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).\n\nExamples\n\njulia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows!(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\njulia> M  # was modified\n[0   1   0]\n[1   0   0]\n[0   0   1]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.swap_cols-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.swap_cols","text":"swap_cols(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nReturn a matrix b with the entries of a, where the ith and jth row are swapped.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.swap_cols!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.swap_cols!","text":"swap_cols!(a::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\n\nSwap the ith and jth column of a in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.block_diagonal_matrix-Union{Tuple{Vector{<:MatElem{T}}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.block_diagonal_matrix","text":"block_diagonal_matrix(V::Vector{<:MatElem{T}}) where T <: NCRingElement\n\nCreate the block diagonal matrix whose blocks are given by the matrices in V. There must be at least one matrix in V.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.block_diagonal_matrix-Union{Tuple{T}, Tuple{Ring, Vector{<:Matrix{T}}}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.block_diagonal_matrix","text":"block_diagonal_matrix(R::NCRing, V::Vector{<:Matrix{T}}) where T <: NCRingElement\n\nCreate the block diagonal matrix over the ring R whose blocks are given by the matrices in V. Entries are coerced into R upon creation.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:FieldElem-matrix","page":"Matrix functionality","title":"LinearAlgebra.lu","text":"lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: FieldElement}\n\nReturn a tuple r p L U consisting of the rank of A, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:RingElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.fflu","text":"fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: RingElement}\n\nReturn a tuple r d p L U consisting of the rank of A, a denominator d, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LDU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A and such that D is the diagonal matrix diag(p_1 p_1p_2 ldots p_n-2p_n-1 p_n-1p_n) where the p_i are the inverses of the diagonal entries of L. The denominator d is set to pm mathrmdet(S) where S is an appropriate submatrix of A (S = A if A is square and nonsingular) and the sign is decided by the parity of the permutation.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.rref_rational","text":"rref_rational(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn a tuple (r A d) consisting of the rank r of M and a denominator d in the base ring of M and a matrix A such that Ad is the reduced row echelon form of M. Note that the denominator is not usually minimal.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.rref","text":"rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn a tuple (r A) consisting of the rank r of M and a reduced row echelon form A of M.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\nis_rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_symmetric-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_symmetric","text":"is_symmetric(M::MatrixElem)\n\nReturn true if the given matrix is symmetric with respect to its main diagonal, i.e., transpose(M) == M, otherwise return false.\n\nAlias for LinearAlgebra.issymmetric.\n\nExamples\n\njulia> M = matrix(ZZ, [1 2 3; 2 4 5; 3 5 6])\n[1   2   3]\n[2   4   5]\n[3   5   6]\n\njulia> is_symmetric(M)\ntrue\n\njulia> N = matrix(ZZ, [1 2 3; 4 5 6; 7 8 9])\n[1   2   3]\n[4   5   6]\n[7   8   9]\n\njulia> is_symmetric(N)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_skew_symmetric-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_skew_symmetric","text":"is_skew_symmetric(M::MatrixElem)\n\nReturn true if the given matrix is skew symmetric with respect to its main diagonal, i.e., transpose(M) == -M, otherwise return false.\n\nExamples\n\njulia> M = matrix(ZZ, [0 -1 -2; 1 0 -3; 2 3 0])\n[0   -1   -2]\n[1    0   -3]\n[2    3    0]\n\njulia> is_skew_symmetric(M)\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_alternating-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.is_alternating","text":"is_alternating(M::MatrixElem)\n\nReturn whether the form corresponding to the matrix M is alternating, i.e. M = -transpose(M) and M has zeros on the diagonal. Return false if M is not a square matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.powers-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.powers","text":"powers(a::Union{NCRingElement, MatElem}, d::Int)\n\nReturn an array M of \"powers\" of a where Mi + 1 = a^i for i = 0d.\n\nExamples\n\njulia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> A = powers(M, 4)\n5-element Vector{AbstractAlgebra.Generic.MatSpaceElem{BigInt}}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 2 3; 2 3 4; 4 5 5]\n [17 23 26; 24 33 38; 34 48 57]\n [167 233 273; 242 337 394; 358 497 579]\n [1725 2398 2798; 2492 3465 4044; 3668 5102 5957]\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.gram-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.gram","text":"gram(x::MatElem)\n\nReturn the Gram matrix of x, i.e. if x is an rtimes c matrix return the rtimes r matrix whose entries i j are the dot products of the i-th and j-th rows, respectively.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = gram(A)\n[2*t^2 + 2*t + 2   t^3 + 2*t^2 + t                   2*t^2 + t - 1]\n[t^3 + 2*t^2 + t       t^4 + 2*t^2                       t^3 + 3*t]\n[  2*t^2 + t - 1         t^3 + 3*t   t^4 + 2*t^3 + 4*t^2 + 6*t + 9]\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.content-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.content","text":"content(x::MatrixElem{T}) where T <: RingElement\n\nReturn the content of the matrix a, i.e. the greatest common divisor of all its entries, assuming it exists.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = content(A)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Base.:*-Union{Tuple{T}, Tuple{Perm, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"Base.:*","text":"*(P::Perm, x::MatrixElem{T}) where T <: NCRingElement\n\nApply the pemutation P to the rows of the matrix x and return the result.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> G = SymmetricGroup(3)\nFull symmetric group over 3 elements\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> P = G([1, 3, 2])\n(2,3)\n\njulia> B = P*A\n[t + 1       t             1]\n[   -2   t + 2   t^2 + t + 1]\n[  t^2       t             t]\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_nilpotent-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.is_nilpotent","text":"is_nilpotent(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn if A is nilpotent, i.e. if there exists a natural number k such that A^k = 0. If A is not square an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.minors-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.minors","text":"minors(A::MatElem, k::Int)\n\nReturn an array consisting of the k-minors of A.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> minors(A, 2)\n3-element Vector{BigInt}:\n -3\n -6\n -3\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.exterior_power-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.exterior_power","text":"exterior_power(A::MatElem, k::Int) -> MatElem\n\nReturn the k-th exterior power of A.\n\nExamples\n\njulia> A = matrix(ZZ, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\njulia> exterior_power(A, 2)\n[-3    -6   -3]\n[-6   -12   -6]\n[-3    -6   -3]\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.pfaffian-Tuple{MatElem}","page":"Matrix functionality","title":"AbstractAlgebra.pfaffian","text":"pfaffian(M::MatElem)\n\nReturn the Pfaffian of a skew-symmetric matrix M.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.pfaffians-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"AbstractAlgebra.pfaffians","text":"pfaffians(M::MatElem, k::Int)\n\nReturn a vector consisting of the k-Pfaffians of a skew-symmetric matrix M.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"LinearAlgebra.nullspace","text":"nullspace(M::MatElem{T}) where {T <: RingElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name \"kernel\" for a function to compute an integral kernel.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over univariate polynomial ring in x over integers\n\njulia> M = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n              -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n              -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n              -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n[  -6*x^2 + 6*x + 12   -12*x^2 - 21*x - 15    -15*x^2 + 21*x + 33     -21*x^2 - 9*x - 9]\n[  -8*x^2 + 8*x + 16   -16*x^2 + 38*x - 20     90*x^2 - 82*x - 44    60*x^2 + 54*x - 34]\n[   -4*x^2 + 4*x + 8    -8*x^2 + 13*x - 10     35*x^2 - 31*x - 14    22*x^2 + 21*x - 15]\n[-10*x^2 + 10*x + 20   -20*x^2 + 70*x - 25   150*x^2 - 140*x - 85   105*x^2 + 90*x - 50]\n\njulia> n, N = nullspace(M)\n(2, [1320*x^4-330*x^2-1320*x-1320 1056*x^4+1254*x^3+1848*x^2-66*x-330; -660*x^4+1320*x^3+1188*x^2-1848*x-1056 -528*x^4+132*x^3+1584*x^2+660*x-264; 396*x^3-396*x^2-792*x 0; 0 396*x^3-396*x^2-792*x])\n\n\n\n\n\nnullspace(M::MatElem{T}) where {T <: FieldElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem-matrix","page":"Matrix functionality","title":"LinearAlgebra.hessenberg","text":"hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Hessenberg form of M, i.e. an upper Hessenberg matrix which is similar to M. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem-matrix","page":"Matrix functionality","title":"AbstractAlgebra.is_hessenberg","text":"is_hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in Hessenberg form, otherwise returns false.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.charpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatrixElem{T}}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.charpoly","text":"charpoly(Y::MatrixElem{T}) where {T <: RingElement}\ncharpoly(S::PolyRing{T}, Y::MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the square matrix Y. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> T, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = charpoly(T, M)\ny^4 + 2*y^2 + 6*y + 2\n\njulia> A = charpoly(M)\nx^4 + 2*x^2 + 6*x + 2\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.minpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatElem{T}, Bool}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.minpoly","text":"minpoly(M::MatElem{T}) where {T <: RingElement}\nminpoly(S::PolyRing{T}, M::MatElem{T}) where {T <: RingElement}\n\nReturn the minimal polynomial p of the square matrix M. If a polynomial ring S over the same base ring as Y is supplied, the resulting polynomial is an element of it.\n\nExamples\n\njulia> R = GF(13)\nFinite field F_13\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> M = R[7 6 1;\n             7 7 5;\n             8 12 5]\n[7    6   1]\n[7    7   5]\n[8   12   5]\n\njulia> A = minpoly(S, M)\ny^2 + 10*y\n\njulia> A = minpoly(M)\nx^2 + 10*x\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.similarity!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.similarity!","text":"similarity!(A::MatrixElem{T}, r::Int, d::T) where {T <: RingElement}\n\nApplies a similarity transform to the ntimes n matrix M in-place. Let P be the ntimes n identity matrix that has had all zero entries of row r replaced with d, then the transform applied is equivalent to M = P^-1MP. We require M to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> similarity!(M, 1, R(3))\n\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.hnf","text":"hnf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the upper right row Hermite normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.hnf_with_transform","text":"hnf_with_transform(A)\n\nReturn the tuple H U consisting of the upper right row Hermite normal form H of A together with invertible matrix U such that UA = H.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.is_hnf","text":"is_hnf(M::MatrixElem{T}) where T <: RingElement\n\nReturn true if the matrix is in Hermite normal form.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_snf-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"AbstractAlgebra.is_snf","text":"is_snf(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is in Smith Normal Form.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.snf","text":"snf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Smith normal form of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"AbstractAlgebra.snf_with_transform","text":"snf_with_transform(A)\n\nReturn the tuple S T U consisting of the Smith normal form S of A together with invertible matrices T and U such that TAU = S.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.is_weak_popov-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64}} where T<:AbstractAlgebra.Generic.Poly","page":"Matrix functionality","title":"AbstractAlgebra.is_weak_popov","text":"is_weak_popov(P::MatrixElem{T}, rank::Int) where T <: PolyRingElem\n\nReturn true if P is a matrix in weak Popov form of the given rank.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.weak_popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"AbstractAlgebra.weak_popov","text":"weak_popov(A::MatElem{T}) where {T <: PolyRingElem}\n\nReturn the weak Popov form of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.weak_popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"AbstractAlgebra.weak_popov_with_transform","text":"weak_popov_with_transform(A::MatElem{T}) where {T <: PolyRingElem}\n\nCompute a tuple (P U) where P is the weak Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"AbstractAlgebra.popov","text":"popov(A::MatElem{T}) where {T <: PolyRingElem}\n\nReturn the Popov form of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix/#AbstractAlgebra.popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyRingElem","page":"Matrix functionality","title":"AbstractAlgebra.popov_with_transform","text":"popov_with_transform(A::MatElem{T}) where {T <: PolyRingElem}\n\nCompute a tuple (P U) where P is the Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#Matrix-Spaces","page":"Matrix Spaces","title":"Matrix Spaces","text":"","category":"section"},{"location":"matrix_spaces/#Matrix-Space-Constructors","page":"Matrix Spaces","title":"Matrix Space Constructors","text":"A matrix space in AbstractAlgebra.jl represents a collection of all matrices with given dimensions and base ring.\n\nIn order to construct matrices in AbstractAlgebra.jl, one can first construct the matrix space itself. This is accomplished with the following constructor. We discuss creation of matrix algebras separately in a dedicated section elsewhere in the documentation.\n\nmatrix_space(R::Ring, rows::Int, cols::Int)\n\nConstruct the space of matrices with the given number of rows and columns over the given base ring.\n\nHere are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"section"},{"location":"matrix_spaces/#Basic-matrix-space-functionality","page":"Matrix Spaces","title":"Basic matrix space functionality","text":"julia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n[ 2       3       1]\n[ t   t + 1   t + 2]\n[-1     t^2     t^3]\n\njulia> r = number_of_rows(B)\n3\n\njulia> c = number_of_columns(B)\n3\n\njulia> length(B)\n9\n\njulia> isempty(B)\nfalse\n\njulia> M = A + B\n[  t + 3         t + 3                   2]\n[t^2 + t       2*t + 1             2*t + 2]\n[     -3   t^2 + t + 2   t^3 + t^2 + t + 1]\n\njulia> N = 2 + A\n[t + 3       t             1]\n[  t^2   t + 2             t]\n[   -2   t + 2   t^2 + t + 3]\n\njulia> M1 = deepcopy(A)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> A != B\ntrue\n\njulia> isone(one(S))\ntrue\n\njulia> V = A[1:2, :]\n[t + 1   t   1]\n[  t^2   t   t]\n\njulia> W = A^3\n[    3*t^4 + 4*t^3 + t^2 - 3*t - 5            t^4 + 5*t^3 + 10*t^2 + 7*t + 4                 2*t^4 + 7*t^3 + 9*t^2 + 8*t + 1]\n[t^5 + 4*t^4 + 3*t^3 - 7*t^2 - 4*t               4*t^4 + 8*t^3 + 7*t^2 + 2*t                 t^5 + 5*t^4 + 9*t^3 + 7*t^2 - t]\n[  t^5 + 3*t^4 - 10*t^2 - 16*t - 2   t^5 + 6*t^4 + 12*t^3 + 11*t^2 + 5*t - 2   t^6 + 3*t^5 + 8*t^4 + 15*t^3 + 10*t^2 + t - 5]\n\njulia> Z = divexact(2*A, 2)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> M = matrix(ZZ, BigInt[2 3 0; 1 1 1])\n[2   3   0]\n[1   1   1]\n\njulia> M[1, 2] = BigInt(4)\n4\n\njulia> c = M[1, 1]\n2","category":"section"},{"location":"matrix_spaces/#Inverses","page":"Matrix Spaces","title":"Inverses","text":"julia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X = inv(A)\n[-343//7817*x^2 + 717//7817*x - 2072//7817   -4964//23451*x^2 + 2195//23451*x - 11162//23451    -232//23451*x^2 - 4187//23451*x - 1561//23451]\n[ 128//7817*x^2 - 655//7817*x + 2209//7817      599//23451*x^2 - 2027//23451*x - 1327//23451   -1805//23451*x^2 + 2702//23451*x - 7394//23451]\n[ 545//7817*x^2 + 570//7817*x + 2016//7817     -1297//23451*x^2 - 5516//23451*x - 337//23451   8254//23451*x^2 - 2053//23451*x + 16519//23451]\n\njulia> is_invertible(A)\ntrue\n\njulia> is_invertible_with_inverse(A)\n(true, [-343//7817*x^2+717//7817*x-2072//7817 -4964//23451*x^2+2195//23451*x-11162//23451 -232//23451*x^2-4187//23451*x-1561//23451; 128//7817*x^2-655//7817*x+2209//7817 599//23451*x^2-2027//23451*x-1327//23451 -1805//23451*x^2+2702//23451*x-7394//23451; 545//7817*x^2+570//7817*x+2016//7817 -1297//23451*x^2-5516//23451*x-337//23451 8254//23451*x^2-2053//23451*x+16519//23451])\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in x over integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X, d = pseudo_inv(A)\n([4*x^2-x+1 -2*x^3+3 x^3-5*x^2-5*x-1; -2*x^3-5*x^2-2*x-2 x^4+3*x^3+2*x^2+3*x+1 -x^4+x^2+2; -x^3+2*x^2+2*x-1 -2*x^3-9*x^2-11*x-3 2*x^3+3*x^2-4*x-6], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)","category":"section"},{"location":"matrix_spaces/#LU-factorisation","page":"Matrix Spaces","title":"LU factorisation","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n[      0   2*x + 3   x^2 + 1]\n[x^2 - 2     x - 1       2*x]\n[x^2 - 2     x - 1       2*x]\n\njulia> r, P, L, U = lu(A)\n(2, (1,2), [1 0 0; 0 1 0; 1 0 1], [x^2-2 x-1 2*x; 0 2*x+3 x^2+1; 0 0 0])\n\njulia> r, d, P, L, U = fflu(A)\n(2, 3*x^2 - 10*x - 8, (1,2), [x^2-2 0 0; 0 3*x^2-10*x-8 0; x^2-2 0 1], [x^2-2 x-1 2*x; 0 3*x^2-10*x-8 -4*x^2-x-2; 0 0 0])","category":"section"},{"location":"matrix_spaces/#Reduced-row-echelon-form","page":"Matrix Spaces","title":"Reduced row-echelon form","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> K, = residue_field(R, x^3 + 3x + 1); a = K(x);\n\njulia> S = matrix_space(K, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over residue field of R modulo x^3 + 3*x + 1\n\njulia> M = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A = rref(M)\n(3, [1 0 0; 0 1 0; 0 0 1])\n\njulia> is_rref(A)\ntrue\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in x over integers\n\njulia> M = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A, d = rref_rational(M)\n(3, [-x^5-2*x^4-15*x^3-18*x^2-8*x-7 0 0; 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7 0; 0 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n\njulia> is_rref(A)\ntrue","category":"section"},{"location":"matrix_spaces/#Matrix-element-constructors","page":"Matrix Spaces","title":"Matrix element constructors","text":"There are a few ways to construct matrices other than by coercing elements as shown above. The first method is from an array of elements.\n\nThis can be done with either two or one dimensional arrays.\n\n(S::MatSpace{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}\n(S::MatRing{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}\n\nCreate the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.\n\n(S::MatSpace{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatRing{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n\nCreate the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.\n\nWe also provide the following syntax for constructing literal matrices (similar to how Julia arrays can be be constructed).\n\nR[a b c...;...]\n\nCreate the matrix over the base ring R consisting of the given rows (separated by semicolons). Each entry is coerced into R  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. R[1 2; 2 (- 3)].\n\nAlso see the Matrix interface for a list of other ways to create matrices.\n\nExamples\n\njulia> S = matrix_space(QQ, 2, 3)\nMatrix space of 2 rows and 3 columns\n  over rationals\n\njulia> T = matrix_ring(QQ, 2)\nMatrix ring of degree 2\n  over rationals\n\njulia> M1 = S(Rational{BigInt}[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M2 = S(BigInt[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M3 = S(BigInt[2, 3, 1, 1, 0, 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> N1 = T(Rational{BigInt}[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N2 = T(BigInt[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N3 = T(BigInt[2, 3, 1, 1])\n[2//1   3//1]\n[1//1   1//1]\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_space(R, 3, 3)\nMatrix space of 3 rows and 3 columns\n  over univariate polynomial ring in t over rationals\n\njulia> M = R[t + 1 1; t^2 0]\n[t + 1   1]\n[  t^2   0]\n\njulia> N = R[t + 1 2 t] # create a row vector\n[t + 1   2   t]\n\njulia> P = R[1; 2; t] # create a column vector\n[1]\n[2]\n[t]","category":"section"},{"location":"matrix_spaces/#Hessenberg-form","page":"Matrix Spaces","title":"Hessenberg form","text":"Examples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> S = matrix_space(R, 4, 4)\nMatrix space of 4 rows and 4 columns\n  over residue ring of integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = hessenberg(M)\n[1   5   5   3]\n[2   1   1   0]\n[0   1   3   2]\n[0   0   2   2]\n\njulia> is_hessenberg(A)\ntrue","category":"section"},{"location":"matrix_spaces/#AbstractAlgebra.number_of_rows-Tuple{MatSpace}","page":"Matrix Spaces","title":"AbstractAlgebra.number_of_rows","text":"number_of_rows(a::MatSpace)\n\nReturn the number of rows of the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.number_of_columns-Tuple{MatSpace}","page":"Matrix Spaces","title":"AbstractAlgebra.number_of_columns","text":"number_of_columns(a::MatSpace)\n\nReturn the number of columns of the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#Base.zero-Tuple{MatSpace}","page":"Matrix Spaces","title":"Base.zero","text":"zero(a::MatSpace)\n\nReturn the zero matrix in the given matrix space.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#Base.one-Tuple{MatSpace}","page":"Matrix Spaces","title":"Base.one","text":"one(a::MatSpace)\n\nReturn the identity matrix of given matrix space. The matrix space must contain square matrices or else an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix Spaces","title":"Base.inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix Spaces","title":"AbstractAlgebra.is_invertible","text":"is_invertible(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use is_invertible_with_inverse.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix Spaces","title":"AbstractAlgebra.is_invertible_with_inverse","text":"is_invertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T <: RingElement}\n\nGiven an n times m matrix A over a ring, return a tuple (flag, B). If side is :right and flag is true, B is a right inverse of A i.e. A B is the n times n unit matrix. If side is :left and flag is true, B is a left inverse of A i.e. B A is the m times m unit matrix. If flag is false, no right or left inverse exists.\n\nTo get the space of all inverses, note that if B and C are both right inverses, then A (B - C) = 0, and similar for left inverses. Hence from one inverse one can find all by making suitable use of kernel.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix Spaces","title":"AbstractAlgebra.pseudo_inv","text":"pseudo_inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix M over a ring return a tuple X d consisting of an ntimes n matrix X and a denominator d such that MX = dI_n, where I_n is the ntimes n identity matrix. The denominator will be the determinant of M up to sign. If M is singular an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:FieldElem","page":"Matrix Spaces","title":"LinearAlgebra.lu","text":"lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: FieldElement}\n\nReturn a tuple r p L U consisting of the rank of A, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:RingElem","page":"Matrix Spaces","title":"AbstractAlgebra.fflu","text":"fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: RingElement}\n\nReturn a tuple r d p L U consisting of the rank of A, a denominator d, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LDU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A and such that D is the diagonal matrix diag(p_1 p_1p_2 ldots p_n-2p_n-1 p_n-1p_n) where the p_i are the inverses of the diagonal entries of L. The denominator d is set to pm mathrmdet(S) where S is an appropriate submatrix of A (S = A if A is square and nonsingular) and the sign is decided by the parity of the permutation.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix Spaces","title":"AbstractAlgebra.rref_rational","text":"rref_rational(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn a tuple (r A d) consisting of the rank r of M and a denominator d in the base ring of M and a matrix A such that Ad is the reduced row echelon form of M. Note that the denominator is not usually minimal.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix Spaces","title":"AbstractAlgebra.rref","text":"rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn a tuple (r A) consisting of the rank r of M and a reduced row echelon form A of M.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix Spaces","title":"AbstractAlgebra.is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix Spaces","title":"AbstractAlgebra.is_rref","text":"is_rref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\nis_rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix Spaces","title":"LinearAlgebra.hessenberg","text":"hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Hessenberg form of M, i.e. an upper Hessenberg matrix which is similar to M. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"matrix_spaces/#AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix Spaces","title":"AbstractAlgebra.is_hessenberg","text":"is_hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in Hessenberg form, otherwise returns false.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Printing-options","page":"Miscellaneous","title":"Printing options","text":"AbstractAlgebra supports printing to LaTeX using the MIME type \"text/latex\". To enable LaTeX rendering in Jupyter notebooks and query for the current state, use the following functions:","category":"section"},{"location":"misc/#Updating-the-type-diagrams","page":"Miscellaneous","title":"Updating the type diagrams","text":"Updating the diagrams of the documentation can be done by modifying and running the script docs/create_type_diagrams.jl. Note that this requires the package Kroki.","category":"section"},{"location":"misc/#Attributes","page":"Miscellaneous","title":"Attributes","text":"Often it is desirable to have a flexible way to attach additional data to mathematical structures such as groups, rings, fields, etc. beyond what the original implementation covers. To facilitate this, we provide an attributes system: for objects of suitable types, one may use set_attribute! to attach key-value pairs to the object, and query them using has_attribute, get_attribute and get_attribute!.\n\nAttributes are supported for all singletons (i.e., instances of an empty struct type), as well as for instances of mutable struct type for which attribute storage was enabled. There are two ways to enable attribute storage for such types:\n\nBy applying @attributes to a mutable struct declaration, storage is reserved inside that struct type itself (this increases the size of each struct by 8 bytes if no attributes are set).\nBy applying @attributes to the name of a mutable struct type, methods are installed which store attributes to instances of the type in a WeakKeyDict outside the struct.","category":"section"},{"location":"misc/#Advanced-printing","page":"Miscellaneous","title":"Advanced printing","text":"","category":"section"},{"location":"misc/#Self-given-names","page":"Miscellaneous","title":"Self-given names","text":"We provide macros @show_name, @show_special and @show_special_elem to change the way certain objects are printed.\n\nIn compact and terse printing mode, @show_name tries to determine a suitable name to print instead of the object (see AbstractAlgebra.get_name).\n\n@show_special checks if an attribute :show is present. If so, it has to be a function taking IO, optionally a MIME-type, and the object. This is then called instead of the usual show function.\n\nSimilarly, @show_special_elem checks if an attribute :show_elem is present in the object's parent. The semantics are the same as for @show_special.\n\nAll are supposed to be used within the usual show function, where @show_special_elem is only relevant for element types of algebraic structures.\n\n@attributes MyObj\n\nfunction show(io::IO, A::MyObj)\n   @show_name(io, A)\n   @show_special(io, A)\n\n   # ... usual stuff\nend\n\nfunction show(io::IO, mime::MIME\"text/plain\", A::MyObj)\n   @show_name(io, A)\n   @show_special(io, mime, A)\n\n   # ... usual stuff\nend\n\nfunction show(io::IO, A::MyObjElem)\n   @show_name(io, A)\n   @show_special_elem(io, A)\n\n   # ... usual stuff\nend\n\nfunction show(io::IO, mime::MIME\"text/plain\", A::MyObjElem)\n   @show_name(io, A)\n   @show_special_elem(io, mime, A)\n\n   # ... usual stuff\nend","category":"section"},{"location":"misc/#Documentation","page":"Miscellaneous","title":"Documentation","text":"","category":"section"},{"location":"misc/#Indentation-and-Decapitalization","page":"Miscellaneous","title":"Indentation and Decapitalization","text":"To facilitate printing of nested mathematical structures, we provide a modified IOCustom object, that supports indentation and decapitalization.","category":"section"},{"location":"misc/#Example","page":"Miscellaneous","title":"Example","text":"We illustrate this with an example\n\nstruct A{T}\n  x::T\nend\n\nfunction Base.show(io::IO, a::A)\n  io = AbstractAlgebra.pretty(io)\n  println(io, \"Something of type A\")\n  print(io, AbstractAlgebra.Indent(), \"over \", AbstractAlgebra.Lowercase(), a.x)\n  print(io, AbstractAlgebra.Dedent()) # don't forget to undo the indentation!\nend\n\nstruct B\nend\n\nfunction Base.show(io::IO, b::B)\n  io = AbstractAlgebra.pretty(io)\n  print(io, LowercaseOff(), \"Hilbert thing\")\nend\n\nAt the REPL, this will then be printed as follows:\n\njulia> A(2)\nSomething of type A\n  over 2\n\njulia> A(A(2))\nSomething of type A\n  over something of type A\n    over 2\n\njulia> A(B())\nSomething of type A\n  over Hilbert thing","category":"section"},{"location":"misc/#Documentation-2","page":"Miscellaneous","title":"Documentation","text":"","category":"section"},{"location":"misc/#Linear-solving-interface-for-developers","page":"Miscellaneous","title":"Linear solving interface for developers","text":"AbstractAlgebra has a generic interface for linear solving and we describe here how one may extend this interface. For the user-facing functionality of linear solving, see Linear Solving.\n\nNotice that the functionality is implemented in the module AbstractAlgebra.Solve and the internal functions are not exported from there.","category":"section"},{"location":"misc/#Matrix-normal-forms","page":"Miscellaneous","title":"Matrix normal forms","text":"To distinguish between different algorithms, we use type traits of abstract type MatrixNormalFormTrait which usually correspond to a certain matrix normal form. The available algorithms/normal forms are\n\nHowellFormTrait: uses a Howell form;\nHermiteFormTrait: uses a Hermite normal form;\nRREFTrait: uses a row-reduced echelon form over fields;\nLUTrait: uses a LU factoring of the matrix;\nFFLUTrait: uses a \"fraction-free\" LU factoring of the matrix over fraction   fields;\nMatrixInterpolateTrait: uses interpolation of polynomials for fraction   fields of polynomial rings.\n\nTo select a normal form type for rings of type NewRing, implement the function\n\nSolve.matrix_normal_form_type(::NewRing) = Bla()\n\nwhere Bla <: MatrixNormalFormTrait. A new type trait can be added via\n\nstruct NewTrait <: Solve.MatrixNormalFormTrait end","category":"section"},{"location":"misc/#Internal-solving-functionality","page":"Miscellaneous","title":"Internal solving functionality","text":"If a new ring type NewRing can make use of one of the available MatrixNormalFormTraits, then it suffices to specify this normal form as described above to use the generic solving functionality. (However, for example HermiteFormTrait requires that the function hermite_form_with_transformation is implemented.)\n\nFor a new trait NewTrait <: MatrixNormalFormTrait, one needs to implement the function\n\nSolve._can_solve_internal_no_check(\n  ::NewTrait, A::MatElem{T}, b::MatElem{T}, task::Symbol; side::Symbol = :left\n  ) where T\n\nInside this function, one can assume that A and b have the same base ring and have compatible dimensions. Further, task and side are set to \"legal\" options. (All this is checked in Solve._can_solve_internal.) This function should then (try to) solve Ax = b (side == :right) or xA = b (side == :left) possibly with kernel. The function must always return a tuple (::Bool, ::MatElem{T}, ::MatElem{T}) consisting of:\n\ntrue/false whether a solution exists or not\nthe solution (or a placeholder if no solution exists or a solution is not requested)\nthe kernel (or a placeholder if the kernel is not requested)\n\nThe input task may be:\n\n:only_check: Only test whether there is a solution, the second and third return value are only for type stability;\n:with_solution: Compute a solution, if it exists, the last return value is only for type stability;\n:with_kernel: Compute a solution and a kernel.\n\nOne should further implement the function\n\nkernel(::NewTrait, A::MatElem; side::Symbol = :left)\n\nwhich computes a left (or right) kernel of A.","category":"section"},{"location":"misc/#Internal-solve-context-functionality","page":"Miscellaneous","title":"Internal solve context functionality","text":"To efficiently solve several linear systems with the same matrix A, we provide the \"solve contexts objects\" of type Solve.SolveCtx. These can be extended for a ring of type NewRing as follows.","category":"section"},{"location":"misc/#Solve-context-type","page":"Miscellaneous","title":"Solve context type","text":"For a new ring type, one may have to define the type parameters of a Solve.SolveCtx object. First of all, one needs to implement the function\n\nfunction Solve.solve_context_type(::NewRing)\n  return Solve.solve_context_type(::NormalFormTrait, elem_type(NewRing))\nend\n\nto pick a MatrixNormalFormTrait.\n\nUsually, nothing else should be necessary. However, if for example the normal form of a matrix does not live over the same ring as the matrix itself, one might also need to implement\n\nfunction Solve.solve_context_type(NF::NormalFormTrait, T::Type{NewRingElem})\n  return Solve.SolveCtx{T, typeof(NF), MatType, RedMatType, TranspMatType}\nend\n\nwhere MatType is the dense matrix type over NewRing, RedMatType the type of a matrix in reduced/normal form and TranspMatType the type of the reduced/normal form of the transposed matrix.","category":"section"},{"location":"misc/#Initialization","page":"Miscellaneous","title":"Initialization","text":"To initialize the solve context functionality for a new normal form NewTrait, one needs to implement the functions\n\nSolve._init_reduce(C::Solve.SolveCtx{T, NewTrait}) where T\nSolve._init_reduce_transpose(C::Solve.SolveCtx{T, NewTrait}) where T\n\nThese should fill the corresponding fields of the solve context C with a \"reduced matrix\" (that is, a matrix in normal form) of matrix(C), respectively transpose(matrix(C)), and other information necessary to solve a linear system. The fields can be accessed via reduced_matrix, reduced_matrix_of_transpose, etc. New fields may also be added via attributes.","category":"section"},{"location":"misc/#Internal-solving-functionality-2","page":"Miscellaneous","title":"Internal solving functionality","text":"As above, one finally needs to implement the functions\n\nSolve._can_solve_internal_no_check(\n  ::NewTrait, C::Solve.SolveCtx{T, NewTrait}, b::MatElem{T}, task::Symbol;\n  side::Symbol = :left\n  ) where T\n\nand\n\nkernel(::NewTrait, C::Solve.SolveCtx{T, NewTrait}; side::Symbol = :left)","category":"section"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.set_html_as_latex","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.set_html_as_latex","text":"set_html_as_latex(fl::Bool)\n\nToggles whether MIME type text/html should be printed as text/latex. Note that this is a global option. The return value is the old value.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.get_html_as_latex","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.get_html_as_latex","text":"get_html_as_latex()\n\nReturns whether MIME type text/html is printed as text/latex.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.@attributes","page":"Miscellaneous","title":"AbstractAlgebra.@attributes","text":"@attributes typedef\n\nThis is a helper macro that ensures that there is storage for attributes in the type declared in the expression typedef, which must be either a mutable struct definition expression, or the name of a mutable struct type.\n\nThe latter variant is useful to enable attribute storage for types defined in other packages. Note that @attributes is idempotent: when applied to a type for which attribute storage is already available, it does nothing.\n\nFor singleton types, attribute storage is also supported, and in fact always enabled. Thus it is not necessary to apply this macro to such a type.\n\nnote: Note\nWhen applied to a struct definition this macro adds a new field to the struct. For structs without constructor, this will change the signature of the default inner constructor, which requires explicit values for every field, including the attribute storage field this macro adds. Usually it is thus preferable to add an explicit default constructor, as in the example below.\n\nExamples\n\nApplying the macro to a struct definition results in internal storage of the attributes:\n\njulia> @attributes mutable struct MyGroup\n           order::Int\n           MyGroup(order::Int) = new(order)\n       end\n\njulia> G = MyGroup(5)\nMyGroup(5, #undef)\n\njulia> set_attribute!(G, :isfinite, :true)\n\njulia> get_attribute(G, :isfinite)\ntrue\n\nApplying the macro to a typename results in external storage of the attributes:\n\njulia> mutable struct MyOtherGroup\n           order::Int\n           MyOtherGroup(order::Int) = new(order)\n       end\n\njulia> @attributes MyOtherGroup\n\njulia> G = MyOtherGroup(5)\nMyOtherGroup(5)\n\njulia> set_attribute!(G, :isfinite, :true)\n\njulia> get_attribute(G, :isfinite)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"misc/#AbstractAlgebra.@attr","page":"Miscellaneous","title":"AbstractAlgebra.@attr","text":"@attr RetType funcdef\n\nThis macro is applied to the definition of a unary function, and enables caching (\"memoization\") of its return values based on the argument. This assumes the argument supports attribute storing (see @attributes) via get_attribute!.\n\nThe name of the function is used as name for the underlying attribute.\n\nThe macro works the same for unary functions with keyword arguments, but ignores the keyword arguments when caching the result, i.e. different calls with different keyword arguments will return the identical (cached) result. In case that there is no result cached yet, the function is called with the given keyword arguments.\n\nEffectively, this turns code like this:\n\n@attr RetType function myattr(obj::Foo)\n   # ... expensive computation\n   return result\nend\n\ninto something essentially equivalent to this:\n\nfunction myattr(obj::Foo)\n  return get_attribute!(obj, :myattr) do\n    # ... expensive computation\n    return result\n  end::RetType\nend\n\nExamples\n\njulia> @attributes mutable struct Foo\n           x::Int\n           Foo(x::Int) = new(x)\n       end;\n\njulia> @attr Int function myattr(obj::Foo)\n                println(\"Performing expensive computation\")\n                return factorial(obj.x)\n             end;\n\njulia> obj = Foo(5);\n\njulia> myattr(obj)\nPerforming expensive computation\n120\n\njulia> myattr(obj) # second time uses the cached result\n120\n\n\n\n\n\n\n","category":"macro"},{"location":"misc/#AbstractAlgebra.has_attribute","page":"Miscellaneous","title":"AbstractAlgebra.has_attribute","text":"has_attribute(G::Any, attr::Symbol)\n\nReturn a boolean indicating whether G has a value stored for the attribute attr.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.get_attribute","page":"Miscellaneous","title":"AbstractAlgebra.get_attribute","text":"get_attribute(f::Function, G::Any, attr::Symbol)\n\nReturn the value stored for the attribute attr, or if no value has been set, return f().\n\nThis is intended to be called using do block syntax.\n\nget_attribute(obj, attr) do\n    # default value calculated here if needed\n    ...\nend\n\n\n\n\n\nget_attribute(G::Any, attr::Symbol, default::Any = nothing)\n\nReturn the value stored for the attribute attr, or if no value has been set, return default.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.get_attribute!","page":"Miscellaneous","title":"AbstractAlgebra.get_attribute!","text":"get_attribute!(f::Function, G::Any, attr::Symbol)\n\nReturn the value stored for the attribute attr of G, or if no value has been set, store key => f() and return f().\n\nThis is intended to be called using do block syntax.\n\nget_attribute!(obj, attr) do\n    # default value calculated here if needed\n    ...\nend\n\n\n\n\n\nget_attribute!(G::Any, attr::Symbol, default::Any)\n\nReturn the value stored for the attribute attr of G, or if no value has been set, store key => default, and return default.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.set_attribute!","page":"Miscellaneous","title":"AbstractAlgebra.set_attribute!","text":"set_attribute!(G::Any, data::Pair{Symbol, <:Any}...)\n\nAttach the given sequence of key=>value pairs as attributes of G.\n\n\n\n\n\nset_attribute!(G::Any, attr::Symbol, value::Any)\n\nAttach the given value as attribute attr of G.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.is_attribute_storing","page":"Miscellaneous","title":"AbstractAlgebra.is_attribute_storing","text":"is_attribute_storing(G::Any)\n\nReturn a boolean indicating whether G has the ability to store attributes.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.is_attribute_storing_type","page":"Miscellaneous","title":"AbstractAlgebra.is_attribute_storing_type","text":"is_attribute_storing_type(T::Type)\n\nReturn a boolean indicating whether instances of type T have the ability to store attributes.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.@show_special","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.@show_special","text":"@show_special(io::IO, obj)\n\nIf the obj has a show attribute, this gets called with io and obj and returns from the current scope. Otherwise, does nothing.\n\nIf obj does not have attribute storage available, this macro does nothing.\n\nIt is supposed to be used at the start of show methods as shown in the documentation.\n\nExamples\n\njulia> R = @polynomial_ring(QQ, :x; cached=false)\nUnivariate polynomial ring in x over rationals\n\njulia> AbstractAlgebra.@show_special(stdout, R)\n\njulia> set_attribute!(R, :show, (i,o) -> print(i, \"=> The One True Ring <=\"))\n\njulia> AbstractAlgebra.@show_special(stdout, R)\n=> The One True Ring <=\n\njulia> R   # show for R uses @show_special, so we can observe the effect directly\n=> The One True Ring <=\n\n\n\n\n\n@show_special(io::IO, mime, obj)\n\nIf the obj has a show attribute, this gets called with io, mime and obj (if applicable) and io and obj otherwise, and returns from the current scope. Otherwise, does nothing.\n\nIf obj does not have attribute storage available, this macro does nothing.\n\nIt is supposed to be used at the start of show methods as shown in the documentation.\n\nExamples\n\njulia> R = @polynomial_ring(QQ, :x; cached=false)\nUnivariate polynomial ring in x over rationals\n\njulia> AbstractAlgebra.@show_special(stdout, MIME\"text/plain\"(), R)\n\njulia> myshow(i,o) = print(i, \"=> The One True Ring <=\");\n\njulia> myshow(i,m,o) = print(i, \"=> The One True Ring with mime type $m <=\");\n\njulia> set_attribute!(R, :show, myshow)\n\njulia> AbstractAlgebra.@show_special(stdout, MIME\"text/plain\"(), R)\n=> The One True Ring with mime type text/plain <=\n\njulia> R   # show for R uses @show_special, so we can observe the effect directly\n=> The One True Ring <=\n\n\n\n\n\n","category":"macro"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.@show_special_elem","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.@show_special_elem","text":"@show_special_elem(io::IO, obj)\n\nIf the parent of obj has a show_elem attribute, this gets called with io and obj and returns from the current scope. Otherwise, does nothing.\n\nIf parent(obj) does not have attribute storage available, this macro does nothing.\n\nIt is supposed to be used at the start of show methods as shown in the documentation.\n\nExamples\n\njulia> R = @polynomial_ring(QQ, :x; cached=false)\nUnivariate polynomial ring in x over rationals\n\njulia> AbstractAlgebra.@show_special_elem(stdout, x)\n\njulia> set_attribute!(R, :show_elem, (i,o) -> print(i, \"=> $o <=\"))\n\njulia> AbstractAlgebra.@show_special_elem(stdout, x)\n=> x <=\n\njulia> x   # show for x does not uses @show_special_elem, so x prints as before\nx\n\n\n\n\n\n@show_special_elem(io::IO, mime, obj)\n\nIf the parent of obj has a show_elem attribute, this gets called with io, mime and obj (if applicable) and io and obj otherwise, and returns from the current scope. Otherwise, does nothing.\n\nIf parent(obj) does not have attribute storage available, this macro does nothing.\n\nIt is supposed to be used at the start of show methods as shown in the documentation.\n\nExamples\n\njulia> R = @polynomial_ring(QQ, :x; cached=false)\nUnivariate polynomial ring in x over rationals\n\njulia> AbstractAlgebra.@show_special_elem(stdout, MIME\"text/plain\"(), x)\n\njulia> set_attribute!(R, :show_elem, (i,m,o) -> print(i, \"=> $o with mime type $m <=\"))\n\njulia> AbstractAlgebra.@show_special_elem(stdout, MIME\"text/plain\"(), x)\n=> x with mime type text/plain <=\n\njulia> x   # show for x does not uses @show_special_elem, so x prints as before\nx\n\n\n\n\n\n","category":"macro"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.@show_name","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.@show_name","text":"@show_name(io::IO, obj)\n\nIf either is_terse(io) is true or property :compact is set to true for io (see IOContext), print the name get_name(obj) of the object obj to the io stream, then return from the current scope. Otherwise, do nothing.\n\nIt is supposed to be used at the start of show methods as shown in the documentation.\n\n\n\n\n\n","category":"macro"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.get_name","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.get_name","text":"get_name(obj) -> Union{String,Nothing}\n\nReturns the name of the object obj if it is set, or nothing otherwise. This function tries to find a name in the following order:\n\nThe name set by AbstractAlgebra.set_name!.\nThe name of a variable in global (Main module) namespace with value bound to the object obj (see AbstractAlgebra.PrettyPrinting.find_name).\nThe name returned by AbstractAlgebra.extra_name.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.set_name!","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.set_name!","text":"set_name!(obj, name::String; override::Bool=true)\n\nSets the name of the object obj to name. This name is used for printing using AbstractAlgebra.@show_name. If override is false, the name is only set if there is no name already set.\n\nThis function errors if obj does not support attribute storage.\n\n\n\n\n\nset_name!(obj; override::Bool=true)\n\nSets the name of the object obj to the name of a variable in global (Main module) namespace with value bound to the object obj, if such a variable exists (see AbstractAlgebra.PrettyPrinting.find_name). This name is used for printing using AbstractAlgebra.@show_name. If override is false, the name is only set if there is no name already set.\n\nThis function errors if obj does not support attribute storage.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.extra_name","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.extra_name","text":"extra_name(obj) -> Union{String,Nothing}\n\nMay be overloaded to provide a fallback name for the object obj in AbstractAlgebra.get_name. The default implementation returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.find_name","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.find_name","text":"find_name(obj, M = Main; all::Bool = false) -> Union{String,Nothing}\n\nReturn name of a variable in M's namespace with value bound to the object obj, or nothing if no such variable exists. If all is true, private and non-exported variables are also searched.\n\nnote: Note\nIf the object is stored in several variables, the first one will be used, but a name returned once is kept until the variable no longer contains this object.\n\nFor this to work in doctests, one should call AbstractAlgebra.set_current_module(@__MODULE__) in the value argument of Documenter.DocMeta.setdocmeta! and keep the default value of M = Main here.\n\nwarning: Warning\nThis function should not be used directly, but rather through AbstractAlgebra.get_name.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.pretty","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.pretty","text":"pretty(io::IO) -> IOCustom\n\nWrap io into an IOCustom object.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.Indent","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.Indent","text":"Indent\n\nWhen printed to an IOCustom object, increases the indentation level by one.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\njulia> print(io, AbstractAlgebra.Indent(), \"This is indented\")\n  This is indented\n\n\n\n\n\n","category":"type"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.Dedent","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.Dedent","text":"Dedent\n\nWhen printed to an IOCustom object, decreases the indentation level by one.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\njulia> print(io, AbstractAlgebra.Indent(), AbstractAlgebra.Dedent(), \"This is indented\")\nThis is indented\n\n\n\n\n\n","category":"type"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.Lowercase","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.Lowercase","text":"Lowercase\n\nWhen printed to an IOCustom object, the next letter printed will be lowercase.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\njulia> print(io, AbstractAlgebra.Lowercase(), \"Foo\")\nfoo\n\n\n\n\n\n","category":"type"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.LowercaseOff","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.LowercaseOff","text":"LowercaseOff\n\nWhen printed to an IOCustom object, the case of the next letter will not be changed when printed.\n\nExamples\n\njulia> io = AbstractAlgebra.pretty(stdout);\n\njulia> print(io, AbstractAlgebra.Lowercase(), AbstractAlgebra.LowercaseOff(), \"Foo\")\nFoo\n\n\n\n\n\n","category":"type"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.terse","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.terse","text":"terse(io::IO) -> IO\n\nReturn a new IO objects derived from io for which \"terse\" printing mode has been enabled.\n\nSee https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/ for details.\n\nExamples\n\njulia> AbstractAlgebra.is_terse(stdout)\nfalse\n\njulia> io = AbstractAlgebra.terse(stdout);\n\njulia> AbstractAlgebra.is_terse(io)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"misc/#AbstractAlgebra.PrettyPrinting.is_terse","page":"Miscellaneous","title":"AbstractAlgebra.PrettyPrinting.is_terse","text":"is_terse(io::IO) -> Bool\n\nTest whether \"terse\" printing mode is enabled for io.\n\nSee https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/ for details.\n\nExamples\n\njulia> AbstractAlgebra.is_terse(stdout)\nfalse\n\njulia> io = AbstractAlgebra.terse(stdout);\n\njulia> AbstractAlgebra.is_terse(io)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"residue_interface/#Residue-Ring-Interface","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Residue rings (currently a quotient ring modulo a principal ideal) are supported in AbstractAlgebra.jl, at least for Euclidean base rings. There is also partial support for residue rings of polynomial rings where the modulus has invertible leading coefficient.\n\nIn addition to the standard Ring interface, some additional functions are required to be present for residue rings.","category":"section"},{"location":"residue_interface/#Types-and-parents","page":"Residue Ring Interface","title":"Types and parents","text":"AbstractAlgebra provides four abstract types for residue rings and their elements:\n\nResidueRing{T} is the abstract type for residue ring parent types\nResidueField{T} is the abstract type for residue rings known to be fields\nResElem{T} is the abstract type for types of elements of residue rings (residues)\nResFieldElem{T} is the abstract type for types of elements of residue fields\n\nWe have that ResidueRing{T} <: AbstractAlgebra.Ring and ResElem{T} <: AbstractAlgebra.RingElem.\n\nNote that these abstract types are parameterised. The type T should usually be the type of elements of the base ring of the residue ring/field.\n\nIf the parent object for a residue ring has type MyResRing and residues in that ring have type MyRes then one would have:\n\nMyResRing <: ResidueRing{BigInt}\nMyRes <: ResElem{BigInt}\n\nResidue rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Residue rings should at least be distinguished based on their base ring and modulus (the principal ideal one is taking a quotient of the base ring by).\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"residue_interface/#Required-functionality-for-residue-rings","page":"Residue Ring Interface","title":"Required functionality for residue rings","text":"In addition to the required functionality for the Ring interface the Residue Ring interface has the following required functions.\n\nWe suppose that R is a fictitious base ring, m is an element of that ring, and that S is the residue ring (quotient ring) R(m) with parent object S of type MyResRing{T}. We also assume the residues r pmodm in the residue ring have type MyRes{T}, where T is the type of elements of the base ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem.","category":"section"},{"location":"residue_interface/#Data-type-and-parent-object-methods","page":"Residue Ring Interface","title":"Data type and parent object methods","text":"modulus(S::MyResRing{T}) where T <: AbstractAlgebra.RingElem\n\nReturn the modulus of the given residue ring, i.e. if the residue ring S was specified to be R(m), return m.","category":"section"},{"location":"residue_interface/#Basic-manipulation-of-rings-and-elements","page":"Residue Ring Interface","title":"Basic manipulation of rings and elements","text":"data(f::MyRes{T}) where T <: RingElem\nlift(f::MyRes{T}) where T <: RingElem\n\nGiven a residue r pmodm, represented as such, return r. In the special case where machine integers are used to represent the residue, data will return the machine integer, whereas lift will return a multiprecision integer. Otherwise lift falls back to data by default.","category":"section"},{"location":"interface_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"AbstractAlgebra defines a series of interfaces that can be extended with new types that implement those interfaces. For example, if one were implementing a new polynomial ring type, one would implement all of the required functionality described in this chapter for the relevant AbstractAlgebra interfaces. This would include the Ring Interface and the Univariate Polynomial Ring Interface.\n\nOnce a new type implements all the required functionality, all the corresponding generic functionality would then function automatically for the new type.\n\nOne may then go on to implement some of the optional functionality for performance if the provided generic functionality is insufficient.\n\nAbstractAlgebra tries to provide all generic constructions recursively so that one can have towers of generic constructions. This means that new interfaces should generally only be added if they cooperate with all the existing interfaces, at least so far as the theory exists to do so.","category":"section"},{"location":"series/#Power-series","page":"Power series","title":"Power series","text":"AbstractAlgebra.jl allows the creation of capped relative and absolute power series over any computable commutative ring R.\n\nCapped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where a_j in R and the relative precision k - j is at most equal to some specified precision n.\n\nCapped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.\n\nThere are two implementations of relative series: relative power series, implemented in src/RelSeries.jl for which j  0 in the above description, and Laurent series where j can be negative, implemented in src/Laurent.jl. Note that there are two implementations for Laurent series, one over rings and one over fields, though in practice most of the implementation uses the same code in both cases.\n\nThere is a single implementation of absolute series: absolute power series, implemented in src/AbsSeries.jl.","category":"section"},{"location":"series/#Generic-power-series-types","page":"Power series","title":"Generic power series types","text":"AbstractAlgebra.jl provides generic series types implemented in src/generic/AbsSeries.jl, src/generic/RelSeries.jl and src/generic/LaurentSeries.jl which implement the Series interface.\n\nThese generic series have types Generic.RelSeries{T}, Generic.AbsSeries{T}, Generic.LaurentSeriesRingElem{T} and Generic.LaurentSeriesFieldElem{T}. See the file src/generic/GenericTypes.jl for details.\n\nThe parent objects have types Generic.AbsPowerSeriesRing{T} and Generic.RelPowerSeriesRing{T} and Generic.LaurentSeriesRing{T} respectively.\n\nThe default precision, string representation of the variable and base ring R of a generic power series are stored in its parent object.","category":"section"},{"location":"series/#Abstract-types","page":"Power series","title":"Abstract types","text":"Relative power series elements belong to the abstract type RelPowerSeriesRingElem.\n\nLaurent series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are relative series.\n\nAbsolute power series elements belong to AbsPowerSeriesRingElem.\n\nThe parent types for relative and absolute power series, Generic.RelPowerSeriesRing{T} and Generic.AbsPowerSeriesRing{T} respectively, belong to SeriesRing{T}.\n\nThe parent types of Laurent series belong directly to Ring and Field respectively.","category":"section"},{"location":"series/#Series-ring-constructors","page":"Power series","title":"Series ring constructors","text":"In order to construct series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.\n\npower_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true, model::Symbol=:capped_relative)\n\nlaurent_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true)\n\nlaurent_series_ring(R::Field, prec_max::Int, s::VarName; cached::Bool = true)\n\nGiven a base ring R, a maximum precision (relative or absolute, depending on the model) and a string s specifying how the generator (variable) should be printed, return a tuple S, x representing the series ring and its generator.\n\nBy default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.\n\nIn the case of power series, the optional argument model can be set to either :capped_absolute or :capped_relative, depending on which power series model is required.\n\nIt is also possible to construct absolute and relative power series with a default variable. These are lightweight constructors and should be used in generic algorithms wherever possible when creating series rings where the symbol does not matter.\n\nAbsPowerSeriesRing(R::Ring, prec::Int)\nRelPowerSeriesRing(R::Ring, prec::Int)\n\nReturn the absolute or relative power series ring over the given base ring R and with precision cap given by prec. Note that a tuple is not returned, only the power series ring itself, not a generator.\n\nHere are some examples of constructing various kinds of series rings and coercing various elements into those rings.\n\nExamples\n\njulia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> S, y = power_series_ring(ZZ, 10, :y; model=:capped_absolute)\n(Univariate power series ring over integers, y + O(y^10))\n\njulia> T, z = laurent_series_ring(ZZ, 10, :z)\n(Laurent series ring in z over integers, z + O(z^11))\n\njulia> U, w = laurent_series_field(QQ, 10, :w)\n(Laurent series field in w over rationals, w + O(w^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = U(BigInt(1234))\n1234 + O(w^10)\n\njulia> k = T(z + 1)\n1 + z + O(z^10)\n\njulia> V = AbsPowerSeriesRing(ZZ, 10)\nUnivariate power series ring in x with precision 10\n  over integers","category":"section"},{"location":"series/#Power-series-constructors","page":"Power series","title":"Power series constructors","text":"Series can be constructed using arithmetic operators using the generator of the series. Also see the big-oh notation below for specifying the precision.\n\nAll of the standard ring constructors can also be used to construct power series.\n\n(R::SeriesRing)() # constructs zero\n(R::SeriesRing)(c::Integer)\n(R::SeriesRing)(c::elem_type(R))\n(R::SeriesRing{T})(a::T) where T <: RingElement\n\nIn addition, the following constructors that are specific to power series are provided. They take an array of coefficients, a length, precision and valuation. Coefficients will be coerced into the coefficient ring if they are not already in that ring.\n\nFor relative series we have:\n\n(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T <: RingElem\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: RingElem}\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: Integer}\n\nAnd for absolute series:\n\n(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T <: RingElem\n\nIt is also possible to create series directly without having to create the corresponding series ring.\n\nabs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\nrel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\nlaurent_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, scale::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\n\nExamples\n\njulia> S, x = power_series_ring(QQ, 10, :x; model=:capped_absolute)\n(Univariate power series ring over rationals, x + O(x^10))\n\njulia> f = S(Rational{BigInt}[0, 2, 3, 1], 4, 6)\n2*x + 3*x^2 + x^3 + O(x^6)\n\njulia> f = abs_series(ZZ, [1, 2, 3], 3, 5, :y)\n1 + 2*y + 3*y^2 + O(y^5)\n\njulia> g = rel_series(ZZ, [1, 2, 3], 3, 7, 4)\nx^4 + 2*x^5 + 3*x^6 + O(x^7)\n\njulia> k = abs_series(ZZ, [1, 2, 3], 1, 6, cached=false)\n1 + O(x^6)\n\njulia> p = rel_series(ZZ, BigInt[], 0, 3, 1)\nO(x^3)\n\njulia> q = abs_series(ZZ, [], 0, 6)\nO(x^6)\n\njulia> s = abs_series(ZZ, [1, 2, 3], 3, 5; max_precision=10)\n1 + 2*x + 3*x^2 + O(x^5)\n\njulia> s = laurent_series(ZZ, [1, 2, 3], 3, 5, 0, 2; max_precision=10)\n1 + 2*x^2 + 3*x^4 + O(x^5)","category":"section"},{"location":"series/#Big-oh-notation","page":"Power series","title":"Big-oh notation","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):\n\nO(x::SeriesElem)\n\nExamples\n\njulia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> S, y = laurent_series_ring(ZZ, 10, :y)\n(Laurent series ring in y over integers, y + O(y^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2y + 7y^2 + O(y^7)\n2*y + 7*y^2 + O(y^7)\n\nWhat is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.\n\nOf course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"section"},{"location":"series/#Power-series-models","page":"Power series","title":"Power series models","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).\n\nThe zero power series is simply taken to be 0 + O(x^b).\n\nThe capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.\n\nHowever, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.\n\nSimilar comments apply to Laurent series.\n\nOn the other hand, capped absolute power series have their absolute precision capped. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form c_ax^a + c_a+1x^a+1 + ldots + O(x^b).\n\nCapped absolute series are additively stable, but not necessarily multiplicatively stable.\n\nFor all models, the maximum precision is also used as a default precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.\n\nIn all models we say that two power series are equal if they agree up to the minimum absolute precision of the two power series.\n\nThus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.\n\nDuring computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.\n\nAmongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).\n\nSometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.\n\nFor example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.\n\nThere are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?\n\nIf one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.\n\nOn the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!\n\nOne should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.\n\nSimply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!\n\nAn absolute power series ring over a ring R with precision p behaves very much like the quotient Rx(x^p) of the polynomial ring over R. Therefore one can often treat absolute power series rings as though they were rings. However, this depends on all series being given a precision equal to the specified maximum precision and not a lower precision.","category":"section"},{"location":"series/#Functions-for-types-and-parents-of-series-rings","page":"Power series","title":"Functions for types and parents of series rings","text":"base_ring(R::SeriesRing)\nbase_ring(a::SeriesElem)\n\nReturn the coefficient ring of the given series ring or series.\n\nparent(a::SeriesElem)\n\nReturn the parent of the given series.","category":"section"},{"location":"series/#Series-functions","page":"Power series","title":"Series functions","text":"Unless otherwise noted, the functions below are available for all series models, including Laurent series. We denote this by using the abstract type RelPowerSeriesRingElem, even though absolute series and Laurent series types do not belong to this abstract type.","category":"section"},{"location":"series/#Basic-functionality","page":"Power series","title":"Basic functionality","text":"Series implement the Ring Interface\n\nzero(R::SeriesRing)\none(R::SeriesRing)\niszero(a::SeriesElem)\nisone(a::SeriesElem)\n\ndivexact(a::T, b::T) where T <: SeriesElem\ninv(a::SeriesElem)\n\nSeries also implement the Series Interface, the most important basic functions being the following.\n\nvar(S::SeriesRing)\n\nReturn a symbol for the variable of the given series ring.\n\nmax_precision(S::SeriesRing)\n\nReturn the precision cap of the given series ring.\n\nprecision(f::SeriesElem)\nvaluation(f::SeriesElem)\n\ngen(R::SeriesRing)\n\nThe following functions are also provided for all series.\n\ncoeff(a::SeriesElem, n::Int)\n\nReturn the degree n coefficient of the given power series. Note coefficients are numbered from n = 0 for the constant coefficient. If n exceeds the current precision of the power series, the function returns a zero coefficient.\n\nFor power series types, n must be non-negative. Laurent series do not have this restriction.\n\nExamples\n\njulia> S, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x + x^2 + O(x^10)\n1 + 2*x + x^2 + O(x^10)\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = pol_length(f)\n4\n\njulia> c = polcoeff(f, 3)\n1\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> max_precision(S) == 10\ntrue\n\njulia> T = parent(x + 1)\nUnivariate power series ring in x with precision 10\n  over integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x + x^2 + O(x^10)\n\njulia> p = precision(f)\n10\n\njulia> R, t = power_series_ring(QQ, 10, :t)\n(Univariate power series ring over rationals, t + O(t^11))\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = is_gen(gen(R))\ntrue\n\njulia> m = is_unit(-1 + x + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4\n\njulia> p = valuation(b)\n1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n\njulia> S, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^5)\n1 + 3*x + x^3 + O(x^5)\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0], 4, 10, 3);\n\njulia> set_length!(g, 3)\nx^3 + 2*x^4 + O(x^10)\n\njulia> g = setcoeff!(g, 2, BigInt(11))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)\n\njulia> fit!(g, 8)\n\njulia> g = setcoeff!(g, 7, BigInt(4))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)","category":"section"},{"location":"series/#Change-base-ring","page":"Power series","title":"Change base ring","text":"Examples\n\njulia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = 4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n\njulia> map_coefficients(AbstractAlgebra.sqrt, f)\n2*x^6 + x^7 + 3*x^8 + 4*x^9 + 5*x^10 + O(x^11)\n\njulia> change_base_ring(QQ, f)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)","category":"section"},{"location":"series/#Shifting","page":"Power series","title":"Shifting","text":"Examples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = shift_left(a, 2)\n2*x^3 + x^5 + O(x^33)\n\njulia> g = shift_left(b, 2)\nO(x^6)\n\njulia> h = shift_right(c, 1)\n1 + 2*x + O(x^4)\n\njulia> k = shift_right(d, 3)\n1 + O(x^1)\n","category":"section"},{"location":"series/#Truncation","page":"Power series","title":"Truncation","text":"Examples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = truncate(a, 3)\n2*x + O(x^3)\n\njulia> g = truncate(b, 2)\nO(x^2)\n\njulia> h = truncate(c, 7)\n1 + x + 2*x^2 + O(x^5)\n\njulia> k = truncate(d, 5)\n2*x + x^3 + O(x^4)\n","category":"section"},{"location":"series/#Division","page":"Power series","title":"Division","text":"Examples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = S(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"section"},{"location":"series/#Composition","page":"Power series","title":"Composition","text":"Note that subst can be used instead of compose, however the provided functionality is the same. General series substitution is not well-defined.","category":"section"},{"location":"series/#Derivative-and-integral","page":"Power series","title":"Derivative and integral","text":"","category":"section"},{"location":"series/#Special-functions","page":"Power series","title":"Special functions","text":"Methods for is_square and sqrt are provided for inputs of type RelPowerSeriesRingElem.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = power_series_ring(R, 30, :x)\n(Univariate power series ring over R, x + O(x^31))\n\njulia> T, z = power_series_ring(QQ, 30, :z)\n(Univariate power series ring over rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> log(exp(b)) == b\ntrue\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"section"},{"location":"series/#Random-generation","page":"Power series","title":"Random generation","text":"Random series can be constructed using the rand function. A range of possible valuations is provided. The maximum precision of the ring is used as a bound on the precision. Other parameters are used to construct random coefficients.\n\nrand(R::SeriesRing, val_range::AbstractUnitRange{Int}, v...)\n\nExamples\n\njulia> R, x = power_series_ring(ZZ, 10, :x)\n(Univariate power series ring over integers, x + O(x^11))\n\njulia> f = rand(R, 3:5, -10:10)\n3*x^4 - x^5 + 4*x^7 + 4*x^8 - 7*x^9 + 2*x^10 + 4*x^11 - x^12 - 4*x^13 + O(x^14)","category":"section"},{"location":"series/#AbstractAlgebra.modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:ResElem","page":"Power series","title":"AbstractAlgebra.modulus","text":"modulus(a::SeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given power series.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.is_gen-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"AbstractAlgebra.is_gen","text":"is_gen(a::RelPowerSeriesRingElem)\n\nReturn true if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.map_coefficients-Tuple{Any, AbsPowerSeriesRingElem{<:RingElem}}","page":"Power series","title":"AbstractAlgebra.map_coefficients","text":"map_coefficients(f, p::SeriesElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the series p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.change_base_ring-Tuple{Ring, AbsPowerSeriesRingElem{<:RingElem}}","page":"Power series","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, p::SeriesElem{<: RingElement}; parent::PolyRing)\n\nReturn the series obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the series will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.shift_left-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"AbstractAlgebra.shift_left","text":"shift_left(x::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.shift_right-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"AbstractAlgebra.shift_right","text":"shift_right(x::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted right by n terms, i.e. divided by x^n.\n\n\n\n\n\n","category":"method"},{"location":"series/#Base.truncate-Union{Tuple{T}, Tuple{RelPowerSeriesRingElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"Base.truncate","text":"truncate(a::RelPowerSeriesRingElem{T}, n::Int) where T <: RingElement\n\nReturn a truncated to (absolute) precision n.\n\n\n\n\n\n","category":"method"},{"location":"series/#Base.inv-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"Base.inv","text":"Base.inv(a::RelPowerSeriesRingElem)\n\nReturn the inverse of the power series a, i.e. 1a.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.compose-Tuple{RelPowerSeriesRingElem, RelPowerSeriesRingElem}","page":"Power series","title":"AbstractAlgebra.compose","text":"compose(f::RelPowerSeriesRingElem, g::RelPowerSeriesRingElem; inner)\n\nCompose the series a with the series b and return the result.\n\nIf inner = :second, then f(g) is returned and g must have positive valuation.\nIf inner = :first, then g(f) is returned and f must have positive valuation.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.derivative-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"AbstractAlgebra.derivative","text":"derivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"series/#AbstractAlgebra.integral-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"AbstractAlgebra.integral","text":"integral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"series/#Base.log-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:FieldElem","page":"Power series","title":"Base.log","text":"log(a::SeriesElem{T}) where T <: FieldElement\n\nReturn the logarithm of the power series a.\n\n\n\n\n\nlog(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"series/#Base.exp-Tuple{RelPowerSeriesRingElem}","page":"Power series","title":"Base.exp","text":"exp(a::AbsPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::RelPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"assertions/#Assertion-and-Verbosity-Macros","page":"Assertion and Verbosity Macros","title":"Assertion and Verbosity Macros","text":"We describe here various macros provided by AbstractAlgebra.","category":"section"},{"location":"assertions/#Verbosity-macros","page":"Assertion and Verbosity Macros","title":"Verbosity macros","text":"There is a (global) list of symbols called verbosity scopes which represent keywords used to trigger some verbosity macros within the code. Each of these verbosity scopes has its own integer verbosity level, which is set to 0 by default. A verbosity macro call must specify the verbosity scope S and optionally the trigger level k (defaulting to 1) such that, if the current verbosity level l of S is bigger than or equal to k, then the macro triggers a given action.  Inside a module, the function add_verbosity_scope must be called in the __init__ function of that module.","category":"section"},{"location":"assertions/#Printings","page":"Assertion and Verbosity Macros","title":"Printings","text":"","category":"section"},{"location":"assertions/#Actions","page":"Assertion and Verbosity Macros","title":"Actions","text":"","category":"section"},{"location":"assertions/#Assertion-macros","page":"Assertion and Verbosity Macros","title":"Assertion macros","text":"There is a list of symbols called assertion scopes which represent keywords used to trigger some particular macros within the codes. Each of these assertion scopes is associated with an assertion level, being set to 0 by default. An assertion macro is joined to an assertion scope S and a value k (set to 1 by default) such that, if the current assertion level l of S is bigger than or equal to k, then the macro triggers an action on the given assertion","category":"section"},{"location":"assertions/#Check","page":"Assertion and Verbosity Macros","title":"Check","text":"","category":"section"},{"location":"assertions/#Miscellaneous","page":"Assertion and Verbosity Macros","title":"Miscellaneous","text":"","category":"section"},{"location":"assertions/#AbstractAlgebra.add_verbosity_scope-Tuple{Symbol}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.add_verbosity_scope","text":"AbstractAlgebra.add_verbosity_scope(s::Symbol) -> Nothing\n\nAdd the symbol s to the list of (global) verbosity scopes. For use inside a module this function must be called in the  __init__ function of that module; the verbosity scope is then available to all functions in the module.\n\nExamples\n\njulia> AbstractAlgebra.add_verbosity_scope(:MyScope)\n\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.set_verbosity_level-Tuple{Symbol, Int64}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.set_verbosity_level","text":"AbstractAlgebra.set_verbosity_level(s::Symbol, l::Int) -> Int\n\nIf s represents a known verbosity scope, set the current verbosity level of s to l.\n\nOne can access the current verbosity level of s by calling the function get_verbosity_level.\n\nIf s is not yet known as a verbosity scope, the function raises an ErrorException showing the error message \"Not a valid symbol\". One can add s to the list of verbosity scopes by calling the function add_verbosity_scope.\n\nExamples\n\njulia> AbstractAlgebra.add_verbosity_scope(:MyScope)\n\njulia> AbstractAlgebra.set_verbosity_level(:MyScope, 4)\n4\n\njulia> AbstractAlgebra.set_verbosity_level(:MyScope, 0)\n0\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.get_verbosity_level-Tuple{Symbol}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.get_verbosity_level","text":"AbstractAlgebra.get_verbosity_level(s::Symbol) -> Int\n\nIf s represents a known verbosity scope, return the current verbosity level of s.\n\nOne can modify the current verbosity level of s by calling the function set_verbosity_level.\n\nIf s is not yet known as a verbosity scope, the function raises an ErrorException showing the error message \"Not a valid symbol\". One can add s to the list of verbosity scopes by calling the function add_verbosity_scope.\n\nExamples\n\njulia> AbstractAlgebra.add_verbosity_scope(:MyScope)\n\njulia> AbstractAlgebra.get_verbosity_level(:MyScope)\n0\n\njulia> AbstractAlgebra.set_verbosity_level(:MyScope, 4)\n4\n\njulia> AbstractAlgebra.get_verbosity_level(:MyScope)\n4\n\njulia> AbstractAlgebra.set_verbosity_level(:MyScope, 0)\n0\n\njulia> AbstractAlgebra.get_verbosity_level(:MyScope)\n0\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.@vprintln","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.@vprintln","text":"@vprintln(S::Symbol, k::Int, msg::String)\n@vprintln S k msg\n\n@vprintln(S::Symbol, msg::String)\n@vprintln S msg\n\nThis macro can be used to control printings inside the code.\n\nThe macro @vprintln takes two or three arguments: a symbol S specifying a verbosity scope, an optional integer k and a string msg. If k is not specified, it is set by default to 1.\n\nTo each verbosity scope S is associated a verbosity level l which is cached. If the verbosity level l of S is bigger than or equal to k, the macro @vprintln triggers the printing of the associated string msg followed by a newline.\n\nOne can add a new verbosity scope by calling the function add_verbosity_scope.\n\nWhen starting a new instance, all the verbosity levels are set to 0. One can adjust the verbosity level of a verbosity scope by calling the function set_verbosity_level.\n\nOne can access the current verbosity level of a verbosity scope by calling the function get_verbosity_level.\n\nExamples\n\nWe will set up different verbosity scopes with different verbosity levels in a custom function to show how to use this macro.\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test1);\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test2);\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test3);\n\njulia> AbstractAlgebra.set_verbosity_level(:Test1, 1);\n\njulia> AbstractAlgebra.set_verbosity_level(:Test2, 3);\n\njulia> function vprint_example()\n       @vprintln :Test1 \"Triggered\"\n       @vprintln :Test2 2 \"Triggered\"\n       @vprintln :Test3 \"Not triggered\"\n       @vprintln :Test2 4 \"Not triggered\"\n       end\nvprint_example (generic function with 1 method)\n\njulia> vprint_example()\nTriggered\nTriggered\n\nIf one does not setup in advance a verbosity scope, the macro will raise an ExceptionError showing the error message \"Not a valid symbol\".\n\n\n\n\n\n","category":"macro"},{"location":"assertions/#AbstractAlgebra.@vprint","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.@vprint","text":"@vprint(S::Symbol, k::Int, msg::String)\n@vprint S k msg\n\n@vprint(S::Symbol, msg::String)\n@vprint S msg\n\nThe same as @vprintln, but without the final newline.\n\n\n\n\n\n","category":"macro"},{"location":"assertions/#AbstractAlgebra.@v_do","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.@v_do","text":"@v_do(S::Symbol, k::Int, act::Expr)\n@v_do S k act\n\n@v_do(S::Symbol, act::Expr)\n@v_do S act\n\nThis macro can be used to control actions inside the code.\n\nThe macro @v_do takes two or three arguments: a symbol S specifying a verbosity scope, an optional integer k and an action act. If k is not specified, it is set by default to 1.\n\nTo each verbosity scope S is associated a verbosity level l. If the verbosity level l of S is bigger than or equal to k, the macro @v_do triggers the action act.\n\nOne can add a new verbosity scope by calling the function add_verbosity_scope.\n\nWhen starting a new instance, all the verbosity levels are set to 0. One can adjust the verbosity level of a verbosity scope by calling the function set_verbosity_level.\n\nOne can access the current verbosity level of a verbosity scope by calling the function get_verbosity_level.\n\nExamples\n\nWe will set up different verbosity scopes with different verbosity levels in a custom function to show how to use this macro.\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test1);\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test2);\n\njulia> AbstractAlgebra.add_verbosity_scope(:Test3);\n\njulia> AbstractAlgebra.set_verbosity_level(:Test1, 1);\n\njulia> AbstractAlgebra.set_verbosity_level(:Test2, 3);\n\njulia> function v_do_example(a::Int, b::Int, c::Int, d::Int)\n       @v_do :Test1 a = 2*a\n       @v_do :Test2 2 b = 3*b\n       @v_do :Test3 c = 4*c\n       @v_do :Test2 4 d = 5*d\n       return (a, b, c, d)\n       end\nv_do_example (generic function with 1 method)\n\njulia> v_do_example(1,1,1,1)\n(2, 3, 1, 1)\n\nIf one does not setup in advance a verbosity scope, the macro will raise an ExceptionError showing the error message \"Not a valid symbol\".\n\n\n\n\n\n","category":"macro"},{"location":"assertions/#AbstractAlgebra.add_assertion_scope-Tuple{Symbol}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.add_assertion_scope","text":"AbstractAlgebra.add_assertion_scope(s::Symbol) -> Nothing\n\nAdd the symbol s to the list of (global) assertion scopes.\n\nExamples\n\njulia> AbstractAlgebra.add_assertion_scope(:MyScope)\n\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.set_assertion_level-Tuple{Symbol, Int64}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.set_assertion_level","text":"AbstractAlgebra.set_assertion_level(s::Symbol, l::Int) -> Int\n\nIf s represents a known assertion scope, set the current assertion level of s to l.\n\nOne can access the current assertion level of s by calling the function get_assertion_level.\n\nIf s is not yet known as an assertion scope, the function raises an ErrorException showing the error message \"Not a valid symbol\". One can add s to the list of assertion scopes by calling the function add_assertion_scope.\n\nExamples\n\njulia> AbstractAlgebra.add_assertion_scope(:MyScope)\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 4)\n4\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 0)\n0\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.get_assertion_level-Tuple{Symbol}","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.get_assertion_level","text":"AbstractAlgebra.get_assertion_level(s::Symbol) -> Int\n\nIf s represents a symbol of a known assertion scope, return the current assertion level of s.\n\nOne can modify the current assertion level of s by calling the function set_assertion_level.\n\nIf s is not yet known as an assertion scope, the function raises an ErrorException showing the error message \"Not a valid symbol\". One can add s to the list of assertion scopes by calling the function add_assertion_scope.\n\nExamples\n\njulia> AbstractAlgebra.add_assertion_scope(:MyScope)\n\njulia> AbstractAlgebra.get_assertion_level(:MyScope)\n0\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 1)\n1\n\njulia> AbstractAlgebra.get_assertion_level(:MyScope)\n1\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 0)\n0\n\njulia> AbstractAlgebra.get_assertion_level(:MyScope)\n0\n\n\n\n\n\n","category":"method"},{"location":"assertions/#AbstractAlgebra.@hassert","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.@hassert","text":"@hassert(S::Symbol, k::Int, assert::Expr)\n@hassert S k assert\n\n@hassert(S::Symbol, assert::Expr)\n@hassert S assert\n\nThis macro can be used to control assertion checks inside the code.\n\nThe macro @hassert takes two or three arguments: a symbol S specifying an assertion scope, an optional integer k and an assertion assert. If k is not specified, it is set by default to 1.\n\nTo each assertion scope S is associated an assertion level l which is cached. If the assertion level l of S is bigger than or equal to k, the macro @hassert triggers the check of the assertion assert. If assert is wrong, an AssertionError is thrown.\n\nOne can add a new assertion scope by calling the function add_assertion_scope.\n\nWhen starting a new instance, all the assertion levels are set to 0. One can adjust the assertion level of an assertion scope by calling the function set_assertion_level.\n\nOne can access the current assertion level of an assertion scope by calling the function get_assertion_level.\n\nExamples\n\nWe will set up different assertion scopes with different assertion levels in a custom function to show how to use this macro.\n\njulia> AbstractAlgebra.add_assertion_scope(:MyScope)\n\njulia> AbstractAlgebra.get_assertion_level(:MyScope)\n0\n\njulia> function hassert_test(x::Int)\n       @hassert :MyScope 700 mod(x, 3) == 0\n       return div(x, 3)\n       end\nhassert_test (generic function with 1 method)\n\njulia> hassert_test(2)\n0\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 701);\n\njulia> try hassert_test(2)\n       catch e e\n       end\nAssertionError(\"\\$(Expr(:escape, :(mod(x, 3) == 0)))\")\n\njulia> hassert_test(3)\n1\n\njulia> AbstractAlgebra.set_assertion_level(:MyScope, 0)\n0\n\nIf one does not setup in advance an assertion scope, the macro will raise an ExceptionError showing the error message \"Not a valid symbol\".\n\n\n\n\n\n","category":"macro"},{"location":"assertions/#AbstractAlgebra.@req","page":"Assertion and Verbosity Macros","title":"AbstractAlgebra.@req","text":"@req(assert, msg)\n@req assert msg\n\nCheck whether the assertion assert is true. If not, throw an ArgumentError with error message msg.\n\nThe macro @req takes two arguments: the first one is an assertion assert (an expression which returns a boolean) and a string msg corresponding to the desired error message to be returned whenever assert is false.\n\nIf the number of arguments is not 2, an AssertionError is raised.\n\nExamples\n\njulia> function req_test(x::Int)\n       @req iseven(x) \"x must be even\"\n       return div(x,2)\n       end\nreq_test (generic function with 1 method)\n\njulia> try req_test(3)\n       catch e e\n       end\nArgumentError(\"x must be even\")\n\njulia> try req_test(2)\n       catch e e\n       end\n1\n\n\n\n\n\n\n","category":"macro"},{"location":"ideal/#Ideal-functionality","page":"Ideal functionality","title":"Ideal functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/Ideal.jl for ideals of a Euclidean domain (assuming the existence of a gcdx function) or of a univariate or multivariate polynomial ring over the integers. Univariate and multivariate polynomial rings over other domains (other than fields) are not supported at this time.\n\ninfo: Info\nA more complete implementation for ideals defined over other rings is provided by Hecke and Oscar.","category":"section"},{"location":"ideal/#Generic-ideal-types","page":"Ideal functionality","title":"Generic ideal types","text":"AbstractAlgebra.jl provides a generic ideal type based on Julia arrays which is implemented in src/generic/Ideal.jl.\n\nThese generic ideals have type Generic.Ideal{T} where T is the type of elements of the ring the ideals belong to. Internally they consist of a Julia array of generators and some additional fields for a parent object, etc. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of ideals have type Generic.IdealSet{T}.","category":"section"},{"location":"ideal/#Abstract-types","page":"Ideal functionality","title":"Abstract types","text":"All ideal types belong to the abstract type Ideal{T} and their parents belong to the abstract type Set. This enables one to write generic functions that can accept any AbstractAlgebra ideal type.\n\nnote: Note\nBoth the generic ideal type Generic.Ideal{T} and the abstract type it belongs to, Ideal{T}, are called Ideal. The former is a (parameterised) concrete type for an ideal in the ring whose elements have type T. The latter is an abstract type representing all ideal types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"section"},{"location":"ideal/#Ideal-constructors","page":"Ideal functionality","title":"Ideal constructors","text":"One may construct ideals in AbstractAlgebra.jl with the following constructor.\n\nGeneric.Ideal(R::Ring, V::Vector{T}) where T <: RingElement\n\nGiven a set of elements V in the ring R, construct the ideal of R generated by the elements V. Note that V may be arbitrary, e.g. it can contain duplicates, zero entries or be empty.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]; internal_ordering=:degrevlex)\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> V = [3*x^2*y - 3*y^2, 9*x^2*y + 7*x*y]\n2-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n 3*x^2*y - 3*y^2\n 9*x^2*y + 7*x*y\n\njulia> I = Generic.Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.MPoly{BigInt}}(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[7*x*y + 9*y^2, 243*y^3 - 147*y^2, x*y^2 + 36*y^3 - 21*y^2, x^2*y + 162*y^3 - 99*y^2])\n\njulia> W = map(ZZ, [2, 5, 7])\n3-element Vector{BigInt}:\n 2\n 5\n 7\n\njulia> J = Generic.Ideal(ZZ, W)\nAbstractAlgebra.Generic.Ideal{BigInt}(Integers, BigInt[1])","category":"section"},{"location":"ideal/#Ideal-functions","page":"Ideal functionality","title":"Ideal functions","text":"","category":"section"},{"location":"ideal/#Basic-functionality","page":"Ideal functionality","title":"Basic functionality","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> V = [1 + 2x^2 + 3x^3, 5x^4 + 1, 2x - 1]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n 2*x - 1\n\njulia> I = Generic.Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(Univariate polynomial ring in x over integers, AbstractAlgebra.Generic.Poly{BigInt}[3, x + 1])\n\njulia> gens(I)\n2-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3\n x + 1","category":"section"},{"location":"ideal/#Arithmetic-of-Ideals","page":"Ideal functionality","title":"Arithmetic of Ideals","text":"Ideals support addition, multiplication, scalar multiplication and equality testing of ideals.","category":"section"},{"location":"ideal/#Containment","page":"Ideal functionality","title":"Containment","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> V = [1 + 2x^2 + 3x^3, 5x^4 + 1, 2x - 1]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n 2*x - 1\n\njulia> W = [1 + 2x^2 + 3x^3, 5x^4 + 1]\n2-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n\njulia> I = Generic.Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(Univariate polynomial ring in x over integers, AbstractAlgebra.Generic.Poly{BigInt}[3, x + 1])\n\njulia> J = Generic.Ideal(R, W)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(Univariate polynomial ring in x over integers, AbstractAlgebra.Generic.Poly{BigInt}[282, 3*x + 255, x^2 + 107])\n\njulia> is_subset(I, J)\nfalse\n\njulia> is_subset(J, I)\ntrue\n\njulia> intersect(I, J) == J\ntrue","category":"section"},{"location":"ideal/#Normal-form","page":"Ideal functionality","title":"Normal form","text":"For ideal of polynomial rings it is possible to return the normal form of a polynomial with respect to an ideal.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]; internal_ordering=:degrevlex)\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> V = [3*x^2*y - 3*y^2, 9*x^2*y + 7*x*y]\n2-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n 3*x^2*y - 3*y^2\n 9*x^2*y + 7*x*y\n\njulia> I = Generic.Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.MPoly{BigInt}}(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[7*x*y + 9*y^2, 243*y^3 - 147*y^2, x*y^2 + 36*y^3 - 21*y^2, x^2*y + 162*y^3 - 99*y^2])\n\n\njulia> normal_form(30x^5*y + 2x + 1, I)\n135*y^4 + 138*y^3 - 147*y^2 + 2*x + 1","category":"section"},{"location":"ideal/#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.Ideal}","page":"Ideal functionality","title":"AbstractAlgebra.gens","text":"gens(I::Ideal{T}) where T <: RingElement\n\nReturn a list of generators of the ideal I in reduced form and canonicalised.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#AbstractAlgebra.is_subset-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractAlgebra.Generic.Ideal","page":"Ideal functionality","title":"AbstractAlgebra.is_subset","text":"Base.issubset(I::T, J::T) where {T <: Ideal}\n\nReturn true if the ideal I is a subset of the ideal J. An exception is thrown if the ideals are not defined over the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.intersect-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Ideal{T}, AbstractAlgebra.Generic.Ideal{T}}} where T<:RingElement","page":"Ideal functionality","title":"Base.intersect","text":"intersect(I::Ideal{T}, J::Ideal{T}) where T <: RingElement\n\nReturn the intersection of the ideals I and J.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#AbstractAlgebra.Generic.normal_form-Union{Tuple{U}, Tuple{T}, Tuple{U, AbstractAlgebra.Generic.Ideal{U}}} where {T<:RingElement, U<:Union{MPolyRingElem{T}, PolyRingElem{T}}}","page":"Ideal functionality","title":"AbstractAlgebra.Generic.normal_form","text":"normal_form(p::U, I::Ideal{U}) where {U}\n\nReturn the normal form of the polynomial p with respect to the ideal I.\n\n\n\n\n\n","category":"method"},{"location":"field_interface/#Field-Interface","page":"Field Interface","title":"Field Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all fields. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their fields.","category":"section"},{"location":"field_interface/#Types","page":"Field Interface","title":"Types","text":"Most fields must supply two types:\n\na type for the parent object (representing the field itself)\na type for elements of that field\n\nFor example, the generic fraction field type in AbstractAlgebra.jl provides two types in generic/GenericTypes.jl:\n\nGeneric.FracField{T} for the parent objects\nGeneric.FracFieldElem{T} for the actual fractions\n\nThe parent type must belong to Field and the element type must belong to FieldElem. Of course, the types may belong to these abstract types transitively.\n\nFor parameterised fields, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring.\n\nThere can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"section"},{"location":"field_interface/#FieldElement-type-union","page":"Field Interface","title":"FieldElement type union","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to FieldElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of fields we define a union type FieldElement in src/julia/JuliaTypes.\n\nSo far, in addition to FieldElem the  union type FieldElement includes the Julia types Rational and AbstractFloat.\n\nMost of the generic code in AbstractAlgebra makes use of the union type FieldElement instead of FieldElem so that the generic functions also accept the Julia Base field types.\n\nnote: Note\nOne must be careful when defining ad hoc binary operations for field element types. It is often necessary to define separate versions of the functions for FieldElem then for each of the Julia types separately in order to avoid ambiguity warnings.\n\nNote that even though FieldElement is a union type we still have the following inclusion\n\nFieldElement <: RingElement","category":"section"},{"location":"field_interface/#Parent-object-caches","page":"Field Interface","title":"Parent object caches","text":"In many cases, it is desirable to have only one object in the system to represent each field. This means that if the same field is constructed twice, elements of the two fields will be compatible as far as arithmetic is concerned.\n\nIn order to facilitate this, global caches of fields are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.FracField parent objects are looked up in a dictionary FracDict to see if they have been previously defined.\n\nWhether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two fields are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two fields if they were constructed from identical data.\n\nIf a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl for examples of how to construct and handle such caches.","category":"section"},{"location":"field_interface/#Required-functions-for-all-fields","page":"Field Interface","title":"Required functions for all fields","text":"In the following, we list all the functions that are required to be provided for fields in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.\n\nWe give this interface for fictitious types MyParent for the type of the field parent object R and MyElem for the type of the elements of the field.\n\nnote: Note\nGeneric functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for fields that implement that additional functionality, and should be documented as such.\n\nIn the first place, all fields are rings and therefore any field type must implement all of the Ring interface. The functionality below is in addition to this basic functionality.","category":"section"},{"location":"field_interface/#Data-type-and-parent-object-methods","page":"Field Interface","title":"Data type and parent object methods","text":"characteristic(R::MyParent)\n\nReturn the characteristic of the field. If the characteristic is not known, an exception is raised.","category":"section"},{"location":"field_interface/#Basic-manipulation-of-rings-and-elements","page":"Field Interface","title":"Basic manipulation of rings and elements","text":"is_unit(f::MyElem)\n\nReturn true if the given element is invertible, i.e. nonzero in the field.","category":"section"},{"location":"mpoly_interface/#Multivariate-Polynomial-Ring-Interface","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Multivariate polynomial rings are supported in AbstractAlgebra.jl, and in addition to the standard Ring interface, numerous additional functions are provided.\n\nUnlike other kinds of rings, even complex operations such as GCD depend heavily on the multivariate representation. Therefore AbstractAlgebra.jl cannot provide much in the way of additional functionality to external multivariate implementations.\n\nThis means that external libraries must be able to implement their multivariate formats in whatever way they see fit. The required interface here should be implemented, even if it is not optimal. But it can be extended, either by implementing one of the optional interfaces, or by extending the required interface in some other way.\n\nNaturally, any multivariate polynomial ring implementation provides the full Ring interface, in order to be treated as a ring for the sake of AbstractAlgebra.jl.\n\nConsiderations which make it impossible for AbstractAlgebra.jl to provide generic functionality on top of an arbitrary multivariate module include:\n\norderings (lexical, degree, weighted, block, arbitrary)\nsparse or dense representation\ndistributed or recursive representation\npacked or unpacked exponents\nexponent bounds (and whether adaptive or not)\nrandom access or iterators\nwhether monomials and polynomials have the same type\nwhether special cache aware data structures such as Geobuckets are used","category":"section"},{"location":"mpoly_interface/#Types-and-parents","page":"Multivariate Polynomial Ring Interface","title":"Types and parents","text":"AbstractAlgebra.jl provides two abstract types for multivariate polynomial rings and their elements:\n\nMPolyRing{T} is the abstract type for multivariate polynomial ring parent types\nMPolyRingElem{T} is the abstract type for multivariate polynomial types\n\nWe have that MPolyRing{T} <: Ring and MPolyRingElem{T} <: RingElem.\n\nNote that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx y the type T would be the type of an integer, e.g. BigInt.\n\nMultivariate polynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Multivariate polynomial rings should at least be distinguished based on their base (coefficient) ring and number of variables. But if they have the same base ring, symbols (for their variables/generators) and ordering, they should certainly have the same parent object.\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"mpoly_interface/#Required-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Required functionality for multivariate polynomials","text":"In addition to the required functionality for the Ring interface, the Multivariate Polynomial interface has the following required functions.\n\nWe suppose that R is a fictitious base ring (coefficient ring) and that S is a multivariate polynomial ring over R (i.e. S = Rx y ldots) with parent object S of type MyMPolyRing{T}. We also assume the polynomials in the ring have type MyMPoly{T}, where T is the type of elements of the base (coefficient) ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem or more generally the union type RingElement which includes the Julia integer, rational and floating point types.","category":"section"},{"location":"mpoly_interface/#Constructors","page":"Multivariate Polynomial Ring Interface","title":"Constructors","text":"To construct a multivariate polynomial ring, there is the following constructor.\n\nPolynomials in a given ring can be constructed using the generators and basic polynomial arithmetic. However, this is inefficient and the following build context is provided for building polynomials term-by-term. It assumes the polynomial data type is random access, and so the constructor functions must be reimplemented for all other types of polynomials.\n\nMPolyBuildCtx(R::MPolyRing)\n\nReturn a build context for creating polynomials in the given polynomial ring.\n\npush_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\n\nAdd the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.\n\nfinish(M::MPolyBuildCtx)\n\nFinish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.","category":"section"},{"location":"mpoly_interface/#Data-type-and-parent-object-methods","page":"Multivariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"symbols(S::MyMPolyRing{T}) where T <: RingElem\n\nReturn an array of Symbols representing the variables (generators) of the polynomial ring. Note that these are Symbols not Strings, though their string values will usually be used when printing polynomials.\n\nnumber_of_variables(f::MyMPolyRing{T}) where T <: RingElem\n\nReturn the number of variables of the polynomial ring.\n\ngens(S::MyMPolyRing{T}) where T <: RingElem\n\nReturn an array of all the generators (variables) of the given polynomial ring (as polynomials).\n\nThe first entry in the array will be the variable with most significance with respect to the ordering.\n\ngen(S::MyMPolyRing{T}, i::Int) where T <: RingElem\n\nReturn the i-th generator (variable) of the given polynomial ring (as a polynomial).\n\ninternal_ordering(S::MyMPolyRing{T})\n\nReturn the ordering of the given polynomial ring as a symbol. Supported values currently include :lex, :deglex and :degrevlex.","category":"section"},{"location":"mpoly_interface/#Basic-manipulation-of-rings-and-elements","page":"Multivariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"length(f::MyMPoly{T}) where T <: RingElem\n\nReturn the number of nonzero terms of the given polynomial. The length of the zero polynomial is defined to be 0. The return value should be of type Int.\n\ndegrees(f::MyMPoly{T}) where T <: RingElem\n\nReturn an array of the degrees of the polynomial f in each of the variables.\n\ntotal_degree(f::MyMPoly{T}) where T <: RingElem\n\nReturn the total degree of the polynomial f, i.e. the highest sum of exponents occurring in any term of f.\n\nis_gen(x::MyMPoly{T}) where T <: RingElem\n\nReturn true if x is a generator of the polynomial ring.\n\ncoefficients(p::MyMPoly{T}) where T <: RingElem\n\nReturn an iterator for the coefficients of the polynomial p, starting with the coefficient of the most significant term with respect to the ordering. Generic code will provide this function automatically for random access polynomials that implement the coeff function.\n\nmonomials(p::MyMPoly{T}) where T <: RingElem\n\nReturn an iterator for the monomials of the polynomial p, starting with the monomial of the most significant term with respect to the ordering. Monomials in AbstractAlgebra are defined to have coefficient 1. See the function terms if you also require the coefficients, however note that only monomials can be compared. Generic code will provide this function automatically for random access polynomials that implement the monomial function.\n\nterms(p::MyMPoly{T}) where T <: RingElem\n\nReturn an iterator for the terms of the polynomial p, starting with the most significant term with respect to the ordering. Terms in AbstractAlgebra include the coefficient. Generic code will provide this function automatically for random access polynomials that implement the term function.\n\nexponent_vectors(a::MyMPoly{T}) where T <: RingElement\n\nReturn an iterator for the exponent vectors for each of the terms of the polynomial starting with the most significant term with respect to the ordering. Each exponent vector is an array of Ints, one for each variable, in the order given when the polynomial ring was created. Generic code will provide this function automatically for random access polynomials that implement the exponent_vector function.","category":"section"},{"location":"mpoly_interface/#Exact-division","page":"Multivariate Polynomial Ring Interface","title":"Exact division","text":"For any ring that implements exact division, the following can be implemented.\n\ndivexact(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn the exact quotient of f by g if it exists, otherwise throw an error.\n\ndivides(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn a tuple (flag, q) where flag is true if g divides f, in which case q will be the exact quotient, or flag is false and q is set to zero.\n\nremove(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn a tuple (v q) such that the highest power of g that divides f is g^v and the cofactor is q.\n\nvaluation(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn v such that the highest power of g that divides f is g^v.","category":"section"},{"location":"mpoly_interface/#Ad-hoc-exact-division","page":"Multivariate Polynomial Ring Interface","title":"Ad hoc exact division","text":"For any ring that implements exact division, the following can be implemented.\n\ndivexact(f::MyMPoly{T}, c::Integer) where T <: RingElem\ndivexact(f::MyMPoly{T}, c::Rational) where T <: RingElem\ndivexact(f::MyMPoly{T}, c::T) where T <: RingElem\n\nDivide the polynomial exactly by the constant c.","category":"section"},{"location":"mpoly_interface/#Euclidean-division","page":"Multivariate Polynomial Ring Interface","title":"Euclidean division","text":"Although multivariate polynomial rings are not in general Euclidean, it is possible to define a quotient with remainder function that depends on the polynomial ordering in the case that the quotient ring is a field or a Euclidean domain. In the case that a polynomial g divides a polynomial f, the result no longer depends on the ordering and the remainder is zero, with the quotient agreeing with the exact quotient.\n\ndivrem(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients).\n\nNote that the result of this function depends on the ordering of the polynomial ring.\n\ndiv(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nAs per the divrem function, but returning the quotient only. Especially when the quotient happens to be exact, this function can be exceedingly fast.","category":"section"},{"location":"mpoly_interface/#GCD","page":"Multivariate Polynomial Ring Interface","title":"GCD","text":"In cases where there is a meaningful Euclidean structure on the coefficient ring, it is possible to compute the GCD of multivariate polynomials.\n\ngcd(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem\n\nReturn a greatest common divisor of f and g.","category":"section"},{"location":"mpoly_interface/#Square-root","page":"Multivariate Polynomial Ring Interface","title":"Square root","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.\n\nsqrt(f::MyMPoly{T}, check::Bool=true) where T <: RingElem\n\nReturn the square root of the polynomial f and raise an exception if it is not a square. If check is set to false, the input is assumed to be a perfect square and this assumption is not fully checked. This can be significantly faster.\n\nis_square(::MyMPoly{T}) where T <: RingElem\n\nReturn true if f is a square.","category":"section"},{"location":"mpoly_interface/#Interface-for-sparse-distributed,-random-access-multivariates","page":"Multivariate Polynomial Ring Interface","title":"Interface for sparse distributed, random access multivariates","text":"The following additional functions should be implemented by libraries that provide a sparse distributed polynomial format, stored in a representation for which terms can be accessed in constant time (e.g. where arrays are used to store coefficients and exponent vectors).","category":"section"},{"location":"mpoly_interface/#Sparse-distributed,-random-access-constructors","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access constructors","text":"In addition to the standard constructors, the following constructor, taking arrays of coefficients and exponent vectors, should be provided.\n\n(S::MyMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: RingElem\n\nCreate the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.\n\nThere is no assumption about coefficients being nonzero or terms being in order or unique. Zero terms are removed by the function, duplicate terms are combined (added) and the terms are sorted so that they are in the correct order.\n\nEach exponent vector uses a separate integer for each exponent field, the first of which should be the exponent for the most significant variable with respect to the ordering. All exponents must be non-negative.\n\nA library may also optionally provide an interface that makes use of BigInt (or any other big integer type) for exponents instead of Int.","category":"section"},{"location":"mpoly_interface/#Sparse-distributed,-random-access-basic-manipulation","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access basic manipulation","text":"coeff(f::MyMPoly{T}, n::Int) where T <: RingElem\n\nReturn the coefficient of the n-th term of f. The first term should be the most significant term with respect to the ordering.\n\ncoeff(a::MyMPoly{T}, exps::Vector{Int}) where T <: RingElement\n\nReturn the coefficient of the term with the given exponent vector, or zero if there is no such term.\n\nmonomial(f::MyMPoly{T}, n::Int) where T <: RingElem\nmonomial!(m::MyMPoly{T}, f::MyMPoly{T}, n::Int) where T <: RingElem\n\nReturn the n-th monomial of f or set m to the n-th monomial of f, respectively. The first monomial should be the most significant term with respect to the ordering. Monomials have coefficient 1 in AbstractAlgebra. See the function term if you also require the coefficient, however, note that only monomials can be compared.\n\nterm(f::MyMPoly{T}, n::Int) where T <: RingElem\n\nReturn the n-th term of f. The first term should be the one whose monomial is most significant with respect to the ordering.\n\nexponent(f::MyMPoly{T}, i::Int, j::Int) where T <: RingElem\n\nReturn the exponent of the j-th variable in the i-th term of the polynomial f. The first term is the one with whose monomial is most significant with respect to the ordering.\n\nexponent_vector(a::MyMPoly{T}, i::Int) where T <: RingElement\n\nReturn a vector of exponents, corresponding to the exponent vector of the i-th term of the polynomial. Term numbering begins at 1 and the exponents are given in the order of the variables for the ring, as supplied when the ring was created.\n\nsetcoeff!(a::MyMPoly, exps::Vector{Int}, c::S) where S <: RingElement\n\nSet the coefficient of the term with the given exponent vector to the given value c. If no such term exists (and c neq 0), one will be inserted. This function takes O(log n) operations if a term with the given exponent already exists and c neq 0, or if the term is inserted at the end of the polynomial. Otherwise it can take O(n) operations in the worst case. This function must return the modified polynomial.","category":"section"},{"location":"mpoly_interface/#Unsafe-functions","page":"Multivariate Polynomial Ring Interface","title":"Unsafe functions","text":"The following functions must be provided, but are considered unsafe, as they may leave the polynomials in an inconsistent state and they mutate their inputs. As usual, such functions should only be applied on polynomials that have no references elsewhere in the system and are mainly intended to be used in carefully written library code, rather than by users.\n\nUsers should instead build polynomials using the constructors described above.\n\nfit!(f::MyMPoly{T}, n::Int) where T <: RingElem\n\nEnsure that the polynomial f internally has space for n nonzero terms. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.\n\nsetcoeff!(a::MyMPoly{T}, i::Int, c::T) where T <: RingElement\nsetcoeff!(a::MyMPoly{T}, i::Int, c::U) where {T <: RingElement, U <: Integer}\n\nSet the i-th coefficient of the polynomial a to c. No check is performed on the index i or for c = 0. It may be necessary to call combine_like_terms after calls to this function, to remove zero terms. The function must return the modified polynomial.\n\ncombine_like_terms!(a::MyMPoly{T}) where T <: RingElement\n\nRemove zero terms and combine any adjacent terms with the same exponent vector (by adding them). It is assumed that all the exponent vectors are already in the correct order with respect to the ordering. The function must return the resulting polynomial.\n\nset_exponent_vector!(a::MyMPoly{T}, i::Int, exps::Vector{Int}) where T <: RingElement\n\nSet the i-th exponent vector to the given exponent vector. No check is performed on the index i, which is assumed to be valid (or that the polynomial has enough space allocated). No sorting of exponents is performed by this function. To sort the terms after setting any number of exponents with this function, run the sort_terms! function. The function must return the modified polynomial.\n\nsort_terms!(a::MyMPoly{T}) where {T <: RingElement}\n\nSort the terms of the given polynomial according to the polynomial ring ordering. Zero terms and duplicate exponents are ignored. To deal with those call combine_like_terms. The sorted polynomial must be returned by the function.","category":"section"},{"location":"mpoly_interface/#Optional-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Optional functionality for multivariate polynomials","text":"The following functions can optionally be implemented for multivariate polynomial types.","category":"section"},{"location":"mpoly_interface/#Reduction-by-an-ideal","page":"Multivariate Polynomial Ring Interface","title":"Reduction by an ideal","text":"divrem(f::MyMPoly{T}, G::Vector{MyMPoly{T}}) where T <: RingElem\n\nAs per the divrem function above, except that each term of r starting with the most significant term, is reduced modulo the leading terms of each of the polynomials in the array G for which the leading monomial is a divisor.\n\nA tuple (Q r) is returned from the function, where Q is an array of polynomials of the same length as G, and such that f = r + sum QiGi.\n\nThe result is again dependent on the ordering in general, but if the polynomials in G are over a field and the reduced generators of a Groebner basis, then the result is unique.","category":"section"},{"location":"mpoly_interface/#Evaluation","page":"Multivariate Polynomial Ring Interface","title":"Evaluation","text":"evaluate(a::MyMPoly{T}, A::Vector{T}) where T <: RingElem\n\nEvaluate the polynomial at the given values in the coefficient ring of the polynomial. The result should be an element of the coefficient ring.\n\nevaluate(f::MyMPoly{T}, A::Vector{U}) where {T <: RingElem, U <: Integer}\n\nEvaluate the polynomial f at the values specified by the entries of the array A.\n\n(a::MyMPoly{T})(vals::NCRingElement...) where T <: RingElement\n\nEvaluate the polynomial at the given arguments. This provides functional notation for polynomial evaluation, i.e. f(a b c). It must be defined for each supported polynomial type (Julia does not allow functional notation to be defined for an abstract type).\n\nThe code for this function in MPoly.jl can be used when implementing this as it provides the most general possible evaluation, which is much more general than the case of evaluation at elements of the same ring.\n\nThe evaluation should succeed for any set of values for which a multiplication is defined with the product of a coefficient and all the values before it.\n\nnote: Note\nThe values at which a polynomial is evaluated may be in non-commutative rings. Products are performed in the order of the variables in the polynomial ring that the polynomial belongs to, preceded by a multiplication by the coefficient on the left.","category":"section"},{"location":"mpoly_interface/#Derivations","page":"Multivariate Polynomial Ring Interface","title":"Derivations","text":"The following function allows to compute derivations of multivariate polynomials of type MPoly.\n\nderivative(f::MyMPoly{T}, j::Int) where T <: RingElem\n\nCompute the derivative of f with respect to the j-th variable of the polynomial ring.","category":"section"},{"location":"mpoly_interface/#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}-mpoly_interface","page":"Multivariate Polynomial Ring Interface","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached=true, internal_ordering=:lex)\n\nGiven a coefficient ring R and variable names, say varnames = [:x1, :x2, ...], return a tuple S, [x1, x2, ...] of the polynomial ring S = Rx1 x2 dots and its generators x1 x2 dots.\n\nBy default (cached=true), the output S will be cached, i.e. if polynomial_ring is invoked again with the same arguments, the same (identical) ring is returned. Setting cached to false ensures a distinct new ring is returned, and will also prevent it from being cached.\n\nThe monomial ordering used for the internal storage of polynomials in S can be set with internal_ordering and must be one of :lex, :deglex or :degrevlex.\n\nSee also: polynomial_ring(::Ring, ::Vararg), @polynomial_ring.\n\nExample\n\njulia> S, generators = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Euclidean-Ring-Interface","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"If a ring provides a meaningful Euclidean structure such that a useful Euclidean remainder can be computed practically, various additional functionality is provided by AbstractAlgebra.jl for those rings. This functionality depends on the following functions existing. An implementation must provide divrem, and the remaining are optional as generic fallbacks exist.","category":"section"},{"location":"euclidean_interface/#Base.divrem-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.divrem","text":"divrem(f::T, g::T) where T <: RingElem\n\nReturn a pair q, r consisting of the Euclidean quotient and remainder of f by g. A DivideError should be thrown if g is zero.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.mod-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.mod","text":"mod(f::T, g::T) where T <: RingElem\n\nReturn the Euclidean remainder of f by g. A DivideError should be thrown if g is zero.\n\nnote: Note\nFor best compatibility with the internal assumptions made by AbstractAlgebra, the Euclidean remainder function should provide unique representatives for the residue classes; the mod function should satisfymod(a_1, b) = mod(a_2, b) if and only if b divides a_1 - a_2, and\nmod(0, b) = 0.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.div-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.div","text":"div(f::T, g::T) where T <: RingElem\n\nReturn the Euclidean quotient of f by g. A DivideError should be thrown if g is zero.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.mulmod-Union{Tuple{T}, Tuple{T, T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.mulmod","text":"mulmod(f::T, g::T, m::T) where T <: RingElem\n\nReturn mod(f*g, m) but possibly computed more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.powermod-Union{Tuple{T}, Tuple{T, Int64, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.powermod","text":"powermod(f::T, e::Int, m::T) where T <: RingElem\n\nReturn mod(f^e, m) but possibly computed more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.invmod-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.invmod","text":"invmod(f::T, m::T) where T <: RingElem\n\nReturn an inverse of f modulo m, meaning that isone(mod(invmod(f,m)*f,m)) returns true.\n\nIf such an inverse doesn't exist, a NotInvertibleError should be thrown.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.divides-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.divides","text":"divides(f::T, g::T) where T <: RingElem\n\nReturn a pair, flag, q, where flag is set to true if g divides f, in which case q is set to the quotient, or flag is set to false and q is undefined.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.is_divisible_by-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.is_divisible_by","text":"is_divisible_by(x::T, y::T) where T <: RingElem\n\nCheck if x is divisible by y, i.e. if x = zy for some z.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.is_associated-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.is_associated","text":"is_associated(x::T, y::T) where T <: RingElem\n\nCheck if x and y are associated, i.e. if x is a unit times y.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.remove-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.remove","text":"remove(f::T, p::T) where T <: RingElem\n\nReturn a pair v, q where p^v is the highest power of p dividing f and q is the cofactor after f is divided by this power.\n\nSee also valuation, which only returns the valuation.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.valuation-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.valuation","text":"valuation(f::T, p::T) where T <: RingElem\n\nReturn v where p^v is the highest power of p dividing f.\n\nSee also remove.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.gcd-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.gcd","text":"gcd(a::T, b::T) where T <: RingElem\n\nReturn a greatest common divisor of a and b, i.e., an element g which is a common divisor of a and b, and with the property that any other common divisor of a and b divides g.\n\nnote: Note\nFor best compatibility with the internal assumptions made by AbstractAlgebra, the return is expected to be unit-normalized in such a way that if the return is a unit, that unit should be one.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.gcd-Union{Tuple{T}, Tuple{T, T, Vararg{T}}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.gcd","text":"gcd(f::T, g::T, hs::T...) where T <: RingElem\n\nReturn a greatest common divisor of f, g and the elements in hs.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.gcd-Union{Tuple{AbstractArray{<:T}}, Tuple{T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.gcd","text":"gcd(fs::AbstractArray{<:T}) where T <: RingElem\n\nReturn a greatest common divisor of the elements in fs. Requires that fs is not empty.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.lcm-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.lcm","text":"lcm(f::T, g::T) where T <: RingElem\n\nReturn a least common multiple of f and g, i.e., an element d which is a common multiple of f and g, and with the property that any other common multiple of f and g is a multiple of d.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.lcm-Union{Tuple{T}, Tuple{T, T, Vararg{T}}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.lcm","text":"lcm(f::T, g::T, hs::T...) where T <: RingElem\n\nReturn a least common multiple of f, g and the elements in hs.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.lcm-Union{Tuple{AbstractArray{<:T}}, Tuple{T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.lcm","text":"lcm(fs::AbstractArray{<:T}) where T <: RingElem\n\nReturn a least common multiple of the elements in fs. Requires that fs is not empty.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#Base.gcdx-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"Base.gcdx","text":"gcdx(f::T, g::T) where T <: RingElem\n\nReturn a triple d, s, t such that d = gcd(f g) and d = sf + tg, with s loosely reduced modulo gd and t loosely reduced modulo fd.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.gcdinv-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"AbstractAlgebra.gcdinv","text":"gcdinv(f::T, g::T) where T <: RingElem\n\nReturn a tuple d, s such that d = gcd(f g) and s = (fd)^-1 pmodgd. Note that d = 1 iff f is invertible modulo g, in which case s = f^-1 pmodg.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.crt-Union{Tuple{T}, NTuple{4, T}} where T<:RingElement","page":"Euclidean Ring Interface","title":"AbstractAlgebra.crt","text":"crt(r1::T, m1::T, r2::T, m2::T; check::Bool=true) where T <: RingElement\n\nReturn an element congruent to r_1 modulo m_1 and r_2 modulo m_2. If check = true and no solution exists, an error is thrown.\n\nIf T is a fixed precision integer type (like Int), the result will be correct if abs(ri) <= abs(mi) and abs(m1 * m2) < typemax(T).\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.crt-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElement","page":"Euclidean Ring Interface","title":"AbstractAlgebra.crt","text":"crt(r::Vector{T}, m::Vector{T}; check::Bool=true) where T <: RingElement\n\nReturn an element congruent to r_i modulo m_i for each i.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.crt_with_lcm-Union{Tuple{T}, NTuple{4, T}} where T<:RingElement","page":"Euclidean Ring Interface","title":"AbstractAlgebra.crt_with_lcm","text":"crt_with_lcm(r1::T, m1::T, r2::T, m2::T; check::Bool=true) where T <: RingElement\n\nReturn a tuple consisting of an element congruent to r_1 modulo m_1 and r_2 modulo m_2 and the least common multiple of m_1 and m_2. If check = true and no solution exists, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.crt_with_lcm-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElement","page":"Euclidean Ring Interface","title":"AbstractAlgebra.crt_with_lcm","text":"crt_with_lcm(r::Vector{T}, m::Vector{T}; check::Bool=true) where T <: RingElement\n\nReturn a tuple consisting of an element congruent to r_i modulo m_i for each i and the least common multiple of the m_i.\n\n\n\n\n\n","category":"method"},{"location":"euclidean_interface/#AbstractAlgebra.coprime_base","page":"Euclidean Ring Interface","title":"AbstractAlgebra.coprime_base","text":"coprime_base(S::Vector{RingElement}) -> Vector{RingElement}\n\nReturns a coprime base for S, i.e. the resulting array contains pairwise coprime objects that multiplicatively generate the same set as the input array.\n\n\n\n\n\n","category":"function"},{"location":"euclidean_interface/#AbstractAlgebra.coprime_base_push!","page":"Euclidean Ring Interface","title":"AbstractAlgebra.coprime_base_push!","text":"coprime_base_push!(S::Vector{RingElem}, a::RingElem) -> Vector{RingElem}\n\nGiven an array S of coprime elements, insert a new element, that is, find a coprime base for push(S, a).\n\n\n\n\n\n","category":"function"},{"location":"quotient_module/#Quotient-modules","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra allows the construction of quotient modules/spaces of AbstractAlgebra modules over euclidean domains. These are given as the quotient of a module by a submodule of that module.\n\nWe define two quotient modules to be equal if they are quotients of the same module M by two equal submodules.","category":"section"},{"location":"quotient_module/#Generic-quotient-module-type","page":"Quotient modules","title":"Generic quotient module type","text":"AbstractAlgebra implements the generic quotient module type Generic.QuotientModule{T} where T is the element type of the base ring, in src/generic/QuotientModule.jl.\n\nElements of generic quotient modules have type Generic.QuotientModuleElem{T}.","category":"section"},{"location":"quotient_module/#Abstract-types","page":"Quotient modules","title":"Abstract types","text":"Quotient module types belong to the FPModule{T} abstract type and their elements to FPModuleElem{T}.","category":"section"},{"location":"quotient_module/#Constructors","page":"Quotient modules","title":"Constructors","text":"Note that a preimage of the canonical projection can be obtained using the preimage function described in the section on module homomorphisms. Note that a preimage element of the canonical projection is not unique and has no special properties.\n\nExamples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> N, f = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N -> M)\n\njulia> Q, g = quo(M, N)\n(Quotient module over integers with 1 generator and no relations, Hom: M -> Q)\n\njulia> p = M([ZZ(3), ZZ(1)])\n(3, 1)\n\njulia> v2 = g(p)\n(-5)\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> Q, g = quo(V, N)\n(Quotient space over rationals with 1 generator and no relations, Hom: V -> Q)\n","category":"section"},{"location":"quotient_module/#Functionality-for-submodules","page":"Quotient modules","title":"Functionality for submodules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"section"},{"location":"quotient_module/#Basic-manipulation","page":"Quotient modules","title":"Basic manipulation","text":"Examples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> N, g = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N -> M)\n\njulia> Q, h = quo(M, N)\n(Quotient module over integers with 2 generators and relations:\n[2 3], Hom: M -> Q)\n\njulia> supermodule(Q) == M\ntrue\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> Q, g = quo(V, N)\n(Quotient space over rationals with 1 generator and no relations, Hom: V -> Q)\n\njulia> dim(V)\n2\n\njulia> dim(Q)\n1\n","category":"section"},{"location":"quotient_module/#AbstractAlgebra.quo-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.Generic.Submodule{T}}} where T<:RingElement","page":"Quotient modules","title":"AbstractAlgebra.quo","text":"quo(m::FPModule{T}, subm::FPModule{T}) where T <: RingElement\n\nReturn the quotient M of the module m by the module subm (which must have been (transitively) constructed as a submodule of m or be m itself) along with the canonical quotient map from m to M.\n\n\n\n\n\n","category":"method"},{"location":"quotient_module/#AbstractAlgebra.Generic.supermodule-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:RingElement","page":"Quotient modules","title":"AbstractAlgebra.Generic.supermodule","text":"supermodule(M::QuotientModule{T}) where T <: RingElement\n\nReturn the module that this module is a quotient of.\n\n\n\n\n\n","category":"method"},{"location":"quotient_module/#AbstractAlgebra.Generic.dim-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:FieldElement","page":"Quotient modules","title":"AbstractAlgebra.Generic.dim","text":"dim(N::QuotientModule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector quotient space.\n\n\n\n\n\n","category":"method"},{"location":"free_module/#Free-Modules-and-Vector-Spaces","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra allows the construction of free modules of any rank over any Euclidean ring and the vector space of any dimension over a field. By default the system considers the free module of a given rank over a given ring or vector space of given dimension over a field to be unique.","category":"section"},{"location":"free_module/#Generic-free-module-and-vector-space-types","page":"Free Modules and Vector Spaces","title":"Generic free module and vector space types","text":"AbstractAlgebra provides generic types for free modules and vector spaces, via the type FreeModule{T} for free modules, where T is the type of the elements of the ring R over which the module is built.\n\nElements of a free module have type FreeModuleElem{T}.\n\nVector spaces are simply free modules over a field.\n\nThe implementation of generic free modules can be found in src/generic/FreeModule.jl.\n\nThe free module of a given rank over a given ring is made unique on the system by caching them (unless an optional cache parameter is set to false).\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"free_module/#Abstract-types","page":"Free Modules and Vector Spaces","title":"Abstract types","text":"The type FreeModule{T} belongs to FPModule{T} and FreeModuleElem{T} to FPModuleElem{T}. Here the FP prefix stands for finitely presented.","category":"section"},{"location":"free_module/#Functionality-for-free-modules","page":"Free Modules and Vector Spaces","title":"Functionality for free modules","text":"As well as implementing the entire module interface, free modules provide the following functionality.","category":"section"},{"location":"free_module/#Constructors","page":"Free Modules and Vector Spaces","title":"Constructors","text":"Construct the free module/vector space of given rank/dimension.\n\nExamples\n\njulia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n","category":"section"},{"location":"free_module/#Basic-manipulation","page":"Free Modules and Vector Spaces","title":"Basic manipulation","text":"rank(M::Generic.FreeModule{T}) where T <: RingElem\ndim(V::Generic.FreeModule{T}) where T <: FieldElem\nbasis(V::Generic.FreeModule{T}) where T <: FieldElem\n\nExamples\n\njulia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> rank(M)\n3\n\njulia> dim(V)\n2\n\njulia> basis(V)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)","category":"section"},{"location":"free_module/#AbstractAlgebra.free_module-Tuple{Ring, Int64}","page":"Free Modules and Vector Spaces","title":"AbstractAlgebra.free_module","text":"free_module(R::NCRing, rank::Int; cached::Bool = true)\n\nReturn the free module over the ring R with the given rank.\n\n\n\n\n\n","category":"method"},{"location":"free_module/#AbstractAlgebra.vector_space-Tuple{Field, Int64}","page":"Free Modules and Vector Spaces","title":"AbstractAlgebra.vector_space","text":"vector_space(R::Field, dim::Int; cached::Bool = true)\n\nReturn the vector space over the field R with the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"constructors/#Constructing-mathematical-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"","category":"section"},{"location":"constructors/#Constructing-objects-in-Julia","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing objects in Julia","text":"In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a BigInt object from an Int in Julia, we simply call the BigInt constructor:\n\nn = BigInt(123)\n\nNote that a number literal too big to fit in an Int or Int128 automatically creates a BigInt:\n\njulia> typeof(12345678765456787654567890987654567898765678909876567890)\nBigInt","category":"section"},{"location":"constructors/#How-we-construct-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"How we construct objects in AbstractAlgebra.jl","text":"As we explain in Elements and parents, Julia types don't contain enough information to properly model groups, rings, fields, etc. Instead of using types to construct objects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.\n\nConsider the following simple example, to create a multiprecision integer:\n\nn = ZZ(12345678765456787654567890987654567898765678909876567890)\n\nHere ZZ is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object as though it were a type.","category":"section"},{"location":"constructors/#Constructing-parent-objects","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing parent objects","text":"For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.\n\nAbstractAlgebra.jl provides a set of functions for constructing such parent objects. For example, to create a parent object for univariate polynomials over the integers, we use the polynomial_ring parent object constructor.\n\nR, x = polynomial_ring(ZZ, :x)\nf = x^3 + 3x + 1\ng = R(12)\n\nIn this example, R is the parent object and we use it to convert the Int value 12 to an element of the polynomial ring mathbbZx.","category":"section"},{"location":"constructors/#List-of-parent-object-constructors","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"List of parent object constructors","text":"For convenience, we provide a list of all the parent object constructors in AbstractAlgebra.jl and explain what mathematical domains they represent.\n\nMathematics AbstractAlgebra.jl constructor\nR = mathbbZ R = ZZ\nR = mathbbQ R = QQ\nR = mathbbF_p R = GF(p)\nR = mathbbZnmathbbZ R, = residue_ring(ZZ, n)\nS = Rx S, x = polynomial_ring(R, :x)\nS = Rx y S, (x, y) = polynomial_ring(R, [:x, :y])\nS = Rlangle x yrangle S, (x, y) = free_associative_algebra(R, [:x, :y])\nS = K(x) S, x = rational_function_field(K, :x)\nS = K(x y) S, (x, y) = rational_function_field(K, [:x, :y])\nS = Rx (to precision n) S, x = power_series_ring(R, n, :x)\nS = Rx y (to precision n) S, (x, y) = power_series_ring(R, n, [:x, :y])\nS = R((x)) (to precision n) S, x = laurent_series_ring(R, n, :x)\nS = K((x)) (to precision n) S, x = laurent_series_field(K, n, :x)\nS = R((x y)) (to precision n) S, (x, y) = laurent_polynomial_ring(R, n, [:x, :y])\nPuiseux series ring to precision n S, x = puiseux_series_ring(R, n, :x)\nPuiseux series field to precision n S, x = puiseux_series_field(K, n, :x)\nS = K(x)(y)(f) S, y = function_field(f, :y) with fin K(x)t\nS = mathrmFrac_R S = fraction_field(R)\nS = R(f) S, = residue_ring(R, f)\nS = R(f) (with (f) maximal) S, = residue_field(R, f)\nS = mathrmMat_mtimes n(R) S = matrix_space(R, m, n)","category":"section"},{"location":"constructors/#Parent-objects-with-variable-names","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Parent objects with variable names","text":"The multivariate parent object constructors (polynomial_ring, power_series_ring, free_associative_algebra, laurent_polynomial_ring, and rational_function_field) share a common interface for specifying the variable names, which is provided by @varnames_interface.","category":"section"},{"location":"constructors/#AbstractAlgebra.@varnames_interface","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"AbstractAlgebra.@varnames_interface","text":"@varnames_interface [M.]f(args..., varnames) macros=:yes n=n range=1:n\n\nAdd methods X, vars = f(args..., varnames...) and macro X = @f(args..., varnames...) to current scope.\n\nCreated methods\n\nX, gens::Vector{T} = f(args..., varnames::Vector{Symbol})\n\nBase method, called by everything else defined below. If a module M is specified, this is implemented as a call to M.f. Otherwise, a method f with this signature must already exist.\n\n\n\nX, gens... = f(args..., varnames...; kv...)\nX, gens... = f(args..., varnames::Tuple; kv...)\n\nCompute X and gens via the base method. Then reshape gens into the shape defined by varnames according to variable_names.\n\nThe vararg varnames... method needs at least one argument to avoid confusion. Moreover a single VarName argument will be dispatched to use a univariate method of f if it exists (e.g. polynomial_ring(R, :x)). If you need those cases, use the Tuple method.\n\nKeyword arguments are passed on to the base method.\n\n\n\nX, x::Vector{T} = f(args..., n::Int, s::VarName = :x; kv...)\n\nShorthand for X, x = f(args..., \"$s#\" => 1:n; kv...). The name of the argument n can be changed via the n option. The range 1:n is given via the range option.\n\nSetting n=:no disables creation of this method.\n\n\n\nX = @f(args..., varnames...; kv...)\nX = @f(args..., varnames::Tuple; kv...)\nX = @f(args..., n::Int, s::VarName = :x; kv...)\nX = @f(args..., varname::VarName; kv...)\n\nThese macros behave like their f(args..., varnames; kv...) counterparts but also introduce the indexed varnames into the current scope. The first version needs at least one varnames argument to avoid confusion. The last version calls the univariate base method if it exists (e.g. polynomial_ring(R, varname)).\n\nSetting macros=:no disables macro creation.\n\nwarning: Warning\nTurning varnames into a vector of symbols happens by evaluating variable_names(varnames) in the global scope of the current module. For interactive usage in the REPL this is fine, but in general you have no access to local variables and should not use any side effects in varnames.\n\nExamples\n\njulia> f(a, s::Vector{Symbol}) = a, String.(s)\nf (generic function with 1 method)\n\njulia> AbstractAlgebra.@varnames_interface f(a, s)\n@f (macro with 1 method)\n\njulia> f\nf (generic function with 5 methods)\n\njulia> f(\"hello\", [:x, :y, :z])\n(\"hello\", [\"x\", \"y\", \"z\"])\n\njulia> f(\"numbered\", 3)\n(\"numbered\", [\"x1\", \"x2\", \"x3\"])\n\njulia> f(\"hello\", :x => (1:1, 1:2), :y => 1:2, [:z])\n(\"hello\", [\"x[1, 1]\" \"x[1, 2]\"], [\"y[1]\", \"y[2]\"], [\"z\"])\n\njulia> f(\"projective\", [\"x$i$j\" for i in 0:1, j in 0:1], [:y0, :y1], [:z])\n(\"projective\", [\"x00\" \"x01\"; \"x10\" \"x11\"], [\"y0\", \"y1\"], [\"z\"])\n\njulia> f(\"fun inputs\", 'a':'g', Symbol.('x':'z', [0 1]))\n(\"fun inputs\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"], [\"x0\" \"x1\"; \"y0\" \"y1\"; \"z0\" \"z1\"])\n\njulia> @f(\"hello\", \"x#\" => (1:1, 1:2), \"y#\" => (1:2), [:z])\n\"hello\"\n\njulia> (x11, x12, y1, y2, z)\n(\"x11\", \"x12\", \"y1\", \"y2\", \"z\")\n\njulia> g(a, s::Vector{Symbol}; kv...) = (a, kv...), String.(s)\ng (generic function with 1 method)\n\njulia> AbstractAlgebra.@varnames_interface g(a, s)\n@g (macro with 1 method)\n\njulia> @g(\"parameters\", [:x, :y], a=1, b=2; c=3)\n(\"parameters\", :c => 3, :a => 1, :b => 2)\n\n\n\n\n\n","category":"macro"},{"location":"constructors/#AbstractAlgebra.variable_names","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"AbstractAlgebra.variable_names","text":"variable_names(a...) -> Vector{Symbol}\nvariable_names(a::Tuple) -> Vector{Symbol}\n\nCreate a vector of variable names from a variable name specification.\n\nEach argument can be either an Array of VarNames, or of the form s::VarName => iter, or of the form s::VarName => (iter...). Here iter is supposed to be any iterable, typically a range like 1:5. The :s => iter specification is shorthand for [\"s[$i]\" for i in iter]. Similarly :s => (iter1, iter2) is shorthand for [\"s[$i,$j]\" for i in iter1, j in iter2], and likewise for three and more iterables.\n\nAs an alternative \"s#\" => iter is shorthand for [\"s$i\" for i in iter]. This also works for multiple iterators in that\"s#\" => (iter1, iter2) is shorthand for [\"s$i$j\" for i in iter1, j in iter2].\n\nExamples\n\njulia> AbstractAlgebra.variable_names([:x, :y])\n2-element Vector{Symbol}:\n :x\n :y\n\njulia> AbstractAlgebra.variable_names(:x => (0:0, 0:1), :y => 0:1, [:z])\n5-element Vector{Symbol}:\n Symbol(\"x[0, 0]\")\n Symbol(\"x[0, 1]\")\n Symbol(\"y[0]\")\n Symbol(\"y[1]\")\n :z\n\njulia> AbstractAlgebra.variable_names(\"x#\" => (0:0, 0:1), \"y#\" => 0:1)\n4-element Vector{Symbol}:\n :x00\n :x01\n :y0\n :y1\n\njulia> AbstractAlgebra.variable_names(\"x#\" => 9:11)\n3-element Vector{Symbol}:\n :x9\n :x10\n :x11\n\njulia> AbstractAlgebra.variable_names([\"x$i$i\" for i in 1:3])\n3-element Vector{Symbol}:\n :x11\n :x22\n :x33\n\njulia> AbstractAlgebra.variable_names('a':'c', ['z'])\n4-element Vector{Symbol}:\n :a\n :b\n :c\n :z\n\n\n\n\n\n","category":"function"},{"location":"constructors/#AbstractAlgebra.reshape_to_varnames","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"AbstractAlgebra.reshape_to_varnames","text":"reshape_to_varnames(vec::Vector{T}, varnames...) :: Tuple{Array{<:Any, T}}\nreshape_to_varnames(vec::Vector{T}, varnames::Tuple) :: Tuple{Array{<:Any, T}}\n\nTurn vec into the shape of varnames. Reverse flattening from variable_names.\n\nExamples\n\njulia> s = ([:a, :b], \"x#\" => (1:1, 1:2), \"y#\" => 1:2, [:z]);\n\njulia> AbstractAlgebra.reshape_to_varnames(AbstractAlgebra.variable_names(s...), s...)\n([:a, :b], [:x11 :x12], [:y1, :y2], [:z])\n\njulia> R, v = polynomial_ring(ZZ, AbstractAlgebra.variable_names(s...))\n(Multivariate polynomial ring in 7 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, x11, x12, y1, y2, z])\n\njulia> (a, b), x, y, z = AbstractAlgebra.reshape_to_varnames(v, s...)\n(AbstractAlgebra.Generic.MPoly{BigInt}[a, b], AbstractAlgebra.Generic.MPoly{BigInt}[x11 x12], AbstractAlgebra.Generic.MPoly{BigInt}[y1, y2], AbstractAlgebra.Generic.MPoly{BigInt}[z])\n\njulia> R, (a, b), x, y, z = polynomial_ring(ZZ, s...)\n(Multivariate polynomial ring in 7 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b], AbstractAlgebra.Generic.MPoly{BigInt}[x11 x12], AbstractAlgebra.Generic.MPoly{BigInt}[y1, y2], AbstractAlgebra.Generic.MPoly{BigInt}[z])\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#Extending-the-interface-of-AbstractAlgebra.jl","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"In this section we will discuss on how to extend the interface of AbstractAlgebra.jl.","category":"section"},{"location":"extending_abstractalgebra/#Elements-and-parents","page":"Extending the interface of AbstractAlgebra.jl","title":"Elements and parents","text":"Any implementation with elements and parents should implement the following interface:","category":"section"},{"location":"extending_abstractalgebra/#Acquiring-associated-elements-and-parents","page":"Extending the interface of AbstractAlgebra.jl","title":"Acquiring associated elements and parents","text":"Further, if one has a base ring, like polynomials over the integers mathbbZx, then one should implement\n\nIf there is a well-defined notion of a coefficient ring (e.g. in the case of polynomial rings or modules), then one should implement","category":"section"},{"location":"extending_abstractalgebra/#Special-elements","page":"Extending the interface of AbstractAlgebra.jl","title":"Special elements","text":"For rings, one has to extend the following methods:\n\nGroups should only extend at least one of these. The one that is required depends on if the group is additive (commutative) or multiplicative.","category":"section"},{"location":"extending_abstractalgebra/#Basic-manipulation","page":"Extending the interface of AbstractAlgebra.jl","title":"Basic manipulation","text":"If one would like to implement a ring, these are the basic manipulation methods that all rings should extend:\n\nWith the same logic as earlier, groups only need to extend one of the methods isone and iszero.","category":"section"},{"location":"extending_abstractalgebra/#Base.parent","page":"Extending the interface of AbstractAlgebra.jl","title":"Base.parent","text":"parent(a)\n\nReturn parent object of given element a.\n\nExamples\n\njulia> G = SymmetricGroup(5); g = Perm([3,4,5,2,1])\n(1,3,5)(2,4)\n\njulia> parent(g) == G\ntrue\n\njulia> S, x = laurent_series_ring(ZZ, 3, :x)\n(Laurent series ring in x over integers, x + O(x^4))\n\njulia> parent(x) == S\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.elem_type","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.elem_type","text":"elem_type(parent)\nelem_type(parent_type)\n\nGiven a parent object (or its type), return the type of its elements.\n\nExamples\n\njulia> S, x = power_series_ring(QQ, 2, :x)\n(Univariate power series ring over rationals, x + O(x^3))\n\njulia> elem_type(S) == typeof(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.parent_type","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.parent_type","text":"parent_type(element)\nparent_type(element_type)\n\nGiven an element (or its type), return the type of its parent object.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = matrix_space(R, 2, 2)\nMatrix space of 2 rows and 2 columns\n  over univariate polynomial ring in x over integers\n\njulia> a = rand(S, 0:1, 0:1);\n\njulia> parent_type(a) == typeof(S)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.base_ring","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.base_ring","text":"base_ring(a)\n\nReturn the internal base ring of the given element or parent a.\n\nExamples\n\njulia> S, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> base_ring(S) == QQ\ntrue\n\njulia> R = GF(7)\nFinite field F_7\n\njulia> base_ring(R)\nERROR: MethodError: no method matching base_ring(::AbstractAlgebra.GFField{Int64})\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.base_ring_type","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.base_ring_type","text":"base_ring_type(a)\n\nReturn the type of the internal base ring of the given element, element type, parent or parent type a.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> base_ring_type(R) == typeof(base_ring(R))\ntrue\n\njulia> base_ring_type(zero(R)) == typeof(base_ring(zero(R)))\ntrue\n\njulia> base_ring_type(typeof(R)) == typeof(base_ring(R))\ntrue\n\njulia> base_ring_type(typeof(zero(R))) == typeof(base_ring(zero(R)))\ntrue\n\njulia> R = GF(7)\nFinite field F_7\n\njulia> base_ring_type(R)\nUnion{}\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.coefficient_ring","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.coefficient_ring","text":"coefficient_ring(a)\n\nReturn the coefficient ring of the given element or parent a.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> coefficient_ring(x^2+1) == QQ\ntrue\n\njulia> S, (z,w) = universal_polynomial_ring(QQ, [:z,:w])\n(Universal Polynomial Ring over Rationals, AbstractAlgebra.Generic.UnivPoly{Rational{BigInt}}[z, w])\n\njulia> coefficient_ring(S) == QQ\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.coefficient_ring_type","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.coefficient_ring_type","text":"coefficient_ring_type(a)\n\nReturn the type of the coefficient ring of the given element, element type, parent or parent type a.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> coefficient_ring_type(R) == typeof(coefficient_ring(R))\ntrue\n\njulia> coefficient_ring_type(zero(R)) == typeof(coefficient_ring(zero(R)))\ntrue\n\njulia> coefficient_ring_type(typeof(R)) == typeof(coefficient_ring(R))\ntrue\n\njulia> coefficient_ring_type(typeof(zero(R))) == typeof(coefficient_ring(zero(R)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#Base.one","page":"Extending the interface of AbstractAlgebra.jl","title":"Base.one","text":"one(a)\n\nReturn the multiplicative identity in the algebraic structure of a, which can be either an element or parent.\n\nExamples\n\njulia> S = matrix_space(ZZ, 2, 2)\nMatrix space of 2 rows and 2 columns\n  over integers\n\njulia> one(S)\n[1   0]\n[0   1]\n\njulia> R, x = puiseux_series_field(QQ, 4, :x)\n(Puiseux series field in x over rationals, x + O(x^5))\n\njulia> one(x)\n1 + O(x^4)\n\njulia> G = GF(5)\nFinite field F_5\n\njulia> one(G)\n1\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#Base.zero","page":"Extending the interface of AbstractAlgebra.jl","title":"Base.zero","text":"zero(a)\n\nReturn the additive identity in the algebraic structure of a, which can be either an element or parent.\n\nExamples\n\njulia> S = matrix_ring(QQ, 2)\nMatrix ring of degree 2\n  over rationals\n\njulia> zero(S)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> zero(x^3 + 2)\n0\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#Base.isone","page":"Extending the interface of AbstractAlgebra.jl","title":"Base.isone","text":"isone(a)\n\nReturn true if a is the multiplicative identity, else return false.\n\nExamples\n\njulia> S = matrix_space(ZZ, 2, 2); T = matrix_space(ZZ, 2, 3); U = matrix_space(ZZ, 3, 2);\n\njulia> isone(S([1 0; 0 1]))\ntrue\n\njulia> isone(T([1 0 0; 0 1 0]))\nfalse\n\njulia> isone(U([1 0; 0 1; 0 0]))\nfalse\n\njulia> T, x = puiseux_series_field(QQ, 10, :x)\n(Puiseux series field in x over rationals, x + O(x^11))\n\njulia> isone(x), isone(T(1))\n(false, true)\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#Base.iszero","page":"Extending the interface of AbstractAlgebra.jl","title":"Base.iszero","text":"iszero(a)\n\nReturn true if a is the additative identity, else return false.\n\nExamples\n\njulia> T, x = puiseux_series_field(QQ, 10, :x)\n(Puiseux series field in x over rationals, x + O(x^11))\n\njulia> a = T(0)\nO(x^10)\n\njulia> iszero(a)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extending_abstractalgebra/#AbstractAlgebra.is_unit","page":"Extending the interface of AbstractAlgebra.jl","title":"AbstractAlgebra.is_unit","text":"is_unit(a::T) where {T <: NCRingElement}\n\nReturn true if a is invertible, else return false.\n\nExamples\n\njulia> S, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> is_unit(x), is_unit(S(1)), is_unit(S(4))\n(false, true, true)\n\njulia> is_unit(ZZ(-1)), is_unit(ZZ(4))\n(true, false)\n\n\n\n\n\n","category":"function"},{"location":"module_interface/#Module-Interface","page":"Module Interface","title":"Module Interface","text":"note: Note\nThe module infrastructure in AbstractAlgebra should be considered experimental at this stage. This means that the interface may change in the future.\n\nAbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules. The generic code provided by AbstractAlgebra will only work for modules over euclidean domains, however there is nothing preventing a library from implementing more general modules using the same interface.\n\nAll finitely presented module types in AbstractAlgebra follow the following interface which is a loose interface of functions, without much generic infrastructure built on top.\n\nFree modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"section"},{"location":"module_interface/#Abstract-types","page":"Module Interface","title":"Abstract types","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:\n\nFPModule{T} is the abstract type for finitely presented module parent\n\ntypes\n\nFPModuleElem{T} is the abstract type for finitely presented module\n\nelement types\n\nNote that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"section"},{"location":"module_interface/#Required-functionality-for-modules","page":"Module Interface","title":"Required functionality for modules","text":"We suppose that R is a fictitious base ring and that S is a module over R with parent object S of type MyModule{T}. We also assume the elements in the module have type MyModuleElem{T}, where T is the type of elements of the ring the module is over.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElement or NCRingElem.\n\nWe describe the functionality below for modules over commutative rings, i.e. with element type belonging to RingElement, however similar constructors should be available for element types belonging to NCRingElem instead, for free modules over a noncommutative ring.\n\nAlthough not part of the module interface, implementations of modules that wish to follow our interface should use the same function names for submodules, quotient modules, direct sums and module homomorphisms if they wish to remain compatible with our module generics in the future.","category":"section"},{"location":"module_interface/#Basic-manipulation","page":"Module Interface","title":"Basic manipulation","text":"iszero(m::MyModuleElem{T}) where T <: RingElement\n\nReturn true if the given module element is zero.\n\nnumber_of_generators(M::MyModule{T}) where T <: RingElement\n\nReturn the number of generators of the module M in its current representation.\n\ngen(M::MyModule{T}, i::Int) where T <: RingElement\n\nReturn the i-th generator (indexed from 1) of the module M.\n\ngens(M::MyModule{T}) where T <: RingElement\n\nReturn a Julia array of the generators of the module M.\n\nrels(M::MyModule{T}) where T <: RingElement\n\nReturn a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.","category":"section"},{"location":"module_interface/#Element-constructors","page":"Module Interface","title":"Element constructors","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.\n\n(M::Module{T})(v::Vector{T}) where T <: RingElement\n\nConstruct the element of the module M corresponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"section"},{"location":"module_interface/#Coercions","page":"Module Interface","title":"Coercions","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.\n\nIn particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.","category":"section"},{"location":"module_interface/#Arithmetic-operators","page":"Module Interface","title":"Arithmetic operators","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.\n\nIn the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"section"},{"location":"ncring_interface/#Noncommutative-ring-Interface","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"AbstractAlgebra.jl supports commutative rings through its Ring interface. In this section we describe the corresponding interface for noncommutative rings. The two interfaces are very similar in terms of required functionality, and so we mainly document the differences here.\n\nNoncommutative rings can be supported through the abstract types NCRing and NCRingElem. Note that we have Ring <: NCRing, etc., so the interface here should more correctly be called the Not-necessarily-Commutative-ring interface.\n\nHowever, the fact remains that if one wishes to implement a noncommutative ring, one should make its type belong to NCRing but not to Ring. Therefore it is not too much of a mistake to think of the NCRing interface as being for noncommutative rings.","category":"section"},{"location":"ncring_interface/#Types","page":"Noncommutative ring Interface","title":"Types","text":"As for the Ring interface, most noncommutative rings must supply two types:\n\na type for the parent object (representing the ring itself)\na type for elements of that ring\n\nThe parent type must belong to NCRing and the element type must belong to NCRingElem. Of course, the types may belong to these abstract types transitively via an intermediate abstract type.\n\nAlso as for the Ring interface, it is advised to make the types of generic parameterised rings that belong to NCRing and NCRingElem depend on the type of the elements of that parameter ring.","category":"section"},{"location":"ncring_interface/#NCRingElement-type-union","page":"Noncommutative ring Interface","title":"NCRingElement type union","text":"As for the Ring interface, the NCRing interface provides a union type NCRingElement in src/julia/JuliaTypes.jl which is a union of NCRingElem and the Julia types Integer, Rational and AbstractFloat.\n\nMost of the generic code in AbstractAlgebra for general rings makes use of the union type NCRingElement instead of NCRingElem so that the generic functions also accept the Julia Base ring types.\n\nAs per usual, one may need to implement one ad hoc binary operation for each concrete type belonging to NCRingElement to avoid ambiguity warnings.","category":"section"},{"location":"ncring_interface/#Parent-object-caches","page":"Noncommutative ring Interface","title":"Parent object caches","text":"Parent object caches for the NCRing interface operate as per the Ring interface.","category":"section"},{"location":"ncring_interface/#Required-functions-for-all-rings","page":"Noncommutative ring Interface","title":"Required functions for all rings","text":"Generic functions may only rely on required functionality for the NCRing interface, which must be implemented by all noncommutative rings.\n\nMost of this required functionality is the same as for the Ring interface, so we refer the reader there for details, with the following modifications.\n\nWe give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.","category":"section"},{"location":"ncring_interface/#Exact-division","page":"Noncommutative ring Interface","title":"Exact division","text":"divexact_left(f::MyElem, g::MyElem)\ndivexact_right(f::MyElem, g::MyElem)\n\nIf f = ga for some a in the ring, the function divexact_left(f, g) returns a. If f = ag then divexact_right(f, g) returns a. A DivideError() should be thrown if division is by zero. If no exact quotient exists or an impossible inverse is unavoidably encountered, an error should be thrown.","category":"section"},{"location":"map_with_inverse/#Map-with-inverse","page":"Map with inverse","title":"Map with inverse","text":"It is not possible to provide generic functionality to invert a map. However, sometimes one knows an inverse map explicitly and would like to keep track of this.\n\nRecall that as map composition is not commutative, there is a notion of a left inverse and a right inverse for maps.\n\nTo keep track of such inverse maps, AbstractAlgebra provides data types Generic.MapWithRetraction and Generic.MapWithSection.\n\nGiven a map f  X to Y, a retraction of f is a map g  Y to X such that g(f(x)) = x for all x in X.\n\nGiven a map f  X to Y, a section of f is a map g  Y to X such that f(g(x)) = x for all y in Y.\n\nIn AbstractAlgebra, a map with retraction/section is an object containing a pair of maps, the second of which is a retraction/section of the first.\n\nMaps with retraction/section can be composed, and we also define the inverse of such a pair to be the map with the pair swapped. Thus the inverse of a map with retraction is a map with section.","category":"section"},{"location":"map_with_inverse/#Map-with-inverse-constructors","page":"Map with inverse","title":"Map with inverse constructors","text":"To construct a map with retraction/section from a pair of maps, we have the following functions:\n\nmap_with_retraction(m::Map{D, C}, r::Map{C, D}) where {D, C}\nmap_with_section(m::Map{D, C}, s::Map{C, D}) where {D, C}\n\nConstruct the map with retraction/section given a known retraction/section r or s respectively, of m.\n\nFor convenience we allow construction of maps with retraction/section from a pair of Julia functions/closures.\n\nmap_with_retraction_from_func(f::Function, r::Function, R, S)\nmap_with_section_from_func(f::Function, s::Function, R, S)\n\nConstruct the map with retraction/section such that the map is given by the function f and the retraction/section is given by the function r or s respectively. Here R is the parent object representing the domain and S is the parent object representing the codomain of f.\n\nExamples\n\njulia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction\n  from integers\n  to integers\n\njulia> a = f(ZZ(1))\n2","category":"section"},{"location":"map_with_inverse/#Functionality-for-maps-with-inverses","page":"Map with inverse","title":"Functionality for maps with inverses","text":"The following functionality is provided for maps with inverses.\n\ninv(M::Generic.MapWithRetraction)\ninv(M::Generic.MapWithSection)\n\nReturn the map with the two maps contained in M swapped. In the first case, a MapWithSection is returned. In the second case a MapWithRetraction is returned.\n\nTo access the two maps stored in a map with retraction/section, we have the following:\n\nimage_map(M::Generic.MapWithRetraction)\nimage_map(M::Generic.MapWithSection)\nretraction_map(M::Generic.MapWithRetraction)\nsection_map(M::Generic.MapWithSection)\n\nThe first two of these functions return the first map in a map with retraction/section, the second two functions return the corresponding second maps.\n\nExamples\n\njulia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction\n  from integers\n  to integers\n\njulia> g = inv(f)\nMap with section\n  from integers\n  to integers\n\njulia> h = f*g\nComposite map\n  from integers\n  to integers\nwhich is the composite of\n  Map: integers -> integers\n  Map: integers -> integers\n\njulia> a = h(ZZ(1))\n1\n","category":"section"},{"location":"finfield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/GF.jl for finite fields. The module is a naive implementation that supports only fields of degree 1 (prime fields). They are modelled as mathbbZpmathbbZ for p a prime.","category":"section"},{"location":"finfield/#Types-and-parent-objects","page":"Finite fields","title":"Types and parent objects","text":"Finite fields have type GFField{T} where T is either Int or BigInt.\n\nElements of such a finite field have type GFElem{T}.","category":"section"},{"location":"finfield/#Finite-field-constructors","page":"Finite fields","title":"Finite field constructors","text":"In order to construct finite fields in AbstractAlgebra.jl, one must first construct the field itself. This is accomplished with the following constructors.\n\nHere are some examples of creating a finite field and making use of the resulting parent object to coerce various elements into the field.\n\nExamples\n\njulia> F = GF(13)\nFinite field F_13\n\njulia> g = F(3)\n3\n\njulia> h = F(g)\n3\n\njulia> GF(4)\nERROR: DomainError with 4:\nCharacteristic is not prime in GF(p)\nStacktrace:\n[...]","category":"section"},{"location":"finfield/#Basic-field-functionality","page":"Finite fields","title":"Basic field functionality","text":"The finite field module in AbstractAlgebra.jl implements the full Field interface.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> F = GF(13)\nFinite field F_13\n\njulia> f = F(7)\n7\n\njulia> h = zero(F)\n0\n\njulia> k = one(F)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(h)\ntrue\n\njulia> T = parent(h)\nFinite field F_13\n\njulia> h == deepcopy(h)\ntrue\n\njulia> h = h + 2\n2\n\njulia> m = inv(k)\n1\n","category":"section"},{"location":"finfield/#Basic-manipulation-of-fields-and-elements","page":"Finite fields","title":"Basic manipulation of fields and elements","text":"Examples\n\njulia> F = GF(13)\nFinite field F_13\n\njulia> d = degree(F)\n1\n\njulia> n = order(F)\n13\n\njulia> g = gen(F)\n1\n","category":"section"},{"location":"finfield/#AbstractAlgebra.GF-Tuple{T} where T<:Integer","page":"Finite fields","title":"AbstractAlgebra.GF","text":"GF(p::T; check::Bool=true) where T <: Integer\n\nReturn the finite field mathbbF_p, where p is a prime. By default, the integer p is checked with a probabilistic algorithm for primality. When check == false, no check is made, but the behaviour of the resulting object is undefined if p is composite.\n\n\n\n\n\n","category":"method"},{"location":"finfield/#AbstractAlgebra.data-Tuple{AbstractAlgebra.GFElem}","page":"Finite fields","title":"AbstractAlgebra.data","text":"data(R::GFElem)\n\nReturn the internal data used to represent the finite field element. This coincides with lift except where the internal data ids a machine integer.\n\n\n\n\n\n","category":"method"},{"location":"finfield/#AbstractAlgebra.lift-Tuple{AbstractAlgebra.GFElem}","page":"Finite fields","title":"AbstractAlgebra.lift","text":"lift(R::GFElem)\n\nLift the finite field element to the integers. The result will be a multiprecision integer regardless of how the field element is represented internally.\n\n\n\n\n\n","category":"method"},{"location":"finfield/#AbstractAlgebra.gen-Union{Tuple{AbstractAlgebra.GFField{T}}, Tuple{T}} where T<:Integer","page":"Finite fields","title":"AbstractAlgebra.gen","text":"gen(R::GFField{T}) where T <: Integer\n\nReturn a generator of the field. Currently this returns 1.\n\n\n\n\n\n","category":"method"},{"location":"finfield/#AbstractAlgebra.order-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"AbstractAlgebra.order","text":"order(R::GFField)\n\nReturn the order, i.e. the number of element in the given finite field.\n\n\n\n\n\n","category":"method"},{"location":"finfield/#AbstractAlgebra.degree-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"AbstractAlgebra.degree","text":"degree(R::GFField)\n\nReturn the degree of the given finite field.\n\n\n\n\n\n","category":"method"},{"location":"functional_map/#Functional-maps","page":"Functional maps","title":"Functional maps","text":"A functional map in AbstractAlgebra is a map which can be applied by evaluating a Julia function or closure. It is represented by a map object that contains such a function/closure, usually in a field called image_fn.\n\nAll functional maps belong to the map class FunctionalMap.\n\nA generic concrete type Generic.FunctionalMap is provided by the Generic module to implement a generic functional map type. This allows for functional maps that contain no extra data, other than a Julia function/closure.\n\nCustom map types can also be defined which have map class FunctionalMap.","category":"section"},{"location":"functional_map/#Functional-map-interface","page":"Functional maps","title":"Functional map interface","text":"All functional map types must define their supertypes as in the following example:\n\nmutable struct MyFunctionalMap{D, C} <: Map{D, C, FunctionalMap, MyFunctionalMap}\n   # some fields\n   image_fn::Function\nend\n\nOf course MyFunctionalMap need not be parameterised if the types D and C of the domain and codomain objects are known.","category":"section"},{"location":"functional_map/#Required-functions-for-functional-maps","page":"Functional maps","title":"Required functions for functional maps","text":"The following functions must be defined for all functional map types or classes:\n\nimage_fn(M::Map(MyFunctionalMap))\n\nReturn the Julia function or closure that corresponds to application of the map M. This function only needs to be provided if this function is not stored in an image_fn field of the MyFunctionalMap type.","category":"section"},{"location":"functional_map/#Generic-functional-maps","page":"Functional maps","title":"Generic functional maps","text":"The Generic module provides a concrete type FunctionalMap which merely keeps track of a Julia function/closure implementing the map.\n\nSuch maps can be constructed using the following function:","category":"section"},{"location":"functional_map/#AbstractAlgebra.map_from_func-Tuple{Function, Any, Any}","page":"Functional maps","title":"AbstractAlgebra.map_from_func","text":"map_from_func(image_fn::Function, domain, codomain)\n\nConstruct the generic functional map with domain and codomain given by the parent objects R and S corresponding to the Julia function f.\n\nExamples\n\njulia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap defined by a Julia function\n  from integers\n  to integers\n\njulia> f(ZZ(2))\n3\n\n\n\n\n\n","category":"method"},{"location":"matrix_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"AbstractAlgebra provides matrix spaces (mtimes n matrices) and matrix algebras (ntimes n matrices) over a ring. Whilst both types of matrix provide matrix multiplication for matrices whose dimensions are compatible for multiplication, only the latter kind of matrices form rings in the system.\n\nMatrix spaces provide a large number of linear algebra operations, including linear solving, elementary row operations, various canonical forms. The system also provides characteristic and minimal polynomial computations, LU decomposition, determinant, matrix inverse, kernel computations.\n\nThere is also code for computation of the Hermite and Smith normal forms over Euclidean domains and Popov form for matrices over polynomial rings over a field.\n\nMost of this generic functionality is provided for arbitrary matrix types that satisfy the AbstractAlgebra matrix interface.","category":"section"},{"location":"matrix_algebras/#Generic-matrix-algebras","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"AbstractAlgebra.jl allows the creation of an algebra (ring) of mtimes m matrices over a computable, commutative ring.\n\nFunctions specific to generic matrix algebras of mtimes m matrices are implemented in src/generic/MatRing.jl. The remaining functionality is in the file src/generic/Matrix.jl.\n\nAs well as implementing the entire Matrix interface, including the optional functionality, there are many additional generic algorithms implemented for matrix algebras.\n\nAlmost all of the functionality specified for generic matrices is available for matrix algebras. The exceptions are functions such as solve and nullspace which may return non-square matrices, or which don't accept square matrices.\n\nAll of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default, so it is not necessary to qualify names of functions.","category":"section"},{"location":"matrix_algebras/#Types-and-parent-objects","page":"Generic matrix algebras","title":"Types and parent objects","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatRingElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.\n\nParents of generic matrices in a matrix algebra have type Generic.MatRing{T}.\n\nNote that matrix algebras are noncommutative rings. Thus their types belong to NCRing and NCRingElem. They cannot be used in constructions which require a commutative ring (Ring and RingElem respectively).\n\nThe generic matrix algebra matrix types belong to the abstract type MatRingElem{T} and the parent types belong to  MatRing{T} Note that both of these require disambiguation from the concrete types in Generic of the same name.\n\nThe degree and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"section"},{"location":"matrix_algebras/#Matrix-algebra-constructors","page":"Generic matrix algebras","title":"Matrix algebra constructors","text":"A matrix algebra in AbstractAlgebra.jl represents a collection of all matrices with given degree and base ring.\n\nIn order to construct matrices in AbstractAlgebra.jl, one must construct the matrix algebra itself. This is accomplished with the following constructor.\n\nmatrix_ring(R::Ring, degree::Int)\n\nConstruct the algebra of matrices with the given degree over the given base ring.\n\nHere are some examples of creating matrix algebras and making use of the resulting parent objects to coerce various elements into the matrix algebra.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_ring(R, 3)\nMatrix ring of degree 3\n  over univariate polynomial ring in t over rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"section"},{"location":"matrix_algebras/#Matrix-algebra-element-constructors","page":"Generic matrix algebras","title":"Matrix algebra element constructors","text":"The following additional constructors are provided for constructing various kinds of matrices in a matrix algebra.\n\nExamples\n\nS = matrix_ring(ZZ, 2)\nM = zero(S)\n\nP = identity_matrix(M)","category":"section"},{"location":"matrix_algebras/#Matrix-algebra-functionality-provided-by-AbstractAlgebra.jl","page":"Generic matrix algebras","title":"Matrix algebra functionality provided by AbstractAlgebra.jl","text":"Most of the generic matrix functionality described in the generic matrix section of the documentation is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve and nullspace which can't be provided for matrix algebras.\n\nIn addition to the functionality described for matrix spaces, matrix algebras support all noncommutative ring operations, and matrix algebras can be used as a base ring for other generic constructs that accept a noncommutative base ring (NCRing).\n\nIn this section we describe functionality provided for matrix algebras only.","category":"section"},{"location":"matrix_algebras/#Basic-matrix-functionality","page":"Generic matrix algebras","title":"Basic matrix functionality","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S = matrix_ring(R, 3)\nMatrix ring of degree 3\n  over univariate polynomial ring in t over rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> n = degree(A)\n3\n","category":"section"},{"location":"matrix_algebras/#AbstractAlgebra.identity_matrix-Union{Tuple{AbstractAlgebra.Generic.MatRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Generic matrix algebras","title":"AbstractAlgebra.identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: NCRingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n\n\nidentity_matrix(M::MatRingElem{T}) where T <: RingElement\n\nReturn the identity matrix over the same base ring as M and with the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"matrix_algebras/#AbstractAlgebra.degree-Tuple{AbstractAlgebra.Generic.MatRingElem}","page":"Generic matrix algebras","title":"AbstractAlgebra.degree","text":"degree(a::MatRingElem{T}) where T <: RingElement\n\nReturn the degree n of the given matrix algebra.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#Generic-Puiseux-series","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring R.\n\nPuiseux series are power series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) for some integer m  0 where i geq 0, a_i in R and the relative precision k - j is at most equal to some specified precision n.\n\nThe generic Puiseux series module is implemented in src/generic/PuiseuxSeries.jl.\n\nAs well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.\n\nAll of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.","category":"section"},{"location":"puiseux/#Types-and-parent-objects","page":"Generic Puiseux series","title":"Types and parent objects","text":"The types of generic Puiseux series implemented by AbstractAlgebra.jl are Generic.PuiseuxSeriesRingElem{T} and Generic.PuiseuxSeriesFieldElem{T}.\n\nBoth series element types belong to the union type Generic.PuiseuxSeriesElem.\n\nPuiseux series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.\n\nThe parent types for Puiseux series, Generic.PuiseuxSeriesRing{T} and Generic.PuiseuxSeriesField{T} respectively, belong to Ring and Field respectively.\n\nThe default precision, string representation of the variable and base ring R of a generic Puiseux series are stored in its parent object.","category":"section"},{"location":"puiseux/#Puiseux-series-ring-constructors","page":"Generic Puiseux series","title":"Puiseux series ring constructors","text":"In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.\n\npuiseux_series_ring(R::Ring, prec_max::Int, s::VarName; cached::Bool = true)\n\npuiseux_series_ring(R::Field, prec_max::Int, s::VarName; cached::Bool = true)\n\npuiseux_series_field(R::Field, prec_max::Int, s::VarName; cached::Bool = true)\n\nGiven a base ring R, a maximum relative precision and a string s specifying how the generator (variable) should be printed, return a tuple S, x representing the Puiseux series ring and its generator.\n\nBy default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.\n\nHere are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.\n\nExamples\n\njulia> R, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> S, y = puiseux_series_field(QQ, 10, :y)\n(Puiseux series field in y over rationals, y + O(y^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = R(BigInt(1234))\n1234 + O(x^10)\n\njulia> k = S(y + 1)\n1 + y + O(y^10)\n","category":"section"},{"location":"puiseux/#Big-oh-notation","page":"Generic Puiseux series","title":"Big-oh notation","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):\n\nO(x::SeriesElem)\n\nExamples\n\njulia> R, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2x^(1//3) + 7x^(2//3) + O(x^(7//3))\n2*x^(1//3) + 7*x^(2//3) + O(x^(7//3))\n\nWhat is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.\n\nOf course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"section"},{"location":"puiseux/#Puiseux-series-implementation","page":"Generic Puiseux series","title":"Puiseux series implementation","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.\n\nThe Puiseux series type stores such a Laurent series and a scale or denominator for the exponents. For example, f(x) = 1 + x^13 + 2x^23 + O(x^73) would be stored as a Laurent series 1 + x + 2x^2 + O(x^7) and a scale of 3..\n\nThe maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.\n\nIn all models we say that two Puiseux series are equal if they agree up to the minimum absolute precision of the two power series.\n\nThus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.\n\nSometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.\n\nFor example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.\n\nThere are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.","category":"section"},{"location":"puiseux/#Basic-ring-functionality","page":"Generic Puiseux series","title":"Basic ring functionality","text":"All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the pol_length and polcoeff functions. Naturally the set_precision!, set_valuation! and coeff functions can take a rational exponent.\n\nExamples\n\njulia> S, x = puiseux_series_ring(ZZ, 10, :x)\n(Puiseux series ring in x over integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> coeff(g, 1//3)\n2\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> T = parent(x + 1)\nPuiseux series ring in x over integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> p = precision(f)\n10//1\n","category":"section"},{"location":"puiseux/#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic Puiseux series","title":"Puiseux series functionality provided by AbstractAlgebra.jl","text":"The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.\n\nOf course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.","category":"section"},{"location":"puiseux/#Basic-functionality","page":"Generic Puiseux series","title":"Basic functionality","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Int)\n\ncoeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})\n\nReturn the coefficient of the term of exponent n of the given power series. If n exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.\n\nExamples\n\njulia> R, t = puiseux_series_ring(QQ, 10, :t)\n(Puiseux series field in t over rationals, t + O(t^11))\n\njulia> S, x = puiseux_series_ring(R, 30, :x)\n(Puiseux series field in x over R, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = is_gen(gen(R))\ntrue\n\njulia> m = is_unit(-1 + x^(1//3) + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4//1\n\njulia> p = valuation(b)\n1//1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n","category":"section"},{"location":"puiseux/#Division","page":"Generic Puiseux series","title":"Division","text":"Examples\n\njulia> R, x = puiseux_series_ring(QQ, 30, :x)\n(Puiseux series field in x over rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = R(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"section"},{"location":"puiseux/#Derivative-and-integral","page":"Generic Puiseux series","title":"Derivative and integral","text":"Examples\n\njulia> R, x = puiseux_series_ring(QQ, 10, :x)\n(Puiseux series field in x over rationals, x + O(x^11))\n\njulia> f = x^(5//3) + x^(7//3) + x^(11//3)\nx^(5//3) + x^(7//3) + x^(11//3) + O(x^5)\n\njulia> derivative(f)\n5//3*x^(2//3) + 7//3*x^(4//3) + 11//3*x^(8//3) + O(x^4)\n\njulia> derivative(integral(f)) == f\ntrue","category":"section"},{"location":"puiseux/#Special-functions","page":"Generic Puiseux series","title":"Special functions","text":"Methods for is_square and sqrt are provided for inputs of type PuiseuxSeriesElem.\n\nExamples\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> S, x = puiseux_series_ring(R, 30, :x)\n(Puiseux series ring in x over R, x + O(x^31))\n\njulia> T, z = puiseux_series_ring(QQ, 30, :z)\n(Puiseux series field in z over rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"section"},{"location":"puiseux/#AbstractAlgebra.modulus-Union{Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T<:ResElem","page":"Generic Puiseux series","title":"AbstractAlgebra.modulus","text":"modulus(a::Generic.PuiseuxSeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given Puiseux series.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#AbstractAlgebra.is_gen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"AbstractAlgebra.is_gen","text":"is_gen(a::Generic.PuiseuxSeriesElem)\n\nReturn true if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#Base.inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"Base.inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n\n\nBase.inv(a::PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the inverse of the power series a, i.e. 1a, if it exists. Otherwise an exception is raised.\n\n\n\n\n\n inv(a::LocalizedEuclideanRingElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#AbstractAlgebra.derivative-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"AbstractAlgebra.derivative","text":"derivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#AbstractAlgebra.integral-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"AbstractAlgebra.integral","text":"integral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#Base.log-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"Base.log","text":"log(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"puiseux/#Base.exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"Base.exp","text":"exp(a::AbsPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::RelPowerSeriesRingElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#solving_chapter","page":"Linear solving","title":"Linear solving","text":"","category":"section"},{"location":"linear_solving/#Overview-of-the-functionality","page":"Linear solving","title":"Overview of the functionality","text":"The module AbstractAlgebra.Solve provides the following four functions for solving linear systems:\n\nsolve\ncan_solve\ncan_solve_with_solution\ncan_solve_with_solution_and_kernel\n\nAll of these take the same set of arguments, namely:\n\na matrix A of type MatElem;\na vector or matrix B of type Vector or MatElem;\na keyword argument side which can be either :left (default) or :right.\n\nIf side is :left, the system xA = B is solved, otherwise the system Ax = B is solved.\n\nThe functionality of the functions can be summarized as follows.\n\nsolve: return a solution, if it exists, otherwise throw an error.\ncan_solve: return true, if a solution exists, false otherwise.\ncan_solve_with_solution: return true and a solution, if this exists, and false and an empty vector or matrix otherwise.\ncan_solve_with_solution_and_kernel: like can_solve_with_solution and additionally return a matrix whose rows (respectively columns) give a basis of the kernel of A.\n\nFurthermore, there is a function kernel which computes the kernel of a matrix A.","category":"section"},{"location":"linear_solving/#Solving-with-several-right-hand-sides","page":"Linear solving","title":"Solving with several right hand sides","text":"Systems xA = b_1dots xA = b_k with the same matrix A, but several right hand sides b_i can be solved more efficiently, by first initializing a \"context object\" C.\n\nNow the functions solve, can_solve, etc. can be used with C in place of A. This way the time-consuming part of the solving (i.e. computing a reduced form of A) is only done once and the result cached in C to be reused.","category":"section"},{"location":"linear_solving/#Detailed-documentation","page":"Linear solving","title":"Detailed documentation","text":"","category":"section"},{"location":"linear_solving/#AbstractAlgebra.Solve.solve_init-Tuple{MatElem}","page":"Linear solving","title":"AbstractAlgebra.Solve.solve_init","text":"solve_init(A::MatElem)\n\nReturn a context object C that allows to efficiently solve linear systems Ax = b or xA = b for different b.\n\nExample\n\njulia> A = QQ[1 2 3; 0 3 0; 5 0 0];\n\njulia> C = solve_init(A)\nLinear solving context of matrix\n  [1//1   2//1   3//1]\n  [0//1   3//1   0//1]\n  [5//1   0//1   0//1]\n\njulia> solve(C, [QQ(1), QQ(1), QQ(1)]; side = :left)\n3-element Vector{Rational{BigInt}}:\n 1//3\n 1//9\n 2//15\n\njulia> solve(C, [QQ(1), QQ(1), QQ(1)]; side = :right)\n3-element Vector{Rational{BigInt}}:\n 1//5\n 1//3\n 2//45\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#AbstractAlgebra.Solve.solve-Union{Tuple{T}, Tuple{Union{MatElem{T}, AbstractAlgebra.Solve.SolveCtx{T}}, Union{MatElem{T}, Vector{T}}}} where T","page":"Linear solving","title":"AbstractAlgebra.Solve.solve","text":"solve(A::MatElem{T}, b::Vector{T}; side::Symbol = :left) where T\nsolve(A::MatElem{T}, b::MatElem{T}; side::Symbol = :left) where T\nsolve(C::SolveCtx{T}, b::Vector{T}; side::Symbol = :left) where T\nsolve(C::SolveCtx{T}, b::MatElem{T}; side::Symbol = :left) where T\n\nReturn x of same type as b solving the linear system xA = b, if side == :left (default), or Ax = b, if side == :right.\n\nIf no solution exists, an error is raised.\n\nIf a context object C is supplied, then the above applies for A = matrix(C).\n\nSee also can_solve_with_solution.\n\nExample\n\njulia> A = QQ[2 0 0;0 3 0;0 0 5]\n[2//1   0//1   0//1]\n[0//1   3//1   0//1]\n[0//1   0//1   5//1]\n\njulia> solve(A, one(A))\n[1//2   0//1   0//1]\n[0//1   1//3   0//1]\n[0//1   0//1   1//5]\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#AbstractAlgebra.Solve.can_solve-Union{Tuple{T}, Tuple{Union{MatElem{T}, AbstractAlgebra.Solve.SolveCtx{T}}, Union{MatElem{T}, Vector{T}}}} where T","page":"Linear solving","title":"AbstractAlgebra.Solve.can_solve","text":"can_solve(A::MatElem{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve(A::MatElem{T}, b::MatElem{T}; side::Symbol = :left) where T\ncan_solve(C::SolveCtx{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve(C::SolveCtx{T}, b::MatElem{T}; side::Symbol = :left) where T\n\nReturn true if the linear system xA = b or Ax = b with side == :left (default) or side == :right, respectively, has a solution and false otherwise.\n\nIf a context object C is supplied, then the above applies for A = matrix(C).\n\nSee also can_solve_with_solution.\n\nExample\n\njulia> A = QQ[2 0 0;0 3 0;0 0 5]\n[2//1   0//1   0//1]\n[0//1   3//1   0//1]\n[0//1   0//1   5//1]\n\njulia> can_solve(A,one(A))\ntrue\n\njulia> A = ZZ[2 0 0;0 3 0;0 0 5]\n[2   0   0]\n[0   3   0]\n[0   0   5]\n\njulia> can_solve(A,one(A))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#AbstractAlgebra.can_solve_with_solution-Union{Tuple{T}, Tuple{Union{MatElem{T}, AbstractAlgebra.Solve.SolveCtx{T}}, Union{MatElem{T}, Vector{T}}}} where T","page":"Linear solving","title":"AbstractAlgebra.can_solve_with_solution","text":"can_solve_with_solution(A::MatElem{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve_with_solution(A::MatElem{T}, b::MatElem{T}; side::Symbol = :left) where T\ncan_solve_with_solution(C::SolveCtx{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve_with_solution(C::SolveCtx{T}, b::MatElem{T}; side::Symbol = :left) where T\n\nReturn true and x of same type as b solving the linear system xA = b, if such a solution exists. Return false and an empty vector or matrix, if the system has no solution.\n\nIf side == :right, the system Ax = b is solved.\n\nIf a context object C is supplied, then the above applies for A = matrix(C).\n\nSee also solve.\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#AbstractAlgebra.kernel-Tuple{Union{MatElem, AbstractAlgebra.Solve.SolveCtx}}","page":"Linear solving","title":"AbstractAlgebra.kernel","text":"kernel(A::MatElem; side::Symbol = :left)\nkernel(C::SolveCtx; side::Symbol = :left)\n\nReturn a matrix K whose rows generate the left kernel of A, that is, KA is the zero matrix.\n\nIf side == :right, the columns of K generate the right kernel of A, that is, AK is the zero matrix.\n\nIf the base ring is a principal ideal domain, the rows or columns respectively of K are a basis of the respective kernel.\n\nIf a context object C is supplied, then the above applies for A = matrix(C).\n\n#Example\n\njulia> A = QQ[2 6 0 0;1 3 0 0;0 0 5 0];\n\njulia> kernel(A, side=:right)\n[-3//1   0//1]\n[ 1//1   0//1]\n[ 0//1   0//1]\n[ 0//1   1//1]\n\njulia> kernel(A)\n[-1//2   1//1   0//1]\n\n\n\n\n\n","category":"method"},{"location":"linear_solving/#AbstractAlgebra.Solve.can_solve_with_solution_and_kernel-Union{Tuple{T}, Tuple{Union{MatElem{T}, AbstractAlgebra.Solve.SolveCtx{T}}, Union{MatElem{T}, Vector{T}}}} where T","page":"Linear solving","title":"AbstractAlgebra.Solve.can_solve_with_solution_and_kernel","text":"can_solve_with_solution_and_kernel(A::MatElem{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve_with_solution_and_kernel(A::MatElem{T}, b::MatElem{T}; side::Symbol = :left) where T\ncan_solve_with_solution_and_kernel(C::SolveCtx{T}, b::Vector{T}; side::Symbol = :left) where T\ncan_solve_with_solution_and_kernel(C::SolveCtx{T}, b::MatElem{T}; side::Symbol = :left) where T\n\nReturn true, x of same type as b solving the linear system xA = b, together with a matrix K giving the kernel of A (i.e. KA = 0), if such a solution exists. Return false, an empty vector or matrix and an empty matrix, if the system has no solution.\n\nIf side == :right, the system Ax = b is solved.\n\nIf a context object C is supplied, then the above applies for A = matrix(C).\n\nSee also solve and kernel.\n\n\n\n\n\n","category":"method"},{"location":"integer/#Integer-ring","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Integer.jl for making Julia BigInts conform to the AbstractAlgebra.jl Ring interface.\n\nIn addition to providing a parent object ZZ for Julia BigInts, we implement any additional functionality required by AbstractAlgebra.jl.\n\nBecause BigInt cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigInts by introducing a type union, called RingElement, which is a union of RingElem and a number of Julia types, including BigInt. Everywhere that RingElem is notionally used in AbstractAlgebra.jl, we are in fact using RingElement, with additional care being taken to avoid ambiguities.\n\nThe details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigInt type as belonging to RingElem.\n\nOne other technicality is that Julia defines certain functions for BigInt, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.\n\nTo access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"section"},{"location":"integer/#Types-and-parent-objects","page":"Integer ring","title":"Types and parent objects","text":"Integers have type BigInt, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.\n\nThe parent objects of such integers has type Integers{BigInt}.\n\nFor convenience, we also make Int a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as zz) has type Integers{Int}. But we caution that this type is not particularly useful as a model of the integers and may not function as expected within AbstractAlgebra.jl.","category":"section"},{"location":"integer/#Integer-constructors","page":"Integer ring","title":"Integer constructors","text":"In order to construct integers in AbstractAlgebra.jl, one can first construct the integer ring itself. This is accomplished using the following constructor.\n\nIntegers{BigInt}()\n\nThis gives the unique object of type Integers{BigInt} representing the ring of integers in AbstractAlgebra.jl.\n\nIn practice, one simply uses ZZ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.\n\nHere are some examples of creating the integer ring and making use of the resulting parent object to coerce various elements into the ring.\n\nExamples\n\njulia> f = ZZ()\n0\n\njulia> g = ZZ(123)\n123\n\njulia> h = ZZ(BigInt(1234))\n1234\n","category":"section"},{"location":"integer/#Basic-ring-functionality","page":"Integer ring","title":"Basic ring functionality","text":"The integer ring in AbstractAlgebra.jl implements the full Ring interface and the Euclidean Ring interface.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> f = ZZ(12)\n12\n\njulia> h = zero(ZZ)\n0\n\njulia> k = one(ZZ)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> T = parent(f)\nIntegers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n24\n\njulia> h = powermod(f, 12, ZZ(17))\n4\n\njulia> flag, q = divides(f, ZZ(3))\n(true, 4)\n","category":"section"},{"location":"integer/#Integer-functionality-provided-by-AbstractAlgebra.jl","page":"Integer ring","title":"Integer functionality provided by AbstractAlgebra.jl","text":"The functionality below supplements that provided by Julia itself for its BigInt type.","category":"section"},{"location":"integer/#Basic-functionality","page":"Integer ring","title":"Basic functionality","text":"Examples\n\njulia> r = ZZ(-1)\n-1\n\njulia> is_unit(r)\ntrue\n","category":"section"},{"location":"integer/#Divisibility-testing","page":"Integer ring","title":"Divisibility testing","text":"Examples\n\njulia> r = ZZ(6)\n6\n\njulia> s = ZZ(3)\n3\n\njulia> is_divisible_by(r, s)\ntrue","category":"section"},{"location":"integer/#Square-root","page":"Integer ring","title":"Square root","text":"Examples\n\njulia> d = AbstractAlgebra.sqrt(ZZ(36))\n6\n\njulia> is_square(ZZ(9))\ntrue\n\njulia> m = AbstractAlgebra.exp(ZZ(0))\n1","category":"section"},{"location":"integer/#Coprime-bases","page":"Integer ring","title":"Coprime bases","text":"Examples\n\njulia> c, n = ppio(ZZ(12), ZZ(26))\n(4, 3)\n","category":"section"},{"location":"integer/#AbstractAlgebra.is_divisible_by-Tuple{BigInt, BigInt}","page":"Integer ring","title":"AbstractAlgebra.is_divisible_by","text":"is_divisible_by(a::Integer, b::Integer)\n\nReturn true if a is divisible by b, i.e. if there exists c such that a = bc.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.is_associated-Tuple{BigInt, BigInt}","page":"Integer ring","title":"AbstractAlgebra.is_associated","text":"is_associated(a::Integer, b::Integer)\n\nReturn true if a and b are associated, i.e. if there exists a unit c such that a = bc. For integers, this reduces to checking if a and b differ by a factor of 1 or -1.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.sqrt-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.sqrt","text":"sqrt(a::T; check::Bool=true) where T <: Integer\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.is_square_with_sqrt-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.is_square_with_sqrt","text":"is_square_with_sqrt(a::T) where T <: Integer\n\nReturn (true, s) if a is a perfect square, where s^2 = a. Otherwise return (false, 0).\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.root-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.root","text":"root(a::T, n::Int; check::Bool=true) where T <: Integer\n\nReturn the n-th root of a. If check=true the function will test if the input was a perfect n-th power, otherwise an exception will be raised. We require n  0.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.iroot-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.iroot","text":"iroot(a::T, n::Int) where T <: Integer\n\nReturn the truncated integer part of the n-th root of a (round towards zero). We require n  0 and also a geq 0 if n is even.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.is_power-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"Integer ring","title":"AbstractAlgebra.is_power","text":"is_power(a::T, n::Int) where T <: Integer\n\nReturn true, q if a is a perfect n-th power with a = q^n. Otherwise return false, 0. We require n  0.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.exp-Tuple{BigInt}","page":"Integer ring","title":"AbstractAlgebra.exp","text":"exp(a::T) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception. This function is not generally of use to the user, but is used internally in AbstractAlgebra.jl.\n\n\n\n\n\nexp(a::Rational{T}) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception.\n\n\n\n\n\n","category":"method"},{"location":"integer/#AbstractAlgebra.ppio-Tuple{BigInt, BigInt}","page":"Integer ring","title":"AbstractAlgebra.ppio","text":"ppio(a::T, b::T)\n\nReturn a pair (cd) such that a=c*d and c = gcd(a b^infty) if aneq 0, and c=b, d=0 if a=0.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#Sparse-distributed-multivariate-polynomials","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"AbstractAlgebra.jl provides a module, implemented in src/MPoly.jl for sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"section"},{"location":"mpolynomial/#Generic-sparse-distributed-multivariable-polynomial-types","page":"Sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariable polynomial types","text":"AbstractAlgebra provides a generic multivariate polynomial type Generic.MPoly{T} where T is the type of elements of the coefficient ring.\n\nThe polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of UInts for the exponent vectors. Note that exponent n is represented by the n-th column of the exponent array, not the n-th row. This is because Julia uses a column major representation. See the file src/generic/GenericTypes.jl for details.\n\nThe top bit of each UInt is reserved for overflow detection.\n\nParent objects of such polynomials have type Generic.MPolyRing{T}.\n\nThe string representation of the variables of the polynomial ring and the base/coefficient ring R and the ordering are stored in the parent object.","category":"section"},{"location":"mpolynomial/#Abstract-types","page":"Sparse distributed multivariate polynomials","title":"Abstract types","text":"The polynomial element types belong to the abstract type MPolyRingElem{T} and the polynomial ring types belong to the abstract type MPolyRing{T}.\n\nnote: Note\nNote that both the generic polynomial ring type Generic.MPolyRing{T} and the abstract type it belongs to, MPolyRing{T} are both called MPolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"section"},{"location":"mpolynomial/#Polynomial-ring-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial ring constructors","text":"In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructors.\n\nLike for univariate polynomials, a shorthand constructor is provided when the number of generators is greater than 1: given a base ring R, we abbreviate the constructor as follows:\n\nR[:x, :y, ...]\n\nIn addition to that, it is also possible to construct univariate polynomial rings over other univariate polynomial rings in a similar fashion:\n\nR[:x][:y]...\n\nHere are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y]; internal_ordering=:deglex)\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> T, (z, t) = QQ[:z, :t]\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[z, t])\n\njulia> f = R()\n0\n\njulia> g = R(123)\n123\n\njulia> h = R(BigInt(1234))\n1234\n\njulia> k = R(x + 1)\nx + 1\n\njulia> m = R(x + y + 1)\nx + y + 1\n\njulia> derivative(k, 1)\n1\n\njulia> derivative(k, 2)\n0\n\njulia> R, x = polynomial_ring(ZZ, 10); R\nMultivariate polynomial ring in 10 variables x1, x2, x3, x4, ..., x10\n  over integers\n\njulia> T, (z, t) = QQ[:z][:t]\n(Univariate polynomial ring in t over univariate polynomial ring, AbstractAlgebra.Generic.Poly{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}[z, t])\n","category":"section"},{"location":"mpolynomial/#Polynomial-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial constructors","text":"Multivariate polynomials can be constructed from the generators in the usual way using arithmetic operations.\n\nAlso, all of the standard ring element constructors may be used to construct multivariate polynomials.\n\n(R::MPolyRing{T})() where T <: RingElement\n(R::MPolyRing{T})(c::Integer) where T <: RingElement\n(R::MPolyRing{T})(a::elem_type(R)) where T <: RingElement\n(R::MPolyRing{T})(a::T) where T <: RingElement\n\nFor more efficient construction of multivariate polynomial, one can use the MPoly build context, where terms (coefficient followed by an exponent vector) are pushed onto a context one at a time and then the polynomial constructed from those terms in one go using the finish function.\n\nNote that the finish function resets the build context so that it can be used to construct multiple polynomials..\n\nWhen a multivariate polynomial type has a representation that allows constant time access (e.g. it is represented internally by arrays), the following additional constructor is available. It takes and array of coefficients and and array of exponent vectors.\n\n(S::MPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: RingElem\n\nCreate the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for an element of R\n\njulia> push_term!(C, ZZ(3), [1, 2]);\n\n\njulia> push_term!(C, ZZ(2), [1, 1]);\n\n\njulia> push_term!(C, ZZ(4), [0, 0]);\n\n\njulia> f = finish(C)\n3*x*y^2 + 2*x*y + 4\n\njulia> push_term!(C, ZZ(4), [1, 1]);\n\n\njulia> f = finish(C)\n4*x*y\n\njulia> S, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = S(Rational{BigInt}[2, 3, 1], [[3, 2], [1, 0], [0, 1]])\n2*x^3*y^2 + 3*x + y","category":"section"},{"location":"mpolynomial/#Functions-for-types-and-parents-of-multivariate-polynomial-rings","page":"Sparse distributed multivariate polynomials","title":"Functions for types and parents of multivariate polynomial rings","text":"base_ring(R::MPolyRing)\nbase_ring(a::MPolyRingElem)\n\nReturn the coefficient ring of the given polynomial ring or polynomial, respectively.\n\nparent(a::MPolyRingElem)\n\nReturn the polynomial ring of the given polynomial.","category":"section"},{"location":"mpolynomial/#Polynomial-functions","page":"Sparse distributed multivariate polynomials","title":"Polynomial functions","text":"","category":"section"},{"location":"mpolynomial/#Basic-manipulation","page":"Sparse distributed multivariate polynomials","title":"Basic manipulation","text":"All the standard ring functions are available, including the following.\n\nzero(R::MPolyRing)\none(R::MPolyRing)\niszero(a::MPolyRingElem)\nisone(a::MPolyRingElem)\n\ndivexact(a::T, b::T) where T <: MPolyRingElem\n\nAll basic functions from the Multivariate Polynomial interface are provided.\n\nsymbols(S::MPolyRing)\nnumber_of_variables(f::MPolyRing)\ngens(S::MPolyRing)\ngen(S::MPolyRing, i::Int)\n\ninternal_ordering(S::MPolyRing{T})\n\nNote that the currently supported orderings are :lex, :deglex and :degrevlex.\n\nlength(f::MPolyRingElem)\ndegrees(f::MPolyRingElem)\ntotal_degree(f::MPolyRingElem)\n\nis_gen(x::MPolyRingElem)\n\ndivexact(f::T, g::T) where T <: MPolyRingElem\n\nFor multivariate polynomial types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.\n\ncoeff(f::MPolyRingElem, n::Int)\ncoeff(a::MPolyRingElem, exps::Vector{Int})\n\nAccess a coefficient by term number or exponent vector.\n\nmonomial(f::MPolyRingElem, n::Int)\nmonomial!(m::T, f::T, n::Int) where T <: MPolyRingElem\n\nThe second version writes the result into a preexisting polynomial object to save an allocation.\n\nterm(f::MPolyRingElem, n::Int)\n\nexponent(f::MyMPolyRingElem, i::Int, j::Int)\n\nReturn the exponent of the j-th variable in the i-th term of the polynomial f.\n\nexponent_vector(a::MPolyRingElem, i::Int)\n\nsetcoeff!(a::MPolyRingElem{T}, exps::Vector{Int}, c::T) where T <: RingElement\n\nAlthough multivariate polynomial rings are not usually Euclidean, the following functions from the Euclidean interface are often provided.\n\ndivides(f::T, g::T) where T <: MPolyRingElem\nremove(f::T, g::T) where T <: MPolyRingElem\nvaluation(f::T, g::T) where T <: MPolyRingElem\n\ndivrem(f::T, g::T) where T <: MPolyRingElem\ndiv(f::T, g::T) where T <: MPolyRingElem\n\nCompute a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients). The divrem version returns both quotient and remainder whilst the div version only returns the quotient.\n\nNote that the result of these functions depend on the ordering of the polynomial ring.\n\ngcd(f::T, g::T) where T <: MPolyRingElem\n\nThe following functionality is also provided for all multivariate polynomials.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^2 + 2x + 1\nx^2 + 2*x + 1\n\njulia> V = vars(f)\n1-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x\n\njulia> var_index(y) == 2\ntrue\n\njulia> degree(f, x) == 2\ntrue\n\njulia> degree(f, 2) == 0\ntrue\n\njulia> d = degrees(f)\n2-element Vector{Int64}:\n 2\n 0\n\njulia> is_constant(R(1))\ntrue\n\njulia> is_term(2x)\ntrue\n\njulia> is_monomial(y)\ntrue\n\njulia> is_unit(R(1))\ntrue\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> c1 = coeff(f, 1)\n1\n\njulia> c2 = coeff(f, x^3*y)\n1\n\njulia> m = monomial(f, 2)\nx*y^2\n\njulia> e1 = exponent(f, 1, 1)\n3\n\njulia> v1 = exponent_vector(f, 1)\n2-element Vector{Int64}:\n 3\n 1\n\njulia> t1 = term(f, 1)\nx^3*y\n\njulia> setcoeff!(f, [3, 1], 12)\n12*x^3*y + 3*x*y^2 + 1\n\njulia> S, (x, y) = polynomial_ring(QQ, [:x, :y]; internal_ordering=:deglex)\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> V = symbols(S)\n2-element Vector{Symbol}:\n :x\n :y\n\njulia> X = gens(S)\n2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x\n y\n\njulia> ord = internal_ordering(S)\n:deglex\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> n = length(f)\n3\n\njulia> is_gen(y)\ntrue\n\njulia> number_of_variables(S) == 2\ntrue\n\njulia> d = total_degree(f)\n4\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x^2*y^2 + 1\nx^2*y^2 + 1\n\njulia> flag, q = divides(f*g, f)\n(true, x^2*y^2 + 1)\n\njulia> d = divexact(f*g, f)\nx^2*y^2 + 1\n\njulia> v, q = remove(f*g^3, g)\n(3, 2*x^2*y + 2*x + y + 1)\n\njulia> n = valuation(f*g^3, g)\n3\n\njulia> R, (x, y) = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 3x^2*y^2 + 2x + 1\n3*x^2*y^2 + 2*x + 1\n\njulia> f1 = divexact(f, 5)\n3//5*x^2*y^2 + 2//5*x + 1//5\n\njulia> f2 = divexact(f, QQ(2, 3))\n9//2*x^2*y^2 + 3*x + 3//2","category":"section"},{"location":"mpolynomial/#Square-root","page":"Sparse distributed multivariate polynomials","title":"Square root","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.\n\nsqrt(f::MPolyRingElem, check::Bool=true)\nis_square(::MPolyRingElem)\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = -4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n-4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n\njulia> sqrt(f^2)\n4*x^5*y^4 - 5*x^5*y^3 - 4*x^4 + x^3*y^4\n\njulia> is_square(f)\nfalse","category":"section"},{"location":"mpolynomial/#Iterators","page":"Sparse distributed multivariate polynomials","title":"Iterators","text":"The following iterators are provided for multivariate polynomials.\n\ncoefficients(p::MPoly)\nmonomials(p::MPoly)\nterms(p::MPoly)\nexponent_vectors(a::MPoly)\n\nExamples\n\njulia> S, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 1\n 3\n 1\n\njulia> M = collect(monomials(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n x*y^2\n 1\n\njulia> T = collect(terms(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n 3*x*y^2\n 1\n\njulia> V = collect(exponent_vectors(f))\n3-element Vector{Vector{Int64}}:\n [3, 1]\n [1, 2]\n [0, 0]","category":"section"},{"location":"mpolynomial/#Changing-base-(coefficient)-rings","page":"Sparse distributed multivariate polynomials","title":"Changing base (coefficient) rings","text":"In order to substitute the variables of a polynomial f over a ring T by elements in a T-algebra S, you first have to change the base ring of f using the following function, where g is a function representing the structure homomorphism of the T-algebra S.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> fz = x^2*y^2 + x + 1\nx^2*y^2 + x + 1\n\njulia> fq = change_base_ring(QQ, fz)\nx^2*y^2 + x + 1\n\njulia> fq = change_coefficient_ring(QQ, fz)\nx^2*y^2 + x + 1\n\n\nIn case a specific parent ring is constructed, it can also be passed to the function.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S,  = polynomial_ring(QQ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> fz = x^5 + y^3 + 1\nx^5 + y^3 + 1\n\njulia> fq = change_base_ring(QQ, fz, parent=S)\nx^5 + y^3 + 1","category":"section"},{"location":"mpolynomial/#Multivariate-coefficients","page":"Sparse distributed multivariate polynomials","title":"Multivariate coefficients","text":"In order to return the \"coefficient\" (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1\nx^4*y^2*z^2 - 2*x^4*y*z^2 + 4*x^4*z^2 + 2*x^2*y^2 + x + 1\n\njulia> coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])\ntrue\n","category":"section"},{"location":"mpolynomial/#Inflation/deflation","page":"Sparse distributed multivariate polynomials","title":"Inflation/deflation","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> def, shift = deflation(f)\n([1, 2], [3, 3])\n\njulia> f1 = deflate(f, def, shift)\nx^2*y^2 + 3*x*y^2 - x + 5*y - 1\n\njulia> f2 = inflate(f1, def, shift)\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> f2 == f\ntrue\n\njulia> g = (x+y+1)^2\nx^2 + 2*x*y + 2*x + y^2 + 2*y + 1\n\njulia> g0 = coeff(g, [y], [0])\nx^2 + 2*x + 1\n\njulia> g1 = deflate(g - g0, [y], [1], [1])\n2*x + y + 2\n\njulia> g == g0 + y * g1\ntrue\n","category":"section"},{"location":"mpolynomial/#Conversions","page":"Sparse distributed multivariate polynomials","title":"Conversions","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S, z = polynomial_ring(ZZ, :z)\n(Univariate polynomial ring in z over integers, z)\n\njulia> f = 2x^5 + 3x^4 - 2x^2 - 1\n2*x^5 + 3*x^4 - 2*x^2 - 1\n\njulia> g = to_univariate(S, f)\n2*z^5 + 3*z^4 - 2*z^2 - 1\n","category":"section"},{"location":"mpolynomial/#Evaluation","page":"Sparse distributed multivariate polynomials","title":"Evaluation","text":"The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.\n\nThe following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.\n\nThe following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y^2 + 3x + y + 1\n2*x^2*y^2 + 3*x + y + 1\n\njulia> evaluate(f, BigInt[1, 2])\n14\n\njulia> evaluate(f, [QQ(1), QQ(2)])\n14//1\n\njulia> evaluate(f, [1, 2])\n14\n\njulia> f(1, 2) == 14\ntrue\n\njulia> evaluate(f, [x + y, 2y - x])\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> f(x + y, 2y - x)\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^2*y^2 + 2x*z + 3y*z + z + 1\nx^2*y^2 + 2*x*z + 3*y*z + z + 1\n\njulia> evaluate(f, [1, 3], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [x, z], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [1, 2], [x + z, x - z])\nx^4 - 2*x^2*z^2 + 5*x*z + z^4 - z^2 + z + 1\n\njulia> S = matrix_ring(ZZ, 2)\nMatrix ring of degree 2\n  over integers\n\njulia> M1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> M2 = S([2 3; 1 -1])\n[2    3]\n[1   -1]\n\njulia> M3 = S([-1 1; 1 1])\n[-1   1]\n[ 1   1]\n\njulia> evaluate(f, [M1, M2, M3])\n[ 64    83]\n[124   149]","category":"section"},{"location":"mpolynomial/#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms","page":"Sparse distributed multivariate polynomials","title":"Leading and constant coefficients, leading monomials and leading terms","text":"The leading and trailing coefficient, constant coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:\n\nExamples\n\nusing AbstractAlgebra\nR,(x,y) = polynomial_ring(ZZ, [:x, :y], internal_ordering=:deglex)\np = 2*x*y + 3*y^3 + 1\nleading_term(p)\nleading_monomial(p)\nleading_coefficient(p)\nleading_term(p) == leading_coefficient(p) * leading_monomial(p)\nconstant_coefficient(p)\ntail(p)","category":"section"},{"location":"mpolynomial/#Least-common-multiple,-greatest-common-divisor","page":"Sparse distributed multivariate polynomials","title":"Least common multiple, greatest common divisor","text":"The greatest common divisor of two polynomials a and b is returned by\n\nNote that this functionality is currently only provided for AbstractAlgebra generic polynomials. It is not automatically provided for all multivariate rings that implement the multivariate interface.\n\nHowever, if such a gcd is provided, the least common multiple of two polynomials a and b is returned by\n\nExamples\n\njulia> using AbstractAlgebra\n\njulia> R,(x,y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> a = x*y + 2*y\nx*y + 2*y\n\njulia> b = x^3*y + y\nx^3*y + y\n\njulia> gcd(a,b)\ny\n\njulia> lcm(a,b)\nx^4*y + 2*x^3*y + x*y + 2*y\n\njulia> lcm(a,b) == a * b // gcd(a,b)\ntrue\n","category":"section"},{"location":"mpolynomial/#Derivations","page":"Sparse distributed multivariate polynomials","title":"Derivations","text":"Examples\n\njulia> R, (x, y) = AbstractAlgebra.polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> derivative(f, x)\ny + 1\n\njulia> derivative(f, y)\nx + 1\n\njulia> derivative(f, 1)\ny + 1\n\njulia> derivative(f, 2)\nx + 1","category":"section"},{"location":"mpolynomial/#Homogeneous-polynomials","page":"Sparse distributed multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"mpolynomial/#Random-generation","page":"Sparse distributed multivariate polynomials","title":"Random generation","text":"Random multivariate polynomials in a given ring can be constructed by passing a range of degrees for the variables and a range on the number of terms. Additional parameters are used to generate the coefficients of the polynomial.\n\nNote that zero coefficients may currently be generated, leading to less than the requested number of terms.\n\nrand(R::MPolyRing, exp_range::AbstractUnitRange{Int}, term_range::AbstractUnitRange{Int}, v...)\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = rand(R, -1:2, 3:5, -10:10)\n4*x^4*y^4\n\njulia> S, (s, t) = polynomial_ring(GF(7), [:x, :y])\n(Multivariate polynomial ring in 2 variables over finite field F_7, AbstractAlgebra.Generic.MPoly{AbstractAlgebra.GFElem{Int64}}[x, y])\n\njulia> g = rand(S, -1:2, 3:5)\n4*x^3*y^4","category":"section"},{"location":"mpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached=true, internal_ordering=:lex)\n\nGiven a coefficient ring R and variable names, say varnames = [:x1, :x2, ...], return a tuple S, [x1, x2, ...] of the polynomial ring S = Rx1 x2 dots and its generators x1 x2 dots.\n\nBy default (cached=true), the output S will be cached, i.e. if polynomial_ring is invoked again with the same arguments, the same (identical) ring is returned. Setting cached to false ensures a distinct new ring is returned, and will also prevent it from being cached.\n\nThe monomial ordering used for the internal storage of polynomials in S can be set with internal_ordering and must be one of :lex, :deglex or :degrevlex.\n\nSee also: polynomial_ring(::Ring, ::Vararg), @polynomial_ring.\n\nExample\n\njulia> S, generators = polynomial_ring(ZZ, [:x, :y, :z])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\npolynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)\n\nLike polynomial_ring(::Ring, ::Vector{Symbol}) with more ways to give varnames as specified in variable_names.\n\nReturn a tuple S, generators... with generators[i] corresponding to varnames[i].\n\nnote: Note\nIn the first method, varnames must not be empty, and if it consists of only one name, the univariate polynomial_ring(R::NCRing, s::VarName) method is called instead.\n\nExamples\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])\n\njulia> S, x, y = polynomial_ring(ZZ, :x => (1:2, 1:2), :y => 1:3);\n\njulia> S\nMultivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]\n  over integers\n\njulia> x\n2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x[1, 1]  x[1, 2]\n x[2, 1]  x[2, 2]\n\njulia> y\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n y[1]\n y[2]\n y[3]\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{Ring, Int64}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\npolynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)\n\nLike polynomial_ring(::Ring, ::Vector{Symbol}) with more ways to give varnames as specified in variable_names.\n\nReturn a tuple S, generators... with generators[i] corresponding to varnames[i].\n\nnote: Note\nIn the first method, varnames must not be empty, and if it consists of only one name, the univariate polynomial_ring(R::NCRing, s::VarName) method is called instead.\n\nExamples\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])\n\njulia> S, x, y = polynomial_ring(ZZ, :x => (1:2, 1:2), :y => 1:3);\n\njulia> S\nMultivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]\n  over integers\n\njulia> x\n2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x[1, 1]  x[1, 2]\n x[2, 1]  x[2, 2]\n\njulia> y\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n y[1]\n y[2]\n y[3]\n\n\n\n\n\npolynomial_ring(R::Ring, n::Int, s::Symbol=:x; cached=true, internal_ordering=:lex)\n\nSame as polynomial_ring(::Ring, [\"s$i\" for i in 1:n]).\n\nExample\n\njulia> S, x = polynomial_ring(ZZ, 3)\n(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x1, x2, x3])\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.@polynomial_ring","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.@polynomial_ring","text":"@polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)\n\nReturn polynomial ring from polynomial_ring(::Ring, ::Vararg) and introduce the generators into the current scope.\n\nExamples\n\njulia> S = @polynomial_ring(ZZ, \"x#\" => (1:2, 1:2), \"y#\" => 1:3)\nMultivariate polynomial ring in 7 variables x11, x21, x12, x22, ..., y3\n  over integers\n\njulia> x11, x21, x12, x22\n(x11, x21, x12, x22)\n\njulia> y1, y2, y3\n(y1, y2, y3)\n\njulia> (S, [x11 x12; x21 x22], [y1, y2, y3]) == polynomial_ring(ZZ, \"x#\" => (1:2, 1:2), \"y#\" => 1:3)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"mpolynomial/#AbstractAlgebra.Generic.MPolyBuildCtx-Tuple{MPolyRing}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.MPolyBuildCtx","text":"MPolyBuildCtx(R::MPolyRing)\n\nReturn a build context for creating polynomials in the given ring.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.Generic.push_term!-Tuple{MPolyBuildCtx, RingElem, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.push_term!","text":"push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\n\nAdd the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.Generic.finish-Tuple{MPolyBuildCtx}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.finish","text":"finish(M::MPolyBuildCtx)\n\nFinish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.is_univariate-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.is_univariate","text":"is_univariate(R::MPolyRing)\n\nReturns true if R is a univariate polynomial ring, i.e. has exactly one variable, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.var_indices-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.var_indices","text":"var_indices(p::MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the indices of the variables actually occurring in p.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.vars-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.vars","text":"vars(p::MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the variables actually occurring in p.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.var_index-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.var_index","text":"var_index(x::MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the index of the given variable x. If x is not a variable in a multivariate polynomial ring, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Int64}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.degree","text":"degree(f::MPolyRingElem{T}, i::Int) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.degree","text":"degree(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the variable x.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.degrees-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.degrees","text":"degrees(f::MPolyRingElem{T}) where T <: RingElement\n\nReturn an array of the degrees of the polynomial f in terms of each variable.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.is_constant-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.is_constant","text":"is_constant(x::MPolyRingElem{T}) where T <: RingElement\n\nReturn true if x is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.is_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.is_term","text":"is_term(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.is_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.is_monomial","text":"is_monomial(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.is_univariate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.is_univariate","text":"is_univariate(p::MPolyRingElem)\n\nReturns true if p is a univariate polynomial, i.e. involves at most one variable (thus constant polynomials are considered univariate), and false otherwise. The result depends on the terms of the polynomial, not simply on the number of variables in the polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.coeff","text":"coeff(f::MPolyRingElem{T}, m::MPolyRingElem{T}) where T <: RingElement\n\nReturn the coefficient of the monomial m of the polynomial f. If there is no such monomial, zero is returned.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, p::MPolyRingElem{<: RingElement}; parent::MPolyRing, cached::Bool=true)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::MPolyRingElem{<: RingElement}; parent::MPolyRing, cached::Bool=true)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.map_coefficients-Tuple{Any, MPolyRingElem}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.map_coefficients","text":"map_coefficients(f, p::MPolyRingElem{<: RingElement}; parent::MPolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.coeff","text":"coeff(a::MPolyRingElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [1, 3], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f (assuming variables x y z in that order).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.coeff","text":"coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: MPolyRingElem\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [x, z], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflation-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflation","text":"deflation(f::MPolyRingElem{T}) where T <: RingElement\n\nCompute deflation parameters for the exponents of the polynomial f. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflate","text":"deflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been reduced by the given shifts (supplied as an array of shifts, one for each variable), then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflate","text":"deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated (divided) by the given exponents (supplied as an array of deflation factors, one for each variable).\n\nThe algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflate","text":"deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated maximally, i.e. with each exponent divide by the largest integer which divides the degrees of all exponents of that variable in f.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflate","text":"deflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\n\nReturn a polynomial with the same coefficients as f but where exponents of some variables (supplied as an array of variable indices) have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.deflate","text":"deflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem\n\nReturn a polynomial with the same coefficients as f but where the exponents of the given variables have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.inflate","text":"inflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then increased by the given shifts (again supplied as an array of shifts, one for each variable).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.inflate","text":"inflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.inflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.inflate","text":"inflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})\n\nReturn a polynomial with the same coefficients as f but where exponents of some variables (supplied as an array of variable indices) have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T<:MPolyRingElem","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.inflate","text":"inflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: MPolyRingElem\n\nReturn a polynomial with the same coefficients as f but where the exponents of the given variables have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.to_univariate","text":"to_univariate(R::PolyRing{T}, p::MPolyRingElem{T}) where T <: RingElement\n\nAssuming the polynomial p is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring R. An exception is raised if the polynomial p involves more than one variable.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.evaluate","text":"evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of the supplied vector.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.evaluate","text":"evaluate(a::MPolyRingElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S, Vector{S}, Vector{U}}} where {T<:RingElement, S<:MPolyRingElem{T}, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.evaluate","text":"evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S <: MPolyRingElem{T}, U <: RingElement} where T <: RingElement\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables (supplied as polynomials) given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T<:RingElement, U<:NCRingElem}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.evaluate","text":"evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T <: RingElement, U <: NCRingElem}\n\nEvaluate the polynomial expression at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which a belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.leading_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(p::MPolyRingElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.trailing_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.trailing_coefficient","text":"trailing_coefficient(p::MPolyRingElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.leading_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.leading_monomial","text":"leading_monomial(p::MPolyRingElem)\n\nReturn the leading monomial of p. This function throws an ArgumentError if p is zero.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.leading_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.leading_term","text":"leading_term(p::MPolyRingElem)\n\nReturn the leading term of the polynomial p. This function throws an ArgumentError if p is zero.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.constant_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.constant_coefficient","text":"constant_coefficient(p::MPolyRingElem)\n\nReturn the constant coefficient of the polynomial p or zero if it doesn't have one.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.tail-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.tail","text":"tail(p::MPolyRingElem)\n\nReturn the tail of the polynomial p, i.e. the polynomial without its leading term (if any).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#Base.gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T}, AbstractAlgebra.Generic.MPoly{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"Base.gcd","text":"gcd(a::MPoly{T}, a::MPoly{T}) where {T <: RingElement}\n\nReturn the greatest common divisor of a and b in parent(a).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#Base.lcm-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"Base.lcm","text":"lcm(a::AbstractAlgebra.MPolyRingElem{T}, a::AbstractAlgebra.MPolyRingElem{T}) where {T <: RingElement}\n\nReturn the least common multiple of a and b in parent(a).\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.derivative","text":"derivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\n","category":"method"},{"location":"mpolynomial/#AbstractAlgebra.Generic.is_homogeneous-Tuple{MPolyRingElem}","page":"Sparse distributed multivariate polynomials","title":"AbstractAlgebra.Generic.is_homogeneous","text":"is_homogeneous(x::MPolyRingElem)\n\nReturn true if the given polynomial is homogeneous with respect to the standard grading and false otherwise. Here by standard grading we mean that all variables of the polynomial ring are graded with weight 1.\n\n\n\n\n\n","category":"method"},{"location":"#AbstractAlgebra.jl","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"","category":"section"},{"location":"#Introduction","page":"AbstractAlgebra.jl","title":"Introduction","text":"AbstractAlgebra.jl is a computer algebra package for the Julia programming language, maintained by William Hart, Tommy Hofmann, Claus Fieker and Fredrik Johansson and other interested contributors.\n\nSource code\n\nAbstractAlgebra.jl grew out of the Nemo project after a number of requests from the community for the pure Julia part of Nemo to be split off into a separate project. See the Nemo repository for more details about Nemo.\n\nNemo repository","category":"section"},{"location":"#Features","page":"AbstractAlgebra.jl","title":"Features","text":"The features of AbstractAlgebra.jl include:\n\nUse of Julia multiprecision integers and rationals\nFinite fields (prime order, naive implementation only)\nNumber fields (naive implementation only)\nUnivariate polynomials\nMultivariate polynomials\nRelative and absolute power series\nLaurent series\nFraction fields\nResidue rings, including mathbbZnmathbbZ\nMatrices and linear algebra\n\nAll implementations are fully recursive and generic, so that one can build matrices over polynomial rings, over a finite field, for example.\n\nAbstractAlgebra.jl also provides a set of abstract types for Groups, Rings, Fields, Modules and elements thereof, which allow external types to be made part of the AbstractAlgebra.jl type hierarchy.","category":"section"},{"location":"#Installation","page":"AbstractAlgebra.jl","title":"Installation","text":"To use AbstractAlgebra we require Julia 1.10 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.\n\nAt the Julia prompt simply type\n\njulia> using Pkg; Pkg.add(\"AbstractAlgebra\")","category":"section"},{"location":"#Quick-start","page":"AbstractAlgebra.jl","title":"Quick start","text":"Here are some examples of using AbstractAlgebra.jl.\n\nThis example makes use of multivariate polynomials.\n\nusing AbstractAlgebra\n\nR, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])\n\nf = x + y + z + 1\n\np = f^20;\n\n@time q = p*(p+1);\n\nHere is an example using generic recursive ring constructions.\n\nusing AbstractAlgebra\n\nR = GF(7)\n\nS, y = polynomial_ring(R, :y)\n\nT, = residue_ring(S, y^3 + 3y + 1)\n\nU, z = polynomial_ring(T, :z)\n\nf = (3y^2 + y + 2)*z^2 + (2*y^2 + 1)*z + 4y + 3;\n\ng = (7y^2 - y + 7)*z^2 + (3y^2 + 1)*z + 2y + 1;\n\ns = f^4;\n\nt = (s + g)^4;\n\n@time resultant(s, t)\n\nHere is an example using matrices.\n\nusing AbstractAlgebra\n\nR, x = polynomial_ring(ZZ, :x)\n\nS = matrix_space(R, 10, 10)\n\nM = rand(S, 0:3, -10:10);\n\n@time det(M)\n\nAnd here is an example with power series.\n\nusing AbstractAlgebra\n\nR, x = QQ[:x]\n\nS, t = power_series_ring(R, 30, :t)\n\nu = t + O(t^100)\n\n@time divexact((u*exp(x*u)), (exp(u)-1));","category":"section"},{"location":"map_cache/#Cached-maps","page":"Cached maps","title":"Cached maps","text":"All basic map (i.e. those not built up from other maps) in AbstractAlgebra can be cached.\n\nA cache is a dictionary that can be switched on and off at run time that keeps a cache of previous evaluations of the map. This can be useful if the map is extremely difficult to evaluate, e.g. a discrete logarithm map. Rather than evaluate the map afresh each time, the map first looks up the dictionary of previous known values of the map.\n\nTo facilitate caching of maps, the Generic module provides a type Generic.MapCache, which can be used to wrap any existing map object with a dictionary.\n\nImportantly, the supertype of the resulting Generic.MapCache object is identical to that of the map being cached. This means that any functions that would accept the original map will also accept the cached version.\n\nnote: Note\nCaching of maps only works for maps that correctly abstract access to their fields using accessor functions, as described in the map interface.","category":"section"},{"location":"map_cache/#Cached-map-constructors","page":"Cached maps","title":"Cached map constructors","text":"To construct a cached map from an existing map object, we have the following function:\n\ncached(M::Map; enabled=true, limit=100)\n\nReturn a cached map with the same supertype as M, caching up to limit values of the map M in a dictionary, assuming that the cache is enabled.\n\nCaches can be disabled by setting the value of the parameter enabled to false. This allows for the user to quickly go through code and completely disable caches of maps that were previously enabled, for testing purposes, etc.\n\nCaches can also be turned on and off at run time (see below).\n\nExamples\n\njulia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap defined by a Julia function\n  from integers\n  to integers\n\njulia> g = cached(f);\n\njulia> f(ZZ(1)) == g(ZZ(1))\ntrue","category":"section"},{"location":"map_cache/#Functionality-for-cached-maps","page":"Cached maps","title":"Functionality for cached maps","text":"The following functions are provided for cached maps.\n\nenable_cache!(M::MapCache)\ndisable_cache!(M::MapCache)\n\nTemporarily enable or disable the cache for the given map. The values stored in the cache are not lost when it is disabled.\n\nset_limit!(M::MapCache, limit::Int)\n\nSet the limit on the number of values that can be cached in the dictionary, to the given value. Setting the value to 0 will effectively disable further caching for this map.\n\nExamples\n\njulia> f = cached(map_from_func(x -> x + 1, ZZ, ZZ));\n\njulia> a = f(ZZ(1))\n2\n\njulia> disable_cache!(f)\n\njulia> b = f(ZZ(1))\n2\n\njulia> enable_cache!(f)\n\njulia> c = f(ZZ(1))\n2\n\njulia> set_limit!(f, 200)\n200\n\njulia> d = f(ZZ(1))\n2","category":"section"},{"location":"types/#Type-interface-of-AbstractAlgebra.jl","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Apart from how we usually think of types in programming, we shall in this section discuss why we do not use the typical type interface.","category":"section"},{"location":"types/#Why-types-aren't-enough","page":"Type interface of AbstractAlgebra.jl","title":"Why types aren't enough","text":"Naively, one might have expected that structures like rings in AbstractAlgebra.jl could be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.\n\nConsider the ring R = mathbbZnmathbbZ for a multiprecision integer n. If we were to model the ring R as a type, then the type would somehow need to contain the modulus n. This is not possible in Julia, and in fact it is not desirable, since the compiler would then recompile all the associated functions every time a different modulus n was used.\n\nWe could attach the modulus n to the objects representing elements of the ring, rather than their type.\n\nBut now we cannot create new elements of the ring mathbbZnmathbbZ given only their type, since the type no longer contains the modulus n.\n\nInstead, the way we get around this in AbstractAlgebra.jl is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called parent objects, can contain extra information, such as the modulus n. In return, we associate this parent object with so called element objects.\n\nIn order to create new elements of mathbbZnmathbbZ as above, we overload the call operator for the parent object.\n\nIn the following AbstractAlgebra.jl example, we create the parent object R corresponding to the ring mathbbZ7mathbbZ. We then create a new element a of this ring by calling the parent object R.\n\nR, = residue_ring(ZZ, 7)\na = R(3)\n\nHere, R is the parent object, containing the modulus 7. So this example creates the element a = 3 pmod7.\n\nObjects known as parents which contain additional information about groups, rings, fields and modules, etc., that can't be stored in types alone.\n\nThese details are technical and can be skipped or skimmed by new users of Julia/AbstractAlgebra.jl. Types are almost never dealt with directly when scripting AbstractAlgebra.jl to do mathematical computations.\n\nIn contrast, AbstractAlgebra.jl developers will want to know how we model mathematical objects and their rings, fields, groups, etc.","category":"section"},{"location":"types/#The-abstract-type-hierarchy-in-AbstractAlgebra.jl","page":"Type interface of AbstractAlgebra.jl","title":"The abstract type hierarchy in AbstractAlgebra.jl","text":"In AbstractAlgebra.jl, we use the abstract type hierarchy in order to give structure when programming the mathematical structures. For example, abstract types in Julia can belong to one another in a hierarchy.\n\nFor example, the Field abstract type belongs to the Ring abstract type. The full hierarchy can be seen in diagrams under the section on visualisation of the abstract types.\n\nIn practice this is practical since it means that any generic function designed to work with ring objects will also work with field objects.\n\nIn AbstractAlgebra.jl we also distinguish between the elements of a field, say, and the field itself.\n\nFor example, we have an object of type Generic.PolyRing to model a generic polynomial ring, and elements of that polynomial ring would have type Generic.PolyRingElem.\n\nFor this purpose, we also have a hierarchy of abstract types, such as FieldElem, that the types of element objects can belong to.","category":"section"},{"location":"types/#More-complex-example-of-parent-objects","page":"Type interface of AbstractAlgebra.jl","title":"More complex example of parent objects","text":"Here is some code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.\n\njulia> using AbstractAlgebra\n\njulia> R, x = ZZ[:x]\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^2 + 3x + 1\nx^2 + 3*x + 1\n\njulia> R isa PolyRing\ntrue\n\njulia> f isa PolyRingElem\ntrue\n\njulia> parent(f) == R\ntrue","category":"section"},{"location":"polynomial/#Univariate-polynomial-functionality","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/Poly.jl for polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any univariate polynomial type which follows the Univariate Polynomial Ring interface.","category":"section"},{"location":"polynomial/#Generic-univariate-polynomial-types","page":"Univariate polynomial functionality","title":"Generic univariate polynomial types","text":"AbstractAlgebra.jl provides a generic polynomial type based on Julia arrays which is implemented in src/generic/Poly.jl.\n\nThese generic polynomials have type Generic.Poly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of such polynomials have type Generic.PolyRing{T}.\n\nThe string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"section"},{"location":"polynomial/#Abstract-types","page":"Univariate polynomial functionality","title":"Abstract types","text":"All univariate polynomial element types belong to the abstract type PolyRingElem{T} and the polynomial ring types belong to the abstract type PolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.\n\nnote: Note\nBoth the generic polynomial ring type Generic.PolyRing{T} and the abstract type it belongs to, PolyRing{T}, are called PolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"section"},{"location":"polynomial/#Polynomial-ring-constructors","page":"Univariate polynomial functionality","title":"Polynomial ring constructors","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.\n\nA shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.\n\nR[:x]\n\nHere are some examples of creating polynomial rings and their associated generators.\n\nExamples\n\njulia> T, z = QQ[:z]\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, x = polynomial_ring(ZZ)\n(Univariate polynomial ring in x over integers, x)\n\nAll of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a polynomial_ring constructor to allow creation of their polynomial rings.","category":"section"},{"location":"polynomial/#Polynomial-constructors","page":"Univariate polynomial functionality","title":"Polynomial constructors","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.\n\nThe easiest way is simply using the generator returned by the polynomial_ring constructor and build up the polynomial using basic arithmetic.\n\nThe Julia language has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.\n\nA second way is to use the polynomial ring to construct a polynomial. There are the usual ways of constructing an element of a ring.\n\n(R::PolyRing)() # constructs zero\n(R::PolyRing)(c::Integer)\n(R::PolyRing)(c::elem_type(R))\n(R::PolyRing{T})(a::T) where T <: RingElement\n\nThe third constructor above cannot be used to coerce a polynomial from one ring to another; instead use a call like map_coefficients(identity, f; parent=dest_ring)), or alternatively, for small polynomials one can simply use evaluation: namely, f(y) where y is the generator of the destination polynomial ring. The fourth constructor creates a constant polynomial from an element of the coefficient ring.\n\nFor polynomials there is also the following more general constructor accepting an array of coefficients.\n\n(S::PolyRing{T})(A::Vector{T}) where T <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: Integer\n\nConstruct the polynomial in the ring S with the given array of coefficients, i.e. where A[1] is the constant coefficient.\n\nA third way of constructing polynomials is to construct them directly without creating the polynomial ring.\n\npolynomial(R::Ring, arr::Vector{T}, var::VarName=:x; cached::Bool=true)\n\nGiven an array of coefficients construct the polynomial with those coefficients over the given ring and with the given variable.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + 3*x + 21\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + 2*x + 1\n\njulia> R()\n0\n\njulia> S(1)\n1\n\njulia> S(y)\ny\n\njulia> S(x)\nx\n\njulia> S, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> f = S(Rational{BigInt}[2, 3, 1])\nx^2 + 3*x + 2\n\njulia> g = S(BigInt[1, 0, 4])\n4*x^2 + 1\n\njulia> h = S([4, 7, 2, 9])\n9*x^3 + 2*x^2 + 7*x + 4\n\njulia> p = polynomial(ZZ, [1, 2, 3])\n3*x^2 + 2*x + 1\n\njulia> f = polynomial(ZZ, [1, 2, 3], :y)\n3*y^2 + 2*y + 1","category":"section"},{"location":"polynomial/#Similar-and-zero","page":"Univariate polynomial functionality","title":"Similar and zero","text":"Another way of constructing polynomials is to construct one similar to an existing polynomial using either similar or zero.\n\nsimilar(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem\n\nConstruct the zero polynomial with the same variable as the given polynomial with coefficients in the given ring. Both functions behave the same way for polynomials.\n\nsimilar(x::MyPoly{T}, R::Ring, var::VarName=var(parent(x))) where T <: RingElem\nsimilar(x::MyPoly{T}, var::VarName=var(parent(x))) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring, var::VarName=var(parent(x))) where T <: RingElem\nzero(x::MyPoly{T}, var::VarName=var(parent(x))) where T <: RingElem\n\nConstruct the zero polynomial with the given variable and coefficients in the given ring, if specified, and in the coefficient ring of the given polynomial otherwise.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = 1 + 2x + 3x^2\n3*x^2 + 2*x + 1\n\njulia> g = similar(f)\n0\n\njulia> h = similar(f, QQ)\n0\n\njulia> k = similar(f, QQ, :y)\n0","category":"section"},{"location":"polynomial/#Functions-for-types-and-parents-of-polynomial-rings","page":"Univariate polynomial functionality","title":"Functions for types and parents of polynomial rings","text":"base_ring(R::PolyRing)\nbase_ring(a::PolyRingElem)\n\nReturn the coefficient ring of the given polynomial ring or polynomial.\n\nparent(a::NCRingElement)\n\nReturn the polynomial ring of the given polynomial.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over integers\n\njulia> V = base_ring(y + 1)\nUnivariate polynomial ring in x over integers\n\njulia> T = parent(y + 1)\nUnivariate polynomial ring in y over R","category":"section"},{"location":"polynomial/#Euclidean-polynomial-rings","page":"Univariate polynomial functionality","title":"Euclidean polynomial rings","text":"For polynomials over a field, the Euclidean Ring Interface is implemented.\n\nmod(f::PolyRingElem, g::PolyRingElem)\ndivrem(f::PolyRingElem, g::PolyRingElem)\ndiv(f::PolyRingElem, g::PolyRingElem)\n\nmulmod(f::PolyRingElem, g::PolyRingElem, m::PolyRingElem)\npowermod(f::PolyRingElem, e::Int, m::PolyRingElem)\ninvmod(f::PolyRingElem, m::PolyRingElem)\n\ndivides(f::PolyRingElem, g::PolyRingElem)\nremove(f::PolyRingElem, p::PolyRingElem)\nvaluation(f::PolyRingElem, p::PolyRingElem)\n\ngcd(f::PolyRingElem, g::PolyRingElem)\nlcm(f::PolyRingElem, g::PolyRingElem)\ngcdx(f::PolyRingElem, g::PolyRingElem)\ngcdinv(f::PolyRingElem, g::PolyRingElem)\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> T, y = polynomial_ring(S, :y)\n(Univariate polynomial ring in y over S, y)\n\njulia> f = (3*x^2 + x + 2)*y + x^2 + 1\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\n(5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1\n\njulia> h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n(2*x^2 - 8*x + 4)*y^5 + 2*x*y + 1\n\njulia> invmod(f, g)\n(707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765\n\njulia> mulmod(f, g, h)\n(-30*x^2 - 43*x - 9)*y^3 + (-7*x^2 - 23*x - 7)*y^2 + (4*x^2 - 10*x - 3)*y + x^2 - 2*x\n\njulia> powermod(f, 3, h)\n(69*x^2 + 243*x + 79)*y^3 + (78*x^2 + 180*x + 63)*y^2 + (27*x^2 + 42*x + 18)*y + 3*x^2 + 3*x + 2\n\njulia> h = mod(f, g)\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> q, r = divrem(f, g)\n(0, (3*x^2 + x + 2)*y + x^2 + 1)\n\njulia> div(g, f)\n(-5//11*x^2 + 2//11*x + 6//11)*y - 13//121*x^2 - 3//11*x - 78//121\n\njulia> d = gcd(f*h, g*h)\ny + 1//11*x^2 + 6//11\n\njulia> k = gcdinv(f, h)\n(y + 1//11*x^2 + 6//11, 0)\n\njulia> m = lcm(f, h)\n(-14*x^2 - 23*x - 2)*y - 4*x^2 - 5*x + 1\n\njulia> flag, q = divides(g^2, g)\n(true, (5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1)\n\njulia> valuation(3g^3, g) == 3\ntrue\n\njulia> val, q = remove(5g^3, g)\n(3, 5)\n\njulia> r, s, t = gcdx(g, h)\n(1, 311//3530*x^2 - 2419//3530*x + 947//1765, (707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765)\n\n\nFunctions in the Euclidean Ring interface are supported over residue rings that are not fields, except that if an impossible inverse is encountered during the computation an error is thrown.","category":"section"},{"location":"polynomial/#Polynomial-functions","page":"Univariate polynomial functionality","title":"Polynomial functions","text":"","category":"section"},{"location":"polynomial/#Basic-functionality","page":"Univariate polynomial functionality","title":"Basic functionality","text":"All basic ring functionality is provided for polynomials. The most important such functions are the following.\n\nzero(R::PolyRing)\none(R::PolyRing)\niszero(a::PolyRingElem)\nisone(a::PolyRingElem)\n\ndivexact(a::T, b::T) where T <: PolyRingElem\n\nAll functions in the polynomial interface are provided. The most important are the following.\n\nvar(S::PolyRing)\nsymbols(S::PolyRing{T}) where T <: RingElem\n\nReturn a symbol or length 1 array of symbols, respectively, specifying the variable of the polynomial ring. This symbol is converted to a string when printing polynomials in that ring.\n\nIn addition, the following basic functions are provided.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> T, z = polynomial_ring(QQ, :z)\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, = residue_ring(ZZ, 17);\n\njulia> V, w = polynomial_ring(U, :w)\n(Univariate polynomial ring in w over U, w)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> a = zero(S)\n0\n\njulia> b = one(S)\n1\n\njulia> isone(b)\ntrue\n\njulia> c = BigInt(1)//2*z^2 + BigInt(1)//3\n1//2*z^2 + 1//3\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(S)\ny\n\njulia> g = is_gen(w)\ntrue\n\njulia> divexact((2x + 1)*(x + 1), (x + 1))\n2*x + 1\n\njulia> m = is_unit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> r = modulus(w)\n17\n\njulia> is_term(2y^2)\ntrue\n\njulia> is_monomial(y^2)\ntrue\n\njulia> is_monomial_recursive(x*y^2)\ntrue\n\njulia> is_monomial(x*y^2)\nfalse\n\njulia> S, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^3 + 3x + 1\nx^3 + 3*x + 1\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0]);\n\njulia> n = length(f)\n4\n\njulia> c = coeff(f, 1)\n3\n\njulia> g = set_coefficient!(g, 2, ZZ(11))\nx^3 + 11*x^2 + 2*x + 1\n\njulia> g = set_coefficient!(g, 7, ZZ(4))\n4*x^7 + x^3 + 11*x^2 + 2*x + 1","category":"section"},{"location":"polynomial/#Iterators","page":"Univariate polynomial functionality","title":"Iterators","text":"An iterator is provided to return the coefficients of a univariate polynomial. The iterator is called coefficients and allows iteration over the coefficients, starting with the term of degree zero (if there is one). Note that coefficients of each degree are given, even if they are zero. This is best illustrated by example.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^2 + 2\nx^2 + 2\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 2\n 0\n 1\n\njulia> for c in coefficients(f)\n          println(c)\n       end\n2\n0\n1","category":"section"},{"location":"polynomial/#Truncation","page":"Univariate polynomial functionality","title":"Truncation","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = truncate(f, 1)\n3\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + 3*x^2 + 4*x + 1)*y^2 + (x^4 + x^3 + 2*x^2 + 7*x + 5)*y + 3*x^3 + 6*x + 6\n","category":"section"},{"location":"polynomial/#Reversal","page":"Univariate polynomial functionality","title":"Reversal","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = reverse(f, 7)\n3*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n3*y^2 + (x + 1)*y + x\n","category":"section"},{"location":"polynomial/#Shifting","page":"Univariate polynomial functionality","title":"Shifting","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + 3*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"section"},{"location":"polynomial/#Inflation-and-deflation","page":"Univariate polynomial functionality","title":"Inflation and deflation","text":"","category":"section"},{"location":"polynomial/#Square-root","page":"Univariate polynomial functionality","title":"Square root","text":"Methods for is_square and sqrt are provided for inputs of type PolyRingElem.\n\nExamples\n\nR, x = polynomial_ring(ZZ, :x)\ng = x^2+6*x+1\nsqrt(g^2)","category":"section"},{"location":"polynomial/#Change-of-base-ring","page":"Univariate polynomial functionality","title":"Change of base ring","text":"Examples\n\nR, x = polynomial_ring(ZZ, :x)\ng = x^3+6*x + 1\nchange_base_ring(GF(2), g)\nchange_coefficient_ring(GF(2), g)","category":"section"},{"location":"polynomial/#Pseudodivision","page":"Univariate polynomial functionality","title":"Pseudodivision","text":"Given two polynomials a b, pseudodivision computes polynomials q and r with length(r)  length(b) such that L^d a = bq + r where d = length(a) - length(b) + 1 and L is the leading coefficient of b.\n\nWe call q the pseudoquotient and r the pseudoremainder.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = pseudorem(f, g)\nx^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1\n\njulia> q, r = pseudodivrem(f, g)\n((x^2 + x)*y - x^4 - x^2 + 1, x^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1)\n","category":"section"},{"location":"polynomial/#Content-and-primitive-part","page":"Univariate polynomial functionality","title":"Content and primitive part","text":"Examples\n\nR, x = polynomial_ring(ZZ, :x)\nS, y = polynomial_ring(R, :y)\n\nk = x*y^2 + (x + 1)*y + 3\n\nn = content(k)\np = primpart(k*(x^2 + 1))","category":"section"},{"location":"polynomial/#Evaluation,-composition-and-substitution","page":"Univariate polynomial functionality","title":"Evaluation, composition and substitution","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a).\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> M = R[x + 1 2x; x - 3 2x - 1]\n[x + 1       2*x]\n[x - 3   2*x - 1]\n\njulia> k = evaluate(f, 3)\n12*x + 6\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + 4*x^4 + 7*x^3 + 7*x^2 + 4*x + 4\n\njulia> n = compose(f, g; inner = :second)\n(x^3 + 2*x^2 + x)*y^2 + (2*x^5 + 2*x^4 + 4*x^3 + 9*x^2 + 6*x + 1)*y + x^7 + 4*x^5 + 5*x^4 + 5*x^3 + 10*x^2 + 8*x + 5\n\njulia> p = subst(f, M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> q = f(M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> r = f(23)\n552*x + 26\n","category":"section"},{"location":"polynomial/#Derivative-and-integral","page":"Univariate polynomial functionality","title":"Derivative and integral","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> T, z = polynomial_ring(QQ, :z)\n(Univariate polynomial ring in z over rationals, z)\n\njulia> U, = residue_ring(T, z^3 + 3z + 1);\n\njulia> V, w = polynomial_ring(U, :w)\n(Univariate polynomial ring in w over U, w)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n(z^2 + 2*z + 1)*w^2 + (z + 1)*w - 2*z + 4\n\njulia> h = derivative(f)\n2*x*y + x + 1\n\njulia> k = integral(g)\n(1//3*z^2 + 2//3*z + 1//3)*w^3 + (1//2*z + 1//2)*w^2 + (-2*z + 4)*w\n","category":"section"},{"location":"polynomial/#Resultant-and-discriminant","page":"Univariate polynomial functionality","title":"Resultant and discriminant","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = 6(x + 1)*y + (x^3 + 2x + 2)\n(6*x + 6)*y + x^3 + 2*x + 2\n\njulia> S = sylvester_matrix(f, g)\n[    3*x           x + 1               3]\n[6*x + 6   x^3 + 2*x + 2               0]\n[      0         6*x + 6   x^3 + 2*x + 2]\n\njulia> h = resultant(f, g)\n3*x^7 + 6*x^5 - 6*x^3 + 96*x^2 + 192*x + 96\n\njulia> k = discriminant(f)\nx^2 - 34*x + 1\n","category":"section"},{"location":"polynomial/#Newton-representation","page":"Univariate polynomial functionality","title":"Newton representation","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = deepcopy(f)\n3*x*y^2 + (x + 1)*y + 3\n\njulia> roots = [R(1), R(2), R(3)]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n\njulia> monomial_to_newton!(g.coeffs, roots)\n\njulia> newton_to_monomial!(g.coeffs, roots)","category":"section"},{"location":"polynomial/#Roots","page":"Univariate polynomial functionality","title":"Roots","text":"","category":"section"},{"location":"polynomial/#Interpolation","page":"Univariate polynomial functionality","title":"Interpolation","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> xs = [R(1), R(2), R(3), R(4)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n 4\n\njulia> ys = [R(1), R(4), R(9), R(16)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 4\n 9\n 16\n\njulia> f = interpolate(S, xs, ys)\ny^2\n","category":"section"},{"location":"polynomial/#Power-sums","page":"Univariate polynomial functionality","title":"Power sums","text":"Examples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = x^4 - 2*x^3 + 10*x^2 + 7*x - 5\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5\n\njulia> V = polynomial_to_power_sums(f)\n4-element Vector{BigInt}:\n   2\n -16\n -73\n  20\n\njulia> power_sums_to_polynomial(V)\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5","category":"section"},{"location":"polynomial/#Special-functions","page":"Univariate polynomial functionality","title":"Special functions","text":"The following special functions can be computed for any polynomial ring. Typically one uses the generator x of a polynomial ring to get the respective special polynomials expressed in terms of that generator.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\njulia> f = chebyshev_t(20, y)\n524288*y^20 - 2621440*y^18 + 5570560*y^16 - 6553600*y^14 + 4659200*y^12 - 2050048*y^10 + 549120*y^8 - 84480*y^6 + 6600*y^4 - 200*y^2 + 1\n\njulia> g = chebyshev_u(15, y)\n32768*y^15 - 114688*y^13 + 159744*y^11 - 112640*y^9 + 42240*y^7 - 8064*y^5 + 672*y^3 - 16*y\n","category":"section"},{"location":"polynomial/#Random-generation","page":"Univariate polynomial functionality","title":"Random generation","text":"One may generate random polynomials with degrees in a given range. Additional parameters are used to construct coefficients as elements of the coefficient ring.\n\nrand(R::PolyRing, deg_range::AbstractUnitRange{Int}, v...)\nrand(R::PolyRing, deg::Int, v...)\n\nExamples\n\nR, x = polynomial_ring(ZZ, :x)\nf = rand(R, -1:3, -10:10)\n\nS, y = polynomial_ring(GF(7), :y)\ng = rand(S, 2:2)\n\nU, z = polynomial_ring(R, :z)\nh = rand(U, 3:3, -1:2, -10:10)","category":"section"},{"location":"polynomial/#Ring-homomorphisms","page":"Univariate polynomial functionality","title":"Ring homomorphisms","text":"","category":"section"},{"location":"polynomial/#AbstractAlgebra.polynomial_ring-Tuple{NCRing, Union{Char, AbstractString, Symbol}}-polynomial","page":"Univariate polynomial functionality","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(R::NCRing, s::VarName = :x; cached::Bool=true)\n\nGiven a base ring R and symbol/string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring.\n\nBy default the parent object S depends only on R and x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S, y = polynomial_ring(R, :y)\n(Univariate polynomial ring in y over R, y)\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.modulus-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:ResElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.modulus","text":"modulus(a::PolyRingElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.leading_coefficient-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.leading_coefficient","text":"leading_coefficient(a::PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\nleading_coefficient(p::MPolyRingElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.trailing_coefficient-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.trailing_coefficient","text":"trailing_coefficient(a::PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\n\ntrailing_coefficient(p::MPolyRingElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.constant_coefficient-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.constant_coefficient","text":"constant_coefficient(a::PolynomialElem)\n\nReturn the constant coefficient of the given polynomial. If the polynomial is the zero polynomial, the function will return zero.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.set_coefficient!-Union{Tuple{T}, Tuple{PolynomialElem{T}, Int64, T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"AbstractAlgebra.set_coefficient!","text":"set_coefficient!(c::PolynomialElem{T}, n::Int, a::T) where T <: RingElement\nset_coefficient!(c::PolynomialElem{T}, n::Int, a::U) where {T <: RingElement, U <: Integer}\n\nSet the coefficient of degree n to a.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.tail-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.tail","text":"tail(a::PolynomialElem)\n\nReturn the tail of the given polynomial, i.e. the polynomial without its leading term (if any).\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.gen-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.gen","text":"gen(a::MPolyRing{T}, i::Int) where {T <: RingElement}\n\nReturn the i-th generator (variable) of the given polynomial ring.\n\n\n\n\n\ngen(R::AbsPowerSeriesRing{T}) where T <: RingElement\n\nReturn the generator of the power series ring, i.e. x + O(x^n) where n is the precision of the power series ring R.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_gen-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_gen","text":"is_gen(a::PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\n\n\nis_gen(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is a generator (variable) of the polynomial ring it belongs to.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_monic-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_monic","text":"is_monic(a::PolynomialElem)\n\nReturn true if the given polynomial is monic, i.e. has leading coefficient equal to one, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Base.length-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"Base.length","text":"length(a::PolynomialElem)\n\nReturn the length of the polynomial. The length of a univariate polynomial is defined to be the number of coefficients in its dense representation, including zero coefficients. Thus naturally the zero polynomial has length zero and additionally for nonzero polynomials the length is one more than the degree. (Note that the leading coefficient will always be nonzero.)\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.degree-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.degree","text":"degree(a::PolynomialElem)\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_monomial-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_monomial","text":"is_monomial(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\n\n\nis_monomial(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_monomial_recursive-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_monomial_recursive","text":"is_monomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_term-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_term","text":"is_term(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\n\n\nis_term(x::MPolyRingElem)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_term_recursive-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_term_recursive","text":"is_term_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial has one term. This function is recursive, with all scalar types returning true.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_constant-Tuple{PolynomialElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_constant","text":"is_constant(a::PolynomialElem)\n\nReturn true if a is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_separable-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_separable","text":"is_separable(f::PolyRingElem) -> Bool\n\nReturn whether for a polynomial f over a ring R the quotient ring Rx(f) is separable over R. If R is a field, this is equivalent to f having no repeated roots in an algebraic closure, or to f being coprime to the formal derivative f.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.is_unit-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.is_unit","text":"is_unit(f::T) where {T <: PolyRingElem}\n\nReturn true if the given polynomial over a commutative ring is invertible, otherwise false.\n\nExamples\n\njulia> Z, x = ZZ[:x]\n(Univariate polynomial ring in x over integers, x)\n\njulia> t = x^2+1\nx^2 + 1\n\njulia> is_unit(t)\nfalse\n\njulia> f = Z(1)\n1\n\njulia> is_unit(f)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Base.truncate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"Base.truncate","text":"truncate(a::PolynomialElem, n::Int)\n\nReturn a truncated to n terms, i.e. the remainder upon division by x^n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.mullow-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}, Int64}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.mullow","text":"mullow(a::PolyRingElem{T}, b::PolyRingElem{T}, n::Int) where T <: RingElement\n\nReturn atimes b truncated to n terms.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Base.reverse-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"Base.reverse","text":"reverse(x::PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Base.reverse-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"Base.reverse","text":"reverse(x::PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.shift_left-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.shift_left","text":"shift_left(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.shift_right-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.shift_right","text":"shift_right(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.deflation-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.deflation","text":"deflation(p::PolyRingElem)\n\nReturn a tuple (shift, defl) where shift is the exponent of the trailing term of p and defl is the gcd of the distance between the exponents of the nonzero terms of p. If p = 0, both shift and defl will be zero.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.inflate-Tuple{PolyRingElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.inflate","text":"inflate(f::PolyRingElem, shift::Int64, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x, return f(x^n)*x^j, i.e. multiply all exponents by n and shift f left by j.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.inflate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.inflate","text":"inflate(f::PolyRingElem, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x, return f(x^n), i.e. multiply all exponents by n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.deflate-Tuple{PolyRingElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.deflate","text":"deflate(f::PolyRingElem, shift::Int64, n::Int64) -> PolyRingElem\n\nGiven a polynomial g in x^n such that f = g(x)*x^{shift}, write f as a polynomial in x, i.e. divide all exponents of g by n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.deflate-Tuple{PolyRingElem, Int64}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.deflate","text":"deflate(f::PolyRingElem, n::Int64) -> PolyRingElem\n\nGiven a polynomial f in x^n, write it as a polynomial in x, i.e. divide all exponents by n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.deflate-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.deflate","text":"deflate(x::PolyRingElem) -> PolyRingElem, Int\n\nDeflate the polynomial f maximally, i.e. find the largest n s.th. f can be deflated by n, i.e. f is actually a polynomial in x^n. Return g n where g is the deflation of f.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, PolyRingElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"AbstractAlgebra.change_base_ring","text":"change_base_ring(R::Ring, p::PolyRingElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, PolyRingElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"AbstractAlgebra.change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::PolyRingElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.map_coefficients-Tuple{Any, PolyRingElem{<:RingElement}}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.map_coefficients","text":"map_coefficients(f, p::PolyRingElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.pseudorem-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.pseudorem","text":"pseudorem(f::PolyRingElem{T}, g::PolyRingElem{T}) where T <: RingElement\n\nReturn the pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.pseudodivrem-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.pseudodivrem","text":"pseudodivrem(f::PolyRingElem{T}, g::PolyRingElem{T}) where T <: RingElement\n\nReturn a tuple (q r) consisting of the pseudoquotient and pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.content-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.content","text":"content(a::PolyRingElem)\n\nReturn the content of a, i.e. the greatest common divisor of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.primpart-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.primpart","text":"primpart(a::PolyRingElem)\n\nReturn the primitive part of a, i.e. the polynomial divided by its content.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.evaluate-Tuple{PolyRingElem, Any}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.evaluate","text":"evaluate(a::PolyRingElem, b)\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.compose-Tuple{PolyRingElem, PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.compose","text":"compose(f::PolyRingElem, g::PolyRingElem; inner)\n\nCompose the polynomial a with the polynomial b and return the result.\n\nIf inner = :right, then f(g) is returned.\nIf inner = :left, then g(f) is returned.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.subst-Union{Tuple{T}, Tuple{PolyRingElem{T}, Any}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.subst","text":"subst(f::PolyRingElem{T}, a::Any) where T <: RingElement\n\nEvaluate the polynomial f at a. Note that a can be anything, whether a ring element or not.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.derivative-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.derivative","text":"derivative(a::PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\n\n\nderivative(f::AbsPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\n\n\n\n\nderivative(f::RelPowerSeriesRingElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\n\n\nderivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.integral-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:Union{FieldElem, ResElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.integral","text":"integral(x::PolyRingElem{T}) where {T <: Union{ResElem, FieldElement}}\n\nReturn the integral of the polynomial x.\n\n\n\n\n\nintegral(f::AbsPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\n\n\n\n\nintegral(f::RelPowerSeriesRingElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = power_series_ring(QQ, 10, :x)\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.sylvester_matrix-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.sylvester_matrix","text":"sylvester_matrix(p::PolyRingElem, q::PolyRingElem)\n\nReturn the sylvester matrix of the given polynomials.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.resultant-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.resultant","text":"resultant(p::PolyRingElem{T}, q::PolyRingElem{T}) where T <: RingElement\n\nReturn the resultant of the given polynomials.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.resx-Union{Tuple{T}, Tuple{PolyRingElem{T}, PolyRingElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.resx","text":"resx(a::PolyRingElem{T}, b::PolyRingElem{T}) where T <: RingElement\n\nReturn a tuple (r s t) such that r is the resultant of a and b and such that r = atimes s + btimes t.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.discriminant-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.discriminant","text":"discriminant(a::PolyRingElem)\n\nReturn the discriminant of the given polynomial.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.monomial_to_newton!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.monomial_to_newton!","text":"monomial_to_newton!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots r_0 r_1 ldots r_n-2. In other words, this determines output coefficients c_i such that c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) is equal to the input polynomial.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.newton_to_monomial!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.newton_to_monomial!","text":"newton_to_monomial!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots r_0 r_1 ldots r_n-2 to the standard monomial basis. In other words, this evaluates c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) where c_i are the input coefficients given by p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.Generic.roots-Tuple{PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.Generic.roots","text":"roots(f::PolyRingElem)\n\nReturns the roots of the polynomial f in the base ring of f as an array.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.Generic.roots-Tuple{Field, PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.Generic.roots","text":"roots(R::Field, f::PolyRingElem)\n\nReturns the roots of the polynomial f in the field R as an array.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.interpolate-Union{Tuple{T}, Tuple{PolyRing, Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.interpolate","text":"interpolate(S::PolyRing, x::Vector{T}, y::Vector{T}) where T <: RingElement\n\nGiven two arrays of values xs and ys of the same length n, find the polynomial f in the polynomial ring R of length at most n such that f has the value ys at the points xs. The values in the arrays xs and ys must belong to the base ring of the polynomial ring R. If no such polynomial exists, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.polynomial_to_power_sums-Union{Tuple{PolyRingElem{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.polynomial_to_power_sums","text":"polynomial_to_power_sums(f::PolyRingElem{T}, n::Int=degree(f)) where T <: RingElement -> Vector{T}\n\nUses Newton (or Newton-Girard) formulas to compute the first n sums of powers of the roots of f from the coefficients of f, starting with the sum of (first powers of) the roots. The input polynomial must be monic, at least degree 1 and have nonzero constant coefficient.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.power_sums_to_polynomial-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"AbstractAlgebra.power_sums_to_polynomial","text":"power_sums_to_polynomial(P::Vector{T};\n                 parent::PolyRing{T}=poly_ring(parent(P[1])) where T <: RingElement -> PolyRingElem{T}\n\nUses the Newton (or Newton-Girard) identities to obtain the polynomial with given sums of powers of roots. The list must be nonempty and contain degree(f) entries where f is the polynomial to be recovered. The list must start with the sum of first powers of the roots.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.chebyshev_t-Tuple{Int64, PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.chebyshev_t","text":"chebyshev_t(n::Int, x::PolyRingElem)\n\nReturn the Chebyshev polynomial of the first kind T_n(x), defined by T_n(x) = cos(n cos^-1(x)).\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.chebyshev_u-Tuple{Int64, PolyRingElem}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.chebyshev_u","text":"chebyshev_u(n::Int, x::PolyRingElem)\n\nReturn the Chebyshev polynomial of the first kind U_n(x), defined by (n+1) U_n(x) = T_n+1(x).\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.hom-Tuple{PolyRing, NCRing, Any, Any}","page":"Univariate polynomial functionality","title":"AbstractAlgebra.hom","text":"hom(R::AbstractAlgebra.PolyRing, S::NCRing, [coeff_map,] image)\n\nGiven a homomorphism coeff_map from C to S, where C is the coefficient ring of R, and given an element image of S, return the homomorphism from R to S whose restriction to C is coeff_map, and which sends the generator of R to image.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nExamples\n\njulia> Zx, x = ZZ[:x];\n\njulia> F = hom(Zx, Zx, x + 1);\n\njulia> F(x^2)\nx^2 + 2*x + 1\n\njulia> Fp = GF(3); Fpy, y = Fp[:y];\n\njulia> G = hom(Zx, Fpy, c -> Fp(c), y^3);\n\njulia> G(5*x + 1)\n2*y^3 + 1\n\n\n\n\n\n","category":"method"},{"location":"module_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"As with many generic constructions in AbstractAlgebra, the modules that are provided in AbstractAlgebra itself work over a Euclidean domain. Moreover, they are limited to finitely presented modules.\n\nFree modules and vector spaces are provided over Euclidean domains and fields respectively and then submodule, quotient module and direct sum module constructions are possible recursively over these.\n\nIt's also possible to compute an invariant decomposition using the Smith Normal Form.\n\nThe system also provides module homomorphisms and isomorphisms, building on top of the map interface.\n\nAs for rings and fields, modules follow an interface which other modules are expected to follow. However, very little generic functionality is provided automatically once this interface is implemented by a new module type.\n\nThe purpose of the module interface is simply to encourage uniformity in the module interfaces of systems that build on AbstractAlgebra. Of course modules are so diverse that this is a very loosely defined interface to accommodate the diversity of possible representations and implementations.","category":"section"},{"location":"mseries/#Multivariate-series","page":"Multivariate series","title":"Multivariate series","text":"AbstractAlgebra.jl provide multivariate series over a commutative ring.\n\nSeries with capped absolute precision are provided with and without weights.\n\nFor the unweighted case precision in each variable can be set per series, but is capped at some maximum precision which is set when defining the ring.\n\nFor the weighted case, a single precision is set on the ring only. Terms are truncated at that precision (after applying weights).","category":"section"},{"location":"mseries/#Generic-multivariate-series","page":"Multivariate series","title":"Generic multivariate series","text":"Generic multivariate series over a commutative ring, AbsMSeries{T} is implemented in src/generic/AbsMSeries.jl.\n\nSuch series are capped absolute series and have type Generic.AbsMSeries{T} where T is the type of elements of the coefficient ring.\n\nInternally they consist of a multivariate polynomial. For unweighted series they also contain a vector of precisions, one for each variable.\n\nFor weighted series weights and a precision are stored on the ring only. The vector of precisions in the series objects is ignored.\n\nSee the file src/generic/GenericTypes.jl for details of the type.\n\nThe series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.\n\nOnly lex ordering is provided at present both weighted and unweighted, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.\n\nParent objects of such series have type Generic.AbsMSeriesRing{T}.\n\nThe symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.","category":"section"},{"location":"mseries/#Abstract-types","page":"Multivariate series","title":"Abstract types","text":"Multivariate series element types belong to the abstract type MSeriesElem{T} and the multivariate series ring types belong to the abstract type MSeriesRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.","category":"section"},{"location":"mseries/#Multivariate-series-ring-constructors","page":"Multivariate series","title":"Multivariate series ring constructors","text":"In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructors.\n\nFor the unweighted case:\n\npower_series_ring(R::Ring, prec::Vector{Int}, s::AbstractVector{<:VarName}; cached::Bool = true)\n\nGiven a base ring R and a vector of strings s specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple U, (x, y, ...) representing the new series ring S and the generators x y ldots of the ring as a tuple. By default the parent object S will depend on R, the precision vector and the variable names x, y, ... and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nIn the weighted case:\n\npower_series_ring(R::Ring, weights::Vector{Int}, s::AbstractVector{<:VarName}, prec::Int; cached::Bool = true)\n\nGiven a base ring R and a vector of strings s specifying how the generators (variables) should be printed, along with a vector of weights, one for each variable and a bound on the (weighted) precision, return a tuple U, (x, y, ...) representing the new series ring S and the generators x y ldots of the ring as a tuple. By default the parent object S will depend on R, the precision, the vector of weights and the variable names x, y, ... and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nHere are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.\n\nNote that one can also use the function call O(x^n) with unweighted series to specify the precision in the variable x of a given series expression should be precision n.\n\nnote: Note\nIt is not possible to use x^0 in the O() function, since there is no distinction between x^0 and y^0 as far as the system is concerned. If one wishes to set the precision of a variable to precision 0, one must use the set_precision! function described below.\n\nIf one wants a series with the same precision in all variables, one can use O(R, n) where R is the series ring and n is the desired precision.\n\nIf all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer in the constructor.\n\nExamples\n\njulia> R, (x, y) = power_series_ring(ZZ, [2, 3], [:x, :y])\n(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])\n\njulia> f = R()\nO(y^3) + O(x^2)\n\njulia> g = R(123)\n123 + O(y^3) + O(x^2)\n\njulia> h = R(BigInt(1234))\n1234 + O(y^3) + O(x^2)\n\njulia> k = R(x + 1)\n1 + x + O(y^3) + O(x^2)\n\njulia> m = x + y + O(y^2)\ny + x + O(y^2) + O(x^2)\n\njulia> R, (x, y) = power_series_ring(ZZ, 3, [:x, :y])\n(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])\n\njulia> n = x + y + O(R, 2)\ny + x + O(y^2) + O(x^2)\n\njulia> R, (x, y) = power_series_ring(ZZ, [2, 3], 10, [:x, :y])\n(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(10), y + O(10)])\n\njulia> R()\nO(10)\n\njulia> R(x)\nx + O(10)","category":"section"},{"location":"mseries/#Basic-ring-functionality","page":"Multivariate series","title":"Basic ring functionality","text":"Once a multivariate series ring is constructed, there are various ways to construct series in that ring.\n\nThe easiest way is simply using the generators returned by the power_series_ring constructor and build up the power series using basic arithmetic, as described in the Ring interface.\n\nThe power series rings in AbstractAlgebra.jl implement the full Ring interface.\n\nWe give some examples of such functionality.\n\nnote: Note\nThe divexact function can currently only divide by unit series (i.e. whose constant coefficient is invertible).\n\nExamples\n\njulia> R, (x,) = power_series_ring(ZZ, [5], [:x])\n(Multivariate power series ring in 1 variable over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])\n\njulia> f = x^3 + 3x + 21\n21 + 3*x + x^3 + O(x^5)\n\njulia> h = zero(R)\nO(x^5)\n\njulia> k = one(R)\n1 + O(x^5)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(f)\n3\n\njulia> U = base_ring(R)\nIntegers\n\njulia> v = symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> T = parent(x + 1)\nMultivariate power series ring in 1 variable x\n  over integers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> t = divexact(f*x, 1 + x)\n21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)\n\njulia> R, (x, y) = power_series_ring(ZZ, [2, 3], 10, [:x, :y])\n(Multivariate power series ring in 2 variables over integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(10), y + O(10)])\n\njulia> f = 3x^2*y + 1\n1 + 3*y*x^2 + O(10)\n\njulia> one(R)\n1 + O(10)","category":"section"},{"location":"mseries/#Power-series-functionality-provided-by-AbstractAlgebra.jl","page":"Multivariate series","title":"Power series functionality provided by AbstractAlgebra.jl","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.","category":"section"},{"location":"mseries/#Basic-functionality","page":"Multivariate series","title":"Basic functionality","text":"The following are provided for weighted and unweighted series:\n\nThe following are only available for unweighted series.","category":"section"},{"location":"mseries/#Iteration","page":"Multivariate series","title":"Iteration","text":"","category":"section"},{"location":"mseries/#Truncation","page":"Multivariate series","title":"Truncation","text":"","category":"section"},{"location":"mseries/#Exact-division","page":"Multivariate series","title":"Exact division","text":"","category":"section"},{"location":"mseries/#Evaluation","page":"Multivariate series","title":"Evaluation","text":"","category":"section"},{"location":"mseries/#Random-generation","page":"Multivariate series","title":"Random generation","text":"","category":"section"},{"location":"mseries/#AbstractAlgebra.number_of_variables-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"AbstractAlgebra.number_of_variables","text":"number_of_variables(R::AbsMSeriesRing)\n\nReturn the number of variables in the series ring.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.symbols-Tuple{AbstractAlgebra.MSeriesRing}","page":"Multivariate series","title":"AbstractAlgebra.symbols","text":"symbols(R::MSeriesRing)\n\nReturn a vector of symbols, one for each of the variables of the series ring R.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"Base.precision","text":"precision(a::AbsMSeries)\n\nReturn a vector of precisions, one for each variable in the series ring. If the ring is weighted the weighted precision is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}","page":"Multivariate series","title":"AbstractAlgebra.coeff","text":"coeff(a::AbsMSeries, n::Int)\n\nReturn the coefficient of the n-th nonzero term of the series (or zero if there are fewer than n nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}","page":"Multivariate series","title":"AbstractAlgebra.gen","text":"gen(R::AbsMSeriesRing, i::Int)\n\nReturn the i-th generator (variable) of the series ring R. Numbering starts from 1 for the most significant variable.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"AbstractAlgebra.gens","text":"gens(R::AbsMSeriesRing)\n\nReturn a vector of the generators (variables) of the series ring R, starting with the most significant.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.is_gen-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"AbstractAlgebra.is_gen","text":"is_gen(a::AbsMSeries)\n\nReturn true if the series a is a generator of its parent series ring.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.is_unit-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"AbstractAlgebra.is_unit","text":"is_unit(a::AbsMSeries)\n\nReturn true if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"Base.length","text":"length(a::AbsMSeries)\n\nReturn the number of nonzero terms in the series a.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"AbstractAlgebra.max_precision","text":"max_precision(R::AbsMSeriesRing)\n\nReturn a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"AbstractAlgebra.valuation","text":"valuation(a::AbsMSeries)\n\nReturn the valuation of a as a vector of integers, one for each variable.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"AbstractAlgebra.coefficients","text":"coefficients(a::AbsMSeries)\n\nReturn an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"AbstractAlgebra.exponent_vectors","text":"exponent_vectors(a::AbsMSeries)\n\nReturn an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}","page":"Multivariate series","title":"Base.truncate","text":"truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})\n\nReturn a truncated to (absolute) precisions given by the vector prec.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}","page":"Multivariate series","title":"Base.truncate","text":"truncate(a::AbstractAlgebra.AbsMSeries, prec::Int)\n\nReturn a truncated to precision prec. This either truncates by weight in the weighted cases or truncates each variable to precision prec in the unweighted case.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S<:MPolyRingElem{T}, AbstractAlgebra.Generic.AbsMSeries{T, S} where S<:MPolyRingElem{T}}} where T<:RingElem","page":"Multivariate series","title":"AbstractAlgebra.divexact","text":"divexact(x::AbsMSeries{T}, y::AbsMSeries{T}; check::Bool=true) where T <: RingElement\n\nReturn the exact quotient of the series x by the series y. This function currently assumes y is an invertible series.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S<:MPolyRingElem{T})}","page":"Multivariate series","title":"AbstractAlgebra.evaluate","text":"evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The values must be in the same ring as a.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S<:MPolyRingElem{T})}","page":"Multivariate series","title":"AbstractAlgebra.evaluate","text":"evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables given by the array vars. The values must be in the same ring as a.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S<:MPolyRingElem{T})}","page":"Multivariate series","title":"AbstractAlgebra.evaluate","text":"evaluate(a::U, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the variables the series ring to which a belongs. The values must be in the same ring as a.\n\n\n\n\n\n","category":"method"},{"location":"mseries/#Base.rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any}}","page":"Multivariate series","title":"Base.rand","text":"rand(S::MSeriesRing, term_range, v...)\n\nReturn a random element of the series ring S with number of terms in the range given by term_range and where coefficients of the series are randomly generated in the base ring using the data given by v. The exponents of the variable in the terms will be less than the precision caps for the Ring S when it was created.\n\n\n\n\n\n","category":"method"},{"location":"matrix_implementation/#Matrix-implementation","page":"Matrix implementation","title":"Matrix implementation","text":"AbstractAlgebra.jl provides a module, implemented in src/Matrix.jl for matrices over any ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any matrix type which follows the Matrix interface.\n\nSimilarly, AbstractAlgebra.jl provides a module in src/MatRing.jl for matrix algebras over a ring.","category":"section"},{"location":"matrix_implementation/#Generic-matrix-types","page":"Matrix implementation","title":"Generic matrix types","text":"AbstractAlgebra.jl allows the creation of dense matrices over any computable ring R. Generic matrices over a ring are implemented in src/generic/Matrix.jl.\n\nGeneric matrix rings of mtimes m matrices are implemented in src/generic/MatRing.jl.\n\nGeneric matrices in AbstractAlgebra.jl have type Generic.MatSpaceElem{T} for matrices in a matrix space, or Generic.MatRingElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.\n\nFor the most part, one doesn't want to work directly with the MatSpaceElem type though, but with an abstract type called Generic.Mat which includes MatSpaceElem and views thereof.\n\nParents of generic matrices (matrix spaces) have type MatSpace{T}. Parents of matrices in a matrix algebra have type Generic.MatRing{T}.\n\nThe dimensions and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"section"},{"location":"matrix_implementation/#Abstract-types","page":"Matrix implementation","title":"Abstract types","text":"The generic matrix types (matrix spaces) belong to the abstract type MatElem{T} and the all matrix space parents are of the concrete type MatSpace{T}. On the other hand, the generic matrix algebra matrix types belong to the abstract type MatRingElem{T} and the parent types belong to the abstract  MatRing{T} Note that both the concrete type of a matrix space parent object and the abstract class it belongs to have the name MatElem, therefore disambiguation is required to specify which is intended. The same is true for the abstract types for matrix spaces and their elements.","category":"section"},{"location":"matrix_implementation/#Conversion-to-Julia-matrices,-iteration-and-broadcasting","page":"Matrix implementation","title":"Conversion to Julia matrices, iteration and broadcasting","text":"While AbstractAlgebra matrices are not instances of AbstractArray, they are closely related to Julia matrices. For convenience, a Matrix and an Array constructors taking an AbstractAlgebra matrix as input are provided:\n\nMatrices also support iteration, and therefore functions accepting an iterator can be called on them, e.g.:\n\njulia> M = matrix_space(ZZ, 2, 3); x = M(1:6)\n[1   2   3]\n[4   5   6]\n\njulia> collect(x)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\njulia> Set(x)\nSet{BigInt} with 6 elements:\n  5\n  4\n  6\n  2\n  3\n  1\n\nMatrices also support broadcasting, which amounts to elementwise application of functions to matrices:\n\njulia> k = GF(5);\n\njulia> A = ZZ[1 2; 3 4];\n\njulia> k.(A)\n[1   2]\n[3   4]\n\njulia> 3 .* A .+ 2\n[ 5    8]\n[11   14]\n\njulia> B = ZZ[3 4; 5 6];\n\njulia> ((x, y) -> x^2 + y^2).(A, B)\n[10   20]\n[34   52]\n\njulia> R, t = polynomial_ring(QQ, :t)\n(Univariate polynomial ring in t over rationals, t)\n\njulia> T = dense_matrix_type(R)\nAbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}","category":"section"},{"location":"matrix_implementation/#Base.Matrix-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix implementation","title":"Base.Matrix","text":"Matrix(A::MatrixElem{T}) where {T<:NCRingElement}\nMatrix{U}(A::MatrixElem{T}) where {U<:NCRingElement, T<:NCRingElement}\n\nConvert A to a Julia Matrix{U} of the same dimensions with the same elements. If U is omitted then eltype(M) is used in its place.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> Matrix(A)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\njulia> Matrix{Int}(A)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"method"},{"location":"matrix_implementation/#Core.Array-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix implementation","title":"Core.Array","text":"Array(A::MatrixElem{T}) where T <: NCRingElement\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> R, x = ZZ[:x]; A = R[x^0 x^1; x^2 x^3]\n[  1     x]\n[x^2   x^3]\n\njulia> Array(A)\n2×2 Matrix{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1    x\n x^2  x^3\n\n\n\n\n\n","category":"method"},{"location":"matrix_implementation/#AbstractAlgebra.dense_matrix_type-Tuple{Ring}","page":"Matrix implementation","title":"AbstractAlgebra.dense_matrix_type","text":"dense_matrix_type(::Type{T}) where T<:NCRingElement\ndense_matrix_type(::T) where T<:NCRingElement\ndense_matrix_type(::Type{S}) where S<:NCRing\ndense_matrix_type(::S) where S<:NCRing\n\nReturn the type of matrices with coefficients of type T respectively elem_type(S).\n\nImplementations of the ring interface only need to provide a method for the argument a subtype of NCRingElement; the other variants are implemented by calling that method.\n\n\n\n\n\n","category":"method"},{"location":"laurent_polynomial/#Generic-Laurent-polynomials","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Laurent polynomials are similar to polynomials but can have terms of negative degrees, and form a ring denoted by Rx x^-1 where R is the coefficient ring.","category":"section"},{"location":"laurent_polynomial/#Generic-Laurent-polynomial-types","page":"Generic Laurent polynomials","title":"Generic Laurent polynomial types","text":"AbstractAlgebra.jl provides a generic implementation of Laurent polynomials, built in terms of regular polynomials in the file src/generic/LaurentPoly.jl.\n\nThe type LaurentPolyWrap{T, ...} <: LaurentPolyRingElem{T} implements generic Laurent polynomials by wrapping regular polynomials: a Laurent polynomial l wraps a polynomial p and an integer n such that l = x^-n * p.\n\nThe corresponding parent type is LaurentPolyWrapRing{T, ...} <: LaurentPolyRing{T}.","category":"section"},{"location":"laurent_polynomial/#Abstract-types","page":"Generic Laurent polynomials","title":"Abstract types","text":"Two abstract types LaurentPolyRingElem{T} and LaurentPolyRing{T} are defined to represent Laurent polynomials and rings thereof, parameterized on a base ring T.","category":"section"},{"location":"laurent_polynomial/#Laurent-polynomials-ring-constructor","page":"Generic Laurent polynomials","title":"Laurent polynomials ring constructor","text":"In order to instantiate Laurent polynomials, one must first construct the parent ring:","category":"section"},{"location":"laurent_polynomial/#Basic-functionality","page":"Generic Laurent polynomials","title":"Basic functionality","text":"Laurent polynomials implement the ring interface, and some methods from the polynomial interface, for example:\n\njulia> R, x = laurent_polynomial_ring(ZZ, :x)\n(Univariate Laurent polynomial ring in x over integers, x)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> number_of_variables(R)\n1\n\njulia> f = x^-2 + 2x\n2*x + x^-2\n\njulia> coeff.(f, -2:2)\n5-element Vector{BigInt}:\n 1\n 0\n 0\n 2\n 0\n\njulia> set_coefficient!(f, 3, ZZ(5))\n5*x^3 + 2*x + x^-2\n\njulia> is_gen(f)\nfalse\n\njulia> shift_left(f,2)\n5*x^5 + 2*x^3 + 1\n\njulia> map_coefficients(x->2x, f)\n10*x^3 + 4*x + 2*x^-2\n\njulia> change_base_ring(RealField, f)\n5.0*x^3 + 2.0*x + x^-2\n\njulia> leading_coefficient(f), trailing_coefficient(f)\n(5, 1)","category":"section"},{"location":"laurent_polynomial/#AbstractAlgebra.laurent_polynomial_ring","page":"Generic Laurent polynomials","title":"AbstractAlgebra.laurent_polynomial_ring","text":"laurent_polynomial_ring(R::Ring, s::VarName)\n\nGiven a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new Laurent polynomial ring S = Rx 1x and the generator x of the ring.\n\nExamples\n\njulia> R, x = laurent_polynomial_ring(ZZ, :x)\n(Univariate Laurent Polynomial Ring in x over Integers, x)\n\njulia> 2x^-3 + x^2\nx^2 + 2*x^-3\n\njulia> rand(R, -3:3, -9:9)\n-3*x^2 - 8*x + 4 + 3*x^-1 - 6*x^-2 + 9*x^-3\n\n\n\n\n\nlaurent_polynomial_ring(R::Ring, varnames...; cached::Bool = true)\n\nGiven a base ring R and variable names varnames..., say :x, :y, :z, return a tuple S, x, y, z representing the new ring S = Rx 1x y 1y z 1z and the generators x y z of the ring.\n\nBy default (cached=true), the output S will be cached, i.e. if laurent_polynomial_ring is invoked again with the same arguments, the same (identical) ring is returned. Setting cached to false ensures a distinct new ring is returned, and will also prevent it from being cached.\n\nFor information about the many ways to specify varnames... refer to polynomial_ring or the specification in AbstractAlgebra.@varnames_interface.\n\n\n\n\n\n","category":"function"},{"location":"ring_interface/#Ring-Interface","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their rings.\n\nIn addition to the required functions, there are also optional functions which can be provided for certain types of rings, e.g. GCD domains or fields, etc. If implemented, these allow the generic code to provide additional functionality for those rings, or in some cases, to select more efficient algorithms.","category":"section"},{"location":"ring_interface/#Types","page":"Ring Interface","title":"Types","text":"Most rings must supply two types:\n\na type for the parent object (representing the ring itself)\na type for elements of that ring\n\nFor example, the generic univariate polynomial type in AbstractAlgebra.jl provides two types in generic/GenericTypes.jl:\n\nGeneric.PolyRing{T} for the parent objects\nGeneric.Poly{T} for the actual polynomials\n\nThe parent type must belong to Ring and the element type must belong to RingElem. Of course, the types may belong to these abstract types transitively, e.g. Poly{T} actually belongs to PolyRingElem{T} which in turn belongs to RingElem.\n\nFor parameterised rings, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring (see the function base_ring below for a definition).\n\nThere can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"section"},{"location":"ring_interface/#RingElement-type-union","page":"Ring Interface","title":"RingElement type union","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to RingElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of rings we define a union type RingElement in src/julia/JuliaTypes.\n\nSo far, in addition to RingElem the  union type RingElement includes the Julia types Integer, Rational and AbstractFloat.\n\nMost of the generic code in AbstractAlgebra makes use of the union type RingElement instead of RingElem so that the generic functions also accept the Julia Base ring types.\n\nnote: Note\nOne must be careful when defining ad hoc binary operations for ring element types. It is often necessary to define separate versions of the functions for RingElem then for each of the Julia types separately in order to avoid ambiguity warnings.\n\nNote that even though RingElement is a union type we still have the following inclusion\n\nRingElement <: NCRingElement","category":"section"},{"location":"ring_interface/#Parent-object-caches","page":"Ring Interface","title":"Parent object caches","text":"In many cases, it is desirable to have only one object in the system to represent each ring. This means that if the same ring is constructed twice, elements of the two rings will be compatible as far as arithmetic is concerned.\n\nIn order to facilitate this, global caches of rings are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.PolyRing parent objects are looked up in a dictionary PolyID to see if they have been previously defined.\n\nWhether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two rings are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two rings if they were constructed from identical data.\n\nIf a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See src/generic/GenericTypes.jl for examples of how to construct and handle such caches.","category":"section"},{"location":"ring_interface/#Required-functions-for-all-rings","page":"Ring Interface","title":"Required functions for all rings","text":"In the following, we list all the functions that are required to be provided for rings in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.\n\nWe give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.\n\nnote: Note\nGeneric functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for rings that implement that additional functionality, and should be documented as such.","category":"section"},{"location":"ring_interface/#Data-type-and-parent-object-methods","page":"Ring Interface","title":"Data type and parent object methods","text":"parent_type(::Type{MyElem})\n\nReturn the type of the corresponding parent object for the given element type. For example, parent_type(Generic.Poly{T}) will return Generic.PolyRing{T}.\n\nelem_type(::Type{MyParent})\n\nReturn the type of the elements of the ring whose parent object has the given type. This is the inverse of the parent_type function, i.e. elem_type(Generic.PolyRing{T}) will return Generic.Poly{T}.\n\nbase_ring_type(::Type{MyParent})\n\nReturn the type of the of base rings for parent objects with the given parent type. For example, base_ring_type(Generic.PolyRing{T}) will return parent_type(T).\n\nIf the rings of this type are not parameterised by another ring, this function must return Union{}.\n\nbase_ring(R::MyParent)\n\nGiven a parent object R, representing a ring, this function returns the parent object of any base ring that parameterises this ring. For example, the base ring of the ring of polynomials over the integers would be the integer ring.\n\nIf the ring is not parameterised by another ring, calling this function should rais an error.\n\nnote: Note\nThere is a distinction between a base ring and other kinds of parameters. For example, in the ring mathbbZnmathbbZ, the modulus n is a parameter, but the only base ring is mathbbZ. We consider the ring mathbbZnmathbbZ to have been constructed from the base ring mathbbZ by taking its quotient by a (principal) ideal.There is no general mathematical definition for base ring, so to know what base_ring does for any given type of ring, you need to consult its documentation.\n\nparent(f::MyElem)\n\nReturn the parent object of the given element, i.e. return the ring to which the given element belongs.\n\nThis is usually stored in a field parent in each ring element. (If the parent objects have mutable struct types, the internal overhead here is just an additional machine pointer stored in each element of the ring.)\n\nFor some element types it isn't necessary to append the parent object as a field of every element. This is the case when the parent object can be reconstructed just given the type of the elements. For example, this is the case for the ring of integers and in fact for any ring element type that isn't parameterised or generic in any way.\n\nis_domain_type(::Type{MyElem})\n\nReturn true if every element of the given element type (which may be parameterised or an abstract type) necessarily has a parent that is an integral domain, otherwise if this cannot be guaranteed, the function returns false.\n\nFor example, if MyElem was the type of elements of generic residue rings of a polynomial ring, the answer to the question would depend on the modulus of the residue ring. Therefore is_domain_type would have to return false, since we cannot guarantee that we are dealing with elements of an integral domain in general. But if the given element type was for rational integers, the answer would be true, since every rational integer has as parent the ring of rational integers, which is an integral domain.\n\nNote that this function depends only on the type of an element and cannot access information about the object itself, or its parent.\n\nis_exact_type(::Type{MyElem})\n\nReturn true if every element of the given type is represented exactly. For example, p-adic numbers, real and complex floating point numbers and power series are not exact, as we can only represent them in general with finite truncations. Similarly polynomials and matrices over inexact element types are themselves inexact.\n\nIntegers, rationals, finite fields and polynomials and matrices over them are always exact.\n\nNote that MyElem may be parameterised or an abstract type, in which case every element of every type represented by MyElem must be exact, otherwise the function must return false.\n\nBase.hash(f::MyElem, h::UInt)\n\nReturn a hash for the object f of type UInt. This is used as a hopefully cheap way to distinguish objects that differ arithmetically.\n\nIf the object has components, e.g. the coefficients of a polynomial or elements of a matrix, these should be hashed recursively, passing the same parameter h to all levels. Each component should then be xor'd with h before combining the individual component hashes to give the final hash.\n\nThe hash functions in AbstractAlgebra.jl usually start from some fixed 64 bit hexadecimal  value that has been picked at random by the library author for that type. That is then truncated to fit a UInt (in case the latter is not 64 bits). This ensures that objects that are the same arithmetically (or that have the same components), but have different types (or structures), are unlikely to hash to the same value.\n\ndeepcopy_internal(f::MyElem, dict::IdDict)\n\nReturn a copy of the given element, recursively copying all components of the object.\n\nObviously the parent, if it is stored in the element, should not be copied. The new element should have precisely the same parent as the old object.\n\nFor types that cannot self-reference themselves anywhere internally, the dict argument may be ignored.\n\nIn the case that internal self-references are possible, please consult the Julia documentation on how to implement deepcopy_internal.","category":"section"},{"location":"ring_interface/#Constructors","page":"Ring Interface","title":"Constructors","text":"Outer constructors for most AbstractAlgebra types are provided by overloading the call syntax for parent objects.\n\nIf R is a parent object for a given ring we require the following constructors.\n\n(R::MyParent)()\n\nReturn the zero object of the given ring.\n\n(R::MyParent)(a::Integer)\n\nCoerce the given integer into the given ring.\n\n(R::MyParent)(a::MyElem)\n\nIf a belongs to the given ring, the function returns it (without making a copy). Otherwise an error is thrown.\n\nFor parameterised rings we also require a function to coerce from the base ring into the parent ring.\n\n(R::MyParent{T})(a::T) where T <: RingElem\n\nCoerce a into the ring R if a belongs to the base ring of R.","category":"section"},{"location":"ring_interface/#Basic-manipulation-of-rings-and-elements","page":"Ring Interface","title":"Basic manipulation of rings and elements","text":"zero(R::MyParent)\n\nReturn the zero element of the given ring.\n\none(R::MyParent)\n\nReturn the multiplicative identity of the given ring.\n\niszero(f::MyElem)\n\nReturn true if the given element is the zero element of the ring it belongs to.\n\nisone(f::MyElem)\n\nReturn true if the given element is the multiplicative identity of the ring it belongs to.","category":"section"},{"location":"ring_interface/#Canonicalisation","page":"Ring Interface","title":"Canonicalisation","text":"canonical_unit(f::MyElem)\n\nWhen fractions are created with two elements of the given type, it is nice to be able to represent them in some kind of canonical form. This is of course not always possible. But for example, fractions of integers can be canonicalised by first removing any common factors of the numerator and denominator, then making the denominator positive.\n\nIn AbstractAlgebra.jl, the denominator would be made positive by dividing both the numerator and denominator by the canonical unit of the denominator. For a negative denominator, this would be -1.\n\nFor non-zero elements of a field, canonical_unit simply returns the element itself. In general, canonical_unit of an invertible element should be that element. Finally, if a = bc, then canonical_unit(a)*a = canonical_unit(b)*canonical_unit(c)*a holds. Thus if a is not a zero-divisor, then we even have canonical_unit(a) = canonical_unit(b)*canonical_unit(c).\n\nFor some rings, it is completely impractical to implement this function, in which case it may return 1 in the given ring. The function must however always exist, and always return an element of the ring.","category":"section"},{"location":"ring_interface/#String-I/O","page":"Ring Interface","title":"String I/O","text":"show(io::IO, R::MyParent)\n\nThis should print an English description of the parent ring (to the given IO object). If the ring is parameterised, it can call the corresponding show function for any rings it depends on.\n\nshow(io::IO, f::MyElem)\n\nThis should print a human readable, textual representation of the object (to the given IO object). It can recursively call the corresponding show functions for any of its components.","category":"section"},{"location":"ring_interface/#Expressions","page":"Ring Interface","title":"Expressions","text":"To obtain best results when printing composed types derived from other types, e.g., polynomials, the following method should be implemented.\n\nexpressify(f::MyElem; context = nothing)\n\nwhich must return either Expr, Symbol, Integer or String.\n\nFor a type which implements  expressify, one can automatically derive show methods supporting output as plain text, LaTeX and html by using the following:\n\n@enable_all_show_via_expressify MyElem\n\nThis defines the following show methods for the specified type MyElem:\n\nfunction Base.show(io::IO, a::MyElem)\n  show_via_expressify(io, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/plain\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/latex\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/html\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nAs an example, assume that an object f of type MyElem has two components f.a and f.b of integer type, which should be printed as a^b, this can be implemented as\n\nexpressify(f::MyElem; context = nothing) = Expr(:call, :^, f.a, f.b)\n\nIf f.a and f.b themselves are objects that can be expressified, this can be implemented as\n\nfunction expressify(f::MyElem; context = nothing)\n  return Expr(:call, :^, expressify(f.a, context = context),\n                         expressify(f.b, context = context))\nend\n\nAs noted above, expressify should return an Expr, Symbol, Integer or String. The rendering of such expressions with a particular MIME type to an output context is controlled by the following rules which are subject to change slightly in future versions of AbstracAlgebra.\n\nInteger: The printing of integers is straightforward and automatically includes transformations such as 1 + (-2)*x => 1 - 2*x as this is cumbersome to implement per-type.\n\nSymbol: Since variable names are stored as mere symbols in AbstractAlgebra, some transformations related to subscripts are applied to symbols automatically in latex output. The \\operatorname{ in the following table is actually replaced with the more portable \\mathop{\\mathrm{.\n\nexpressify latex output\nSymbol(\"a\") a\nSymbol(\"α\") {\\alpha}\nSymbol(\"x1\") \\operatorname{x1}\nSymbol(\"xy_1\") \\operatorname{xy}_{1}\nSymbol(\"sin\") \\operatorname{sin}\nSymbol(\"sin_cos\") \\operatorname{sin\\_cos}\nSymbol(\"sin_1\") \\operatorname{sin}_{1}\nSymbol(\"sin_cos_1\") \\operatorname{sin\\_cos}_{1}\nSymbol(\"αaβb_1_2\") \\operatorname{{\\alpha}a{\\beta}b}_{1,2}\n\nExpr: These are the most versatile as the Expr objects themselves contain a symbolic head and any number of arguments. What looks like f(a,b) in textual output is Expr(:call, :f, :a, :b) under the hood. AbstractAlgebra currently contains the following printing rules for such expressions.\n\nexpressify output latex notes\nExpr(:call, :+, a, b) a + b \nExpr(:call, :*, a, b) a*b one space for implied multiplication\nExpr(:call, :cdot, a, b) a * b a real \\cdot is used\nExpr(:call, :^, a, b) a^b may include some courtesy parentheses\nExpr(:call, ://, a, b) a//b will create a fraction box\nExpr(:call, :/, a, b) a/b will not create a fraction box\nExpr(:call, a, b, c) a(b, c) \nExpr(:ref, a, b, c) a[b, c] \nExpr(:vcat, a, b) [a; b] actually vertical\nExpr(:vect, a, b) [a, b] \nExpr(:tuple, a, b) (a, b) \nExpr(:list, a, b) {a, b} \nExpr(:series, a, b) a, b \nExpr(:sequence, a, b) ab \nExpr(:row, a, b) a b combine with :vcat to make matrices\nExpr(:hcat, a, b) a b \n\nString: Strings are printed verbatim and should only be used as a last resort as they provide absolutely no precedence information on their contents.","category":"section"},{"location":"ring_interface/#Unary-operations","page":"Ring Interface","title":"Unary operations","text":"-(f::MyElem)\n\nReturn -f.","category":"section"},{"location":"ring_interface/#Binary-operations","page":"Ring Interface","title":"Binary operations","text":"+(f::MyElem, g::MyElem)\n-(f::MyElem, g::MyElem)\n*(f::MyElem, g::MyElem)\n\nReturn f + g, f - g or fg, respectively.","category":"section"},{"location":"ring_interface/#Comparison","page":"Ring Interface","title":"Comparison","text":"==(f::MyElem, g::MyElem)\n\nReturn true if f and g are arithmetically equal. In the case where the two elements are inexact, the function returns true if they agree to the minimum precision of the two.\n\nisequal(f::MyElem, g::MyElem)\n\nFor exact rings, this should return the same thing as == above. For inexact rings, this returns true only if the two elements are arithmetically equal and have the same precision.","category":"section"},{"location":"ring_interface/#Powering","page":"Ring Interface","title":"Powering","text":"^(f::MyElem, e::Int)\n\nReturn f^e. The function should throw a DomainError() if negative exponents don't make sense but are passed to the function.","category":"section"},{"location":"ring_interface/#Exact-division","page":"Ring Interface","title":"Exact division","text":"divexact(f::MyElem, g::MyElem; check::Bool=true)\n\nReturn fg, though note that Julia uses / for floating point division. Here we mean exact division in the ring, i.e. return q such that f = gq. A DivideError() should be thrown if g is zero.\n\nIf check=true the function should check that the division is exact and throw an exception if not.\n\nIf check=false the check may be omitted for performance reasons. The behaviour is then undefined if a division is performed that is not exact. This may include throwing an exception, returning meaningless results, hanging or crashing. The function should only be called with check=false if it is already known that the division will be exact.","category":"section"},{"location":"ring_interface/#Inverse","page":"Ring Interface","title":"Inverse","text":"inv(f::MyElem)\n\nReturn the inverse of f, i.e. 1f, though note that Julia uses / for floating point division. Here we mean exact division in the ring.\n\nA fallback for this function is provided in terms of divexact so an implementation can be omitted if preferred.","category":"section"},{"location":"ring_interface/#Random-generation","page":"Ring Interface","title":"Random generation","text":"The random functions are only used for test code to generate test data. They therefore don't need to provide any guarantees on uniformity, and in fact, test values that are known to be a good source of corner cases can be supplied.\n\nrand(R::MyParent, v...)\n\nReturn a random element in the given ring of the specified size.\n\nThere can be as many arguments as is necessary to specify the size of the test example which is being produced.","category":"section"},{"location":"ring_interface/#Promotion-rules","page":"Ring Interface","title":"Promotion rules","text":"AbstractAlgebra currently has a very simple coercion model. With few exceptions only simple coercions are supported. For example if x in mathbbZ and y in mathbbZx then x + y can be computed by coercing x into the same ring as y and then adding in that ring.\n\nComplex coercions such as adding elements of mathbbQ and mathbbZx are not supported, as this would require finding and creating a common overring in which the elements could be added.\n\nAbstractAlgebra supports simple coercions by overloading parent object call syntax R(x) to coerce the object x into the ring R. However, to coerce elements up a tower of rings, one needs to also have a promotion system similar to Julia's type promotion system.\n\nAs for Julia, AbstractAlgebra's promotion system only specifies what happens to types. It is the coercions themselves that must deal with the mathematical situation at the level of rings, including checking that the object can even be coerced into the given ring.\n\nWe now describe the required AbstractAlgebra type promotion rules.\n\nFor every ring, one wants to be able to coerce integers into the ring. And for any ring constructed over a base ring, one would like to be able to coerce from the base ring into the ring.\n\nThe required promotion rules to support this look a bit different depending on whether the element type is parameterised or not and whether it is built on a base ring.\n\nFor ring element types MyElem that are neither parameterised nor built over a base ring, the promotion rules can be defined as follows:\n\npromote_rule(::Type{MyElem}, ::Type{T}) where {T <: Integer} = MyElem\n\nFor ring element types MyElem that aren't parameterised, but which have a base ring with concrete element type T the promotion rules can be defined as follows:\n\npromote_rule(::Type{MyElem}, ::Type{U}) where U <: Integer = MyElem\n\npromote_rule(::Type{MyElem}, ::Type{T}) = MyElem\n\nFor ring element types MyElem{T} that are parameterised by the type of elements of the base ring, the promotion rules can be defined as follows:\n\npromote_rule(::Type{MyElem{T}}, ::Type{MyElem{T}}) where T <: RingElement = MyElem{T}\n\nfunction promote_rule(::Type{MyElem{T}}, ::Type{U}) where {T <: RingElement, U <: RingElement}\n   promote_rule(T, U) == T ? MyElem{T} : Union{}\nend","category":"section"},{"location":"ring_interface/#Required-functionality-for-inexact-rings","page":"Ring Interface","title":"Required functionality for inexact rings","text":"","category":"section"},{"location":"ring_interface/#Approximation-(floating-point-and-ball-arithmetic-only)","page":"Ring Interface","title":"Approximation (floating point and ball arithmetic only)","text":"isapprox(f::MyElem, g::MyElem; atol::Real=sqrt(eps()))\n\nThis is used by test code that uses rings involving floating point or ball arithmetic. The function should return true if all components of f and g are equal to within the square root of the Julia epsilon, since numerical noise may make an exact comparison impossible.\n\nFor parameterised rings over an inexact ring, we also require the following ad hoc approximation functionality.\n\nisapprox(f::MyElem{T}, g::T; atol::Real=sqrt(eps())) where T <: RingElem\n\nisapprox(f::T, g::MyElem{T}; atol::Real=sqrt(eps())) where T <: RingElem\n\nThese notionally coerce the element of the base ring into the parameterised ring and do a full comparison.","category":"section"},{"location":"ring_interface/#Optional-functionality","page":"Ring Interface","title":"Optional functionality","text":"Some functionality is difficult or impossible to implement for all rings in the system. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can't be relied on by generic functions in the AbstractAlgebra Ring interface.\n\nIt may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn't exist.","category":"section"},{"location":"ring_interface/#Optional-unsafe-operators","page":"Ring Interface","title":"Optional unsafe operators","text":"The various operators described in Unsafe ring operators such as add! and mul! have default implementations which are not faster than their regular safe counterparts. Implementors may wish to implement some or all of them for their rings. Note that in general only the variants with the most arguments needs to be implemented. E.g. for add! only add(z,a,b) has to be implemented for any new ring type, as add!(a,b) delegates to add!(a,a,b).","category":"section"},{"location":"ring_interface/#Optional-basic-manipulation-functionality","page":"Ring Interface","title":"Optional basic manipulation functionality","text":"is_unit(f::MyElem)\n\nReturn true if the given element is a unit in the ring it belongs to.\n\nis_zero_divisor(f::MyElem)\n\nReturn true if the given element is a zero divisor in the ring it belongs to. When this function does not exist for a given ring then the total ring of fractions may not be usable over that ring. All fields in the system have a fallback defined for this function.\n\ncharacteristic(R::MyParent)\n\nReturn the characteristic of the ring. The function should not be defined if it is not possible to unconditionally give the characteristic. AbstractAlgebra will raise an exception is such cases.","category":"section"},{"location":"ring_interface/#Optional-binary-ad-hoc-operators","page":"Ring Interface","title":"Optional binary ad hoc operators","text":"By default, ad hoc operations are handled by AbstractAlgebra.jl if they are not defined explicitly, by coercing both operands into the same ring and then performing the required operation.\n\nIn some cases, e.g. for matrices, this leads to very inefficient behaviour. In such cases, it is advised to implement some of these operators explicitly.\n\nIt can occasionally be worth adding a separate set of ad hoc binary operators for the type Int, if this can be done more efficiently than for arbitrary Julia Integer types.\n\n+(f::MyElem, c::Integer)\n-(f::MyElem, c::Integer)\n*(f::MyElem, c::Integer)\n\n+(c::Integer, f::MyElem)\n-(c::Integer, f::MyElem)\n*(c::Integer, f::MyElem)\n\nFor parameterised types, it is also sometimes more performant to provide explicit ad hoc operators with elements of the base ring.\n\n+(f::MyElem{T}, c::T) where T <: RingElem\n-(f::MyElem{T}, c::T) where T <: RingElem\n*(f::MyElem{T}, c::T) where T <: RingElem\n\n+(c::T, f::MyElem{T}) where T <: RingElem\n-(c::T, f::MyElem{T}) where T <: RingElem\n*(c::T, f::MyElem{T}) where T <: RingElem","category":"section"},{"location":"ring_interface/#Optional-ad-hoc-comparisons","page":"Ring Interface","title":"Optional ad hoc comparisons","text":"==(f::MyElem, c::Integer)\n\n==(c::Integer, f::MyElem)\n\n==(f::MyElem{T}, c:T) where T <: RingElem\n\n==(c::T, f::MyElem{T}) where T <: RingElem","category":"section"},{"location":"ring_interface/#Optional-ad-hoc-exact-division-functions","page":"Ring Interface","title":"Optional ad hoc exact division functions","text":"divexact(a::MyElem{T}, b::T) where T <: RingElem\n\ndivexact(a::MyElem, b::Integer)","category":"section"},{"location":"ring_interface/#Optional-powering-functions","page":"Ring Interface","title":"Optional powering functions","text":"^(f::MyElem, e::BigInt)\n\nIn case f cannot explode in size when powered by a very large integer, and it is practical to do so, one may provide this function to support powering with BigInt exponents (or for external modules, any other big integer type).","category":"section"},{"location":"ring_interface/#Optional-unsafe-operators-2","page":"Ring Interface","title":"Optional unsafe operators","text":"addmul!(c::MyElem, a::MyElem, b::MyElem, t::MyElem)\n\nSet c = c + ab in-place. Return the mutated value. The value t should be a temporary of the same type as a, b and c, which can be used arbitrarily by the implementation to speed up the computation. Aliasing between a, b and c is permitted.","category":"section"},{"location":"ring_interface/#Minimal-example-of-ring-implementation","page":"Ring Interface","title":"Minimal example of ring implementation","text":"Here is a minimal example of implementing the Ring Interface for a constant polynomial type (i.e. polynomials of degree less than one).\n\n# ConstPoly.jl : Implements constant polynomials\n\nusing AbstractAlgebra\n\nusing Random: Random, SamplerTrivial\nusing AbstractAlgebra.RandomExtensions: RandomExtensions, Make2, AbstractRNG\n\nimport AbstractAlgebra: parent_type, elem_type, base_ring, base_ring_type, parent, is_domain_type,\n       is_exact_type, canonical_unit, isequal, divexact, zero!, mul!, add!,\n       get_cached!, is_unit, characteristic, Ring, RingElem, expressify,\n       @show_name, @show_special, is_terse, pretty, terse, Lowercase\n\nimport Base: show, +, -, *, ^, ==, inv, isone, iszero, one, zero, rand,\n             deepcopy_internal, hash\n\n@attributes mutable struct ConstPolyRing{T <: RingElement} <: Ring\n   base_ring::Ring\n\n   function ConstPolyRing{T}(R::Ring, cached::Bool) where T <: RingElement\n      return get_cached!(ConstPolyID, R, cached) do\n         new{T}(R)\n      end::ConstPolyRing{T}\n   end\nend\n\nconst ConstPolyID = AbstractAlgebra.CacheDictType{Ring, ConstPolyRing}()\n\nmutable struct ConstPoly{T <: RingElement} <: RingElem\n   c::T\n   parent::ConstPolyRing{T}\n\n   function ConstPoly{T}(c::T) where T <: RingElement\n      return new(c)\n   end\nend\n\n# Data type and parent object methods\n\nparent_type(::Type{ConstPoly{T}}) where T <: RingElement = ConstPolyRing{T}\n\nelem_type(::Type{ConstPolyRing{T}}) where T <: RingElement = ConstPoly{T}\n\nbase_ring_type(::Type{ConstPolyRing{T}}) where T <: RingElement = parent_type(T)\n\nbase_ring(R::ConstPolyRing) = R.base_ring::base_ring_type(R)\n\nparent(f::ConstPoly) = f.parent\n\nis_domain_type(::Type{ConstPoly{T}}) where T <: RingElement = is_domain_type(T)\n\nis_exact_type(::Type{ConstPoly{T}}) where T <: RingElement = is_exact_type(T)\n\nfunction hash(f::ConstPoly, h::UInt)\n   r = 0x65125ab8e0cd44ca\n   return xor(r, hash(f.c, h))\nend\n\nfunction deepcopy_internal(f::ConstPoly{T}, dict::IdDict) where T <: RingElement\n   r = ConstPoly{T}(deepcopy_internal(f.c, dict))\n   r.parent = f.parent # parent should not be deepcopied\n   return r\nend\n\n# Basic manipulation\n\nzero(R::ConstPolyRing) = R()\n\none(R::ConstPolyRing) = R(1)\n\niszero(f::ConstPoly) = iszero(f.c)\n\nisone(f::ConstPoly) = isone(f.c)\n\nis_unit(f::ConstPoly) = is_unit(f.c)\n\ncharacteristic(R::ConstPolyRing) = characteristic(base_ring(R))\n\n# Canonical unit\n\ncanonical_unit(f::ConstPoly) = canonical_unit(f.c)\n\n# String I/O\n\nfunction show(io::IO, R::ConstPolyRing)\n   @show_name(io, R)\n   @show_special(io, R)\n   print(io, \"Constant polynomials\")\n   if !is_terse(io)\n     io = pretty(io)\n     print(terse(io), \" over \", Lowercase(), base_ring(R))\n   end\nend\n\nfunction show(io::IO, f::ConstPoly)\n   print(io, f.c)\nend\n\n# Expressification (optional)\n\nfunction expressify(R::ConstPolyRing; context = nothing)\n   return Expr(:sequence, Expr(:text, \"Constant polynomials over \"),\n                          expressify(base_ring(R), context = context))\nend\n\nfunction expressify(f::ConstPoly; context = nothing)\n   return expressify(f.c, context = context)\nend\n\n# Unary operations\n\nfunction -(f::ConstPoly)\n   R = parent(f)\n   return R(-f.c)\nend\n\n# Binary operations\n\nfunction +(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   check_parent(f, g)\n   R = parent(f)\n   return R(f.c + g.c)\nend\n\nfunction -(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   check_parent(f, g)\n   R = parent(f)\n   return R(f.c - g.c)\nend\n\nfunction *(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   check_parent(f, g)\n   R = parent(f)\n   return R(f.c*g.c)\nend\n\n# Comparison\n\nfunction ==(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   check_parent(f, g)\n   return f.c == g.c\nend\n\nfunction isequal(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   check_parent(f, g)\n   return isequal(f.c, g.c)\nend\n\n# Powering need not be implemented if * is\n\n# Exact division\n\nfunction divexact(f::ConstPoly{T}, g::ConstPoly{T}; check::Bool = true) where T <: RingElement\n   check_parent(f, g)\n   R = parent(f)\n   return R(divexact(f.c, g.c, check = check))\nend\n\n# Inverse\n\nfunction inv(f::ConstPoly)\n   R = parent(f)\n   return R(AbstractAlgebra.inv(f.c))\nend\n\n# Unsafe operators\n\nfunction zero!(f::ConstPoly)\n   f.c = zero(base_ring(parent(f)))\n   return f\nend\n\nfunction one!(f::ConstPoly)\n   f.c = one(base_ring(parent(f)))\n   return f\nend\n\nfunction mul!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T <: RingElement\n   f.c = g.c*h.c\n   return f\nend\n\nfunction add!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T <: RingElement\n   f.c = g.c + h.c\n   return f\nend\n\n# Random generation\n\nRandomExtensions.maketype(R::ConstPolyRing, _) = elem_type(R)\n\nrand(rng::AbstractRNG, sp::SamplerTrivial{<:Make2{ConstPoly,ConstPolyRing}}) =\n        sp[][1](rand(rng, sp[][2]))\n\nrand(rng::AbstractRNG, R::ConstPolyRing, n::AbstractUnitRange{Int}) = R(rand(rng, n))\n\nrand(R::ConstPolyRing, n::AbstractUnitRange{Int}) = rand(Random.default_rng(), R, n)\n\n# Promotion rules\n\npromote_rule(::Type{ConstPoly{T}}, ::Type{ConstPoly{T}}) where T <: RingElement = ConstPoly{T}\n\nfunction promote_rule(::Type{ConstPoly{T}}, ::Type{U}) where {T <: RingElement, U <: RingElement}\n   promote_rule(T, U) == T ? ConstPoly{T} : Union{}\nend\n\n# Constructors\n\nfunction (R::ConstPolyRing{T})() where T <: RingElement\n   r = ConstPoly{T}(base_ring(R)(0))\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(c::Integer) where T <: RingElement\n   r = ConstPoly{T}(base_ring(R)(c))\n   r.parent = R\n   return r\nend\n\n# Needed to prevent ambiguity\nfunction (R::ConstPolyRing{T})(c::T) where T <: Integer\n   r = ConstPoly{T}(base_ring(R)(c))\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(c::T) where T <: RingElement\n   base_ring(R) != parent(c) && error(\"Unable to coerce element\")\n   r = ConstPoly{T}(c)\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(f::ConstPoly{T}) where T <: RingElement\n   R != parent(f) && error(\"Unable to coerce element\")\n   return f\nend\n\n# Parent constructor\n\nfunction constant_polynomial_ring(R::Ring, cached::Bool=true)\n   T = elem_type(R)\n   return ConstPolyRing{T}(R, cached)\nend\n\n# output\n\nconstant_polynomial_ring (generic function with 2 methods)\n\nThe above implementation of constant_polynomial_ring may be tested as follows.\n\nusing Test\n\nfunction ConformanceTests.generate_element(R::ConstPolyRing{elem_type(ZZ)})\n   n = rand(1:999)\n   return R(rand(-n:n))\nend\n\ntest_Ring_interface(constant_polynomial_ring(ZZ))\n\n# output\nTest Summary:                                                                       |  Pass  Total  Time\nRing interface for Constant polynomials over integers of type ConstPolyRing{BigInt} | 13844  13844  0.9s\n\nNote that we only showed a minimal implementation of the ring interface. Additional interfaces exists, e.g. for Euclidean rings. Additional interface usually require implementing additional methods, and in some cases we also provide additional conformance tests. In this case, just one necessary method is missing.\n\nfunction Base.divrem(a::ConstPoly{elem_type(ZZ)}, b::ConstPoly{elem_type(ZZ)})\n   check_parent(a, b)\n   q, r = AbstractAlgebra.divrem(a.c, b.c)\n   return parent(a)(q), parent(a)(r)\nend\n\n# output\n\n\nWe can test it like this.\n\ntest_EuclideanRing_interface(constant_polynomial_ring(ZZ))\n\n# output\nTest Summary:                                                                                 | Pass  Total  Time\nEuclidean Ring interface for Constant polynomials over integers of type ConstPolyRing{BigInt} | 2212   2212  0.1s","category":"section"},{"location":"fraction_interface/#Fraction-Field-Interface","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Fraction fields are supported in AbstractAlgebra.jl, at least for gcd domains. In addition to the standard Ring interface, some additional functions are required to be present for fraction fields.","category":"section"},{"location":"fraction_interface/#Types-and-parents","page":"Fraction Field Interface","title":"Types and parents","text":"AbstractAlgebra provides two abstract types for fraction fields and their elements:\n\nFracField{T} is the abstract type for fraction field parent types\nFracElem{T} is the abstract type for types of fractions\n\nWe have that FracField{T} <: Field and FracElem{T} <: FieldElem.\n\nNote that both abstract types are parameterised. The type T should usually be the type of elements of the base ring of the fraction field.\n\nFraction fields should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Fraction fields should at least be distinguished based on their base ring.\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"fraction_interface/#Required-functionality-for-fraction-fields","page":"Fraction Field Interface","title":"Required functionality for fraction fields","text":"In addition to the required functionality for the Field interface the Fraction Field interface has the following required functions.\n\nWe suppose that R is a fictitious base ring, and that S is the fraction field with parent object S of type MyFracField{T}. We also assume the fractions in the field have type MyFrac{T}, where T is the type of elements of the base ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem.","category":"section"},{"location":"fraction_interface/#Constructors","page":"Fraction Field Interface","title":"Constructors","text":"The following constructors create fractions. Note that these constructors don't require construction of the parent object first. This is easier to achieve if the fraction element type doesn't contain a reference to the parent object, but merely contains a reference to the base ring. The parent object can then be constructed on demand.\n\n//(x::T, y::T) where T <: RingElem\n\nReturn the fraction xy.\n\n//(x::T, y::FracElem{T}) where T <: RingElem\n\nReturn xy where x is in the base ring of y.\n\n//(x::FracElem{T}, y::T) where T <: RingElem\n\nReturn xy where y is in the base ring of x.","category":"section"},{"location":"fraction_interface/#Basic-manipulation-of-fields-and-elements","page":"Fraction Field Interface","title":"Basic manipulation of fields and elements","text":"numerator(d::MyFrac{T}) where T <: RingElem\n\nGiven a fraction d = ab return a, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.\n\ndenominator(d::MyFrac{T}) where T <: RingElem\n\nGiven a fraction d = ab return b, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.","category":"section"},{"location":"fraction/#Generic-fraction-fields","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl provides a module, implemented in src/Fraction.jl for fraction fields over any gcd domain belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"section"},{"location":"fraction/#Generic-fraction-types","page":"Generic fraction fields","title":"Generic fraction types","text":"AbstractAlgebra.jl implements a generic fraction type Generic.FracFieldElem{T} where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of such fraction elements have type Generic.FracField{T}.","category":"section"},{"location":"fraction/#Factored-fraction-types","page":"Generic fraction fields","title":"Factored fraction types","text":"AbstractAlgebra.jl also implements a fraction type Generic.FactoredFracFieldElem{T} with parent objects of such fractions having type Generic.FactoredFracField{T}. As opposed to the fractions of type Generic.FracFieldElem{T}, which are just a numerator and denominator, these fractions are maintained in factored form as much as possible.","category":"section"},{"location":"fraction/#Abstract-types","page":"Generic fraction fields","title":"Abstract types","text":"All fraction element types belong to the abstract type FracElem{T} and the fraction field types belong to the abstract type FracField{T}. This enables one to write generic functions that can accept any AbstractAlgebra fraction type.\n\nnote: Note\nBoth the generic fraction field type Generic.FracField{T} and the abstract type it belongs to, FracField{T} are both called FracField. The former is a (parameterised) concrete type for a fraction field over a given base ring whose elements have type T. The latter is an abstract type representing all fraction field types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"section"},{"location":"fraction/#Fraction-field-constructors","page":"Generic fraction fields","title":"Fraction field constructors","text":"In order to construct fractions in AbstractAlgebra.jl, one can first construct the fraction field itself. This is accomplished with the following constructor.\n\nfraction_field(R::Ring; cached::Bool = true)\n\nGiven a base ring R return the parent object of the fraction field of R. By default the parent object S will depend only on R and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nHere are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into the fraction field.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over integers\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1","category":"section"},{"location":"fraction/#Factored-Fraction-field-constructors","page":"Generic fraction fields","title":"Factored Fraction field constructors","text":"The corresponding factored field uses the following constructor.\n\nfactored_fraction_field(R::Ring; cached::Bool = true)\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [:x, :y])\n(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S = factored_fraction_field(R)\nFactored fraction field of Multivariate polynomial ring in 2 variables over integers\n\njulia> (X, Y) = (S(x), S(y))\n(x, y)\n\njulia> f = X^6*(X+Y)^2*(X^2+Y)^3*(X+2*Y)^-3*(X+3*Y)^-4\nx^6*(x + y)^2*(x^2 + y)^3/((x + 2*y)^3*(x + 3*y)^4)\n\njulia> numerator(f)\nx^14 + 2*x^13*y + x^12*y^2 + 3*x^12*y + 6*x^11*y^2 + 3*x^10*y^3 + 3*x^10*y^2 + 6*x^9*y^3 + 3*x^8*y^4 + x^8*y^3 + 2*x^7*y^4 + x^6*y^5\n\njulia> denominator(f)\nx^7 + 18*x^6*y + 138*x^5*y^2 + 584*x^4*y^3 + 1473*x^3*y^4 + 2214*x^2*y^5 + 1836*x*y^6 + 648*y^7\n\njulia> derivative(f, x)\nx^5*(x + y)*(x^2 + y)^2*(7*x^5 + 58*x^4*y + 127*x^3*y^2 + x^3*y + 72*x^2*y^3 + 22*x^2*y^2 + 61*x*y^3 + 36*y^4)/((x + 2*y)^4*(x + 3*y)^5)","category":"section"},{"location":"fraction/#Fraction-constructors","page":"Generic fraction fields","title":"Fraction constructors","text":"One can construct fractions using the fraction field parent object, as for any ring or field.\n\n(R::FracField)() # constructs zero\n(R::FracField)(c::Integer)\n(R::FracField)(c::elem_type(R))\n(R::FracField{T})(a::T) where T <: RingElement\n\nOne may also use the Julia double slash operator to construct elements of the fraction field without constructing the fraction field parent first.\n\n//(x::T, y::T) where T <: RingElement\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> x//f\nx//(x + 1)\n\njulia> f//x\n(x + 1)//x","category":"section"},{"location":"fraction/#Functions-for-types-and-parents-of-fraction-fields","page":"Generic fraction fields","title":"Functions for types and parents of fraction fields","text":"Fraction fields in AbstractAlgebra.jl implement the Ring interface.\n\nbase_ring(R::FracField)\nbase_ring(a::FracElem)\n\nReturn the base ring of which the fraction field was constructed.\n\nparent(a::FracElem)\n\nReturn the fraction field of the given fraction.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over rationals\n\njulia> V = base_ring(f)\nUnivariate polynomial ring in x over rationals\n\njulia> T = parent(f)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> m = characteristic(S)\n0","category":"section"},{"location":"fraction/#Fraction-field-functions","page":"Generic fraction fields","title":"Fraction field functions","text":"","category":"section"},{"location":"fraction/#Basic-functions","page":"Generic fraction fields","title":"Basic functions","text":"Fraction fields implement the Ring interface.\n\nzero(R::FracField)\none(R::FracField)\niszero(a::FracElem)\nisone(a::FracElem)\n\ninv(a::T) where T <: FracElem\n\nThey also implement the field interface.\n\nis_unit(f::FracElem)\n\nAnd they implement the fraction field interface.\n\nnumerator(a::FracElem)\ndenominator(a::FracElem)\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1","category":"section"},{"location":"fraction/#Greatest-common-divisor","page":"Generic fraction fields","title":"Greatest common divisor","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"section"},{"location":"fraction/#Square-root","page":"Generic fraction fields","title":"Square root","text":"Methods for is_square and sqrt are provided for inputs of type FracElem.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over rationals\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> is_square(a^2)\ntrue","category":"section"},{"location":"fraction/#Remove-and-valuation","page":"Generic fraction fields","title":"Remove and valuation","text":"When working over a Euclidean domain, it is convenient to extend valuations to the fraction field. To facilitate this, we define the following functions.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 1)//(x^2 + x + 1)\n(x^2 + 1)//(x^2 + x + 1)\n\njulia> v, q = remove(f^3*g, x + 1)\n(3, (x^2 + 1)//(x^11 + x^10 + 10*x^9 + 12*x^8 + 39*x^7 + 48*x^6 + 75*x^5 + 75*x^4 + 66*x^3 + 37*x^2 + 10*x + 1))\n\njulia> v = valuation(f^3*g, x + 1)\n3\n","category":"section"},{"location":"fraction/#Random-generation","page":"Generic fraction fields","title":"Random generation","text":"Random fractions can be generated using rand. The parameters passed after the fraction field tell rand how to generate random elements of the base ring.\n\nrand(R::FracField, v...)\n\nExamples\n\njulia> K = fraction_field(ZZ)\nRationals\n\njulia> f = rand(K, -10:10)\n-1//3\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = fraction_field(R)\nFraction field\n  of univariate polynomial ring in x over integers\n\njulia> g = rand(S, -1:3, -10:10)\n(-4*x - 4)//(4*x^2 + x - 4)","category":"section"},{"location":"fraction/#Extra-functionality-for-factored-fractions","page":"Generic fraction fields","title":"Extra functionality for factored fractions","text":"The Generic.FactoredFracFieldElem{T} type implements an interface similar to that of the Fac{T} type for iterating over the terms in the factorisation. There is also the function push_term!(a, b, e) for efficiently performing a *= b^e, and the function normalise returns relatively prime terms.\n\nExamples\n\njulia> F = factored_fraction_field(ZZ)\nFactored fraction field of Integers\n\njulia> f = F(-1)\n-1\n\njulia> push_term!(f, 10, 10)\n-10^10\n\njulia> push_term!(f, 42, -8)\n-10^10/42^8\n\njulia> normalise(f)\n-5^10*2^2/21^8\n\njulia> unit(f)\n-1\n\njulia> collect(f)\n2-element Vector{Tuple{BigInt, Int64}}:\n (10, 10)\n (42, -8)","category":"section"},{"location":"fraction/#Base.gcd-Union{Tuple{T}, Tuple{FracElem{T}, FracElem{T}}} where T<:RingElem","page":"Generic fraction fields","title":"Base.gcd","text":"gcd(a::FracElem{T}, b::FracElem{T}) where {T <: RingElem}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n\n\n","category":"method"},{"location":"fraction/#AbstractAlgebra.remove-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"AbstractAlgebra.remove","text":"remove(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the tuple n x such that z = p^nx where x has valuation 0 at p.\n\n\n\n\n\n","category":"method"},{"location":"fraction/#AbstractAlgebra.valuation-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"AbstractAlgebra.valuation","text":"valuation(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the valuation of z at p.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#Rational-function-fields","page":"Rational function fields","title":"Rational function fields","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/RationalFunctionField.jl for rational function fields k(x) or k[x_1, x_2, \\ldots, x_n] over a field k.","category":"section"},{"location":"function_field/#Generic-rational-function-field-type","page":"Rational function fields","title":"Generic rational function field type","text":"Rational functions have type Generic.RationalFunctionFieldElem{T, U} where T is the type of elements of the coefficient field k and U is the type of polynomials (either univariate or multivariate) over that field. See the file src/generic/GenericTypes.jl for details.\n\nParent objects corresponding to the rational function field k have type Generic.RationalFunctionField{T, U}.","category":"section"},{"location":"function_field/#Abstract-types","page":"Rational function fields","title":"Abstract types","text":"The rational function types belong to the abstract type Field and the rational function field types belong to the abstract type FieldElem.","category":"section"},{"location":"function_field/#Rational-function-field-constructors","page":"Rational function fields","title":"Rational function field constructors","text":"In order to construct rational functions in AbstractAlgebra.jl, one can first construct the function field itself. This is accomplished with one of the following constructors.\n\nrational_function_field(k::Field, s::VarName; cached::Bool = true)\nrational_function_field(k::Field, s::Vector{<:VarName}; cached::Bool = true)\n\nGiven a coefficient field k return a tuple (S, x) consisting of the parent object of the rational function field over k and the generator(s) x. By default the parent object S will depend only on R and s and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nHere are some examples of creating rational function fields and making use of the resulting parent objects to coerce various elements into the function field.\n\nExamples\n\njulia> S, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n\njulia> m = S(numerator(x + 1, false), numerator(x + 2, false))\n(x + 1)//(x + 2)\n\njulia> R, (x, y) = rational_function_field(QQ, [:x, :y])\n(Rational function field over rationals, AbstractAlgebra.Generic.RationalFunctionFieldElem{Rational{BigInt}, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}[x, y])\n\njulia> (x + y)//y^2\n(x + y)//y^2","category":"section"},{"location":"function_field/#Basic-rational-function-field-functionality","page":"Rational function fields","title":"Basic rational function field functionality","text":"Fraction fields in AbstractAlgebra.jl implement the full Field interface and the entire fraction field interface.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> S, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> m = characteristic(S)\n0\n\njulia> U = base_ring(S)\nRationals\n\njulia> V = base_ring(f)\nRationals\n\njulia> T = parent(f)\nRational function field\n  over rationals\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1\n\n\nNote that numerator and denominator are returned as elements of a polynomial ring whose variable is printed the same way as that of the generator of the rational function field.","category":"section"},{"location":"function_field/#Rational-function-field-functionality-provided-by-AbstractAlgebra.jl","page":"Rational function fields","title":"Rational function field functionality provided by AbstractAlgebra.jl","text":"The following functionality is provided for rational function fields.","category":"section"},{"location":"function_field/#Greatest-common-divisor","page":"Rational function fields","title":"Greatest common divisor","text":"Examples\n\njulia> R, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"section"},{"location":"function_field/#Square-root","page":"Rational function fields","title":"Square root","text":"Methods for is_square and sqrt are provided for inputs of type RationalFunctionFieldElem.\n\nExamples\n\njulia> R, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> is_square(a^2)\ntrue","category":"section"},{"location":"function_field/#Univariate-function-fields","page":"Rational function fields","title":"Univariate function fields","text":"Univariate function fields in AbstractAlgebra are algebraic extensions Kk(x) of a rational function field k(x) over a field k.\n\nThese are implemented in a module implemented in src/generic/FunctionField.jl.","category":"section"},{"location":"function_field/#Generic-function-field-types","page":"Rational function fields","title":"Generic function field types","text":"Function field objects Kk(x) in AbstractAlgebra have type Generic.FunctionField{T} where T is the type of elements of the field k.\n\nCorresponding function field elements have type Generic.FunctionFieldElement{T}. See the file src/generic/GenericTypes.jl for details.","category":"section"},{"location":"function_field/#Abstract-types-2","page":"Rational function fields","title":"Abstract types","text":"Function field types belong to the abstract type Field and their elements to the abstract type FieldElem.","category":"section"},{"location":"function_field/#Function-field-constructors","page":"Rational function fields","title":"Function field constructors","text":"In order to construct function fields in AbstractAlgebra.jl, one first constructs the rational function field they are an extension of, then supplies a polynomial over this field to the following constructor:\n\nfunction_field(p::Poly{RationalFunctionFieldElem{T, U}}, s::AbstractString; cached::Bool=true) where {T <: FieldElement, U <: PolyRingElem{T}}\n\nGiven an irreducible polynomial p over a rational function field return a tuple (S, z) consisting of the parent object of the function field defined by that polynomial over k(x) and the generator z. By default the parent object S will depend only on p and s and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nHere are some examples of creating function fields and making use of the resulting parent objects to coerce various elements into the function field.\n\nExamples\n\njulia> R1, x1 = rational_function_field(QQ, \"x1\") # characteristic 0\n(Rational function field over rationals, x1)\n\njulia> U1, z1 = R1[\"z1\"]\n(Univariate polynomial ring in z1 over R1, z1)\n\njulia> f = (x1^2 + 1)//(x1 + 1)*z1^3 + 4*z1 + 1//(x1 + 1)\n(x1^2 + 1)//(x1 + 1)*z1^3 + 4*z1 + 1//(x1 + 1)\n\njulia> S1, y1 = function_field(f, \"y1\")\n(Function Field over rationals with defining polynomial (x1^2 + 1)*y1^3 + (4*x1 + 4)*y1 + 1, y1)\n\njulia> a = S1()\n0\n\njulia> b = S1((x1 + 1)//(x1 + 2))\n(x1 + 1)//(x1 + 2)\n\njulia> c = S1(1//3)\n1//3\n\njulia> R2, x2 = rational_function_field(GF(23), \"x1\") # characteristic p\n(Rational function field over finite field F_23, x1)\n\njulia> U2, z2 = R2[\"z2\"]\n(Univariate polynomial ring in z2 over R2, z2)\n\njulia> g = z2^2 + 3z2 + 1\nz2^2 + 3*z2 + 1\n\njulia> S2, y2 = function_field(g, \"y2\")\n(Function Field over finite field F_23 with defining polynomial y2^2 + 3*y2 + 1, y2)\n\njulia> d = S2(R2(5))\n5\n\njulia> e = S2(y2)\ny2","category":"section"},{"location":"function_field/#Basic-function-field-functionality","page":"Rational function fields","title":"Basic function field functionality","text":"Function fields implement the full Ring and Field interfaces. We give some examples of such functionality.\n\nExamples\n\njulia> R, x = rational_function_field(GF(23), :x) # characteristic p\n(Rational function field over finite field F_23, x)\n\njulia> U, z = R[:z]\n(Univariate polynomial ring in z over R, z)\n\njulia> g = z^2 + 3z + 1\nz^2 + 3*z + 1\n\njulia> S, y = function_field(g, :y)\n(Function Field over finite field F_23 with defining polynomial y^2 + 3*y + 1, y)\n\njulia> f = (x + 1)*y + 1\n(x + 1)*y + 1\n\njulia> base_ring(f)\nRational function field\n  over finite field F_23\n\njulia> f^2\n(20*x^2 + 19*x + 22)*y + 22*x^2 + 21*x\n\njulia> f*inv(f)\n1","category":"section"},{"location":"function_field/#Function-field-functionality-provided-by-AbstractAlgebra.jl","page":"Rational function fields","title":"Function field functionality provided by AbstractAlgebra.jl","text":"The following functionality is provided for function fields.","category":"section"},{"location":"function_field/#Basic-manipulation","page":"Rational function fields","title":"Basic manipulation","text":"Examples\n\njulia> R, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> U, z = R[:z]\n(Univariate polynomial ring in z over R, z)\n\njulia> g = z^2 + 3*(x + 1)//(x + 2)*z + 1\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> S, y = function_field(g, :y)\n(Function Field over rationals with defining polynomial (x + 2)*y^2 + (3*x + 3)*y + x + 2, y)\n\njulia> base_field(S)\nRational function field\n  over rationals\n\njulia> var(S)\n:y\n\njulia> characteristic(S)\n0\n\njulia> defining_polynomial(S)\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> numerator(S)\n(x + 2)*y^2 + (3*x + 3)*y + x + 2\n\njulia> denominator(S)\nx + 2\n\njulia> a = (x + 1)//(x^2 + 1)*y + 3x + 2\n((x + 1)*y + 3*x^3 + 2*x^2 + 3*x + 2)//(x^2 + 1)\n\njulia> numerator(a, false)\n(x + 1)*y + 3*x^3 + 2*x^2 + 3*x + 2\n\njulia> denominator(a, false)\nx^2 + 1\n\njulia> degree(S)\n2\n\njulia> gen(S)\ny\n\njulia> is_gen(y)\ntrue\n\njulia> coeff(a, 1)\n(x + 1)//(x^2 + 1)\n\njulia> num_coeff(a, 1)\nx + 1","category":"section"},{"location":"function_field/#Trace-and-norm","page":"Rational function fields","title":"Trace and norm","text":"julia> R, x = rational_function_field(QQ, :x)\n(Rational function field over rationals, x)\n\njulia> U, z = R[:z]\n(Univariate polynomial ring in z over R, z)\n\njulia> g = z^2 + 3*(x + 1)//(x + 2)*z + 1\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> S, y = function_field(g, :y)\n(Function Field over rationals with defining polynomial (x + 2)*y^2 + (3*x + 3)*y + x + 2, y)\n\njulia> f = (-3*x - 5//3)//(x - 2)*y + (x^3 + 1//9*x^2 + 5)//(x - 2)\n((-3*x - 5//3)*y + x^3 + 1//9*x^2 + 5)//(x - 2)\n\njulia> norm(f)\n(x^7 + 20//9*x^6 + 766//81*x^5 + 2027//81*x^4 + 110//3*x^3 + 682//9*x^2 + 1060//9*x + 725//9)//(x^3 - 2*x^2 - 4*x + 8)\n\njulia> tr(f)\n(2*x^4 + 38//9*x^3 + 85//9*x^2 + 24*x + 25)//(x^2 - 4)","category":"section"},{"location":"function_field/#Base.gcd-Union{Tuple{U}, Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionFieldElem{T, U}, AbstractAlgebra.Generic.RationalFunctionFieldElem{T, U}}} where {T<:FieldElement, U<:Union{MPolyRingElem, PolyRingElem}}","page":"Rational function fields","title":"Base.gcd","text":"gcd(a::RationalFunctionFieldElem{T, U}, b::RationalFunctionFieldElem{T, U}) where {T <: FieldElement, U <: Union{PolyRingElem, MPolyRingElem}}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.Generic.base_field-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"AbstractAlgebra.Generic.base_field","text":"base_field(R::FunctionField)\n\nReturn the rational function field that the field R is an extension of. Synonymous with base_ring.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.var-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"AbstractAlgebra.var","text":"var(R::FunctionField)\n\nReturn the variable name of the generator of the function field R as a symbol.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.Generic.defining_polynomial-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"AbstractAlgebra.Generic.defining_polynomial","text":"defining_polynomial(R::FunctionField)\nmodulus(R::FunctionField)\n\nReturn the original polynomial that was used to define the function field R.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#Base.numerator-Union{Tuple{AbstractAlgebra.Generic.FunctionField{T}}, Tuple{T}, Tuple{AbstractAlgebra.Generic.FunctionField{T}, Bool}} where T<:FieldElement","page":"Rational function fields","title":"Base.numerator","text":"Base.numerator(R::FunctionField{T}, canonicalise::Bool=true) where T <: FieldElement\nBase.denominator(R::FunctionField{T}, canonicalise::Bool=true) where T <: FieldElement\n\nThinking of elements of the rational function field as fractions, put the defining polynomial of the function field over a common denominator and return the numerator/denominator respectively. Note that the resulting polynomials belong to a different ring than the original defining polynomial. The canonicalise is ignored, but exists for compatibility with the Generic interface.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#Base.numerator-Union{Tuple{AbstractAlgebra.Generic.FunctionFieldElem{T}}, Tuple{T}, Tuple{AbstractAlgebra.Generic.FunctionFieldElem{T}, Bool}} where T<:FieldElement","page":"Rational function fields","title":"Base.numerator","text":"Base.numerator(a::FunctionFieldElem{T}, canonicalise::Bool=true) where T <: FieldElement\nBase.denominator(a::FunctionFieldElem{T}, canonicalise::Bool=true) where T <: FieldElement\n\nReturn the numerator and denominator of the function field element a. Note that elements are stored in fraction free form so that the denominator is a common denominator for the coefficients of the element a. If canonicalise is set to true the fraction is first canonicalised.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.degree-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"AbstractAlgebra.degree","text":"degree(S::FunctionField)\n\nReturn the degree of the defining polynomial of the function field, i.e. the degree of the extension that the function field makes of the underlying rational function field.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.gen-Union{Tuple{AbstractAlgebra.Generic.FunctionField{T}}, Tuple{T}} where T<:FieldElement","page":"Rational function fields","title":"AbstractAlgebra.gen","text":"gen(S::FunctionField{T}) where T <: FieldElement\n\nReturn the generator of the function field returned by the function field constructor.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.is_gen-Tuple{AbstractAlgebra.Generic.FunctionFieldElem}","page":"Rational function fields","title":"AbstractAlgebra.is_gen","text":"is_gen(a::FunctionFieldElem)\n\nReturn true if a is the generator of the function field returned by the function field constructor.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.FunctionFieldElem, Int64}","page":"Rational function fields","title":"AbstractAlgebra.coeff","text":"coeff(a::FunctionFieldElem, n::Int)\n\nReturn the degree n coefficient of the element a in its polynomial representation in terms of the generator of the function field. The coefficient is returned as an element of the underlying rational function field.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#AbstractAlgebra.Generic.num_coeff-Tuple{AbstractAlgebra.Generic.FunctionFieldElem, Int64}","page":"Rational function fields","title":"AbstractAlgebra.Generic.num_coeff","text":"num_coeff(a::FunctionFieldElem, n::Int)\n\nReturn the degree n coefficient of the numerator of the element a (in its polynomial representation in terms of the generator of the function field, rationalised as per numerator/denominator described above). The coefficient will be an polynomial over the base_ring of the underlying rational function field.\n\n\n\n\n\n","category":"method"},{"location":"function_field/#LinearAlgebra.norm-Tuple{AbstractAlgebra.Generic.FunctionFieldElem}","page":"Rational function fields","title":"LinearAlgebra.norm","text":"norm(a::FunctionFieldElem)\n\nReturn the absolute norm of a as an element of the underlying rational function field.\n\n\n\n\n\n","category":"method"},{"location":"total_fraction/#Total-ring-of-fractions","page":"Total ring of fractions","title":"Total ring of fractions","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/TotalFraction.jl, for the total ring of fractions of a ring.\n\nThe total ring of fractions of a ring R is the localisation of R at the non-zero divisors of R, the latter being a multiplicative subset of R.\n\nThere are no restrictions on the ring except the function is_zero_divisor must be defined and effective for R.\n\nIn particular, we do not assume that all elements of R which are not zero divisors are units in R. This has the effect of making exact division impossible generically in the total ring of fractions of R.\n\nThis in turn limits the usefulness of the total ring of fractions as a ring in AbstractAlgebra as a great deal of generic code relies on divexact. Should this be a limitation, the user can define their own divexact function for the total ring of fractions in question.\n\nNote that in most cases a*inv(b) is not a sufficient definition of divexact(a, b) due to the possibility that b is not a unit in the total ring of fractions.\n\nIt is also possible to construct a total ring of fractions of R without the is_zero_divisor function existing for R, but some functions such as is_unit, inv, rand and ad hoc arithmetic operations involving rational numbers are not available for the total ring of fractions. One must also construct fractions using the option check=false and it is one's own responsibility to check that the denominator is not a zero divisor.\n\nNote that although the total ring of fractions of an integral domain R is mathematically the same thing as the fraction field of R, these will be different objects in AbstractAlgebra and have different types.","category":"section"},{"location":"total_fraction/#Generic-total-ring-of-fraction-types","page":"Total ring of fractions","title":"Generic total ring of fraction types","text":"AbstractAlgebra.jl implements a generic type for elements of a total ring of fractions, namelyGeneric.TotFrac{T} where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of such elements have type Generic.TotFracRing{T}.","category":"section"},{"location":"total_fraction/#Abstract-types","page":"Total ring of fractions","title":"Abstract types","text":"The types for elements of a total ring of fractions belong directly to the abstract type RingElem and the type for the total ring of fractions parent object belongs directly to the abstract type Ring.","category":"section"},{"location":"total_fraction/#Total-ring-of-fractions-constructors","page":"Total ring of fractions","title":"Total ring of fractions constructors","text":"In order to construct fractions in a total ring of fractions in AbstractAlgebra.jl, one must first construct the parent object for the total ring of fractions itself. This is accomplished with the following constructor.\n\ntotal_ring_of_fractions(R::Ring; cached::Bool = true)\n\nGiven a base ring R return the parent object of the total ring of fractions of R. By default the parent object S will depend only on R and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nHere are some examples of creating a total ring of fractions and making use of the resulting parent objects to coerce various elements into the ring.\n\nExamples\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1","category":"section"},{"location":"total_fraction/#Fraction-constructors","page":"Total ring of fractions","title":"Fraction constructors","text":"One can construct fractions using the total ring of fractions parent object, as for any ring or field.\n\n(R::TotFracRing)() # constructs zero\n(R::TotFracRing)(c::Integer)\n(R::TotFracRing)(c::elem_type(R))\n(R::TotFracRing{T})(a::T) where T <: RingElement\n\nAlthough one cannot use the double slash operator // to construct elements of a total ring of fractions, as no parent has been specified, one can use the double slash operator to construct elements of a total ring of fractions so long as one of the arguments to the double slash operator is already in the total ring of fractions in question.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> f = S(x + 1)\nx + 1\n\njulia> f//3\n(x + 1)//3\n\njulia> 3//f\n3//(x + 1)\n\njulia> f//x\n(x + 1)//x","category":"section"},{"location":"total_fraction/#Functions-for-types-and-parents-of-total-rings-of-fractions","page":"Total ring of fractions","title":"Functions for types and parents of total rings of fractions","text":"Total rings of fractions in AbstractAlgebra.jl implement the Ring interface except for the divexact function which is not generically possible to implement.\n\nbase_ring(R::TotFracRing)\nbase_ring(a::TotFrac)\n\nReturn the base ring of which the total ring of fractions was constructed.\n\nparent(a::TotFrac)\n\nReturn the total ring of fractions that the given fraction belongs to.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> f = S(x + 1)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over rationals\n\njulia> V = base_ring(f)\nUnivariate polynomial ring in x over rationals\n\njulia> T = parent(f)\nTotal ring of fractions of R\n\njulia> m = characteristic(S)\n0","category":"section"},{"location":"total_fraction/#Total-ring-of-fractions-functions","page":"Total ring of fractions","title":"Total ring of fractions functions","text":"","category":"section"},{"location":"total_fraction/#Basic-functions","page":"Total ring of fractions","title":"Basic functions","text":"Total rings of fractions implement the Ring interface.\n\nzero(R::TotFracRing)\none(R::TotFracRing)\niszero(a::TotFrac)\nisone(a::TotFrac)\n\ninv(a::T) where T <: TotFrac\n\nThey also implement some of the following functions which would usually be associated with the field and fraction field interfaces.\n\nis_unit(f::TotFrac)\n\nnumerator(a::TotFrac)\ndenominator(a::TotFrac)\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = f//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1","category":"section"},{"location":"total_fraction/#Random-generation","page":"Total ring of fractions","title":"Random generation","text":"Random fractions can be generated using rand. The parameters passed after the total ring of fractions tell rand how to generate random elements of the base ring.\n\nrand(R::TotFracRing, v...)\n\nExamples\n\njulia> R, = residue_ring(ZZ, 12);\n\njulia> K = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> f = rand(K, 0:11)\n7//5\n\njulia> R, x = polynomial_ring(ZZ, :x)\n(Univariate polynomial ring in x over integers, x)\n\njulia> S = total_ring_of_fractions(R)\nTotal ring of fractions of R\n\njulia> g = rand(S, -1:3, -10:10)\n(4*x + 4)//(-4*x^2 - x + 4)","category":"section"},{"location":"rand/#Random-interface","page":"Random interface","title":"Random interface","text":"AbstractAlgebra makes use of the Julia Random interface for random generation.\n\nIn addition we make use of an experimental package RandomExtensions.jl for extending the random interface in Julia.\n\nThe latter is required because some of our types require more than one argument to specify how to randomise them.\n\nThe usual way of generating random values that Julia and these extensions provide would look as follows:\n\njulia> using AbstractAlgebra\n\njulia> using Random\n\njulia> using RandomExtensions\n\njulia> S, x = polynomial_ring(ZZ, :x)\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> rand(Random.default_rng(), make(S, 1:3, -10:10))\n-5*x + 4\n\nThis example generates a polynomial over the integers with degree in the range 1 to 3 and with coefficients in the range -10 to 10.\n\nIn addition we implement shortened versions for ease of use which don't require creating a make instance or passing in the standard RNG.\n\njulia> using AbstractAlgebra\n\njulia> S, x = polynomial_ring(ZZ, :x)\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> rand(S, 1:3, -10:10)\n-5*x + 4\n\nBecause rings can be constructed over other rings in a tower, all of this is supported by defining RandomExtensions.make instances that break the various levels of the ring down into separate make instances.\n\nFor example, here is the implementation of make for polynomial rings such as the above:\n\nfunction RandomExtensions.make(S::PolyRing, deg_range::AbstractUnitRange{Int}, vs...)\n   R = base_ring(S)\n   if length(vs) == 1 && elem_type(R) == Random.gentype(vs[1])\n      Make(S, deg_range, vs[1]) # forward to default Make constructor\n   else\n      Make(S, deg_range, make(R, vs...))\n   end\nend\n\nAs you can see, it has two cases. The first is where this invocation of make is already at the bottom of the tower of rings, in which case it just forwards to the default Make constructor.\n\nThe second case expects that we are higher up in the tower of rings and that make needs to be broken up (recursively) into the part that deals with the ring level we are at and the level that deals with the base ring.\n\nTo help make we tell it the type of object we are hoping to randomly generate.\n\nRandomExtensions.maketype(S::PolyRing, dr::AbstractUnitRange{Int}, _) = elem_type(S)\n\nFinally we implement the actual random generation itself.\n\n# define rand for make(S, deg_range, v)\nfunction rand(rng::AbstractRNG, sp::SamplerTrivial{<:Make3{<:RingElement, <:PolyRing, <:AbstractUnitRange{Int}}})\n   S, deg_range, v = sp[][1:end]\n   R = base_ring(S)\n   f = S()\n   x = gen(S)\n   # degree -1 is zero polynomial\n   deg = rand(rng, deg_range)\n   if deg == -1\n      return f\n   end\n   for i = 0:deg - 1\n      f += rand(rng, v)*x^i\n   end\n   # ensure leading coefficient is nonzero\n   c = R()\n   while iszero(c)\n      c = rand(rng, v)\n   end\n   f += c*x^deg\n   return f\nend\n\nNote that when generating random elements of the base ring for example, one should use the random number generator rng that is passed in.\n\nAs mentioned above, we define a simplified random generator that saves the user having to create make instances.\n\nrand(rng::AbstractRNG, S::PolyRing, deg_range::AbstractUnitRange{Int}, v...) =\n   rand(rng, make(S, deg_range, v...))\n\nrand(S::PolyRing, degs, v...) = rand(Random.default_rng(), S, degs, v...)\n\nTo test whether a random generator is working properly, the test_rand function exists in the AbstractAlgebra test submodule in the file test/runtests.jl. For example, in AbstractAlgebra test code:\n\nusing Test\n\nR, x = polynomial_ring(ZZ, :x)\n\ntest_rand(R, -1:10, -10:10)\n\nIn general, we try to use UnitRange's to specify how 'big' we want the random instance to be, e.g. the range of degrees a polynomial could take, the range random integers could lie in, etc. The objective is to make it easy for the user to control the 'size' of random values in test code.","category":"section"},{"location":"map_interface/#Map-Interface","page":"Map Interface","title":"Map Interface","text":"Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.\n\nIn the following, we will always use the word \"function\" to mean a Julia function, and reserve the word \"map\" for a map on sets, whether mathematically, or as an object in the system.","category":"section"},{"location":"map_interface/#Parent-objects","page":"Map Interface","title":"Parent objects","text":"Maps in AbstractAlgebra currently don't have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.","category":"section"},{"location":"map_interface/#Map-classes","page":"Map Interface","title":"Map classes","text":"All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from SetMap at the top of the hierarchy. Other classes that inherit from SetMap are FunctionalMap for maps that are constructed from a Julia function (or closure), and IdentityMap for the class of the identity maps within the system.\n\nOne might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.\n\nInstead, a map type MyMap will belong to an abstract type of the form Map{D, C, T, MyMap}, where D is the type of the object representing the domain of the map type (this can also be an abstract type, such as Group), C is the type of the object representing the codomain of the map type and T is the map class that MyMap belongs to, e.g. SetMap or FunctionalMap.\n\nBecause a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.\n\nIf writing a function that accepts any map type, one makes the type of its argument belong to Map. For example f(M::Map) = 1.\n\nIf writing a function that accepts any map from a domain of type D to a codomain of type C, one makes writes for example f(M::Map{D, C}) = 2. Note that D and C can be abstract types, such as Group, but otherwise must be the types of the parent objects representing the domain and codomain.\n\nA function that accepts any map belonging to a given map class might be written as f(M::Map(FunctionalMap)) = 3 or f(M::Map(FunctionalMap){D, C}) = 4 for example, where D and C are the types of the parent objects for the domain and codomain.\n\nFinally, if a function should only work for a map of a given map type MyMap, say, one writes this f(M::Map(MyMap)) or f(M::Map(MyMap){D, C}, where as usual D and C are the types of the domain and codomain parent objects.","category":"section"},{"location":"map_interface/#Implementing-new-map-types","page":"Map Interface","title":"Implementing new map types","text":"There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.\n\nIn the case of fixed domain and codomain, e.g. Integers{BigInt}, we would write it as follows:\n\nmutable struct MyMap <: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}\n   # some data fields\nend\n\nIn the case of parameterisation by the type of the domain and codomain:\n\nmutable struct MyMap{D, C} <: Map{D, C, SetMap, MyMap}\n   # some data fields\nend\n\nAs mentioned above, to write a function that only accepts maps of type MyMap, one writes the functions as follows:\n\nfunction my_fun(M::Map(MyMap))\n\nThe Map function then computes the correct type to use, which is actually not MyMap if all features of the generic Map infrastructure are required. It is bad practice to write functions for MyMap directly instead of Map(MyMap), since other users will be unable to use generic constructions over the map type MyMap.","category":"section"},{"location":"map_interface/#Required-functionality-for-maps","page":"Map Interface","title":"Required functionality for maps","text":"All map types must implement a standard interface, which we specify here.\n\nWe will define this interface for a custom map type MyMap belonging to Map(SetMap), SetMap being the map class that all maps types belong to.\n\nNote that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.\n\nThe required accessors for map types of class SetMap are as follows.\n\ndomain(M::Map(MyMap))\ncodomain(M::Map(MyMap))\n\nReturn the domain and codomain parent objects respectively, for the map M. It is only necessary to define these functions if the map type MyMap does not contain fields domain and codomain containing these parent objects.\n\nIt is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to Map(MyMap).\n\n(M::Map(MyMap)(a))\n\nApply the map M to the element a of the domain of M. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type elem_type(C) where C is the type of the codomain parent object.","category":"section"},{"location":"map_interface/#Optional-functionality-for-maps","page":"Map Interface","title":"Optional functionality for maps","text":"The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.\n\nHowever, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.\n\nWe describe this optional functionality here.","category":"section"},{"location":"map_interface/#Show-method","page":"Map Interface","title":"Show method","text":"Custom map types may like to provide a custom show method if the default of displaying the domain and codomain of the map is not sufficient.\n\nshow(io::IO, M::Map(MyMap))","category":"section"},{"location":"map_interface/#Identity-maps","page":"Map Interface","title":"Identity maps","text":"There is a concrete map type Generic.IdentityMap{D} for the identity map on a given domain. Here D is the type of the object representing that domain.\n\nGeneric.IdentityMap belongs to the supertype Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}.\n\nNote that the map class is also called IdentityMap. It is an abstract type, whereas Generic.IdentityMap is a concrete type in the Generic module.\n\nAn identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.\n\nWe do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.\n\nTo construct an identity map for a given domain, specified by a parent object R, say, we have the following function.\n\nReturn an identity map on the domain R.\n\nOf course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to IdentityMap so that composition with other map types still works.","category":"section"},{"location":"map_interface/#Composition-of-maps","page":"Map Interface","title":"Composition of maps","text":"Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.\n\nIn order to facilitate this, the Generic module provides a type Generic.CompositeMap{D, C}, which contains two maps map1 and map2, corresponding to the two maps to be applied in a composition, in the order they should be applied.\n\nTo construct a composition map from two existing maps, we have the following function:\n\nAs a shortcut for this function we have the following operator:\n\n*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)\n\nNote the order of composition. If we have maps f  X to Y, g  Y to Z the correct order of the maps in this operator is f*g, so that (f*g)(x) = g(f(x)).\n\nThis is chosen so that for left R-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.\n\nOf course, a custom map type or class of maps can implement its own composition type and compose function.\n\nThis is the case with the FunctionalMap class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.\n\nBy default, compose will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:\n\ncheck_composable(f::Map{D, U}, g::Map{U, C})\n\nRaise an exception if the codomain of f doesn't match the domain of g.\n\nNote that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:\n\nmap1(f::CompositeMap)\nmap2(f::CompositeMap)\n\nAny custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.","category":"section"},{"location":"map_interface/#AbstractAlgebra.identity_map-Tuple{AbstractAlgebra.Set}","page":"Map Interface","title":"AbstractAlgebra.identity_map","text":"identity_map(R::D) where D <: AbstractAlgebra.Set\n\nReturn an identity map on the domain R.\n\nExamples\n\njulia> R, t = ZZ[:t]\n(Univariate polynomial ring in t over integers, t)\n\njulia> f = identity_map(R)\nIdentity map\n  of univariate polynomial ring in t over integers\n\njulia> f(t)\nt\n\n\n\n\n\n","category":"method"},{"location":"map_interface/#AbstractAlgebra.compose-Tuple{Map, Map}","page":"Map Interface","title":"AbstractAlgebra.compose","text":"compose(f::Map, g::Map)\n\nCompose the two maps f and g, i.e. return the map h such that h(x) = g(f(x)).\n\nExamples\n\njulia> f = map_from_func(x -> x + 1, ZZ, ZZ);\n\njulia> g = map_from_func(x -> QQ(x), ZZ, QQ);\n\njulia> h = compose(f, g)\nFunctional composite map\n  from integers\n  to rationals\nwhich is the composite of\n  Map: integers -> integers\n  Map: integers -> rationals\n\n\n\n\n\n","category":"method"},{"location":"real/#Real-field","page":"Real field","title":"Real field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Float.jl for making Julia BigFloats conform to the AbstractAlgebra.jl Field interface.\n\nIn addition to providing a parent object RealField for Julia BigFloats, we implement any additional functionality required by AbstractAlgebra.jl.\n\nBecause BigFloat cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigFloats by introducing a type union, called FieldElement, which is a union of FieldElem and a number of Julia types, including BigFloat. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.\n\nThe details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigFloat type as belonging to FieldElem.","category":"section"},{"location":"real/#Types-and-parent-objects","page":"Real field","title":"Types and parent objects","text":"Reals have type BigFloat, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.\n\nThe parent objects of such integers has type Floats{BigFloat}.\n\nFor convenience, we also make Float64 a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as RDF) has type Floats{Float64}.","category":"section"},{"location":"real/#Rational-constructors","page":"Real field","title":"Rational constructors","text":"In order to construct reals in AbstractAlgebra.jl, one can first construct the real field itself. This is accomplished using the following constructor.\n\nFloats{BigFloat}()\n\nThis gives the unique object of type Floats{BigFloat} representing the field of reals in AbstractAlgebra.jl.\n\nIn practice, one simply uses RealField which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.\n\nHere are some examples of creating the real field and making use of the resulting parent object to coerce various elements into the field.\n\nExamples\n\njulia> RR = RealField\nFloats\n\njulia> f = RR()\n0.0\n\njulia> g = RR(123)\n123.0\n\njulia> h = RR(BigInt(1234))\n1234.0\n\njulia> k = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> m = RR(2.3)\n2.29999999999999982236431605997495353221893310546875\n","category":"section"},{"location":"real/#Basic-field-functionality","page":"Real field","title":"Basic field functionality","text":"The real field in AbstractAlgebra.jl implements the full Field interface.\n\nWe give some examples of such functionality.\n\nExamples\n\njulia> RR = RealField\nFloats\n\njulia> f = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> h = zero(RR)\n0.0\n\njulia> k = one(RR)\n1.0\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> base_ring_type(RR)\nUnion{}\n\njulia> T = parent(f)\nFloats\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n13.71428571428571428571428571428571428571428571428571428571428571428571428571433\n\njulia> m = inv(g)\n0.07291666666666666666666666666666666666666666666666666666666666666666666666666631\n","category":"section"},{"location":"series_interface/#Series-Ring-Interface","page":"Series Ring Interface","title":"Series Ring Interface","text":"Univariate power series rings are supported in AbstractAlgebra in a variety of different forms, including absolute and relative precision models and Laurent series.\n\nIn addition to the standard Ring interface, numerous additional functions are required to be present for power series rings.","category":"section"},{"location":"series_interface/#Types-and-parents","page":"Series Ring Interface","title":"Types and parents","text":"AbstractAlgebra provides two abstract types for power series rings and their elements:\n\nSeriesRing{T} is the abstract type for all power series ring parent types\nSeriesElem{T} is the abstract type for all power series types\n\nWe have that SeriesRing{T} <: Ring and SeriesElem{T} <: RingElem.\n\nNote that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the power series ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.\n\nWithin the SeriesElem{T} abstract type is the abstract type RelPowerSeriesRingElem{T} for relative power series, and AbsPowerSeriesRingElem{T} for absolute power series.\n\nRelative series are typically stored with a valuation and a series that is either zero or that has nonzero constant term. Absolute series are stored starting from the constant term, even if it is zero.\n\nIf the parent object for a relative series ring over the bignum integers has type MySeriesRing and series in that ring have type MySeries then one would have:\n\nMySeriesRing <: SeriesRing{BigInt}\nMySeries <: RelPowerSeriesRingElem{BigInt}\n\nSeries rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Series rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator) and same default precision, they should certainly have the same parent object.\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"series_interface/#Required-functionality-for-series","page":"Series Ring Interface","title":"Required functionality for series","text":"In addition to the required functionality for the Ring interface the Series Ring interface has the following required functions.\n\nWe suppose that R is a fictitious base ring (coefficient ring) and that S is a series ring over R (e.g. S = Rx) with parent object S of type MySeriesRing{T}. We also assume the series in the ring have type MySeries{T}, where T is the type of elements of the base (coefficient) ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem.","category":"section"},{"location":"series_interface/#Constructors","page":"Series Ring Interface","title":"Constructors","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.\n\nFor relative power series and Laurent series we have:\n\n(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T <: RingElem\n\nCreate the series in the given ring whose valuation is val, whose absolute precision is given by prec and the coefficients of which are given by A, starting from the first nonzero term. Only len terms of the array are used, the remaining terms being ignored. The value len cannot exceed the length of the supplied array.\n\nIt is permitted to have trailing zeros in the array, but it is not needed, even if the precision minus the valuation is bigger than the length of the array.\n\n(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: RingElem}\n\nAs above, but where the array is an array of coefficient that can be coerced into the base ring of the series ring.\n\n(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: Integer}\n\nAs above, but where the array is an array of integers that can be coerced into the base ring of the series ring.\n\nIt may be desirable to implement an addition version which accepts an array of Julia Int values if this can be done more efficiently.\n\nFor absolute power series we have:\n\n(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T <: RingElem\n\nCreate the series in the given ring whose absolute precision is given by prec and the coefficients of which are given by A, starting from the constant term. Only len terms of the array are used, the remaining terms being ignored.\n\nNote that len is usually maintained separately of any polynomial that is underlying the power series. This allows for easy trucation of a power series without actually modifying the polynomial underlying it.\n\nIt is permitted to have trailing zeros in the array, but it is not needed, even if the precision is bigger than the length of the array.\n\nIt is also possible to create series directly without having to create the corresponding series ring.\n\nabs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\nrel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::VarName=:x; max_precision::Int=prec, cached::Bool=true) where T\n\nCreate the power series over the given base ring R with coefficients specified by arr with the given absolute precision prec and in the case of relative series with the given valuation val.\n\nNote that more coefficients may be specified than are actually used. Only the first len coefficients are made part of the series, the remainder being stored internally but ignored.\n\nIn the case of absolute series one must have prec >= len and in the case of relative series one must have prec >= len + val.\n\nBy default the series are created in a ring with variable x and max_precision equal to prec, however one may specify these directly to override the defaults. Note that series are only compatible if they have the same coefficient ring R, max_precision and variable name var.\n\nAlso by default any parent ring created is cached. If this behaviour is not desired, set cached=false. However, this means that subsequent series created in the same way will not be compatible. Instead, one should use the parent object of the first series to create subsequent series instead of calling this function repeatedly with cached=false.","category":"section"},{"location":"series_interface/#Data-type-and-parent-object-methods","page":"Series Ring Interface","title":"Data type and parent object methods","text":"var(S::MySeriesRing{T}) where T <: RingElem\n\nReturn a Symbol representing the variable (generator) of the series ring. Note that this is a Symbol not a String, though its string value will usually be used when printing series.\n\nCustom series types over a given ring should define one of the following functions which return the type of an absolute or relative series object over that ring.\n\nabs_series_type(::Type{T}) where T <: RingElement\nrel_series_type(::Type{T}) where T <: RingElement\n\nReturn the type of a series whose coefficients have the given type.\n\nThis function is defined for generic series and only needs to be defined for custom series rings, e.g. ones defined by a C implementation.\n\nmax_precision(S::MySeriesRing{T}) where T <: RingElem\n\nReturn the (default) maximum precision of the power series ring. This is the precision that the output of an operation will be if it cannot be represented to full precision (e.g. because it mathematically has infinite precision).\n\nThis value is usually supplied upon creation of the series ring and stored in the ring. It is independent of the precision which each series in the ring actually has. Those are stored on a per element basis in the actual series elements.","category":"section"},{"location":"series_interface/#Basic-manipulation-of-rings-and-elements","page":"Series Ring Interface","title":"Basic manipulation of rings and elements","text":"pol_length(f::MySeries{T}) where T <: RingElem\n\nReturn the length of the polynomial underlying the given power series. This is not generally useful to the user, but is used internally.\n\nset_length!(f::MySeries{T}, n::Int) where T <: RingElem\n\nThis function sets the effective length of the polynomial underlying the given series. The function doesn't modify the actual polynomial, but simply changes the number of terms of the polynomial which are considered to belong to the power series. The remaining terms are ignored.\n\nThis function cannot set the length to a value greater than the length of any underlying polynomial.\n\nThe function mutates the series in-place but does not return the mutated series.\n\nprecision(f::MySeries{T})\n\nReturn the absolute precision of f.\n\nset_precision!(f::MySeries{T}, prec::Int)\n\nSet the absolute precision of the given series to the given value.\n\nThis return the updated series.\n\nvaluation(f::MySeries{T})\n\nReturn the valuation of the given series.\n\nset_valuation!(f::MySeries{T}, val::Int)\n\nFor relative series and Laurent series only, this function alters the valuation of the given series to the given value.\n\nThis function returns the updated series.\n\npolcoeff(f::MySeries{T}, n::Int)\n\nReturn the coefficient of degree n of the polynomial underlying the series. If n is larger than the degree of this polynomial, zero is returned. This function is not generally of use to the user but is used internally.\n\nsetcoeff!(f::MySeries{T}, n::Int, a::T) where T <: RingElem\n\nSet the degree n coefficient of the polynomial underlying f to a. This mutates the polynomial in-place if possible and returns the mutated series (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.\n\nnote: Note\nThis function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.\n\nnormalise(f::MySeries{T}, n::Int)\n\nGiven a series f represented by a polynomial of at least the given length, return the normalised length of the underlying polynomial assuming it has length at most n. This function does not actually normalise the polynomial and is not particularly useful to the user. It is used internally.\n\nrenormalize!(f::MySeries{T}) where T <: RingElem\n\nGiven a relative series or Laurent series whose underlying polynomial has zero constant term, say as the result of some internal computation, renormalise the series so that the polynomial has nonzero constant term. The precision and valuation of the series are adjusted to compensate. This function is not intended to be useful to the user, but is used internally.\n\nfit!(f::MySeries{T}, n::Int) where T <: RingElem\n\nEnsure that the polynomial underlying f internally has space for n coefficients. This function must mutate the series in-place if it is mutable. It does not return the mutated series. Immutable types can still be supported by defining this function to do nothing.\n\nSome interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.\n\ngen(R::MySeriesRing{T}) where T <: RingElem\n\nReturn the generator x of the series ring.","category":"section"},{"location":"series_interface/#Optional-functionality-for-series","page":"Series Ring Interface","title":"Optional functionality for series","text":"","category":"section"},{"location":"series_interface/#Similar-and-zero","page":"Series Ring Interface","title":"Similar and zero","text":"The following functions are available for all absolute and relative series types. The functions similar and zero do the same thing, but are provided for uniformity with other parts of the interface.\n\nsimilar(x::MySeries, R::Ring, max_prec::Int, var::VarName=var(parent(x)); cached::Bool=true)\nzero(a::MySeries, R::Ring, max_prec::Int, var::VarName=var(parent(a)); cached::Bool=true)\n\nConstruct the zero series with the given variable (if specified), coefficients in the specified coefficient ring and with relative/absolute precision cap on its parent ring as given by max_prec.\n\nsimilar(x::MySeries, R::Ring, var::VarName=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, max_prec::Int, var::VarName=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, var::VarName=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, R::Ring, max_prec::Int, var::VarName; cached::Bool=true)\nsimilar(x::MySeries, R::Ring, var::VarName; cached::Bool=true)\nsimilar(x::MySeries, max_prec::Int, var::VarName; cached::Bool=true)\nsimilar(x::MySeries, var::VarName; cached::Bool=true)\nzero(x::MySeries, R::Ring, var::VarName=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, max_prec::Int, var::VarName=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, var::VarName=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, R::Ring, max_prec::Int, var::VarName; cached::Bool=true)\nzero(x::MySeries, R::Ring, var::VarName; cached::Bool=true)\nzero(x::MySeries, max_prec::Int, var::VarName; cached::Bool=true)\nzero(x::MySeries, var::VarName; cached::Bool=true)\n\nAs above, but use the precision cap of the parent ring of x and the base_ring of x if these are not specified.\n\nCustom series rings may choose which series type is best-suited to return for the given coefficient ring, precision cap and variable, however they should return a series with the same model as x, i.e. relative or series.\n\nIf custom implementations don't specialise these function the default return type is a Generic.AbsSeries or Generic.RelSeries.\n\nThe default implementation of zero calls out to similar, so it's generally sufficient to specialise only similar. For both similar and zero only the most general method has to be implemented as all other methods call out to this more general method.","category":"section"},{"location":"residue/#Generic-residue-rings","page":"Generic residue rings","title":"Generic residue rings","text":"AbstractAlgebra.jl provides modules, implemented in src/Residue.jl and src/residue_field for residue rings and fields, respectively, over any Euclidean domain (in practice most of the functionality is provided for GCD domains that provide a meaningful GCD function) belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"section"},{"location":"residue/#Generic-residue-types","page":"Generic residue rings","title":"Generic residue types","text":"AbstractAlgebra.jl implements generic residue rings of Euclidean rings with type EuclideanRingResidueRingElem{T} or in the case of residue rings that are known to be fields, EuclideanRingResidueFieldElem{T}, where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.\n\nParent objects of generic residue ring elements have type EuclideanRingResidueRing{T} and those of residue fields have type EuclideanRingResidueField{T}.\n\nThe defining modulus of the residue ring is stored in the parent object.","category":"section"},{"location":"residue/#Abstract-types","page":"Generic residue rings","title":"Abstract types","text":"All residue element types belong to the abstract type ResElem{T} or ResFieldElem{T} in the case of residue fields, and the residue ring types belong to the abstract type ResidueRing{T} or ResidueField{T} respectively. This enables one to write generic functions that can accept any AbstractAlgebra residue type.","category":"section"},{"location":"residue/#Residue-ring-constructors","page":"Generic residue rings","title":"Residue ring constructors","text":"In order to construct residues in AbstractAlgebra.jl, one must first construct the residue ring itself. This is accomplished with one of the following constructors.\n\nresidue_ring(R::Ring, m::RingElem; cached::Bool = true)\n\nresidue_field(R::Ring, m::RingElem; cached::Bool = true)\n\nGiven a base ring R and residue m contained in this ring, return the parent object of the residue ring R(m) together with the canonical projection. By default the parent object S will depend only on R and m and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nThe residue_field constructor does the same thing as the residue_ring constructor, but the resulting object has type belonging to Field rather than Ring, so it can be used anywhere a field is expected in AbstractAlgebra.jl. No check is made for maximality of the ideal generated by m.\n\nThere are also the following for constructing residue rings and fields.\n\nHere are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into the residue ring.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n\njulia> U, f = quo(R, x^3 + 3x + 1)\n(Residue ring of R modulo x^3 + 3*x + 1, Map: R -> S)\n\njulia> U === S\ntrue\n\nAll of the examples here are generic residue rings, but specialised implementations of residue rings provided by external modules will also usually provide a residue_ring constructor to allow creation of their residue rings.","category":"section"},{"location":"residue/#Residue-constructors","page":"Generic residue rings","title":"Residue constructors","text":"One can use the parent objects of a residue ring to construct residues, as per any ring.\n\n(R::ResidueRing)() # constructs zero\n(R::ResidueRing)(c::Integer)\n(R::ResidueRing)(c::elem_type(R))\n(R::ResidueRing{T})(a::T) where T <: RingElement","category":"section"},{"location":"residue/#Functions-for-types-and-parents-of-residue-rings","page":"Generic residue rings","title":"Functions for types and parents of residue rings","text":"base_ring(R::ResidueRing)\nbase_ring(a::ResElem)\n\nReturn the base ring over which the ring was constructed.\n\nparent(a::ResElem)\n\nReturn the parent of the given residue.","category":"section"},{"location":"residue/#Residue-ring-functions","page":"Generic residue rings","title":"Residue ring functions","text":"","category":"section"},{"location":"residue/#Basic-functionality","page":"Generic residue rings","title":"Basic functionality","text":"Residue rings implement the Ring interface.\n\nzero(R::NCRing)\none(R::NCRing)\niszero(a::NCRingElement)\nisone(a::NCRingElement)\n\ndivexact(a::T, b::T) where T <: RingElement\ninv(a::T)\n\nThe Residue Ring interface is also implemented.\n\nmodulus(S::ResidueRing)\n\ndata(f::ResElem)\nlift(f::ResElem)\n\nReturn a lift of the residue to the base ring.\n\nThe following functions are also provided for residues.\n\nExamples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> f = S(x + 1)\nx + 1\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> is_unit(f)\ntrue\n\njulia> m = modulus(S)\nx^3 + 3*x + 1\n\njulia> d = data(f)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate polynomial ring in x over rationals\n\njulia> V = base_ring(f)\nUnivariate polynomial ring in x over rationals\n\njulia> T = parent(f)\nResidue ring of R modulo x^3 + 3*x + 1\n\njulia> f == deepcopy(f)\ntrue\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)","category":"section"},{"location":"residue/#Inversion","page":"Generic residue rings","title":"Inversion","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = inv(f)\n1//3*x^2 - 1//3*x + 4//3\n","category":"section"},{"location":"residue/#Greatest-common-divisor","page":"Generic residue rings","title":"Greatest common divisor","text":"Examples\n\njulia> R, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> S, = residue_ring(R, x^3 + 3x + 1);\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = S(x^2 + 2x + 1)\nx^2 + 2*x + 1\n\njulia> h = gcd(f, g)\n1\n","category":"section"},{"location":"residue/#Square-Root","page":"Generic residue rings","title":"Square Root","text":"Methods for is_square and sqrt are provided for inputs of type ResFieldElem.\n\nExamples\n\njulia> R = residue_field(ZZ, 733)\nResidue field of Integers modulo 733\n\njulia> a = R(86)\n86\n\njulia> is_square(a)\ntrue\n\njulia> sqrt(a)\n532","category":"section"},{"location":"residue/#Random-generation","page":"Generic residue rings","title":"Random generation","text":"Random residues can be generated using rand. The parameters after the residue ring are used to generate elements of the base ring.\n\nrand(R::ResidueRing, v...)\n\nExamples\n\njulia> R, = residue_ring(ZZ, 7);\n\njulia> f = rand(R, 0:6)\n4\n\njulia> S, x = polynomial_ring(QQ, :x)\n(Univariate polynomial ring in x over rationals, x)\n\njulia> g = rand(S, 2:2, -10:10)\n-1//4*x^2 - 2//7*x + 1","category":"section"},{"location":"residue/#AbstractAlgebra.quo-Tuple{Ring, RingElem}","page":"Generic residue rings","title":"AbstractAlgebra.quo","text":"quo(R::Ring, a::RingElement; cached::Bool = true)\n\nReturns S, f where S = residue_ring(R, a) and f is the projection map from R to S. This map is supplied as a map with section where the section is the lift of an element of the residue field back to the ring R.\n\n\n\n\n\n","category":"method"},{"location":"residue/#AbstractAlgebra.quo-Tuple{Type{Field}, Ring, RingElem}","page":"Generic residue rings","title":"AbstractAlgebra.quo","text":"quo(::Type{Field}, R::Ring, a::RingElement; cached::Bool = true)\n\nReturns S, f where S = residue_field(R, a) and f is the projection map from R to S. This map is supplied as a map with section where the section is the lift of an element of the residue field back to the ring R.\n\n\n\n\n\n","category":"method"},{"location":"residue/#AbstractAlgebra.modulus-Tuple{ResElem}","page":"Generic residue rings","title":"AbstractAlgebra.modulus","text":"modulus(R::ResElem)\n\nReturn the modulus a of the residue ring S = R(a) that the supplied residue r belongs to.\n\n\n\n\n\n","category":"method"},{"location":"residue/#Base.inv-Tuple{ResElem}","page":"Generic residue rings","title":"Base.inv","text":"Base.inv(a::ResElem)\n\nReturn the inverse of the element a in the residue ring. If an impossible inverse is encountered, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"residue/#Base.gcd-Union{Tuple{T}, Tuple{ResElem{T}, ResElem{T}}} where T<:RingElem","page":"Generic residue rings","title":"Base.gcd","text":"gcd(a::ResElem{T}, b::ResElem{T}) where {T <: RingElement}\n\nReturn a greatest common divisor of a and b if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.\n\n\n\n\n\n","category":"method"},{"location":"laurent_mpolynomial/#Sparse-distributed-multivariate-Laurent-polynomials","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"Every element of the multivariate Laurent polynomial ring Rx_1 x_1^-1 dots x_n x_n^-1 can be presented as a sum of products of powers of the x_i where the power can be any integer. Therefore, the interface for sparse multivarate polynomials carries over with the additional feature that exponents can be negative.","category":"section"},{"location":"laurent_mpolynomial/#Generic-multivariate-Laurent-polynomial-types","page":"Sparse distributed multivariate Laurent polynomials","title":"Generic multivariate Laurent polynomial types","text":"AbstractAlgebra.jl provides a generic implementation of multivariate Laurent polynomials, built in terms of regular multivariate polynomials, in the file src/generic/LaurentMPoly.jl.\n\nThe type LaurentMPolyWrap{T, ...} <: LaurentMPolyRingElem{T} implements generic multivariate Laurent polynomials by wrapping regular polynomials: a Laurent polynomial l wraps a polynomial p and a vector of integers n_i such that l = prod_i x_i^n_i * p. The representation is said to be normalized when each n_i is as large as possible (or zero when l is zero), but the representation of a given element is not required to be normalized internally.\n\nThe corresponding parent type is LaurentMPolyWrapRing{T, ...} <: LaurentMPolyRing{T}.","category":"section"},{"location":"laurent_mpolynomial/#Abstract-types","page":"Sparse distributed multivariate Laurent polynomials","title":"Abstract types","text":"Two abstract types LaurentMPolyRingElem{T} and LaurentMPolyRing{T} are defined to represent Laurent polynomials and rings thereof, parameterized on a base ring T.","category":"section"},{"location":"laurent_mpolynomial/#Multivate-Laurent-polynomial-operations","page":"Sparse distributed multivariate Laurent polynomials","title":"Multivate Laurent polynomial operations","text":"Since, from the point of view of the interface, Laurent polynomials are simply regular polynomials with possibly negative exponents, the following functions from the polynomial interface are completely analogous. As with regular polynomials, an implementation must provide access to the elements as a sum of individual terms in some order. This order currently cannot be specified in the constructor.\n\nlaurent_polynomial_ring(R::Ring, S::Vector{<:VarName}; cached::Bool = true)\nlaurent_polynomial_ring(R::Ring, n::Int, s::VarName; cached::Bool = false)\n\n(S::LaurentMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}})\n\nMPolyBuildCtx(R::LaurentMPolyRing)\npush_term!(M::LaurentMPolyBuildCtx, c::RingElem, v::Vector{Int})\nfinish(M::LaurentMPolyBuildCtx)\n\nsymbols(S::LaurentMPolyRing)\nnumber_of_variables(f::LaurentMPolyRing)\ngens(S::LaurentMPolyRing)\ngen(S::LaurentMPolyRing, i::Int)\nis_gen(x::LaurentMPolyRingElem)\nvar_index(p::LaurentMPolyRingElem)\nlength(f::LaurentMPolyRingElem)\n\ncoefficients(p::LaurentMPolyRingElem)\nmonomials(p::LaurentMPolyRingElem)\nterms(p::LaurentMPolyRingElem)\nexponent_vectors(p::LaurentMPolyRingElem)\nleading_coefficient(p::LaurentMPolyRingElem)\nleading_monomial(p::LaurentMPolyRingElem)\nleading_term(p::LaurentMPolyRingElem)\nleading_exponent_vector(p::LaurentMPolyRingElem)\n\nchange_base_ring(::Ring, p::LaurentMPolyRingElem)\nchange_coefficient_ring(::Ring, p::LaurentMPolyRingElem)\nmap_coefficients(::Any, p::LaurentMPolyRingElem)\n\nevaluate(p::LaurentMPolyRingElem, ::Vector)\n\nderivative(p::LaurentMPolyRingElem, x::LaurentMPolyRingElem)\nderivative(p::LaurentMPolyRingElem, i::Int)\n\nrand(R::LaurentMPolyRingElem, length_range::AbstractUnitRange{Int}, exp_range::AbstractUnitRange{Int}, v...)\n\nThe choice of canonical unit for Laurent polynomials includes the product prod_i x_i^n_i from the normalized representation. In particular, this means that the output of gcd will not have any negative exponents.\n\njulia> R, (x, y) = laurent_polynomial_ring(ZZ, [:x, :y]);\n\njulia> canonical_unit(2*x^-5 - 3*x + 4*y^-4 + 5*y^2)\n-x^-5*y^-4\n\njulia> gcd(x^-3 - y^3, x^-2 - y^2)\nx*y - 1","category":"section"},{"location":"module_homomorphism/#Module-Homomorphisms","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Abstract Algebra provides homomorphisms of finitely presented modules.","category":"section"},{"location":"module_homomorphism/#Generic-module-homomorphism-types","page":"Module Homomorphisms","title":"Generic module homomorphism types","text":"AbstractAlgebra defines two module homomorphism types, namely Generic.ModuleHomomorphism and Generic.ModuleIsomorphism. Functionality for these is implemented in src/generic/ModuleHomomorphism.jl.","category":"section"},{"location":"module_homomorphism/#Abstract-types","page":"Module Homomorphisms","title":"Abstract types","text":"The Generic.ModuleHomomorphism and Generic.ModuleIsomorphism types inherit from Map(FPModuleHomomorphism).","category":"section"},{"location":"module_homomorphism/#Generic-functionality","page":"Module Homomorphisms","title":"Generic functionality","text":"The following generic functionality is provided for module homomorphisms.","category":"section"},{"location":"module_homomorphism/#Constructors","page":"Module Homomorphisms","title":"Constructors","text":"Homomorphisms of AbstractAlgebra modules, f  R^s to R^t, can be represented by stimes t matrices over R.\n\nExamples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> f = ModuleHomomorphism(M, M, matrix(ZZ, 2, 2, [1, 2, 3, 4]))\nModule homomorphism\n  from free module of rank 2 over integers\n  to free module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> f(m)\n(7, 10)\n\n\nThey can also be created by giving images (in the codomain) of the generators of the domain:\n\nModuleHomomorphism(M1::FPModule{T}, M2::FPModule{T}, v::Vector{<:FPModuleElem{T}}) where T <: RingElement","category":"section"},{"location":"module_homomorphism/#Kernels","page":"Module Homomorphisms","title":"Kernels","text":"Examples\n\njulia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m = M([ZZ(1), ZZ(2), ZZ(3)])\n(1, 2, 3)\n\njulia> S, f = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: S -> M)\n\njulia> Q, g = quo(M, S)\n(Quotient module over integers with 2 generators and no relations, Hom: M -> Q)\n\njulia> kernel(g)\n(Submodule over integers with 1 generator and no relations, Hom: submodule over integers with 1 generator and no relations -> M)\n","category":"section"},{"location":"module_homomorphism/#Images","page":"Module Homomorphisms","title":"Images","text":"M = free_module(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\nK, k = kernel(g)\n\nimage(compose(k, g))","category":"section"},{"location":"module_homomorphism/#Preimages","page":"Module Homomorphisms","title":"Preimages","text":"M = free_module(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\n\nm = rand(M, -10:10)\nn = g(m)\n\np = preimage(g, n)","category":"section"},{"location":"module_homomorphism/#Inverses","page":"Module Homomorphisms","title":"Inverses","text":"Module isomorphisms can be cheaply inverted.\n\nM = free_module(ZZ, 2)\nN = matrix(ZZ, 2, 2, BigInt[1, 0, 0, 1])\nf = ModuleIsomorphism(M, M, N)\n\ng = inv(f)","category":"section"},{"location":"module_homomorphism/#AbstractAlgebra.ModuleHomomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"AbstractAlgebra.ModuleHomomorphism","text":"ModuleHomomorphism(M1::FPModule{T},\n                   M2::FPModule{T}, m::MatElem{T}) where T <: RingElement\n\nCreate the homomorphism f  M_1 to M_2 represented by the matrix m.\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#AbstractAlgebra.ModuleIsomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"AbstractAlgebra.ModuleIsomorphism","text":"ModuleIsomorphism(M1::FPModule{T}, M2::FPModule{T}, M::MatElem{T},\n                  minv::MatElem{T}) where T <: RingElement\n\nCreate the isomorphism f  M_1 to M_2 represented by the matrix M. The inverse morphism is automatically computed.\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#AbstractAlgebra.kernel-Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}}","page":"Module Homomorphisms","title":"AbstractAlgebra.kernel","text":"kernel(f::ModuleHomomorphism{T}) where T <: RingElement\n\nReturn a pair K, g consisting of the kernel object K of the given module homomorphism f (as a submodule of its domain) and the canonical injection from the kernel into the domain of f.\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#AbstractAlgebra.image-Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}}","page":"Module Homomorphisms","title":"AbstractAlgebra.image","text":"image(f::Map(FPModuleHomomorphism))\n\nReturn a pair I, g consisting of the image object I of the given module homomorphism f (as a submodule of its codomain) and the canonical injection from the image into the codomain of f\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#AbstractAlgebra.preimage-Union{Tuple{T}, Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}, AbstractAlgebra.FPModuleElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"AbstractAlgebra.preimage","text":"preimage(f::Map(FPModuleHomomorphism),\n         v::FPModuleElem{T}) where T <: RingElement\n\nReturn a preimage of v under the homomorphism f, i.e. an element of the domain of f that maps to v under f. Note that this has no special mathematical properties. It is an element of the set theoretical preimage of the map f as a map of sets, if one exists. The preimage is neither unique nor chosen in a canonical way in general. When no such element exists, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#AbstractAlgebra.has_preimage_with_preimage-Union{Tuple{T}, Tuple{Map{D, C, <:AbstractAlgebra.FPModuleHomomorphism, T} where {D, C, T}, AbstractAlgebra.FPModuleElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"AbstractAlgebra.has_preimage_with_preimage","text":"has_preimage_with_preimage(f::Map(FPModuleHomomorphism),\n  v::FPModuleElem{T}) where T <: RingElement\n\nCheck if v has a preimage under the homomorphism f. If it does, return a tuple (true, y) for y in domain(f) such that f(y) = x holds, otherwise, return (false, id) where id is the identity of domain(f).\n\n\n\n\n\n","category":"method"},{"location":"module_homomorphism/#Base.inv-Tuple{Map{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModuleHomomorphism, AbstractAlgebra.Generic.ModuleIsomorphism} where T<:RingElement}","page":"Module Homomorphisms","title":"Base.inv","text":"Base.inv(f::Map(ModuleIsomorphism))\n\nReturn the inverse map of the given module isomorphism. This is computed cheaply.\n\n\n\n\n\n","category":"method"},{"location":"ring_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"A rich ring hierarchy is provided, supporting both commutative and noncommutative rings.\n\nA number of basic rings are provided, such as the integers, integers mod n and numerous fields.\n\nA recursive rings implementation is then built on top of the basic rings via a number of generic ring constructions. These include univariate and multivariate polynomials and power series, univariate Laurent and Puiseux series, residue rings, matrix algebras, etc.\n\nWhere possible, these constructions can be built on top of one another in generic towers.\n\nThe ring hierarchy can be extended by implementing new rings to follow one or more ring interfaces. Generic functionality provided by the system is then automatically available for the new rings. These implementations can either be generic or can be specialised implementations provided by, for example, a C library.\n\nIn most cases, the interfaces consist of a set of constructors and functions that must be implemented to satisfy the interface. These are the functions that the generic code relies on being available.","category":"section"},{"location":"poly_interface/#Univariate-Polynomial-Ring-Interface","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings are supported in AbstractAlgebra, and in addition to the standard Ring interface, numerous additional functions are required to be present for univariate polynomial rings.\n\nUnivariate polynomial rings can be built over both commutative and noncommutative rings.\n\nUnivariate polynomial rings over a field are also Euclidean and therefore such rings must implement the Euclidean interface.\n\nSince a sparse distributed multivariate format can generally also handle sparse univariate polynomials, the univariate polynomial interface is designed around the assumption that they are dense. This is not a requirement, but it may be easier to use the multivariate interface for sparse univariate types.","category":"section"},{"location":"poly_interface/#Types-and-parents","page":"Univariate Polynomial Ring Interface","title":"Types and parents","text":"AbstractAlgebra provides two abstract types for polynomial rings and their elements over a commutative ring:\n\nPolyRing{T} is the abstract type for univariate polynomial ring parent types\nPolyRingElem{T} is the abstract type for univariate polynomial types\n\nSimilarly there are two abstract types for polynomial rings and their elements over a noncommutative ring:\n\nNCPolyRing{T} is the abstract type for univariate polynomial ring parent types\nNCPolyRingElem{T} is the abstract type for univariate polynomial types\n\nWe have that PolyRing{T} <: Ring and PolyRingElem{T} <: RingElem. Similarly we have that NCPolyRing{T} <: NCRing and NCPolyRingElem{T} <: NCRingElem.\n\nNote that the abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.\n\nIf the parent object for such a ring has type MyZX and polynomials in that ring have type MyZXPoly then one would have:\n\nMyZX <: PolyRing{BigInt}\nMyZXPoly <: PolyRingElem{BigInt}\n\nPolynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Polynomial rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator), they should certainly have the same parent object.\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"poly_interface/#Required-functionality-for-univariate-polynomials","page":"Univariate Polynomial Ring Interface","title":"Required functionality for univariate polynomials","text":"In addition to the required functionality for the Ring/NCRing interface (and in the case of polynomials over a field, the Euclidean Ring interface), the Polynomial Ring interface has the following required functions.\n\nWe suppose that R is a fictitious base ring (coefficient ring) and that S is a univariate polynomial ring over R (i.e. S = Rx) with parent object S of type MyPolyRing{T}. We also assume the polynomials in the ring have type MyPoly{T}, where T is the type of elements of the base (coefficient) ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem or NCRingElem.\n\nWe describe the functionality below for polynomials over commutative rings, i.e. with element type belonging to RingElem, however similar constructors should be available for element types belonging to NCRingElem instead, if the coefficient ring is noncommutative.","category":"section"},{"location":"poly_interface/#Constructors","page":"Univariate Polynomial Ring Interface","title":"Constructors","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.\n\n(S::MyPolyRing{T})(A::Vector{T}) where T <: RingElem\n(S::MyPolyRing{T})(A::Vector{U}) where T <: RingElem, U <: RingElem\n(S::MyPolyRing{T})(A::Vector{U}) where T <: RingElem, U <: Integer\n\nCreate the polynomial in the given ring whose degree i coefficient is given by A[1 + i]. The elements of the array are assumed to be able to be coerced into the base ring R. If the argument is an empty vector, the zero polynomial shall be returned.\n\nIt may be desirable to have a additional version of the function that accepts an array of Julia Int values  if this can be done more efficiently.\n\nIt is also possible to create polynomials directly without first creating the corresponding polynomial ring.\n\npolynomial(R::Ring, arr::Vector{T}, var::VarName=:x; cached::Bool=true)\n\nGiven an array of coefficients construct the polynomial with those coefficients over the given ring and with the given variable.\n\nnote: Note\nIf cached is set to false then the parent ring of the created polynomial is not cached. However, this means that subsequent polynomials created in the same way will not be compatible. Instead, one should use the parent object of the first polynomial to create subsequent polynomials instead of calling this function repeatedly with cached=false.","category":"section"},{"location":"poly_interface/#Data-type-and-parent-object-methods","page":"Univariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"var(S::MyPolyRing{T}) where T <: RingElem\n\nReturn a Symbol representing the variable (generator) of the polynomial ring. Note that this is a Symbol not a String, though its string value will usually be used when printing polynomials.\n\nsymbols(S::MyPolyRing{T}) where T <: RingElem\n\nReturn the array [s] where s is a Symbol representing the variable of the given polynomial ring. This is provided for uniformity with the multivariate interface, where there is more than one variable and hence an array of symbols.\n\npoly_type(::Type{T}) where T <: RingElement\n\nReturn the type of a polynomial whose coefficients have the given type. In our example MyPoly{T}.\n\nThis function is defined for generic polynomials and only needs to be defined for custom polynomial rings, e.g. ones defined by a C implementation.\n\nThe default implementation figures out the appropriate polynomial ring type via poly_type and calls its constructor with R, s, cached as arguments. In our example, this would be\n\nMyPolyRing{T}(R, s, cached)\n\nAccordingly, a poly_ring method only needs to be defined if such a constructor does not exist for poly_type(T) or if other behaviour is wanted.","category":"section"},{"location":"poly_interface/#Basic-manipulation-of-rings-and-elements","page":"Univariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"length(f::MyPoly{T}) where T <: RingElem\n\nReturn the length of the given polynomial. The length of the zero polynomial is defined to be 0, otherwise the length is the degree plus 1. The return value should be of type Int.\n\nset_length!(f::MyPoly{T}, n::Int) where T <: RingElem\n\nThis function must zero any coefficients beyond the requested length n and then set the length of the polynomial to n. This function does not need to normalise the polynomial and is not useful to the user, but is used extensively by the AbstractAlgebra generic functionality.\n\nThis function returns the resulting polynomial.\n\ncoeff(f::MyPoly{T}, n::Int) where T <: RingElem\n\nReturn the coefficient of the polynomial f of degree n. If n is larger than the degree of the polynomial, it should return zero in the coefficient ring.\n\nsetcoeff!(f::MyPoly{T}, n::Int, a::T) where T <: RingElem\n\nSet the degree n coefficient of f to a. This mutates the polynomial in-place if possible and returns the mutated polynomial (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.\n\nNote that this function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.\n\nnormalise(f::MyPoly{T}, n::Int) where T <: RingElem\n\nGiven a polynomial whose length is currently n, including any leading zero coefficients, return the length of the normalised polynomial (either zero or the length of the polynomial with nonzero leading coefficient). Note that the function does not actually perform the normalisation.\n\nfit!(f::MyPoly{T}, n::Int) where T <: RingElem\n\nEnsure that the polynomial f internally has space for n coefficients. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.\n\nSome interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.","category":"section"},{"location":"poly_interface/#Optional-functionality-for-polynomial-rings","page":"Univariate Polynomial Ring Interface","title":"Optional functionality for polynomial rings","text":"Sometimes parts of the Euclidean Ring interface can and should be implemented for polynomials over a ring that is not necessarily a field.\n\nWhen divisibility testing can be implemented for a polynomial ring over a field, it should be possible to implement the following functions from the Euclidean Ring interface:\n\ndivides\nremove\nvaluation\n\nWhen the given polynomial ring is a GCD domain, with an effective GCD algorithm, it may be possible to implement the following functions:\n\ngcd\nlcm\n\nPolynomial rings can optionally implement any part of the generic univariate polynomial functionality provided by AbstractAlgebra.jl, using the same interface.\n\nObviously additional functionality can also be added to that provided by AbstractAlgebra.jl on an ad hoc basis.","category":"section"},{"location":"poly_interface/#Similar","page":"Univariate Polynomial Ring Interface","title":"Similar","text":"The similar function is available for all univariate polynomial types, but new polynomial rings can define a specialised version of it if required.\n\nsimilar(x::MyPoly{T}, R::Ring=base_ring(x), var::VarName=var(parent(x))) where T <: RingElem\n\nConstruct the zero polynomial with the given variable and coefficients in the given ring, if specified, and with the defaults shown if not.\n\nCustom polynomial rings may choose which polynomial type is best-suited to return for any given arguments. If they don't specialise the function the default polynomial type returned is a Generic.Poly.","category":"section"},{"location":"poly_interface/#AbstractAlgebra.poly_ring-Tuple{Ring, Symbol}","page":"Univariate Polynomial Ring Interface","title":"AbstractAlgebra.poly_ring","text":"poly_ring(R::NCRing, s::Symbol; cached::Bool=false)\n\nLike polynomial_ring(R::NCRing, s::Symbol) but return only the polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"ring/#Ring-functionality","page":"Ring functionality","title":"Ring functionality","text":"AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.","category":"section"},{"location":"ring/#Abstract-types-for-rings","page":"Ring functionality","title":"Abstract types for rings","text":"All commutative ring types in AbstractAlgebra belong to the Ring abstract type and commutative ring elements belong to the RingElem abstract type.\n\nNoncommutative ring types belong to the NCRing abstract type and their elements to NCRingElem.\n\nAs Julia types cannot belong to our RingElem type hierarchy, we also provide the union type RingElement which includes RingElem in union with the Julia types Integer, Rational and AbstractFloat.\n\nSimilarly NCRingElement includes the Julia types just mentioned in union with NCRingElem.\n\nNote that\n\nRing <: NCRing\nRingElem <: NCRingElem\nRingElement <: NCRingElement","category":"section"},{"location":"ring/#Functions-for-types-and-parents-of-rings","page":"Ring functionality","title":"Functions for types and parents of rings","text":"parent_type(::Type{T}) where T <: NCRingElement\nelem_type(::Type{T}) where T <: NCRing\n\nReturn the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.\n\nbase_ring(R::NCRing)\nbase_ring(a::NCRingElement)\n\nFor generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.\n\nparent(a::NCRingElement)\n\nReturn the parent of the given ring element.\n\nis_domain_type(::Type{T}) where T <: NCRingElement\nis_exact_type(::Type{T}) where T <: NCRingElement\n\nReturn true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)\n\nThe following function is implemented where mathematically and algorithmically possible.","category":"section"},{"location":"ring/#Constructors","page":"Ring functionality","title":"Constructors","text":"If R is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.\n\n(R::NCRing)() # constructs zero\n(R::NCRing)(c::Integer)\n(R::NCRing)(c::elem_type(R))\n(R::NCRing{T})(a::T) where T <: RingElement","category":"section"},{"location":"ring/#Basic-functions","page":"Ring functionality","title":"Basic functions","text":"All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.\n\nIn addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.\n\nzero(R::NCRing)\none(R::NCRing)\niszero(a::NCRingElement)\nisone(a::NCRingElement)\n\nIn addition, the following are implemented where it is mathematically/algorithmically viable to do so.\n\nis_unit(a::NCRingElement)\nis_zero_divisor(a::NCRingElement)\nis_zero_divisor_with_annihilator(a::NCRingElement)\n\nThe following standard Julia functions are also implemented for all ring elements.\n\nhash(f::RingElement, h::UInt)\ndeepcopy_internal(a::RingElement, dict::IdDict)\nshow(io::IO, R::NCRing)\nshow(io::IO, a::NCRingElement)","category":"section"},{"location":"ring/#Basic-functionality-for-inexact-rings-only","page":"Ring functionality","title":"Basic functionality for inexact rings only","text":"By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.\n\nisequal(a::T, b::T) where T <: NCRingElement\n\nFor floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.\n\nisapprox(a::T, b::T; atol::Real=sqrt(eps())) where T <: RingElement\n\nSimilarly, for a parameterised ring with type MyElem{T} over such an inexact ring we have the following.\n\nisapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T <: RingElement\nisapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T <: RingElement\n\nThese notionally perform a coercion into the parameterised ring before doing the approximate equality test.","category":"section"},{"location":"ring/#Basic-functionality-for-commutative-rings-only","page":"Ring functionality","title":"Basic functionality for commutative rings only","text":"divexact(a::T, b::T) where T <: RingElement\ninv(a::T)\n\nReturn a/b or 1/a respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia's floating point division operator.","category":"section"},{"location":"ring/#Basic-functionality-for-noncommutative-rings-only","page":"Ring functionality","title":"Basic functionality for noncommutative rings only","text":"divexact_left(a::T, b::T) where T <: NCRingElement\ndivexact_right(a::T, b::T) where T <: NCRingElement\n\nAs per divexact above, except that division by b happens on the left or right, respectively, of a.","category":"section"},{"location":"ring/#Unsafe-ring-operators","page":"Ring functionality","title":"Unsafe ring operators","text":"To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.\n\nFor this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don't have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.\n\nNote the exclamation point is a convention, which indicates that the object may be mutated in-place.\n\nTo make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!\n\nThe results of deepcopy and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.\n\nnote: Note\nIt is important to recognise that R(a) where R is the ring a belongs to, does not create a new value. For this case, use deepcopy(a).","category":"section"},{"location":"ring/#Random-generation","page":"Ring functionality","title":"Random generation","text":"The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. -1:10 for the range of allowed degrees for a univariate polynomial.\n\nrand(R::NCRing, v...)","category":"section"},{"location":"ring/#Factorization","page":"Ring functionality","title":"Factorization","text":"For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.\n\nfactor(a::T) where T <: RingElement\nfactor_squarefree(a::T) where T <: RingElement\n\nReturn a factorization into irreducible or squarefree elements, respectively. The return is an object of type Fac{T}.","category":"section"},{"location":"ring/#Square-root","page":"Ring functionality","title":"Square root","text":"Rings may implement functionality for detecting and computing square roots.\n\nThe exact behaviour depends on the ring. Some rings provide both operations, while others only implement is_square.","category":"section"},{"location":"ring/#Miscellaneous","page":"Ring functionality","title":"Miscellaneous","text":"There are some miscellaneous functions for rings to ease up certain computations.","category":"section"},{"location":"ring/#AbstractAlgebra.characteristic-Tuple{NCRing}","page":"Ring functionality","title":"AbstractAlgebra.characteristic","text":"characteristic(R::NCRing)\n\nReturn the characteristic of the ring R. If the characteristic is not known, an exception is raised.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.zero!","page":"Ring functionality","title":"AbstractAlgebra.zero!","text":"zero!(a)\n\nReturn zero(parent(a)), possibly modifying the object a in the process.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.one!","page":"Ring functionality","title":"AbstractAlgebra.one!","text":"one!(a)\n\nReturn one(parent(a)), possibly modifying the object a in the process.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.add!","page":"Ring functionality","title":"AbstractAlgebra.add!","text":"add!(z, a, b)\nadd!(a, b)\n\nReturn a + b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for add!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.sub!","page":"Ring functionality","title":"AbstractAlgebra.sub!","text":"sub!(z, a, b)\nsub!(a, b)\n\nReturn a - b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for sub!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.mul!","page":"Ring functionality","title":"AbstractAlgebra.mul!","text":"mul!(z, a, b)\nmul!(a, b)\n\nReturn a * b, possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for mul!(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.neg!","page":"Ring functionality","title":"AbstractAlgebra.neg!","text":"neg!(z, a)\nneg!(a)\n\nReturn -a, possibly modifying the object z in the process. Aliasing is permitted. The unary version is a shorthand for neg!(a, a).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.inv!","page":"Ring functionality","title":"AbstractAlgebra.inv!","text":"inv!(z, a)\ninv!(a)\n\nReturn AbstractAlgebra.inv(a), possibly modifying the object z in the process. Aliasing is permitted. The unary version is a shorthand for inv!(a, a).\n\nnote: Note\nAbstractAlgebra.inv and Base.inv differ only in their behavior on julia types like Integer and Rational{Int}. The former makes it adhere to the Ring interface.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.addmul!","page":"Ring functionality","title":"AbstractAlgebra.addmul!","text":"addmul!(z, a, b, t)\naddmul!(z, a, b)\n\nReturn z + a * b, possibly modifying the objects z and t in the process.\n\nThe second version is usually a shorthand for addmul!(z, a, b, parent(z)()), but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.submul!","page":"Ring functionality","title":"AbstractAlgebra.submul!","text":"submul!(z, a, b, t)\nsubmul!(z, a, b)\n\nReturn z - a * b, possibly modifying the objects z and t in the process.\n\nThe second version is usually a shorthand for submul!(z, a, b, parent(z)()), but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.divexact!","page":"Ring functionality","title":"AbstractAlgebra.divexact!","text":"divexact!(z, a, b)\ndivexact!(a, b)\n\nReturn divexact(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for divexact(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.div!","page":"Ring functionality","title":"AbstractAlgebra.div!","text":"div!(z, a, b)\ndiv!(a, b)\n\nReturn div(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for div(a, a, b).\n\nnote: Note\nAbstractAlgebra.div and Base.div differ only in their behavior on julia types like Integer and Rational{Int}. The former makes it adhere to the Ring interface.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.rem!","page":"Ring functionality","title":"AbstractAlgebra.rem!","text":"rem!(z, a, b)\nrem!(a, b)\n\nReturn rem(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for rem(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.mod!","page":"Ring functionality","title":"AbstractAlgebra.mod!","text":"mod!(z, a, b)\nmod!(a, b)\n\nReturn mod(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for mod(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.gcd!","page":"Ring functionality","title":"AbstractAlgebra.gcd!","text":"gcd!(z, a, b)\ngcd!(a, b)\n\nReturn gcd(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for gcd(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.lcm!","page":"Ring functionality","title":"AbstractAlgebra.lcm!","text":"lcm!(z, a, b)\nlcm!(a, b)\n\nReturn lcm(a, b), possibly modifying the object z in the process. Aliasing is permitted. The two argument version is a shorthand for lcm(a, a, b).\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.is_irreducible-Tuple{T} where T<:RingElement","page":"Ring functionality","title":"AbstractAlgebra.is_irreducible","text":"is_irreducible(a::RingElement)\n\nReturn true if a is irreducible, else return false. Zero and units are by definition never irreducible.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.is_squarefree-Tuple{T} where T<:RingElement","page":"Ring functionality","title":"AbstractAlgebra.is_squarefree","text":"is_squarefree(a::RingElement)\n\nReturn true if a is squarefree, else return false. An element is squarefree if it it is not divisible by any squares except the squares of units.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.Fac","page":"Ring functionality","title":"AbstractAlgebra.Fac","text":"Fac{T <: RingElement}\n\nType for factored ring elements. The structure holds a unit of type T and is an iterable collection of T => Int pairs for the factors and exponents.\n\nSee unit(a::Fac), evaluate(a::Fac).\n\n\n\n\n\n","category":"type"},{"location":"ring/#AbstractAlgebra.unit-Tuple{Fac}","page":"Ring functionality","title":"AbstractAlgebra.unit","text":"unit(a::Fac{T}) -> T\n\nReturn the unit of the factorization.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.evaluate-Tuple{Fac}","page":"Ring functionality","title":"AbstractAlgebra.evaluate","text":"evaluate(a::Fac{T}) -> T\n\nMultiply out the factorization into a single element.\n\n\n\n\n\n","category":"method"},{"location":"ring/#Base.getindex-Tuple{Fac, Any}","page":"Ring functionality","title":"Base.getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"ring/#Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}","page":"Ring functionality","title":"Base.setindex!","text":"setindex!(a::Fac{T}, c::Int, b::T)\n\nIf b is a factor of a, the corresponding entry is set to c.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.is_square","page":"Ring functionality","title":"AbstractAlgebra.is_square","text":"is_square(a::NCRingElement)\n\nReturn true iff a is the square of a value in its own ring. See also is_square(M::MatElem) which tests whether a matrix has square shape.\n\n\n\n\n\nis_square(M::MatElem)\n\nReturn true iff the matrix M has square shape. See also is_square(a::T)  where {T <: NCRingElement} which tests whether the given value a is a square in its own ring.\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.sqrt-Tuple{NCRingElem}","page":"Ring functionality","title":"AbstractAlgebra.sqrt","text":"sqrt(a::NCRingElem; check::Bool=true)\n\nReturn a square root of a, if it exists. By default (check=true), implementations should raise an exception if a is not a square in its ring. If check=false, implementations may skip this verification.\n\nSee also is_square and is_square_with_sqrt.\n\n\n\n\n\n","category":"method"},{"location":"ring/#AbstractAlgebra.Generic.falling_factorial","page":"Ring functionality","title":"AbstractAlgebra.Generic.falling_factorial","text":"falling_factorial(x::RingElement, n::Integer)\n\nReturn the falling factorial of x, i.e. x(x - 1)(x - 2)cdots (x - n + 1). If n  0 we throw a DomainError().\n\nExamples\n\njulia> R, x = ZZ[:x];\n\njulia> falling_factorial(x, 1)\nx\n\njulia> falling_factorial(x, 2)\nx^2 - x\n\njulia> falling_factorial(4, 2)\n12\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.Generic.rising_factorial","page":"Ring functionality","title":"AbstractAlgebra.Generic.rising_factorial","text":"rising_factorial(x::RingElement, n::Integer)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)cdots (x + n - 1). If n  0 we throw a DomainError().\n\nExamples\n\njulia> R, x = ZZ[:x];\n\njulia> rising_factorial(x, 1)\nx\n\njulia> rising_factorial(x, 2)\nx^2 + x\n\njulia> rising_factorial(4, 2)\n20\n\n\n\n\n\n","category":"function"},{"location":"ring/#AbstractAlgebra.Generic.rising_factorial2","page":"Ring functionality","title":"AbstractAlgebra.Generic.rising_factorial2","text":"rising_factorial2(x::RingElement, n::Integer)\n\nReturn a tuple containing the rising factorial x(x + 1)cdots (x + n - 1) and its derivative. If n  0 we throw a DomainError().\n\nExamples\n\njulia> R, x = ZZ[:x];\n\njulia> rising_factorial2(x, 1)\n(x, 1)\n\njulia> rising_factorial2(x, 2)\n(x^2 + x, 2*x + 1)\n\njulia> rising_factorial2(4, 2)\n(20, 9)\n\n\n\n\n\n","category":"function"},{"location":"perm/#Permutations-and-Symmetric-groups","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in src/generic/PermGroups.jl). All functionality of permutations is accessible in the Generic submodule.\n\nPermutations are represented internally via vector of integers, wrapped in type Perm{T}, where T<:Integer carries the information on the type of elements of a permutation. Symmetric groups are singleton parent objects of type SymmetricGroup{T} and are used mostly to store the length of a permutation, since it is not included in the permutation type.\n\nSymmetric groups are created using the SymmetricGroup (inner) constructor.\n\nBoth SymmetricGroup and Perm and can be parametrized by any type T<:Integer . By default the parameter is the Int-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as Int32, UInt16, or even Int8), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticeable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.\n\nAll the permutation group types belong to the Group abstract type and the corresponding permutation element types belong to the GroupElem abstract type.","category":"section"},{"location":"perm/#Permutations-constructors","page":"Permutations and Symmetric groups","title":"Permutations constructors","text":"There are several methods to construct permutations in AbstractAlgebra.jl.\n\nThe easiest way is to directly call to the Perm (inner) constructor:\n\nSince the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitly constructing the parent object.\n\nThe other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor SymmetricGroup(n::Integer) which constructs the permutation group on n symbols and returns the parent object representing the group.\n\nA vector of integers can be then coerced to a permutation by calling a parent permutation group on it.   The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.\n\nExamples:\n\njulia> G = SymmetricGroup(BigInt(5)); p = G([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(p)\nPerm{BigInt}\n\njulia> H = SymmetricGroup(UInt16(5)); r = H([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(r)\nPerm{UInt16}\n\njulia> one(H)\n()\n\nBy default the coercion checks for non-unique values in the vector, but this can be switched off with G([2,3,1,5,4], false).\n\nFinally there is a perm\"...\" string macro to construct a permutation from a string input.","category":"section"},{"location":"perm/#Permutation-interface","page":"Permutations and Symmetric groups","title":"Permutation interface","text":"The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide the group element arithmetic and comparison.\n\nA custom implementation also needs to implement hash(::Perm, ::UInt) and (possibly) deepcopy_internal(::Perm, ::IdDict).\n\nnote: Note\nPermutation group elements are mutable and so returning shallow copies is not sufficient.\n\ngetindex(a::Perm, n::Integer)\n\nAllow access to entry n of the given permutation via the syntax a[n]. Note that entries are 1-indexed.\n\nsetindex!(a::Perm, d::Integer, n::Integer)\n\nSet the n-th entry of the given permutation to d. This allows Julia to provide the syntax a[n] = d for setting entries of a permutation. Entries are 1-indexed.\n\nnote: Note\nUsing setindex! invalidates the cycle decomposition cached in a permutation, which will be computed the next time it is needed.\n\nGiven the parent object G for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.\n\none(G)\n\nReturn the identity permutation.\n\nG(A::Vector{<:Integer})\n\nReturn the permutation whose entries are given by the elements of the supplied vector.\n\nG(p::Perm)\n\nTake a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.","category":"section"},{"location":"perm/#Basic-manipulation","page":"Permutations and Symmetric groups","title":"Basic manipulation","text":"Numerous functions are provided to manipulate permutation group elements.\n\nCycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.\n\nNote that even an Int64 can be easily overflowed when computing with symmetric groups. Thus, by default, order returns (always correct) BigInts. If you are sure that the computation will not overflow, you may use order(::Type{T}, ...) to perform computations with machine integers. Julia's standard promotion rules apply for the returned value.\n\nSince SymmetricGroup implements the iterator protocol, you may iterate over all permutations via a simple loop:\n\nfor p in SymmetricGroup(n)\n   ...\nend\n\nIteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when n  13.\n\nYou may also use the non-allocating Generic.elements! function for n  14 (or even 15 if you are patient enough), which is an order of magnitude faster.\n\nHowever, since all permutations yielded by elements! are aliased (modified \"in-place\"), collect(Generic.elements!(SymmetricGroup(n))) returns a vector of identical permutations.\n\nnote: Note\nIf you intend to use or store elements yielded by elements! you need to deepcopy them explicitly.","category":"section"},{"location":"perm/#Arithmetic-operators","page":"Permutations and Symmetric groups","title":"Arithmetic operators","text":"Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:\n\ng = rand(SymmetricGroup(Int8(5)));\nh = rand(SymmetricGroup(UInt32(5)));\ntypeof(g*h)\n\n# output\nPerm{UInt32}","category":"section"},{"location":"perm/#Coercion","page":"Permutations and Symmetric groups","title":"Coercion","text":"The following coercions are available for G::SymmetricGroup parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.\n\nExamples\n\n(G::SymmetricGroup)(::AbstractVector{<:Integer}[, check=true])\n\nTurn a vector of integers into a permutation (performing conversion, if necessary).\n\n(G::SymmetricGroup)(::Perm[, check=true])\n\nCoerce a permutation p into group G (performing the conversion, if necessary). If p is already an element of G no copy is performed.\n\n(G::SymmetricGroup)(::String[, check=true])\n\nParse the string input e.g. copied from the output of GAP. The method uses the same logic as the perm\"...\" macro. The string is sanitized and checked for disjoint cycles. Both string(p::Perm) (if setpermstyle(:cycles)) and string(cycles(p::Perm)) are valid input for this method.\n\n(G::SymmetricGroup{T})(::CycleDec{T}[, check=true]) where T\n\nTurn a cycle decomposition object into a permutation.","category":"section"},{"location":"perm/#Comparison","page":"Permutations and Symmetric groups","title":"Comparison","text":"","category":"section"},{"location":"perm/#Misc","page":"Permutations and Symmetric groups","title":"Misc","text":"","category":"section"},{"location":"perm/#AbstractAlgebra.Generic.setpermstyle","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.setpermstyle","text":"setpermstyle(format::Symbol)\n\nSelect the style in which permutations are displayed (in the REPL or in general as strings). This can be either\n\n:array - as vector of integers whose n-th position represents the value at n), or\n:cycles - as, more familiar for mathematicians, decomposition into disjoint cycles, where the value at n is represented by the entry immediately following n in a cycle (the default).\n\nThe difference is purely esthetical.\n\nExamples\n\njulia> setpermstyle(:array)\n:array\n\njulia> Perm([2,3,1,5,4])\n[2, 3, 1, 5, 4]\n\njulia> setpermstyle(:cycles)\n:cycles\n\njulia> Perm([2,3,1,5,4])\n(1,2,3)(4,5)\n\n\n\n\n\n","category":"function"},{"location":"perm/#AbstractAlgebra.Perm","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Perm","text":"Perm{T<:Integer}\n\nThe type of permutations. Fieldnames:\n\nd::Vector{T} - vector representing the permutation\nmodified::Bool - bit to check the validity of cycle decomposition\ncycles::CycleDec{T} - (cached) cycle decomposition\n\nA permutation p consists of a vector (p.d) of n integers from 1 to n. If the i-th entry of the vector is j, this corresponds to p sending i to j. The cycle decomposition (p.cycles) is computed on demand and should never be accessed directly. Use cycles(p) instead.\n\nThere are two inner constructors of Perm:\n\nPerm(n::T) constructs the trivial Perm{T}-permutation of length n.\nPerm(v::AbstractVector{<:Integer} [,check=true]) constructs a permutation represented by v. By default Perm constructor checks if the vector constitutes a valid permutation. To skip the check call Perm(v, false).\n\nExamples\n\njulia> Perm([1,2,3])\n()\n\njulia> g = Perm(Int32[2,3,1])\n(1,2,3)\n\njulia> typeof(g)\nPerm{Int32}\n\n\n\n\n\n","category":"type"},{"location":"perm/#AbstractAlgebra.Generic.SymmetricGroup","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.SymmetricGroup","text":"SymmetricGroup{T<:Integer}\n\nThe full symmetric group singleton type. SymmetricGroup(n) constructs the full symmetric group S_n on n-symbols. The type of elements of the group is inferred from the type of n.\n\nExamples\n\njulia> G = SymmetricGroup(5)\nFull symmetric group over 5 elements\n\njulia> elem_type(G)\nPerm{Int64}\n\njulia> H = SymmetricGroup(UInt16(5))\nFull symmetric group over 5 elements\n\njulia> elem_type(H)\nPerm{UInt16}\n\n\n\n\n\n","category":"type"},{"location":"perm/#AbstractAlgebra.Generic.@perm_str","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.@perm_str","text":"perm\"...\"\n\nString macro to parse disjoint cycles into Perm{Int}.\n\nStrings for the output of GAP could be copied directly into perm\"...\". Cycles of length 1 are not necessary, but can be included. A permutation of the minimal support is constructed, i.e. the maximal n in the decomposition determines the parent group S_n.\n\nExamples\n\njulia> p = perm\"(1,3)(2,4)\"\n(1,3)(2,4)\n\njulia> typeof(p)\nPerm{Int64}\n\njulia> parent(p) == SymmetricGroup(4)\ntrue\n\njulia> p = perm\"(1,3)(2,4)(10)\"\n(1,3)(2,4)\n\njulia> parent(p) == SymmetricGroup(10)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"perm/#AbstractAlgebra.Generic.cycles-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.cycles","text":"cycles(g::Perm)\n\nDecompose permutation g into disjoint cycles.\n\nReturn a CycleDec object which iterates over disjoint cycles of g. The ordering of cycles is not guaranteed, and the order within each cycle is computed up to a cyclic permutation. The cycle decomposition is cached in g and used in future computation of permtype, parity, sign, order and ^ (powering).\n\nExamples\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> collect(cycles(g))\n3-element Vector{Vector{Int64}}:\n [1, 3, 5]\n [2, 4]\n [6]\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.parity-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.parity","text":"parity(g::Perm)\n\nReturn the parity of the given permutation, i.e. the parity of the number of transpositions in any decomposition of g into transpositions.\n\nparity returns 1 if the number is odd and 0 otherwise. parity uses cycle decomposition of g if already available, but will not compute it on demand. Since cycle structure is cached in g you may call cycles(g) before calling parity.\n\nExamples\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> parity(g)\n0\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> parity(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.sign-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"Base.sign","text":"sign(g::Perm)\n\nReturn the sign of a permutation.\n\nsign returns 1 if g is even and -1 if g is odd. sign represents the homomorphism from the permutation group to the unit group of mathbbZ whose kernel is the alternating group.\n\nExamples\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> sign(g)\n1\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> sign(g)\n-1\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.permtype-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.permtype","text":"permtype(g::Perm)\n\nReturn the type of permutation g, i.e. lengths of disjoint cycles in cycle decomposition of g.\n\nThe lengths are sorted in decreasing order by default. permtype(g) fully determines the conjugacy class of g.\n\nExamples\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> permtype(g)\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> e = one(g)\n()\n\njulia> permtype(e)\n6-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.elements!","text":"Generic.elements!(G::SymmetricGroup)\n\nReturn an unsafe iterator over all permutations in G. Only one permutation is allocated and then modified in-place using the non-recursive Heaps algorithm.\n\nNote: you need to explicitly copy permutations intended to be stored or modified.\n\nExamples\n\njulia> elts = Generic.elements!(SymmetricGroup(5));\n\n\njulia> length(elts)\n120\n\njulia> for p in Generic.elements!(SymmetricGroup(3))\n         println(p)\n       end\n()\n(1,2)\n(1,3,2)\n(2,3)\n(1,2,3)\n(1,3)\n\njulia> A = collect(Generic.elements!(SymmetricGroup(3))); A\n6-element Vector{Perm{Int64}}:\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n\njulia> unique(A)\n1-element Vector{Perm{Int64}}:\n (1,3)\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.:*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T","page":"Permutations and Symmetric groups","title":"Base.:*","text":"*(g::Perm, h::Perm)\n\nReturn the composition h  g of two permutations.\n\nThis corresponds to the action of permutation group on the set [1..n] on the right and follows the convention of GAP.\n\nIf g and h are parametrized by different types, the result is promoted accordingly.\n\nExamples\n\njulia> Perm([2,3,1,4])*Perm([1,3,4,2]) # (1,2,3)*(2,3,4)\n(1,3)(2,4)\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.:^-Tuple{Perm, Integer}","page":"Permutations and Symmetric groups","title":"Base.:^","text":"^(g::Perm, n::Integer)\n\nReturn the n-th power of a permutation g.\n\nBy default g^n is computed by cycle decomposition of g if n > 3. Generic.power_by_squaring provides a different method for powering which may or may not be faster, depending on the particular case. Due to caching of the cycle structure, repeated powering of g will be faster with the default method.\n\nExamples\n\njulia> g = Perm([2,3,4,5,1])\n(1,2,3,4,5)\n\njulia> g^3\n(1,4,2,5,3)\n\njulia> g^5\n()\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.inv-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"Base.inv","text":"Base.inv(g::Perm)\n\nReturn the inverse of the given permutation, i.e. the permutation g^-1 such that g  g^-1 = g^-1  g is the identity permutation.\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.:==-Tuple{Perm, Perm}","page":"Permutations and Symmetric groups","title":"Base.:==","text":"==(g::Perm, h::Perm)\n\nReturn true if permutations are equal, otherwise return false.\n\nPermutations parametrized by different integer types are considered equal if they define the same permutation in the abstract permutation group.\n\nExamples\n\njulia> g = Perm(Int8[2,3,1])\n(1,2,3)\n\njulia> h = perm\"(3,1,2)\"\n(1,2,3)\n\njulia> g == h\ntrue\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.:==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"Base.:==","text":"==(G::SymmetricGroup, H::SymmetricGroup)\n\nReturn true if permutation groups are equal, otherwise return false.\n\nPermutation groups on the same number of letters, but parametrized by different integer types are considered different.\n\nExamples\n\njulia> G = SymmetricGroup(UInt(5))\nPermutation group over 5 elements\n\njulia> H = SymmetricGroup(5)\nPermutation group over 5 elements\n\njulia> G == H\nfalse\n\n\n\n\n\n","category":"method"},{"location":"perm/#Base.rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"Base.rand","text":"rand([rng=Random.default_rng(),] G::SymmetricGroup)\n\nReturn a random permutation from G.\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.matrix_repr-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.matrix_repr","text":"matrix_repr(a::Perm)\n\nReturn the permutation matrix as a sparse matrix representing a via natural embedding of the permutation group into the general linear group over mathbbZ.\n\nExamples\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> matrix_repr(p)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n ⋅  1  ⋅\n ⋅  ⋅  1\n 1  ⋅  ⋅\n\njulia> Array(ans)\n3×3 Matrix{Int64}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\n\n\nmatrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n 1  2  3  4\n 5  6  7  ⋅\n 8  ⋅  ⋅  ⋅\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.emb","text":"emb(G::SymmetricGroup, V::Vector{Int}, check::Bool=true)\n\nReturn the natural embedding of a permutation group into G as the subgroup permuting points indexed by V.\n\nExamples\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> f = Generic.emb(SymmetricGroup(5), [3,2,5]);\n\n\njulia> f(p)\n(2,5,3)\n\n\n\n\n\n","category":"method"},{"location":"perm/#AbstractAlgebra.Generic.emb!-Tuple{Perm, Perm, Any}","page":"Permutations and Symmetric groups","title":"AbstractAlgebra.Generic.emb!","text":"emb!(result::Perm, p::Perm, V)\n\nEmbed permutation p into permutation result on the indices given by V.\n\nThis corresponds to the natural embedding of S_k into S_n as the subgroup permuting points indexed by V.\n\nExamples\n\njulia> p = Perm([2,1,4,3])\n(1,2)(3,4)\n\njulia> Generic.emb!(Perm(collect(1:5)), p, [3,1,4,5])\n(1,3)(4,5)\n\n\n\n\n\n","category":"method"},{"location":"matrix_interface/#Matrix-Interface","page":"Matrix Interface","title":"Matrix Interface","text":"Generic matrices are supported in AbstractAlgebra.jl. Both the space of mtimes n matrices and the algebra (ring) of mtimes m matrices are supported.\n\nAs the space of mtimes n matrices over a commutative ring is not itself a commutative ring, not all of the Ring interface needs to be implemented for such matrices in.\n\nIn particular, the following functions do not need to be implemented: is_domain_type, and divexact. The canonical_unit function should be implemented, but simply needs to return the corresponding value for entry 1 1 (the function is never called on empty matrices).\n\nFor matrix algebras, all of the ring interface must be implemented.\n\nnote: Note\nAbstractAlgebra.jl matrices are not the same as Julia matrices. We store a base ring in our matrix and matrices are row major instead of column major in order to support the numerous large C libraries that use this convention.\n\nAll AbstractAlgebra.jl matrices are assumed to be mutable. This is usually critical to performance.","category":"section"},{"location":"matrix_interface/#Types-and-parents","page":"Matrix Interface","title":"Types and parents","text":"AbstractAlgebra provides two types for matrix spaces and their elements:\n\nMatSpace{T} is the concrete type for matrix space parent types\nMatElem{T} is the abstract type for matrix types belonging to a matrix space\n\nIt also provides two abstract types for matrix algebras and their elements:\n\nMatRing{T} is the abstract type for matrix algebra parent types\nMatRingElem{T} is the abstract type for matrix types belonging to a matrix algebra\n\nNote that these abstract types are parameterised. The type T should usually be the type of elements of the matrices.\n\nMatrix spaces and matrix algebras should be made unique on the system by either making them struct types, or by caching parent objects (unless an optional cache parameter is set to false). Matrix spaces and algebras should at least be distinguished based on their base (coefficient) ring and the dimensions of the matrices in the space.\n\nSee src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"section"},{"location":"matrix_interface/#Required-functionality-for-matrices","page":"Matrix Interface","title":"Required functionality for matrices","text":"In addition to the required (relevant) functionality for the Ring interface (see above), the following functionality is required for the Matrix interface.\n\nWe suppose that R is a fictitious base ring (coefficient ring) and that S is a space of mtimes n matrices over R, or ring of mtimes m matrices with parent object S of type MatSpace{T} or MyMatRing{T}, respectively. We also assume the matrices in the space have type MyMat{T}, where T is the type of elements of the base (element) ring.\n\nOf course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.\n\nNote that the type T must (transitively) belong to the abstract type RingElem.\n\nCurrently only matrices over commutative rings are supported.","category":"section"},{"location":"matrix_interface/#Constructors","page":"Matrix Interface","title":"Constructors","text":"In addition to the standard constructors, the following constructors, taking an array of elements, must be available.\n\n(S::MatSpace{T})(A::Matrix{T}) where T <: RingElem\n(S::MyMatRing{T})(A::Matrix{T}) where T <: RingElem\n\nCreate the matrix in the given space/algebra whose (i j) entry is given by A[i, j].\n\n(S::MatSpace{T})(A::Matrix{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatRing{T})(A::Matrix{S}) where {S <: RingElem, T <: RingElem}\n\nCreate the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.\n\n(S::MatSpace{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatRing{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n\nCreate the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.\n\nIt is also possible to create matrices (in a matrix space only) directly, without first creating the corresponding matrix space (the inner constructor being called directly). Note that to support this, matrix space parent objects don't contain a reference to their parent. Instead, parents are constructed on-the-fly if requested. (The same strategy is used for matrix algebras.)\n\nmatrix(R::Ring, arr::Matrix{T}) where T <: RingElem\n\nGiven an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.\n\nmatrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T <: RingElem\n\nConstruct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.\n\nzero_matrix(R::Ring, r::Int, c::Int)\n\nConstruct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.","category":"section"},{"location":"matrix_interface/#Views","page":"Matrix Interface","title":"Views","text":"Just as Julia supports views of matrices, AbstractAlgebra requires all matrix types to support views. These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.\n\nNote that deepcopy of a view type must return the same type, but it should return a view into a deepcopy of the original matrix. Julia enforces this for consistency.\n\nTo support views, generic matrices in AbstractAlgebra of type Generic.MatSpaceElem have an associated Generic.MatSpaceView type. Both belong to the Generic.Mat abstract type, so that one can work with that in functions that can accept both views and actual matrices.\n\nThe syntax for views is as for Julia's own views.\n\nNote that the parent_type function returns the same type for a view as for the original matrix type. This could potentially cause a problem if the elem_type function is applied to the return value of parent_type and then used in a type assertion. For this reason, there may be some limitations on the use of views.\n\nThe similar function also returns a matrix of type MatSpaceElem when applied to a view, rather than another view.","category":"section"},{"location":"matrix_interface/#Basic-manipulation-of-matrices","page":"Matrix Interface","title":"Basic manipulation of matrices","text":"dense_matrix_type(::Type{T}) where T<:NCRingElement\ndense_matrix_type(::T) where T<:NCRingElement\ndense_matrix_type(::Type{S}) where S<:NCRing\ndense_matrix_type(::S) where S<:NCRing\n\nReturn the type of dense matrices whose entries have type T respectively elem_type(S). It suffices to provide a method with the first signature. For the other three signatures, the default methods dispatch to the first. E.g. in Nemo, which depends on AbstractAlgebra, we define dense_matrix_type(::Type{ZZRingElem}) = ZZMatrix.\n\nnumber_of_rows(M::MatSpace{T}) where T <: RingElem\nnumber_of_rows(M::MyMatRing{T}) where T <: RingElem\n\nReturn the number of rows of matrices in the matrix space.\n\nnumber_of_columns(M:MatSpace{T}) where T <: RingElem\nnumber_of_columns(M:MyMatRing{T}) where T <: RingElem\n\nReturn the number of columns of matrices in the matrix space.\n\nnumber_of_rows(f::MyMat{T}) where T <: RingElem\n\nReturn the number of rows of the given matrix.\n\nnumber_of_columns(f::MyMat{T}) where T <: RingElem\n\nReturn the number of columns of the given matrix.\n\ngetindex(M::MyMat{T}, r::Int, c::Int) where T <: RingElem\n\nReturn the (i j)-th entry of the matrix M.\n\nsetindex!(M::MyMat{T}, d::T, r::Int, c::Int) where T <: RingElem\n\nSet the (i j)-th entry of the matrix M to d, which is assumed to be in the base ring of the matrix. The matrix must have such an entry and the matrix is mutated in place and not returned from the function.","category":"section"},{"location":"matrix_interface/#Transpose","page":"Matrix Interface","title":"Transpose","text":"transpose(::MyMat{T}) where T <: RingElem\n\nReturn the transpose of the given matrix.","category":"section"},{"location":"matrix_interface/#Optional-functionality-for-matrices","page":"Matrix Interface","title":"Optional functionality for matrices","text":"Especially when wrapping C libraries, some functions are best implemented directly, rather than relying on the generic functionality. The following are all provided by the AbstractAlgebra.jl generic code, but can optionally be implemented directly for performance reasons.","category":"section"},{"location":"matrix_interface/#Optional-submatrices","page":"Matrix Interface","title":"Optional submatrices","text":"The following are only available for matrix spaces, not for matrix algebras.\n\nBase.getindex(M::MyMat, rows::AbstractVector{Int}, cols::AbstractVector{Int})\n\nReturn a new matrix with the same entries as the submatrix with the given range of rows and columns.","category":"section"},{"location":"matrix_interface/#Optional-row-swapping","page":"Matrix Interface","title":"Optional row swapping","text":"swap_rows!(M::MyMat{T}, i::Int, j::Int) where T <: RingElem\n\nSwap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"section"},{"location":"matrix_interface/#Optional-concatenation","page":"Matrix Interface","title":"Optional concatenation","text":"The following are only available for matrix spaces, not for matrix algebras.\n\nhcat(M::MyMat{T}, N::MyMat{T}) where T <: RingElem\n\nReturn the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.\n\nvcat(M::MyMat{T}, N::MyMat{T}) where T <: RingElem\n\nReturn the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.","category":"section"},{"location":"matrix_interface/#Optional-zero-tests","page":"Matrix Interface","title":"Optional zero tests","text":"The following functions are available for matrices in both matrix algebras and matrix spaces.\n\nis_zero_entry(M::MatrixElem{T}, i::Int, j::Int) where T <: NCRingElement\nis_zero_row(M::MatrixElem{T}, i::Int) where T <: NCRingElement\nis_zero_column(M::MatrixElem{T}, j::Int) where T <: NCRingElement","category":"section"},{"location":"matrix_interface/#Optional-similar-and-zero","page":"Matrix Interface","title":"Optional similar and zero","text":"The following functions are available for matrices in both matrix algebras and matrix spaces. Both similar and zero construct new matrices, with the same methods, but the entries are either undefined with similar or zero-initialized with zero.\n\nsimilar(x::MyMat{T}, R::Ring=base_ring(x)) where T <: RingElem\nzero(x::MyMat{T}, R::Ring=base_ring(x)) where T <: RingElem\n\nConstruct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.\n\nsimilar(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: RingElem\nsimilar(x::MyMat{T}, r::Int, c::Int) where T <: RingElem\nzero(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: RingElem\nzero(x::MyMat{T}, r::Int, c::Int) where T <: RingElem\n\nConstruct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).\n\nCustom matrices and rings may choose which specific matrix type is best-suited to return for the given ring and dimensionality. If they do not specialize these functions, the default is a Generic.MatSpaceElem matrix, or Generic.MatRingElem for matrix algebras. The default implementation of zero calls out to similar, so it's generally sufficient to specialize only similar. For both similar and zero, only the most general method has to be implemented (e.g. similar(x::MyMat, R::Ring, r::Int, c::Int), as all other methods (which have defaults) call out to this more general method.\n\nBase.isassigned(M::MyMat, i, j)\n\nTest whether the given matrix has a value associated with indices i and j. It is recommended to overload this method for custom matrices.","category":"section"},{"location":"matrix_interface/#Optional-symmetry-test","page":"Matrix Interface","title":"Optional symmetry test","text":"is_symmetric(a::MatrixElem)\n\nReturn true if the given matrix is symmetric with respect to its main diagonal, otherwise return false.","category":"section"},{"location":"ideal_interface/#Ideal-Interface","page":"Ideal Interface","title":"Ideal Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented by anyone implementing ideals for commutative rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their ideals. There are already many helper methods in AbstractAlgebra.jl for the methods mentioned below.\n\nIn addition to the required functions, there are also optional functions which can be provided for certain types of ideals e.g., for ideals of polynomial rings. If implemented, these allow the generic code to provide additional functionality for those ideals, or in some cases, to select more efficient algorithms.","category":"section"},{"location":"ideal_interface/#Types-and-parents","page":"Ideal Interface","title":"Types and parents","text":"Below we describe this interface for a fictitious type NewIdeal representing ideals over a base ring of type NewRing, with element type NewRingElem. To make use of the functionality described on this page, NewIdeal must be a subtype of Ideal{NewRingElem}. To inform the system about this relationship, it is necessary to provide the following method:\n\nideal_type(::Type{NewRing}) = NewIdeal\n\njulia The system automatically provides the following reverse method:\n\nbase_ring_type(::Type{NewIdeal}) = NewRing\n\nFor ideals of a Euclidean domain, it may also be possibly to opt into using the existing functionality  which is implemented in src/generic/Ideal.jl. In that case you would essentially defined const NewIdeal = Generic.Ideal{NewRingElem}. For more information about implementing new rings, see the Ring interface.","category":"section"},{"location":"ideal_interface/#Required-functionality-for-ideals","page":"Ideal Interface","title":"Required functionality for ideals","text":"In the following, we list all the functions that are required to be provided for ideals in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.\n\nTo facilitate construction of new ideals, implementations must provide a method with signature\n\nideal(R::NewRing, xs::Vector{NewRingElem})\n\nHere xs is a list of generators, and NewRingElem === elem_type(NewRing) holds.\n\nWith this in place, the following additional ideal constructors will automatically work via generic implementations:\n\nideal(R::NewRing, x::RingElement...) = ideal(R, [x...])\nideal(x::RingElement, y::RingElement...) = ideal(parent(x), x, y...)\nideal(xs::Vector{NewRingElem}) = ideal(parent(xs[1]), xs)\n*(x::NewRingElem, R::NewRing) = ideal(R, x)\n*(R::NewRing, x::NewRingElem) = ideal(R, x)\n\nIn addition sums and products of ideals can be formed:\n\n+(I::T, J::T) where {T <: NewIdeal}\n*(I::T, J::T) where {T <: NewIdeal}\n\nAn implementation of an Ideal subtype must also provide the following methods:\n\nbase_ring(I::NewIdeal)\ngen(I::NewIdeal, k::Int)\ngens(I::NewIdeal)\nngens(I::NewIdeal)","category":"section"},{"location":"ideal_interface/#Optional-functionality-for-ideals","page":"Ideal Interface","title":"Optional functionality for ideals","text":"Some functionality is difficult or impossible to implement for all ideals. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can't be relied on by generic functions in the AbstractAlgebra Ideal interface.\n\nIt may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn't exist.\n\nThe following method have no generic implementation and only work when explicitly implemented.\n\nin(v::NewRingElem, I::NewIdeal)\nintersect(I::T, J::T) where {T <: NewIdeal}\n\nIf a method for in as above is provided, then the following automatically works:\n\nissubset(I::NewIdeal, J::NewIdeal)\n\nIf a method for in as above is provided (e.g. indirectly by providing method for in), then the following automatically works:\n\n==(I::T, J::T) where {T <: NewIdeal}\n\nNote that implementing == for a Julia type means that we have to provide a matching hash method which preserves the invariant that I == J implies hash(I) == hash(J). We provide such a method but by necessity it is very conservative and hence does not provide good hashing. You may wish to implement a better hash methods.\n\nThe following method is implemented generically via the ideal generators.\n\niszero(I::Ideal) = all(iszero, gens(I))","category":"section"},{"location":"univpolynomial/#Universal-polynomial","page":"Universal polynomial","title":"Universal polynomial","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/UnivPoly.jl for a universal polynomial ring. This is very similar to the multivariate polynomial rings, except that variables can be added to the ring at any time.\n\nTo compensate for the fact that the number of variables may change, many of the functions relax their restrictions on exponent vectors. For example, if one creates a polynomial when the ring only has two variables, each exponent vector would consist of two integers. Later, when the ring has more variable, these exponent vectors will still be accepted. The exponent vectors are simply padded out to the full number of variables behind the scenes.","category":"section"},{"location":"univpolynomial/#Generic-sparse-distributed-universal-multivariable-polynomial-types","page":"Universal polynomial","title":"Generic sparse distributed universal multivariable polynomial types","text":"AbstractAlgebra provides a generic universal polynomial type Generic.UnivPoly{T, U} where T is the type of elements of the coefficient ring and U is the type of the elements of the underlying multivariate polynomial ring. Essentially, U can be any type belonging to MPolyRingElem{T}.\n\nParent objects of such polynomials have type Generic.UniversalPolyRing{T, U}.","category":"section"},{"location":"univpolynomial/#Abstract-types","page":"Universal polynomial","title":"Abstract types","text":"AbstractAlgebra also provides abstract types for universal polynomials and their rings. These are UniversalPolyRingElem{T, U} and UniversalPolyRing{T, U} respectively. These in turn belong to Ring.","category":"section"},{"location":"univpolynomial/#Polynomial-ring-constructors","page":"Universal polynomial","title":"Polynomial ring constructors","text":"In order to construct universal polynomials in AbstractAlgebra.jl, one must first construct the universal polynomial ring itself. This is unique given a base ring.\n\nThe universal polynomial ring over a given base ring R is constructed with one of the following constructor functions.","category":"section"},{"location":"univpolynomial/#Adding-variables","page":"Universal polynomial","title":"Adding variables","text":"There are two ways to add variables to a universal polynomial ring S.\n\ngen(S::UniversalPolyRing, var::VarName)\ngens(S::UniversalPolyRing, vars::Vector{VarName})\n\nExamples\n\njulia> S = universal_polynomial_ring(ZZ)\nUniversal Polynomial Ring over Integers\n\njulia> x = gen(S, :x)\nx\n\njulia> number_of_generators(S)\n1\n\njulia> y, z = gens(S, [:y, :z])\n2-element Vector{AbstractAlgebra.Generic.UnivPoly{BigInt}}:\n y\n z\n\njulia> number_of_generators(S)\n3","category":"section"},{"location":"univpolynomial/#Universal-polynomial-functionality","page":"Universal polynomial","title":"Universal polynomial functionality","text":"The universal polynomial ring behaves exactly like a multivariate polynomial ring with the few differences noted above.\n\nThe only functionality not implemented is the ability to do divrem by an ideal of polynomials.\n\nThe universal polynomial ring is very useful for doing symbolic manipulation. However, it is important to understand that AbstractAlgebra is not a symbolic system and the performance of the universal polynomial ring will closely match that of a multivariate polynomial ring with the same number of variables.\n\nThe disadvantage of this approach to symbolic manipulation is that some manipulations that would be offered by a symbolic system are not available, as variables are not identified by their names alone in AbstractAlgebra, as would be the case symbolically, but by objects.\n\nThe most powerful symbolic tools we offer are the generalised evaluation functions, the multivariate coefficient functionality, the ability to change coefficient ring and to map coefficients according to a supplied function and the ability to convert a multivariate which happens to have just one variable into a dense univariate polynomial.\n\nFurther facilities may be added in future to ease symbolic manipulations.","category":"section"},{"location":"univpolynomial/#AbstractAlgebra.universal_polynomial_ring","page":"Universal polynomial","title":"AbstractAlgebra.universal_polynomial_ring","text":"universal_polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached::Bool=true, internal_ordering::Symbol=:lex)\nuniversal_polynomial_ring(R::Ring; cached::Bool=true, internal_ordering::Symbol=:lex)\n\nGiven a coefficient ring R and variable names, say varnames = [:x1, :x2, ...], return a tuple S, [x1, x2, ...] of the universal polynomial ring S = R[x1, x2, \\dots] and its generators x1, x2, \\dots.\n\nIf varnames is omitted, return an object representing the universal polynomial ring S = R[\\ldots] with no variables in it initially.\n\nExamples\n\njulia> S, (x,y) = universal_polynomial_ring(ZZ, [:x,:y])\n(Universal Polynomial Ring over Integers, AbstractAlgebra.Generic.UnivPoly{BigInt}[x, y])\n\njulia> z = gen(S, :z)\nz\n\njulia> x*y - z\nx*y - z\n\njulia> S = universal_polynomial_ring(ZZ)\nUniversal Polynomial Ring over Integers\n\njulia> x = gen(S, :x)\nx\n\njulia> y, z = gens(S, [:y, :z])\n2-element Vector{AbstractAlgebra.Generic.UnivPoly{BigInt}}:\n y\n z\n\njulia> x*y - z\nx*y - z\n\n\n\n\n\n","category":"function"},{"location":"field/#Field-functionality","page":"Field functionality","title":"Field functionality","text":"","category":"section"},{"location":"field/#Abstract-types-for-rings","page":"Field functionality","title":"Abstract types for rings","text":"All field types in AbstractAlgebra belong to the Field abstract type and field elements belong to the FieldElem abstract type.\n\nAs Julia types cannot belong to our FieldElem type hierarchy, we also provide the union type FieldElement which includes FieldElem in union with the Julia types Rational and AbstractFloat.\n\nNote that\n\nField <: Ring\nFieldElem <: RingElem\nFieldElement <: RingElement\n\nOf course all Ring functionality is available for AbstractAlgebra fields and their elements.","category":"section"},{"location":"field/#Functions-for-types-and-parents-of-fields","page":"Field functionality","title":"Functions for types and parents of fields","text":"characteristic(R::MyParent)\n\nReturn the characteristic of the field. If the characteristic is not known, an exception is raised.","category":"section"},{"location":"field/#Basic-functions","page":"Field functionality","title":"Basic functions","text":"is_unit(f::MyElem)\n\nReturn true if the given element is invertible, i.e. nonzero in the field.","category":"section"},{"location":"submodule/#Submodules","page":"Submodules","title":"Submodules","text":"AbstractAlgebra allows the construction of submodules/subvector spaces of AbstractAlgebra modules over euclidean domains. These are given as the submodule generated by a finite list of elements in the original module.\n\nWe define two submodules to be equal if they are (transitively) submodules of the same module M and their generators generate the same set of elements.","category":"section"},{"location":"submodule/#Generic-submodule-type","page":"Submodules","title":"Generic submodule type","text":"AbstractAlgebra implements a generic submodule type Generic.Submodule{T} where T is the element type of the base ring in src/generic/Submodule.jl. See src/generic/GenericTypes.jl for more details of the type definition.\n\nElements of a generic submodule have type Generic.SubmoduleElem{T}.","category":"section"},{"location":"submodule/#Abstract-types","page":"Submodules","title":"Abstract types","text":"Submodule types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"section"},{"location":"submodule/#Constructors","page":"Submodules","title":"Constructors","text":"Note that the preimage of the canonical injection can be obtained using the preimage function described in the section on module homomorphisms. As the canonical injection is injective, this is unique.\n\nExamples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> n = M([ZZ(2), ZZ(-1)])\n(2, -1)\n\njulia> N, f = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: N -> M)\n\njulia> v = N([ZZ(3), ZZ(4)])\n(3, 4)\n\njulia> v2 = f(v)\n(3, 26)\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> n = V([QQ(2), QQ(-1)])\n(2//1, -1//1)\n\njulia> N, f = sub(V, [m, n])\n(Subspace over rationals with 2 generators and no relations, Hom: N -> V)\n","category":"section"},{"location":"submodule/#Functionality-for-submodules","page":"Submodules","title":"Functionality for submodules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"section"},{"location":"submodule/#Basic-manipulation","page":"Submodules","title":"Basic manipulation","text":"Examples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1, = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: N1 -> M)\n\njulia> N2, = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: N2 -> M)\n\njulia> supermodule(N1) == M\ntrue\n\njulia> is_compatible(N1, N2)\n(true, Free module of rank 2 over integers)\n\njulia> is_submodule(N1, M)\nfalse\n\njulia> V = vector_space(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> m = V([QQ(2), QQ(3)])\n(2//1, 3//1)\n\njulia> N, = sub(V, [m])\n(Subspace over rationals with 1 generator and no relations, Hom: N -> V)\n\njulia> dim(V)\n2\n\njulia> dim(N)\n1","category":"section"},{"location":"submodule/#Intersection","page":"Submodules","title":"Intersection","text":"Examples\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1 = sub(M, [m, n])\n(Submodule over integers with 2 generators and no relations, Hom: submodule over integers with 2 generators and no relations -> M)\n\njulia> N2 = sub(M, [m])\n(Submodule over integers with 1 generator and no relations, Hom: submodule over integers with 1 generator and no relations -> M)\n\njulia> I = intersect(N1, N2)\nAny[]","category":"section"},{"location":"submodule/#AbstractAlgebra.sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.FPModuleElem{T}, 1}}} where T<:RingElement","page":"Submodules","title":"AbstractAlgebra.sub","text":"sub(m::FPModule{T}, gens::Vector{<:FPModuleElem{T}}) where T <: RingElement\n\nReturn the submodule of the module m generated by the given generators, given as elements of m.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#AbstractAlgebra.sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.Generic.Submodule{T}, 1}}} where T<:RingElement","page":"Submodules","title":"AbstractAlgebra.sub","text":"sub(m::Module{T}, subs::Vector{<:Generic.Submodule{T}}) where T <: RingElement\n\nReturn the submodule S of the module m generated by the union of the given submodules of m, and a map which is the canonical injection from S to m.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#AbstractAlgebra.Generic.supermodule-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:RingElement","page":"Submodules","title":"AbstractAlgebra.Generic.supermodule","text":"supermodule(M::Submodule{T}) where T <: RingElement\n\nReturn the module that this module is a submodule of.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#AbstractAlgebra.Generic.is_submodule-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"AbstractAlgebra.Generic.is_submodule","text":"is_submodule(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if N was constructed as a submodule of M. The relation is taken transitively (i.e. subsubmodules are submodules for the purposes of this relation, etc). The module M is also considered a submodule of itself for this relation.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#AbstractAlgebra.Generic.is_compatible-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"AbstractAlgebra.Generic.is_compatible","text":"is_compatible(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true, P if the given modules are compatible, i.e. that they are (transitively) submodules of the same module, P. Otherwise return false, M.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#AbstractAlgebra.Generic.dim-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:FieldElement","page":"Submodules","title":"AbstractAlgebra.Generic.dim","text":"dim(N::Submodule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector subspace.\n\n\n\n\n\n","category":"method"},{"location":"submodule/#Base.intersect-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"Base.intersect","text":"intersect(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn the intersection of the modules M as a submodule of M. Note that M and N must be (constructed as) submodules (transitively) of some common module P.\n\n\n\n\n\n","category":"method"},{"location":"module/#Finitely-presented-modules","page":"Finitely presented modules","title":"Finitely presented modules","text":"AbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules.\n\nThe generic code provided by AbstractAlgebra will only work for modules over euclidean domains.\n\nFree modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"section"},{"location":"module/#Abstract-types","page":"Finitely presented modules","title":"Abstract types","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:\n\nFPModule{T} is the abstract type for finitely presented module parent\n\ntypes\n\nFPModuleElem{T} is the abstract type for finitely presented module\n\nelement types\n\nNote that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"section"},{"location":"module/#Module-functions","page":"Finitely presented modules","title":"Module functions","text":"All finitely presented modules over a Euclidean domain implement the following functions.","category":"section"},{"location":"module/#Basic-functions","page":"Finitely presented modules","title":"Basic functions","text":"zero(M::FPModule)\n\niszero(m::FPModuleElem{T}) where T <: RingElement\n\nReturn true if the given module element is zero.\n\nnumber_of_generators(M::FPModule{T}) where T <: RingElement\n\nReturn the number of generators of the module M in its current representation.\n\ngen(M::FPModule{T}, i::Int) where T <: RingElement\n\nReturn the i-th generator (indexed from 1) of the module M.\n\ngens(M::FPModule{T}) where T <: RingElement\n\nReturn a Julia array of the generators of the module M.\n\nrels(M::FPModule{T}) where T <: RingElement\n\nReturn a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.\n\nExamples\n\njulia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> n = number_of_generators(M)\n2\n\njulia> G = gens(M)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)\n\njulia> R = rels(M)\nAbstractAlgebra.Generic.MatSpaceElem{Rational{BigInt}}[]\n\njulia> g1 = gen(M, 1)\n(1//1, 0//1)\n\njulia> !iszero(g1)\ntrue\n\njulia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> z = zero(M)\n(0//1, 0//1)\n\njulia> iszero(z)\ntrue","category":"section"},{"location":"module/#Element-constructors","page":"Finitely presented modules","title":"Element constructors","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.\n\n(M::FPModule{T})(v::Vector{T}) where T <: RingElement\n\nConstruct the element of the module M corresponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"section"},{"location":"module/#Coercions","page":"Finitely presented modules","title":"Coercions","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.\n\nIn particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.\n\nExamples\n\nF = free_module(ZZ, 3)\n\nS1, f = sub(F, [rand(F, -10:10)])\n\nS, g = sub(F, [rand(F, -10:10)])\nQ, h = quo(F, S)\n\nm = rand(S1, -10:10)\nn = Q(m)","category":"section"},{"location":"module/#Arithmetic-operators","page":"Finitely presented modules","title":"Arithmetic operators","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.\n\nIn the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"section"},{"location":"module/#Basic-manipulation","page":"Finitely presented modules","title":"Basic manipulation","text":"zero(M::FPModule)\n\nExamples\n\njulia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> z = zero(M)\n(0//1, 0//1)","category":"section"},{"location":"module/#Element-indexing","page":"Finitely presented modules","title":"Element indexing","text":"Examples\n\njulia> F = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m = F(BigInt[2, -5, 4])\n(2, -5, 4)\n\njulia> m[1]\n2","category":"section"},{"location":"module/#Module-comparison","page":"Finitely presented modules","title":"Module comparison","text":"Examples\n\njulia> M = free_module(QQ, 2)\nVector space of dimension 2 over rationals\n\njulia> M == M\ntrue\n","category":"section"},{"location":"module/#Isomorphism","page":"Finitely presented modules","title":"Isomorphism","text":"note: Note\nNote that this function relies on the Smith normal form over the base ring of the modules being able to be made unique. This is true for Euclidean domains for which divrem has a fixed choice of quotient and remainder, but it will not in general be true for Euclidean rings that are not domains.\n\nExamples\n\njulia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m1 = rand(M, -10:10)\n(3, -1, 0)\n\njulia> m2 = rand(M, -10:10)\n(4, 4, -7)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S -> M)\n\njulia> I, g = image(f)\n(Submodule over integers with 2 generators and no relations, Hom: I -> M)\n\njulia> is_isomorphic(S, I)\ntrue\n","category":"section"},{"location":"module/#Invariant-Factor-Decomposition","page":"Finitely presented modules","title":"Invariant Factor Decomposition","text":"For modules over a euclidean domain one can take the invariant factor decomposition to determine the structure of the module. The invariant factors are unique up to multiplication by a unit, and even unique if a canonical_unit is available for the ring that canonicalises elements.\n\nExamples\n\njulia> M = free_module(ZZ, 3)\nFree module of rank 3 over integers\n\njulia> m1 = rand(M, -10:10)\n(3, -1, 0)\n\njulia> m2 = rand(M, -10:10)\n(4, 4, -7)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S -> M)\n\njulia> Q, g = quo(M, S)\n(Quotient module over integers with 2 generators and relations:\n[16 -21], Hom: M -> Q)\n\njulia> I, f = snf(Q)\n(Invariant factor decomposed module over integers with invariant factors BigInt[0], Hom: I -> Q)\n\njulia> invs = invariant_factors(Q)\n1-element Vector{BigInt}:\n 0\n","category":"section"},{"location":"module/#Base.getindex-Union{Tuple{AbstractAlgebra.FPModuleElem{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"Base.getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"module/#AbstractAlgebra.coordinates-Union{Tuple{AbstractAlgebra.FPModuleElem{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"AbstractAlgebra.coordinates","text":"coordinates(v::FPModuleElem{T}, i::Int) where T <: RingElement\n\nReturn the coordinates of the module element v as a Vector{T}.\n\n\n\n\n\n","category":"method"},{"location":"module/#Base.:==-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"Base.:==","text":"==(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules are (constructed to be) the same module elementwise. This is not object equality and it is not isomorphism. In fact, each method of constructing modules (submodules, quotient modules, products, etc.) must extend this notion of equality to the modules they create.\n\n\n\n\n\n","category":"method"},{"location":"module/#AbstractAlgebra.is_isomorphic-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules M and N are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"module/#AbstractAlgebra.snf-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"AbstractAlgebra.snf","text":"snf(m::FPModule{T}) where T <: RingElement\n\nReturn a pair M, f consisting of the invariant factor decomposition M of the module m and a module homomorphism (isomorphisms) f  M to m. The module M is itself a module which can be manipulated as any other module in the system.\n\n\n\n\n\n","category":"method"},{"location":"module/#AbstractAlgebra.invariant_factors-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"AbstractAlgebra.invariant_factors","text":"invariant_factors(m::FPModule{T}) where T <: RingElement\n\nReturn a vector of the invariant factors of the module M.\n\n\n\n\n\n","category":"method"},{"location":"direct_sum/#Direct-Sums","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra allows the construction of the external direct sum of any nonempty vector of finitely presented modules.\n\nNote that external direct sums are considered equal iff they are the same object.","category":"section"},{"location":"direct_sum/#Generic-direct-sum-type","page":"Direct Sums","title":"Generic direct sum type","text":"AbstractAlgebra provides a generic direct sum type Generic.DirectSumModule{T} where T is the element type of the base ring. The implementation is in src/generic/DirectSum.jl\n\nElements of direct sum modules have type Generic.DirectSumModuleElem{T}.","category":"section"},{"location":"direct_sum/#Abstract-types","page":"Direct Sums","title":"Abstract types","text":"Direct sum module types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"section"},{"location":"direct_sum/#Constructors","page":"Direct Sums","title":"Constructors","text":"Examples\n\njulia> F = free_module(ZZ, 5)\nFree module of rank 5 over integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S1 -> F)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S2 -> F)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S3 -> F)\n\njulia> D, f = direct_sum(S1, S2, S3)\n(DirectSumModule over integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: S1 -> D, Hom: S2 -> D, Hom: S3 -> D], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: D -> S1, Hom: D -> S2, Hom: D -> S3])","category":"section"},{"location":"direct_sum/#Functionality-for-direct-sums","page":"Direct Sums","title":"Functionality for direct sums","text":"In addition to the Module interface, AbstractAlgebra direct sums implement the following functionality.","category":"section"},{"location":"direct_sum/#Basic-manipulation","page":"Direct Sums","title":"Basic manipulation","text":"Examples\n\njulia> F = free_module(ZZ, 5)\nFree module of rank 5 over integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S1 -> F)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S2 -> F)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over integers with 2 generators and no relations, Hom: S3 -> F)\n\njulia> D, f = direct_sum(S1, S2, S3)\n(DirectSumModule over integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: S1 -> D, Hom: S2 -> D, Hom: S3 -> D], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Hom: D -> S1, Hom: D -> S2, Hom: D -> S3])\n\njulia> summands(D)\n3-element Vector{AbstractAlgebra.Generic.Submodule{BigInt}}:\n Submodule over integers with 2 generators and no relations\n Submodule over integers with 2 generators and no relations\n Submodule over integers with 2 generators and no relations\n\n    (D::DirectSumModule{T}(::Vector{<:FPModuleElem{T}}) where T <: RingElement\n\nGiven a vector (or 1-dim array) of module elements, where the i-th entry has to be an element of the i-summand of D, create the corresponding element in D.\n\nExamples\n\njulia> N = free_module(QQ, 1);\n\njulia> M = free_module(QQ, 2);\n\njulia> D, _ = direct_sum(M, N, M);\n\njulia> D([gen(M, 1), gen(N, 1), gen(M, 2)])\n(1//1, 0//1, 1//1, 0//1, 1//1)","category":"section"},{"location":"direct_sum/#Special-Homomorphisms","page":"Direct Sums","title":"Special Homomorphisms","text":"Due to the special structure as direct sums, homomorphisms can be created by specifying homomorphisms for all summands. In case of the codmain being a direct sum as well, any homomorphism may be thought of as a matrix containing maps from the i-th source summand to the j-th target module:\n\nModuleHomomorphism(D::DirectSumModule{T}, S::DirectSumModule{T}, m::Matrix{Any}) where T <: RingElement\n\nGiven a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.\n\nModuleHomomorphism(D::DirectSumModule{T}, S::FPModuleElem{T}, m::Vector{ModuleHomomorphism})\n\nGiven an array a of ModuleHomomorphism such that a_i, the i-th entry of a is a ModuleHomomorphism from the i-th summand of D into S, construct the direct sum of the components.\n\nGiven a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.\n\nExamples\n\njulia> N = free_module(QQ, 2);\n\njulia> D, _ = direct_sum(N, N);\n\njulia> p = ModuleHomomorphism(N, N, [3,4] .* basis(N));\n\njulia> q = ModuleHomomorphism(N, N, [5,7] .* basis(N));\n\njulia> phi = ModuleHomomorphism(D, D, [p 0; 0 q])\nModule homomorphism\n  from DirectSumModule over rationals\n  to DirectSumModule over rationals\n\njulia> r = ModuleHomomorphism(N, D, [2,3] .* gens(D)[1:2])\nModule homomorphism\n  from vector space of dimension 2 over rationals\n  to DirectSumModule over rationals\n\njulia> psi = ModuleHomomorphism(D, D, [r, r])\nModule homomorphism\n  from DirectSumModule over rationals\n  to DirectSumModule over rationals","category":"section"},{"location":"direct_sum/#AbstractAlgebra.direct_sum","page":"Direct Sums","title":"AbstractAlgebra.direct_sum","text":"direct_sum(m::Vector{<:FPModule{T}}) where T <: RingElement\ndirect_sum(vals::FPModule{T}...) where T <: RingElement\n\nReturn a tuple M f g consisting of M the direct sum of the modules m (supplied as a vector of modules), a vector f of the injections of the mi into M and a vector g of the projections from M onto the mi.\n\n\n\n\n\n","category":"function"},{"location":"direct_sum/#AbstractAlgebra.Generic.summands-Union{Tuple{AbstractAlgebra.Generic.DirectSumModule{T}}, Tuple{T}} where T<:RingElement","page":"Direct Sums","title":"AbstractAlgebra.Generic.summands","text":"summands(M::DirectSumModule{T}) where T <: RingElement\n\nReturn the modules that this module is a direct sum of.\n\n\n\n\n\n","category":"method"}]
}
