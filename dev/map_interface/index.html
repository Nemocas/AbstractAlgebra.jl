<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Map Interface · AbstractAlgebra.jl</title><meta name="title" content="Map Interface · AbstractAlgebra.jl"/><meta property="og:title" content="Map Interface · AbstractAlgebra.jl"/><meta property="twitter:title" content="Map Interface · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li class="is-active"><a class="tocitem" href>Map Interface</a><ul class="internal"><li><a class="tocitem" href="#Parent-objects"><span>Parent objects</span></a></li><li><a class="tocitem" href="#Map-classes"><span>Map classes</span></a></li><li><a class="tocitem" href="#Implementing-new-map-types"><span>Implementing new map types</span></a></li><li><a class="tocitem" href="#Required-functionality-for-maps"><span>Required functionality for maps</span></a></li><li><a class="tocitem" href="#Optional-functionality-for-maps"><span>Optional functionality for maps</span></a></li></ul></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>Map Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Map Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/map_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Map-Interface"><a class="docs-heading-anchor" href="#Map-Interface">Map Interface</a><a id="Map-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Map-Interface" title="Permalink"></a></h1><p>Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.</p><p>In the following, we will always use the word &quot;function&quot; to mean a Julia function, and reserve the word &quot;map&quot; for a map on sets, whether mathematically, or as an object in the system.</p><h2 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h2><p>Maps in AbstractAlgebra currently don&#39;t have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.</p><h2 id="Map-classes"><a class="docs-heading-anchor" href="#Map-classes">Map classes</a><a id="Map-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Map-classes" title="Permalink"></a></h2><p>All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from <code>SetMap</code> at the top of the hierarchy. Other classes that inherit from <code>SetMap</code> are <code>FunctionalMap</code> for maps that are constructed from a Julia function (or closure), and <code>IdentityMap</code> for the class of the identity maps within the system.</p><p>One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.</p><p>Instead, a map type <code>MyMap</code> will belong to an abstract type of the form <code>Map{D, C, T, MyMap}</code>, where <code>D</code> is the type of the object representing the domain of the map type (this can also be an abstract type, such as <code>Group</code>), <code>C</code> is the type of the object representing the codomain of the map type and <code>T</code> is the map class that <code>MyMap</code> belongs to, e.g. <code>SetMap</code> or <code>FunctionalMap</code>.</p><p>Because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.</p><p>If writing a function that accepts any map type, one makes the type of its argument belong to <code>Map</code>. For example <code>f(M::Map) = 1</code>.</p><p>If writing a function that accepts any map from a domain of type <code>D</code> to a codomain of type <code>C</code>, one makes writes for example <code>f(M::Map{D, C}) = 2</code>. Note that <code>D</code> and <code>C</code> can be abstract types, such as <code>Group</code>, but otherwise must be the types of the parent objects representing the domain and codomain.</p><p>A function that accepts any map belonging to a given map class might be written as <code>f(M::Map(FunctionalMap)) = 3</code> or <code>f(M::Map(FunctionalMap){D, C}) = 4</code> for example, where <code>D</code> and <code>C</code> are the types of the parent objects for the domain and codomain.</p><p>Finally, if a function should only work for a map of a given map type <code>MyMap</code>, say, one writes this <code>f(M::Map(MyMap))</code> or <code>f(M::Map(MyMap){D, C}</code>, where as usual <code>D</code> and <code>C</code> are the types of the domain and codomain parent objects.</p><h2 id="Implementing-new-map-types"><a class="docs-heading-anchor" href="#Implementing-new-map-types">Implementing new map types</a><a id="Implementing-new-map-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-map-types" title="Permalink"></a></h2><p>There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.</p><p>In the case of fixed domain and codomain, e.g. <code>Integers{BigInt}</code>, we would write it as follows:</p><pre><code class="language-julia hljs">mutable struct MyMap &lt;: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}
   # some data fields
end</code></pre><p>In the case of parameterisation by the type of the domain and codomain:</p><pre><code class="language-julia hljs">mutable struct MyMap{D, C} &lt;: Map{D, C, SetMap, MyMap}
   # some data fields
end</code></pre><p>As mentioned above, to write a function that only accepts maps of type <code>MyMap</code>, one writes the functions as follows:</p><pre><code class="language-julia hljs">function my_fun(M::Map(MyMap))</code></pre><p>The <code>Map</code> function then computes the correct type to use, which is actually not <code>MyMap</code> if all features of the generic Map infrastructure are required. It is bad practice to write functions for <code>MyMap</code> directly instead of <code>Map(MyMap)</code>, since other users will be unable to use generic constructions over the map type <code>MyMap</code>.</p><h2 id="Required-functionality-for-maps"><a class="docs-heading-anchor" href="#Required-functionality-for-maps">Required functionality for maps</a><a id="Required-functionality-for-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-maps" title="Permalink"></a></h2><p>All map types must implement a standard interface, which we specify here.</p><p>We will define this interface for a custom map type <code>MyMap</code> belonging to <code>Map(SetMap)</code>, <code>SetMap</code> being the map class that all maps types belong to.</p><p>Note that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.</p><p>The required accessors for map types of class <code>SetMap</code> are as follows.</p><pre><code class="language-julia hljs">domain(M::Map(MyMap))
codomain(M::Map(MyMap))</code></pre><p>Return the domain and codomain parent objects respectively, for the map <span>$M$</span>. It is only necessary to define these functions if the map type <code>MyMap</code> does not contain fields <code>domain</code> and <code>codomain</code> containing these parent objects.</p><p>It is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to <code>Map(MyMap)</code>.</p><pre><code class="language-julia hljs">(M::Map(MyMap)(a))</code></pre><p>Apply the map <code>M</code> to the element <code>a</code> of the domain of <code>M</code>. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type <code>elem_type(C)</code> where <code>C</code> is the type of the codomain parent object.</p><h2 id="Optional-functionality-for-maps"><a class="docs-heading-anchor" href="#Optional-functionality-for-maps">Optional functionality for maps</a><a id="Optional-functionality-for-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-maps" title="Permalink"></a></h2><p>The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.</p><p>However, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.</p><p>We describe this optional functionality here.</p><h3 id="Show-method"><a class="docs-heading-anchor" href="#Show-method">Show method</a><a id="Show-method-1"></a><a class="docs-heading-anchor-permalink" href="#Show-method" title="Permalink"></a></h3><p>Custom map types may like to provide a custom <code>show</code> method if the default of displaying the domain and codomain of the map is not sufficient.</p><pre><code class="language-julia hljs">show(io::IO, M::Map(MyMap))</code></pre><h3 id="Identity-maps"><a class="docs-heading-anchor" href="#Identity-maps">Identity maps</a><a id="Identity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-maps" title="Permalink"></a></h3><p>There is a concrete map type <code>Generic.IdentityMap{D}</code> for the identity map on a given domain. Here <code>D</code> is the type of the object representing that domain.</p><p><code>Generic.IdentityMap</code> belongs to the supertype <code>Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}</code>.</p><p>Note that the map class is also called <code>IdentityMap</code>. It is an abstract type, whereas <code>Generic.IdentityMap</code> is a concrete type in the Generic module.</p><p>An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.</p><p>We do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.</p><p>To construct an identity map for a given domain, specified by a parent object <code>R</code>, say, we have the following function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.identity_map-Tuple{AbstractAlgebra.Set}" href="#AbstractAlgebra.identity_map-Tuple{AbstractAlgebra.Set}"><code>AbstractAlgebra.identity_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">identity_map(R::D) where D &lt;: AbstractAlgebra.Set</code></pre><p>Return an identity map on the domain <span>$R$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = ZZ[:t]
(Univariate polynomial ring in t over integers, t)

julia&gt; f = identity_map(R)
Identity map
  of univariate polynomial ring in t over integers

julia&gt; f(t)
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/b02dca91fda6b006ec6ad8394bc463d2e103f30c/src/Map.jl#L99-L116">source</a></section></article><p>Return an identity map on the domain <span>$R$</span>.</p><p>Of course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to <code>IdentityMap</code> so that composition with other map types still works.</p><h3 id="Composition-of-maps"><a class="docs-heading-anchor" href="#Composition-of-maps">Composition of maps</a><a id="Composition-of-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-maps" title="Permalink"></a></h3><p>Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.</p><p>In order to facilitate this, the Generic module provides a type <code>Generic.CompositeMap{D, C}</code>, which contains two maps <code>map1</code> and <code>map2</code>, corresponding to the two maps to be applied in a composition, in the order they should be applied.</p><p>To construct a composition map from two existing maps, we have the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.compose-Tuple{Map, Map}" href="#AbstractAlgebra.compose-Tuple{Map, Map}"><code>AbstractAlgebra.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(f::Map, g::Map)</code></pre><p>Compose the two maps <span>$f$</span> and <span>$g$</span>, i.e. return the map <span>$h$</span> such that <span>$h(x) = g(f(x))$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = map_from_func(x -&gt; x + 1, ZZ, ZZ);

julia&gt; g = map_from_func(x -&gt; QQ(x), ZZ, QQ);

julia&gt; h = compose(f, g)
Functional composite map
  from integers
  to rationals
which is the composite of
  Map: integers -&gt; integers
  Map: integers -&gt; rationals</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/b02dca91fda6b006ec6ad8394bc463d2e103f30c/src/Map.jl#L66-L85">source</a></section></article><p>As a shortcut for this function we have the following operator:</p><pre><code class="language-julia hljs">*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)</code></pre><p>Note the order of composition. If we have maps <span>$f : X \to Y$</span>, <span>$g : Y \to Z$</span> the correct order of the maps in this operator is <code>f*g</code>, so that <code>(f*g)(x) = g(f(x))</code>.</p><p>This is chosen so that for left <span>$R$</span>-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.</p><p>Of course, a custom map type or class of maps can implement its own composition type and compose function.</p><p>This is the case with the <code>FunctionalMap</code> class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.</p><p>By default, <code>compose</code> will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:</p><pre><code class="language-julia hljs">check_composable(f::Map{D, U}, g::Map{U, C})</code></pre><p>Raise an exception if the codomain of <span>$f$</span> doesn&#39;t match the domain of <span>$g$</span>.</p><p>Note that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:</p><pre><code class="language-julia hljs">map1(f::CompositeMap)
map2(f::CompositeMap)</code></pre><p>Any custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_interface/">« Matrix Interface</a><a class="docs-footer-nextpage" href="../rand/">Random interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 23 October 2024 03:35">Wednesday 23 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
