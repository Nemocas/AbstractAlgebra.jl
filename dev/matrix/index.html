<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix functionality · AbstractAlgebra.jl</title><meta name="title" content="Matrix functionality · AbstractAlgebra.jl"/><meta property="og:title" content="Matrix functionality · AbstractAlgebra.jl"/><meta property="twitter:title" content="Matrix functionality · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Matrix functionality</a><ul class="internal"><li><a class="tocitem" href="#Basic-matrix-functionality"><span>Basic matrix functionality</span></a></li><li><a class="tocitem" href="#Inverse"><span>Inverse</span></a></li><li><a class="tocitem" href="#Submatrices"><span>Submatrices</span></a></li><li><a class="tocitem" href="#Elementary-row-and-column-operations"><span>Elementary row and column operations</span></a></li><li><a class="tocitem" href="#Swapping-rows-and-columns"><span>Swapping rows and columns</span></a></li><li><a class="tocitem" href="#Concatenation"><span>Concatenation</span></a></li><li><a class="tocitem" href="#Linear-solving"><span>Linear solving</span></a></li><li><a class="tocitem" href="#Block-diagonal-matrix-constructors"><span>Block diagonal matrix constructors</span></a></li><li><a class="tocitem" href="#Similar-and-zero"><span>Similar and zero</span></a></li><li><a class="tocitem" href="#LU-factorisation"><span>LU factorisation</span></a></li><li><a class="tocitem" href="#Reduced-row-echelon-form"><span>Reduced row-echelon form</span></a></li><li><a class="tocitem" href="#Other-functionality"><span>Other functionality</span></a></li></ul></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Matrices</a></li><li class="is-active"><a href>Matrix functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix functionality</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/matrix.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="matrix_functionality_chapter"><a class="docs-heading-anchor" href="#matrix_functionality_chapter">Matrix functionality</a><a id="matrix_functionality_chapter-1"></a><a class="docs-heading-anchor-permalink" href="#matrix_functionality_chapter" title="Permalink"></a></h1><h2 id="Basic-matrix-functionality"><a class="docs-heading-anchor" href="#Basic-matrix-functionality">Basic matrix functionality</a><a id="Basic-matrix-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-matrix-functionality" title="Permalink"></a></h2><p>As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices and to set and retrieve entries and other basic data associated with the matrices.</p><p>It is possible to create matrices directly, without first creating a corresponding matrix space. The following constructors are necessary, because unfortunately, Julia&#39;s matrices and linear algebra cannot be made to work in our context due to two independent problems:</p><ul><li>In empty matrices (0 rows or columns) all that is known is the type of the matrix entries, </li></ul><p>however for the complex types used in AbstractAlgebra, this information is not sufficient to create elements, hence <code>zero(T)</code> or friends cannot work</p><ul><li>Many functions (e.g. <code>det</code>) assume that all types used embed into the real or complex numbers,</li></ul><p>in Julia <code>det(ones(Int, (1,1))) == 1.0</code>, so the fact that this is exactly the integer <code>1</code> is lost. Furthermore, more general rings cannot be embedded into the reals at all.</p><pre><code class="language-julia hljs">matrix(R::Ring, arr::Matrix{T}) where T &lt;: RingElement</code></pre><p>Given an <span>$m\times n$</span> Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring <code>R</code>, assuming all the entries can be coerced into <code>R</code>.</p><pre><code class="language-julia hljs">matrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T &lt;: RingElement</code></pre><p>Construct the given <span>$r\times c$</span> AbstractAlgebra.jl matrix over the ring <code>R</code> whose <span>$(i, j)$</span> entry is given by <code>A[c*(i - 1) + j]</code>, assuming that all the entries can be coerced into <code>R</code>.</p><pre><code class="language-julia hljs">zero_matrix(R::Ring, r::Int, c::Int)</code></pre><p>Construct the <span>$r\times c$</span> AbstractAlgebra.jl zero matrix over the ring <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, BigInt[3 1 2; 2 0 1])
[3   1   2]
[2   0   1]

julia&gt; N = matrix(ZZ, 3, 2, BigInt[3, 1, 2, 2, 0, 1])
[3   1]
[2   2]
[0   1]

julia&gt; P = zero_matrix(ZZ, 3, 2)
[0   0]
[0   0]
[0   0]</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.number_of_rows-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.number_of_rows-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.number_of_rows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_of_rows(a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the number of rows of the given matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.number_of_columns-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.number_of_columns-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.number_of_columns</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_of_columns(a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the number of columns of the given matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#Base.length-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the number of entries in the given matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#Base.isempty-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return <code>true</code> if <code>a</code> does not contain any entry (i.e. <code>length(a) == 0</code>), and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.identity_matrix-Tuple{Ring, Int64}" href="#AbstractAlgebra.identity_matrix-Tuple{Ring, Int64}"><code>AbstractAlgebra.identity_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">identity_matrix(R::NCRing, n::Int)</code></pre><p>Return the <span>$n \times n$</span> identity matrix over <span>$R$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6874-L6878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.identity_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">identity_matrix(M::MatElem{T}) where T &lt;: NCRingElement</code></pre><p>Construct the identity matrix in the same matrix space as <code>M</code>, i.e. with ones down the diagonal and zeroes elsewhere. <code>M</code> must be square. This is an alias for <code>one(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6881-L6887">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.ones_matrix-Tuple{Ring, Int64, Int64}" href="#AbstractAlgebra.ones_matrix-Tuple{Ring, Int64, Int64}"><code>AbstractAlgebra.ones_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ones_matrix(R::Ring, r::Int, c::Int)</code></pre><p>Return the <span>$r \times c$</span> ones matrix over <span>$R$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6855-L6859">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.scalar_matrix-Tuple{Ring, Int64, RingElement}" href="#AbstractAlgebra.scalar_matrix-Tuple{Ring, Int64, RingElement}"><code>AbstractAlgebra.scalar_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalar_matrix(R::NCRing, n::Int, a::NCRingElement)
scalar_matrix(n::Int, a::NCRingElement)</code></pre><p>Return the <span>$n \times n$</span> matrix over <code>R</code> with <code>a</code> along the main diagonal and zeroes elsewhere. If <code>R</code> is not specified, it defaults to <code>parent(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6909-L6915">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.diagonal_matrix-Tuple{RingElement, Int64, Int64}" href="#AbstractAlgebra.diagonal_matrix-Tuple{RingElement, Int64, Int64}"><code>AbstractAlgebra.diagonal_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonal_matrix(x::NCRingElement, m::Int, [n::Int])</code></pre><p>Return the <span>$m \times n$</span> matrix over <span>$R$</span> with <code>x</code> along the main diagonal and zeroes elsewhere. If <code>n</code> is not specified, it defaults to <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; diagonal_matrix(ZZ(2), 2, 3)
[2   0   0]
[0   2   0]

julia&gt; diagonal_matrix(QQ(-1), 3)
[-1//1    0//1    0//1]
[ 0//1   -1//1    0//1]
[ 0//1    0//1   -1//1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6930-L6947">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zero-Union{Tuple{T}, Tuple{MatElem{T}, Ring}} where T&lt;:RingElement" href="#Base.zero-Union{Tuple{T}, Tuple{MatElem{T}, Ring}} where T&lt;:RingElement"><code>Base.zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero(x::MatElem{T}, R::NCRing, r::Int, c::Int) where T &lt;: NCRingElement
zero(x::MatElem{T}, r::Int, c::Int) where T &lt;: NCRingElement
zero(x::MatElem{T}, R::NCRing) where T &lt;: NCRingElement
zero(x::MatElem{T}) where T &lt;: NCRingElement</code></pre><p>Create an zero matrix over the given ring and dimensions, with defaults based upon the given source matrix <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L394-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.one-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#Base.one-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>Base.one</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">one(a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the identity matrix in the same matrix space as <span>$a$</span>. If the space does not contain square matrices, an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#Base.transpose-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose(x::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the transpose of the given matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; B = transpose(A)
[t + 1   t^2            -2]
[    t     t         t + 2]
[    1     t   t^2 + t + 1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1500-L1526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tr-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#LinearAlgebra.tr-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tr(x::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the trace of the matrix <span>$a$</span>, i.e. the sum of the diagonal elements. We require the matrix to be square.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; b = tr(A)
t^2 + 3*t + 2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1608-L1633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.det-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#LinearAlgebra.det-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>LinearAlgebra.det</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">det(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the determinant of the matrix <span>$M$</span>. We assume <span>$M$</span> is square.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, :x)
(Univariate polynomial ring in x over rationals, x)

julia&gt; A = R[x 1; 1 x^2];

julia&gt; d = det(A)
x^3 - 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2438-L2454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#LinearAlgebra.rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the rank of the matrix <span>$M$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = QQ[1 2; 3 4];

julia&gt; d = rank(A)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2882-L2895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.lower_triangular_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lower_triangular_matrix(L::AbstractVector{T}) where {T &lt;: NCRingElement}</code></pre><p>Return the <span>$n$</span> by <span>$n$</span> matrix whose entries on and below the main diagonal are the elements of <code>L</code>, and which has zeroes elsewhere. The value of <span>$n$</span> is determined by the condition that <code>L</code> has length <span>$n(n+1)/2$</span>.</p><p>An exception is thrown if there is no integer <span>$n$</span> with this property.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lower_triangular_matrix([1, 2, 3])
[1   0]
[2   3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L7030-L7046">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.upper_triangular_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">upper_triangular_matrix(L::AbstractVector{T}) where {T &lt;: NCRingElement}</code></pre><p>Return the <span>$n$</span> by <span>$n$</span> matrix whose entries on and above the main diagonal are the elements of <code>L</code>, and which has zeroes elsewhere. The value of <span>$n$</span> is determined by the condition that <code>L</code> has length <span>$n(n+1)/2$</span>.</p><p>An exception is thrown if there is no integer <span>$n$</span> with this property.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; upper_triangular_matrix([1, 2, 3])
[1   2]
[0   3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L7069-L7085">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.strictly_lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.strictly_lower_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.strictly_lower_triangular_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">strictly_lower_triangular_matrix(L::AbstractVector{T}) where {T &lt;: NCRingElement}</code></pre><p>Return the <span>$n$</span> by <span>$n$</span> matrix whose entries below the main diagonal are the elements of <code>L</code>, and which has zeroes elsewhere. The value of <span>$n$</span> is determined by the condition that <code>L</code> has length <span>$(n-1)n/2$</span>.</p><p>An exception is thrown if there is no integer <span>$n$</span> with this property.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; strictly_lower_triangular_matrix([1, 2, 3])
[0   0   0]
[1   0   0]
[2   3   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L7108-L7125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.strictly_upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.strictly_upper_triangular_matrix-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.strictly_upper_triangular_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">strictly_upper_triangular_matrix(L::AbstractVector{T}) where {T &lt;: NCRingElement}</code></pre><p>Return the <span>$n$</span> by <span>$n$</span> matrix whose entries above the main diagonal are the elements of <code>L</code>, and which has zeroes elsewhere. The value of <span>$n$</span> is determined by the condition that <code>L</code> has length <span>$(n-1)n/2$</span>.</p><p>An exception is thrown if there is no integer <span>$n$</span> with this property.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; strictly_upper_triangular_matrix([1, 2, 3])
[0   1   2]
[0   0   3]
[0   0   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L7148-L7165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_lower_triangular-Tuple{MatrixElem}" href="#AbstractAlgebra.is_lower_triangular-Tuple{MatrixElem}"><code>AbstractAlgebra.is_lower_triangular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_lower_triangular(A::MatrixElem)</code></pre><p>Return <code>true</code> if <span>$A$</span> is an lower triangular matrix, that is, all entries above the main diagonal are zero. Note that this definition also applies to non-square matrices.</p><p>Alias for <code>LinearAlgebra.istril</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_lower_triangular(QQ[1 2 ; 0 4])
false

julia&gt; is_lower_triangular(QQ[1 0 ; 3 4])
true

julia&gt; is_lower_triangular(QQ[1 2 ;])
false

julia&gt; is_lower_triangular(QQ[1 ; 2])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3627-L3650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_upper_triangular-Tuple{MatrixElem}" href="#AbstractAlgebra.is_upper_triangular-Tuple{MatrixElem}"><code>AbstractAlgebra.is_upper_triangular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_upper_triangular(A::MatrixElem)</code></pre><p>Return <code>true</code> if <span>$A$</span> is an upper triangular matrix, that is, all entries below the main diagonal are zero. Note that this definition also applies to non-square matrices.</p><p>Alias for <code>LinearAlgebra.istriu</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_upper_triangular(QQ[1 2 ; 0 4])
true

julia&gt; is_upper_triangular(QQ[1 0 ; 3 4])
false

julia&gt; is_upper_triangular(QQ[1 2 ;])
true

julia&gt; is_upper_triangular(QQ[1 ; 2])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3462-L3485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_diagonal-Tuple{MatrixElem}" href="#AbstractAlgebra.is_diagonal-Tuple{MatrixElem}"><code>AbstractAlgebra.is_diagonal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_diagonal(A::MatrixElem)</code></pre><p>Return <code>true</code> if <span>$A$</span> is a diagonal matrix, that is, all entries off the main diagonal are zero. Note that this definition also applies to non-square matrices.</p><p>Alias for <code>LinearAlgebra.isdiag</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_diagonal(QQ[1 0 ; 0 4])
true

julia&gt; is_diagonal(QQ[1 2 ; 3 4])
false

julia&gt; is_diagonal(QQ[1 0 ;])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3662-L3682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MatElem{T}}} where T&lt;:RingElement" href="#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MatElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.change_base_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_base_ring(R::NCRing, M::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Return the matrix obtained by coercing each entry into <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6557-L6561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.map-Union{Tuple{T}, Tuple{Any, MatrixElem{T}}} where T&lt;:RingElement" href="#Base.map-Union{Tuple{T}, Tuple{Any, MatrixElem{T}}} where T&lt;:RingElement"><code>Base.map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map(f, a::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Transform matrix <code>a</code> by applying <code>f</code> on each element. This is equivalent to <code>map_entries(f, a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6613-L6618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.map!-Union{Tuple{T}, Tuple{S}, Tuple{Any, MatrixElem{S}, MatrixElem{T}}} where {S&lt;:RingElement, T&lt;:RingElement}" href="#Base.map!-Union{Tuple{T}, Tuple{S}, Tuple{Any, MatrixElem{S}, MatrixElem{T}}} where {S&lt;:RingElement, T&lt;:RingElement}"><code>Base.map!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map!(f, dst::MatrixElem{T}, src::MatrixElem{U}) where {T &lt;: NCRingElement, U &lt;: NCRingElement}</code></pre><p>Like <code>map</code>, but stores the result in <code>dst</code> rather than a new matrix. This is equivalent to <code>map_entries!(f, dst, src)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6588-L6593">source</a></section></article><h2 id="Inverse"><a class="docs-heading-anchor" href="#Inverse">Inverse</a><a id="Inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix" href="#Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Given a non-singular <span>$n\times n$</span> matrix over a ring, return an <span>$n\times n$</span> matrix <span>$X$</span> such that <span>$MX = I_n$</span>, where <span>$I_n$</span> is the <span>$n\times n$</span> identity matrix. If <span>$M$</span> is not invertible over the base ring an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3723-L3730">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix" href="#AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix"><code>AbstractAlgebra.is_invertible</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_invertible(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use <code>is_invertible_with_inverse</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3768-L3773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix" href="#AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix"><code>AbstractAlgebra.is_invertible_with_inverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_invertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T &lt;: RingElement}</code></pre><p>Given an <span>$n \times m$</span> matrix <span>$A$</span> over a ring, return a tuple <code>(flag, B)</code>. If <code>side</code> is <code>:right</code> and <code>flag</code> is <code>true</code>, <span>$B$</span> is a right inverse of <span>$A$</span> i.e. <span>$A B$</span> is the <span>$n \times n$</span> unit matrix. If <code>side</code> is <code>:left</code> and <code>flag</code> is <code>true</code>, <span>$B$</span> is a left inverse of <span>$A$</span> i.e. <span>$B A$</span> is the <span>$m \times m$</span> unit matrix. If <code>flag</code> is <code>false</code>, no right or left inverse exists.</p><p>To get the space of all inverses, note that if <span>$B$</span> and <span>$C$</span> are both right inverses, then <span>$A (B - C) = 0$</span>, and similar for left inverses. Hence from one inverse one can find all by making suitable use of <a href="../linear_solving/#AbstractAlgebra.kernel-Tuple{Union{MatElem, AbstractAlgebra.Solve.SolveCtx}}"><code>kernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3744-L3756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix" href="#AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement-matrix"><code>AbstractAlgebra.pseudo_inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pseudo_inv(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Given a non-singular <span>$n\times n$</span> matrix <span>$M$</span> over a ring return a tuple <span>$X, d$</span> consisting of an <span>$n\times n$</span> matrix <span>$X$</span> and a denominator <span>$d$</span> such that <span>$MX = dI_n$</span>, where <span>$I_n$</span> is the <span>$n\times n$</span> identity matrix. The denominator will be the determinant of <span>$M$</span> up to sign. If <span>$M$</span> is singular an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3700-L3708">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])
[1//1   2//1   3//1]
[4//1   5//1   6//1]
[0//1   0//1   1//1]

julia&gt; X = inv(M)
[-5//3    2//3    1//1]
[ 4//3   -1//3   -2//1]
[ 0//1    0//1    1//1]

julia&gt; is_invertible(M)
true

julia&gt; is_invertible_with_inverse(M)
(true, [-5//3 2//3 1; 4//3 -1//3 -2; 0 0 1])

julia&gt; pseudo_inv(M)
([5 -2 -3; -4 1 6; 0 0 -3], -3//1)</code></pre><h2 id="Submatrices"><a class="docs-heading-anchor" href="#Submatrices">Submatrices</a><a id="Submatrices-1"></a><a class="docs-heading-anchor-permalink" href="#Submatrices" title="Permalink"></a></h2><p>Submatrices are only available for matrix spaces, not for matrix algebras and generally only available for generic matrices built on Julia arrays.</p><p>Submatrices return a new matrix with the same entries as the submatrix with the given range of rows and columns. They are best illustrated with examples.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])
[1   2   3]
[2   3   4]
[3   4   5]

julia&gt; N1 = M[1:2, :]
[1   2   3]
[2   3   4]

julia&gt; N2 = M[:, :]
[1   2   3]
[2   3   4]
[3   4   5]

julia&gt; N3 = M[2:3, 2:3]
[3   4]
[4   5]</code></pre><p>As per Julia, AbstractAlgebra supports the construction of matrix views.  These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.</p><p>The syntax for views is as for Julia&#39;s own views.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, 3, 3, BigInt[1, 2, 3, 2, 3, 4, 3, 4, 5])
[1   2   3]
[2   3   4]
[3   4   5]

julia&gt; N1 = @view M[1:2, :]
[1   2   3]
[2   3   4]

julia&gt; N2 = @view M[:, 1:2]
[1   2]
[2   3]
[3   4]

julia&gt; R = N1*N2
[14   20]
[20   29]</code></pre><h2 id="Elementary-row-and-column-operations"><a class="docs-heading-anchor" href="#Elementary-row-and-column-operations">Elementary row and column operations</a><a id="Elementary-row-and-column-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-row-and-column-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.add_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.add_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.add_column</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_column(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T &lt;: RingElement</code></pre><p>Create a copy of <span>$a$</span> and add <span>$s$</span> times the <span>$i$</span>-th row to the <span>$j$</span>-th row of <span>$a$</span>.</p><p>By default, the transformation is applied to all rows of <span>$a$</span>. This can be changed using the optional <code>rows</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6297-L6305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.add_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.add_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.add_column!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_column!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, rows = 1:nrows(a)) where T &lt;: RingElement</code></pre><p>Add <span>$s$</span> times the <span>$i$</span>-th row to the <span>$j$</span>-th row of <span>$a$</span>.</p><p>By default, the transformation is applied to all rows of <span>$a$</span>. This can be changed using the optional <code>rows</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6276-L6283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.add_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.add_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.add_row</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_row(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T &lt;: RingElement</code></pre><p>Create a copy of <span>$a$</span> and add <span>$s$</span> times the <span>$i$</span>-th row to the <span>$j$</span>-th row of <span>$a$</span>.</p><p>By default, the transformation is applied to all columns of <span>$a$</span>. This can be changed using the optional <code>cols</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6332-L6339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.add_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.add_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.add_row!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_row!(a::MatrixElem{T}, s::RingElement, i::Int, j::Int, cols = 1:ncols(a)) where T &lt;: RingElement</code></pre><p>Add <span>$s$</span> times the <span>$i$</span>-th row to the <span>$j$</span>-th row of <span>$a$</span>.</p><p>By default, the transformation is applied to all columns of <span>$a$</span>. This can be changed using the optional <code>cols</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6311-L6318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.multiply_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.multiply_column-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.multiply_column</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_column(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T &lt;: RingElement</code></pre><p>Create a copy of <span>$a$</span> and multiply the <span>$i$</span>th column of <span>$a$</span> with <span>$s$</span>.</p><p>By default, the transformation is applied to all rows of <span>$a$</span>. This can be changed using the optional <code>rows</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6366-L6373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.multiply_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.multiply_column!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.multiply_column!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_column!(a::MatrixElem{T}, s::RingElement, i::Int, rows = 1:nrows(a)) where T &lt;: RingElement</code></pre><p>Multiply the <span>$i$</span>th column of <span>$a$</span> with <span>$s$</span>.</p><p>By default, the transformation is applied to all rows of <span>$a$</span>. This can be changed using the optional <code>rows</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6347-L6354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.multiply_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.multiply_row-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.multiply_row</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_row(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T &lt;: RingElement</code></pre><p>Create a copy of <span>$a$</span> and multiply  the <span>$i$</span>th row of <span>$a$</span> with <span>$s$</span>.</p><p>By default, the transformation is applied to all columns of <span>$a$</span>. This can be changed using the optional <code>cols</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6400-L6407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.multiply_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.multiply_row!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.multiply_row!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply_row!(a::MatrixElem{T}, s::RingElement, i::Int, cols = 1:ncols(a)) where T &lt;: RingElement</code></pre><p>Multiply the <span>$i$</span>th row of <span>$a$</span> with <span>$s$</span>.</p><p>By default, the transformation is applied to all columns of <span>$a$</span>. This can be changed using the optional <code>cols</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6381-L6388">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ZZ[1 2 3; 2 3 4; 4 5 5]
[1   2   3]
[2   3   4]
[4   5   5]

julia&gt; add_column(M, 2, 3, 1)
[ 7   2   3]
[10   3   4]
[14   5   5]

julia&gt; add_row(M, 1, 2, 3)
[1   2   3]
[2   3   4]
[6   8   9]

julia&gt; multiply_column(M, 2, 3)
[1   2    6]
[2   3    8]
[4   5   10]

julia&gt; multiply_row(M, 2, 3)
[1    2    3]
[2    3    4]
[8   10   10]</code></pre><h2 id="Swapping-rows-and-columns"><a class="docs-heading-anchor" href="#Swapping-rows-and-columns">Swapping rows and columns</a><a id="Swapping-rows-and-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Swapping-rows-and-columns" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.swap_rows-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.swap_rows-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.swap_rows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap_rows(a::MatrixElem{T}, i::Int, j::Int) where T &lt;: NCRingElement</code></pre><p>Return a matrix <span>$b$</span> with the entries of <span>$a$</span>, where the <span>$i$</span>th and <span>$j$</span>th row are swapped.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = identity_matrix(ZZ, 3)
[1   0   0]
[0   1   0]
[0   0   1]

julia&gt; swap_rows(M, 1, 2)
[0   1   0]
[1   0   0]
[0   0   1]

julia&gt; M  # was not modified
[1   0   0]
[0   1   0]
[0   0   1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6126-L6149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.swap_rows!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.swap_rows!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.swap_rows!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap_rows!(a::MatrixElem{T}, i::Int, j::Int) where T &lt;: NCRingElement</code></pre><p>Swap the <span>$i$</span>th and <span>$j$</span>th row of <span>$a$</span> in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = identity_matrix(ZZ, 3)
[1   0   0]
[0   1   0]
[0   0   1]

julia&gt; swap_rows!(M, 1, 2)
[0   1   0]
[1   0   0]
[0   0   1]

julia&gt; M  # was modified
[0   1   0]
[1   0   0]
[0   0   1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6157-L6180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.swap_cols-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.swap_cols-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.swap_cols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap_cols(a::MatrixElem{T}, i::Int, j::Int) where T &lt;: NCRingElement</code></pre><p>Return a matrix <span>$b$</span> with the entries of <span>$a$</span>, where the <span>$i$</span>th and <span>$j$</span>th row are swapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6190-L6195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.swap_cols!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement" href="#AbstractAlgebra.swap_cols!-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.swap_cols!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">swap_cols!(a::MatrixElem{T}, i::Int, j::Int) where T &lt;: NCRingElement</code></pre><p>Swap the <span>$i$</span>th and <span>$j$</span>th column of <span>$a$</span> in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6203-L6208">source</a></section></article><p>Swap the rows of <code>M</code> in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).</p><h2 id="Concatenation"><a class="docs-heading-anchor" href="#Concatenation">Concatenation</a><a id="Concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation" title="Permalink"></a></h2><p>The following are only available for matrix spaces, not for matrix algebras.</p><pre><code class="language-julia hljs">hcat(M::T, N::T) where T &lt;: MatElem</code></pre><p>Return the horizontal concatenation of <span>$M$</span> and <span>$N$</span>. It is assumed that the number of rows of <span>$M$</span> and <span>$N$</span> are the same.</p><pre><code class="language-julia hljs">vcat(M::T, N::T) where T &lt;: MatElem</code></pre><p>Return the vertical concatenation of <span>$M$</span> and <span>$N$</span>. It is assumed that the number of columns of <span>$M$</span> and <span>$N$</span> are the same.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])
[1   2   3]
[2   3   4]
[3   4   5]

julia&gt; N = matrix(ZZ, BigInt[1 0 1; 0 1 0; 1 0 1])
[1   0   1]
[0   1   0]
[1   0   1]

julia&gt; P = hcat(M, N)
[1   2   3   1   0   1]
[2   3   4   0   1   0]
[3   4   5   1   0   1]

julia&gt; Q = vcat(M, N)
[1   2   3]
[2   3   4]
[3   4   5]
[1   0   1]
[0   1   0]
[1   0   1]
</code></pre><h2 id="Linear-solving"><a class="docs-heading-anchor" href="#Linear-solving">Linear solving</a><a id="Linear-solving-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solving" title="Permalink"></a></h2><p>See <a href="../linear_solving/#solving_chapter">Linear Solving &amp; Kernel</a></p><h2 id="Block-diagonal-matrix-constructors"><a class="docs-heading-anchor" href="#Block-diagonal-matrix-constructors">Block diagonal matrix constructors</a><a id="Block-diagonal-matrix-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Block-diagonal-matrix-constructors" title="Permalink"></a></h2><p>It is also possible to create block diagonal matrices from a vector of existing matrices. It is also possible to construct them from Julia matrices if one supplies the base ring.</p><p>Note that if the input matrices are not square, the output matrix may not be square.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.block_diagonal_matrix-Union{Tuple{Vector{&lt;:MatElem{T}}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.block_diagonal_matrix-Union{Tuple{Vector{&lt;:MatElem{T}}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.block_diagonal_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block_diagonal_matrix(V::Vector{&lt;:MatElem{T}}) where T &lt;: NCRingElement</code></pre><p>Create the block diagonal matrix whose blocks are given by the matrices in <code>V</code>. There must be at least one matrix in V.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L308-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.block_diagonal_matrix-Union{Tuple{T}, Tuple{Ring, Vector{&lt;:Matrix{T}}}} where T&lt;:RingElement" href="#AbstractAlgebra.block_diagonal_matrix-Union{Tuple{T}, Tuple{Ring, Vector{&lt;:Matrix{T}}}} where T&lt;:RingElement"><code>AbstractAlgebra.block_diagonal_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block_diagonal_matrix(R::NCRing, V::Vector{&lt;:Matrix{T}}) where T &lt;: NCRingElement</code></pre><p>Create the block diagonal matrix over the ring <code>R</code> whose blocks are given by the matrices in <code>V</code>. Entries are coerced into <code>R</code> upon creation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L342-L347">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; block_diagonal_matrix(ZZ, [[1 2; 3 4], [4 5 6; 7 8 9]])
[1   2   0   0   0]
[3   4   0   0   0]
[0   0   4   5   6]
[0   0   7   8   9]

julia&gt; M = matrix(ZZ, [1 2; 3 4])
[1   2]
[3   4]

julia&gt; N = matrix(ZZ, [4 5 6; 7 8 9])
[4   5   6]
[7   8   9]

julia&gt; block_diagonal_matrix([M, N])
[1   2   0   0   0]
[3   4   0   0   0]
[0   0   4   5   6]
[0   0   7   8   9]</code></pre><h2 id="Similar-and-zero"><a class="docs-heading-anchor" href="#Similar-and-zero">Similar and zero</a><a id="Similar-and-zero-1"></a><a class="docs-heading-anchor-permalink" href="#Similar-and-zero" title="Permalink"></a></h2><p>Both <code>similar</code> and <code>zero</code> construct new matrices, but the entries are either undefined with <code>similar</code> or zero-initialized with <code>zero</code>.</p><pre><code class="language-julia hljs">similar(x::MatElem, R::Ring=base_ring(x))
zero(x::MatElem, R::Ring=base_ring(x))</code></pre><p>Construct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.</p><pre><code class="language-julia hljs">similar(x::MatElem, R::Ring, r::Int, c::Int)
similar(x::MatElem, r::Int, c::Int)
zero(x::MatElem, R::Ring, r::Int, c::Int)
zero(x::MatElem, r::Int, c::Int)</code></pre><p>Construct the <span>$r\times c$</span> matrix with <code>R</code> as base ring (which defaults to the base ring of the the given matrix). If <span>$x$</span> belongs to a matrix algebra and <span>$r \neq c$</span>, an exception is raised, and it&#39;s also possible to specify only one <code>Int</code> as the order (e.g. <code>similar(x, n)</code>).</p><pre><code class="language-julia hljs">Base.isassigned(M::MatElem, i, j)</code></pre><p>Test whether the given matrix has a value associated with indices <code>i</code> and <code>j</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, BigInt[3 1 2; 2 0 1])
[3   1   2]
[2   0   1]

julia&gt; isassigned(M, 1, 2)
true

julia&gt; isassigned(M, 4, 4)
false

julia&gt; A = similar(M)
[#undef   #undef   #undef]
[#undef   #undef   #undef]

julia&gt; isassigned(A, 1, 2)
false

julia&gt; B = zero(M)
[0   0   0]
[0   0   0]

julia&gt; C = similar(M, 4, 5)
[#undef   #undef   #undef   #undef   #undef]
[#undef   #undef   #undef   #undef   #undef]
[#undef   #undef   #undef   #undef   #undef]
[#undef   #undef   #undef   #undef   #undef]

julia&gt; base_ring(B)
Integers

julia&gt; D = zero(M, QQ, 2, 2)
[0//1   0//1]
[0//1   0//1]

julia&gt; base_ring(D)
Rationals</code></pre><h2 id="LU-factorisation"><a class="docs-heading-anchor" href="#LU-factorisation">LU factorisation</a><a id="LU-factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#LU-factorisation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:FieldElem-matrix" href="#LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:FieldElem-matrix"><code>LinearAlgebra.lu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T &lt;: FieldElement}</code></pre><p>Return a tuple <span>$r, p, L, U$</span> consisting of the rank of <span>$A$</span>, a permutation <span>$p$</span> of <span>$A$</span> belonging to <span>$P$</span>, a lower triangular matrix <span>$L$</span> and an upper triangular matrix <span>$U$</span> such that <span>$p(A) = LU$</span>, where <span>$p(A)$</span> stands for the matrix whose rows are the given permutation <span>$p$</span> of the rows of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1843-L1850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:RingElem-matrix" href="#AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:RingElem-matrix"><code>AbstractAlgebra.fflu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T &lt;: RingElement}</code></pre><p>Return a tuple <span>$r, d, p, L, U$</span> consisting of the rank of <span>$A$</span>, a denominator <span>$d$</span>, a permutation <span>$p$</span> of <span>$A$</span> belonging to <span>$P$</span>, a lower triangular matrix <span>$L$</span> and an upper triangular matrix <span>$U$</span> such that <span>$p(A) = LDU$</span>, where <span>$p(A)$</span> stands for the matrix whose rows are the given permutation <span>$p$</span> of the rows of <span>$A$</span> and such that <span>$D$</span> is the diagonal matrix diag<span>$(p_1, p_1p_2, \ldots, p_{n-2}p_{n-1}, p_{n-1}p_n)$</span> where the <span>$p_i$</span> are the inverses of the diagonal entries of <span>$L$</span>. The denominator <span>$d$</span> is set to <span>$\pm \mathrm{det}(S)$</span> where <span>$S$</span> is an appropriate submatrix of <span>$A$</span> (<span>$S = A$</span> if <span>$A$</span> is square and nonsingular) and the sign is decided by the parity of the permutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1993-L2006">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])
[1//1   2//1   3//1]
[4//1   5//1   6//1]
[0//1   0//1   1//1]

julia&gt; r, P, L, U = lu(M)
(3, (), [1 0 0; 4 1 0; 0 0 1], [1 2 3; 0 -3 -6; 0 0 1])

julia&gt; r, d, P, L, U = fflu(M)
(3, -3//1, (), [1 0 0; 4 -3 0; 0 0 -3], [1 2 3; 0 -3 -6; 0 0 -3])</code></pre><h2 id="Reduced-row-echelon-form"><a class="docs-heading-anchor" href="#Reduced-row-echelon-form">Reduced row-echelon form</a><a id="Reduced-row-echelon-form-1"></a><a class="docs-heading-anchor-permalink" href="#Reduced-row-echelon-form" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix" href="#AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix"><code>AbstractAlgebra.rref_rational</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rref_rational(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return a tuple <span>$(r, A, d)$</span> consisting of the rank <span>$r$</span> of <span>$M$</span> and a denominator <span>$d$</span> in the base ring of <span>$M$</span> and a matrix <span>$A$</span> such that <span>$A/d$</span> is the reduced row echelon form of <span>$M$</span>. Note that the denominator is not usually minimal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2111-L2118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem-matrix" href="#AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem-matrix"><code>AbstractAlgebra.rref</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rref(M::MatrixElem{T}) where {T &lt;: FieldElement}</code></pre><p>Return a tuple <span>$(r, A)$</span> consisting of the rank <span>$r$</span> of <span>$M$</span> and a reduced row echelon form <span>$A$</span> of <span>$M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2185-L2190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix" href="#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix"><code>AbstractAlgebra.is_rref</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2197-L2202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem-matrix" href="#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem-matrix"><code>AbstractAlgebra.is_rref</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2197-L2202">source</a></section><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: FieldElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2227-L2232">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; M = matrix(QQ, 3, 3, [1 2 3;4 5 6;0 0 1])
[1//1   2//1   3//1]
[4//1   5//1   6//1]
[0//1   0//1   1//1]

julia&gt; r1, A = rref(M)
(3, [1 0 0; 0 1 0; 0 0 1])

julia&gt; N = matrix(ZZ, 3, 3, [1 2 3;4 5 6;0 0 1])
[1   2   3]
[4   5   6]
[0   0   1]

julia&gt; r2, B = rref_rational(N)
(3, [-3 0 0; 0 -3 0; 0 0 -3], -3)

julia&gt; is_rref(A)
true

julia&gt; is_rref(B)
true</code></pre><h2 id="Other-functionality"><a class="docs-heading-anchor" href="#Other-functionality">Other functionality</a><a id="Other-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functionality" title="Permalink"></a></h2><h3 id="Symmetry-testing"><a class="docs-heading-anchor" href="#Symmetry-testing">Symmetry testing</a><a id="Symmetry-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-testing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_symmetric-Tuple{MatrixElem}" href="#AbstractAlgebra.is_symmetric-Tuple{MatrixElem}"><code>AbstractAlgebra.is_symmetric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_symmetric(M::MatrixElem)</code></pre><p>Return <code>true</code> if the given matrix is symmetric with respect to its main diagonal, i.e., <code>transpose(M) == M</code>, otherwise return <code>false</code>.</p><p>Alias for <code>LinearAlgebra.issymmetric</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, [1 2 3; 2 4 5; 3 5 6])
[1   2   3]
[2   4   5]
[3   5   6]

julia&gt; is_symmetric(M)
true

julia&gt; N = matrix(ZZ, [1 2 3; 4 5 6; 7 8 9])
[1   2   3]
[4   5   6]
[7   8   9]

julia&gt; is_symmetric(N)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1462-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_skew_symmetric-Tuple{MatrixElem}" href="#AbstractAlgebra.is_skew_symmetric-Tuple{MatrixElem}"><code>AbstractAlgebra.is_skew_symmetric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_skew_symmetric(M::MatrixElem)</code></pre><p>Return <code>true</code> if the given matrix is skew symmetric with respect to its main diagonal, i.e., <code>transpose(M) == -M</code>, otherwise return <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matrix(ZZ, [0 -1 -2; 1 0 -3; 2 3 0])
[0   -1   -2]
[1    0   -3]
[2    3    0]

julia&gt; is_skew_symmetric(M)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2703-L2720">source</a></section></article><h3 id="Powering"><a class="docs-heading-anchor" href="#Powering">Powering</a><a id="Powering-1"></a><a class="docs-heading-anchor-permalink" href="#Powering" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.powers-Tuple{MatElem, Int64}" href="#AbstractAlgebra.powers-Tuple{MatElem, Int64}"><code>AbstractAlgebra.powers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">powers(a::Union{NCRingElement, MatElem}, d::Int)</code></pre><p>Return an array <span>$M$</span> of &quot;powers&quot; of <code>a</code> where <span>$M[i + 1] = a^i$</span> for <span>$i = 0..d$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = ZZ[1 2 3; 2 3 4; 4 5 5]
[1   2   3]
[2   3   4]
[4   5   5]

julia&gt; A = powers(M, 4)
5-element Vector{AbstractAlgebra.Generic.MatSpaceElem{BigInt}}:
 [1 0 0; 0 1 0; 0 0 1]
 [1 2 3; 2 3 4; 4 5 5]
 [17 23 26; 24 33 38; 34 48 57]
 [167 233 273; 242 337 394; 358 497 579]
 [1725 2398 2798; 2492 3465 4044; 3668 5102 5957]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/NCRings.jl#L235-L256">source</a></section></article><h3 id="Gram-matrix"><a class="docs-heading-anchor" href="#Gram-matrix">Gram matrix</a><a id="Gram-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Gram-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.gram-Tuple{MatElem}" href="#AbstractAlgebra.gram-Tuple{MatElem}"><code>AbstractAlgebra.gram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gram(x::MatElem)</code></pre><p>Return the Gram matrix of <span>$x$</span>, i.e. if <span>$x$</span> is an <span>$r\times c$</span> matrix return the <span>$r\times r$</span> matrix whose entries <span>$i, j$</span> are the dot products of the <span>$i$</span>-th and <span>$j$</span>-th rows, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; B = gram(A)
[2*t^2 + 2*t + 2   t^3 + 2*t^2 + t                   2*t^2 + t - 1]
[t^3 + 2*t^2 + t       t^4 + 2*t^2                       t^3 + 3*t]
[  2*t^2 + t - 1         t^3 + 3*t   t^4 + 2*t^3 + 4*t^2 + 6*t + 9]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1560-L1588">source</a></section></article><h3 id="Content"><a class="docs-heading-anchor" href="#Content">Content</a><a id="Content-1"></a><a class="docs-heading-anchor-permalink" href="#Content" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.content-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.content-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.content</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">content(x::MatrixElem{T}) where T &lt;: RingElement</code></pre><p>Return the content of the matrix <span>$a$</span>, i.e. the greatest common divisor of all its entries, assuming it exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; b = content(A)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1649-L1674">source</a></section></article><h3 id="Permutation"><a class="docs-heading-anchor" href="#Permutation">Permutation</a><a id="Permutation-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{Perm, MatElem{T}}} where T&lt;:RingElement" href="#Base.:*-Union{Tuple{T}, Tuple{Perm, MatElem{T}}} where T&lt;:RingElement"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(P::Perm, x::MatrixElem{T}) where T &lt;: NCRingElement</code></pre><p>Apply the pemutation <span>$P$</span> to the rows of the matrix <span>$x$</span> and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; G = SymmetricGroup(3)
Full symmetric group over 3 elements

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; P = G([1, 3, 2])
(2,3)

julia&gt; B = P*A
[t + 1       t             1]
[   -2   t + 2   t^2 + t + 1]
[  t^2       t             t]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L1691-L1723">source</a></section></article><h3 id="Nilpotency"><a class="docs-heading-anchor" href="#Nilpotency">Nilpotency</a><a id="Nilpotency-1"></a><a class="docs-heading-anchor-permalink" href="#Nilpotency" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_nilpotent-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.is_nilpotent-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_nilpotent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_nilpotent(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return if <code>A</code> is nilpotent, i.e. if there exists a natural number <span>$k$</span> such that <span>$A^k = 0$</span>. If <code>A</code> is not square an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3910-L3915">source</a></section></article><h3 id="Minors"><a class="docs-heading-anchor" href="#Minors">Minors</a><a id="Minors-1"></a><a class="docs-heading-anchor-permalink" href="#Minors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.minors-Tuple{MatElem, Int64}" href="#AbstractAlgebra.minors-Tuple{MatElem, Int64}"><code>AbstractAlgebra.minors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minors(A::MatElem, k::Int)</code></pre><p>Return an array consisting of the <code>k</code>-minors of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = ZZ[1 2 3; 4 5 6]
[1   2   3]
[4   5   6]

julia&gt; minors(A, 2)
3-element Vector{BigInt}:
 -3
 -6
 -3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2558-L2577">source</a></section></article><h3 id="Exterior-power"><a class="docs-heading-anchor" href="#Exterior-power">Exterior power</a><a id="Exterior-power-1"></a><a class="docs-heading-anchor-permalink" href="#Exterior-power" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.exterior_power-Tuple{MatElem, Int64}" href="#AbstractAlgebra.exterior_power-Tuple{MatElem, Int64}"><code>AbstractAlgebra.exterior_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exterior_power(A::MatElem, k::Int) -&gt; MatElem</code></pre><p>Return the <code>k</code>-th exterior power of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(ZZ, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);

julia&gt; exterior_power(A, 2)
[-3    -6   -3]
[-6   -12   -6]
[-3    -6   -3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2654-L2669">source</a></section></article><h3 id="Pfaffian"><a class="docs-heading-anchor" href="#Pfaffian">Pfaffian</a><a id="Pfaffian-1"></a><a class="docs-heading-anchor-permalink" href="#Pfaffian" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.pfaffian-Tuple{MatElem}" href="#AbstractAlgebra.pfaffian-Tuple{MatElem}"><code>AbstractAlgebra.pfaffian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pfaffian(M::MatElem)</code></pre><p>Return the Pfaffian of a skew-symmetric matrix <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2735-L2739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.pfaffians-Tuple{MatElem, Int64}" href="#AbstractAlgebra.pfaffians-Tuple{MatElem, Int64}"><code>AbstractAlgebra.pfaffians</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pfaffians(M::MatElem, k::Int)</code></pre><p>Return a vector consisting of the <code>k</code>-Pfaffians of a skew-symmetric matrix <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L2753-L2757">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, [&quot;x$i&quot; for i in 1:6])
(Multivariate polynomial ring in 6 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x1, x2, x3, x4, x5, x6])

julia&gt; M = R[0 x[1] x[2] x[3]; -x[1] 0 x[4] x[5]; -x[2] -x[4] 0 x[6]; -x[3] -x[5] -x[6] 0]
[  0    x1    x2   x3]
[-x1     0    x4   x5]
[-x2   -x4     0   x6]
[-x3   -x5   -x6    0]

julia&gt; pfaffian(M)
x1*x6 - x2*x5 + x3*x4

julia&gt; pfaffians(M, 2)
6-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x1
 x2
 x4
 x3
 x5
 x6
 </code></pre><h3 id="Nullspace"><a class="docs-heading-anchor" href="#Nullspace">Nullspace</a><a id="Nullspace-1"></a><a class="docs-heading-anchor-permalink" href="#Nullspace" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#LinearAlgebra.nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>LinearAlgebra.nullspace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nullspace(M::MatElem{T}) where {T &lt;: RingElement}</code></pre><p>Return a tuple <span>$(\nu, N)$</span> consisting of the nullity <span>$\nu$</span> of <span>$M$</span> and a basis <span>$N$</span> (consisting of column vectors) for the right nullspace of <span>$M$</span>, i.e. such that <span>$MN$</span> is the zero matrix. If <span>$M$</span> is an <span>$m\times n$</span> matrix <span>$N$</span> will be an <span>$n\times \nu$</span> matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name &quot;kernel&quot; for a function to compute an integral kernel.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(ZZ, :x)
(Univariate polynomial ring in x over integers, x)

julia&gt; S = matrix_space(R, 4, 4)
Matrix space of 4 rows and 4 columns
  over univariate polynomial ring in x over integers

julia&gt; M = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;
              -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;
              -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;
              -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])
[  -6*x^2 + 6*x + 12   -12*x^2 - 21*x - 15    -15*x^2 + 21*x + 33     -21*x^2 - 9*x - 9]
[  -8*x^2 + 8*x + 16   -16*x^2 + 38*x - 20     90*x^2 - 82*x - 44    60*x^2 + 54*x - 34]
[   -4*x^2 + 4*x + 8    -8*x^2 + 13*x - 10     35*x^2 - 31*x - 14    22*x^2 + 21*x - 15]
[-10*x^2 + 10*x + 20   -20*x^2 + 70*x - 25   150*x^2 - 140*x - 85   105*x^2 + 90*x - 50]

julia&gt; n, N = nullspace(M)
(2, [1320*x^4-330*x^2-1320*x-1320 1056*x^4+1254*x^3+1848*x^2-66*x-330; -660*x^4+1320*x^3+1188*x^2-1848*x-1056 -528*x^4+132*x^3+1584*x^2+660*x-264; 396*x^3-396*x^2-792*x 0; 0 396*x^3-396*x^2-792*x])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3784-L3817">source</a></section><section><div><pre><code class="language-julia hljs">nullspace(M::MatElem{T}) where {T &lt;: FieldElement}</code></pre><p>Return a tuple <span>$(\nu, N)$</span> consisting of the nullity <span>$\nu$</span> of <span>$M$</span> and a basis <span>$N$</span> (consisting of column vectors) for the right nullspace of <span>$M$</span>, i.e. such that <span>$MN$</span> is the zero matrix. If <span>$M$</span> is an <span>$m\times n$</span> matrix <span>$N$</span> will be an <span>$n\times \nu$</span> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3857-L3864">source</a></section></article><h3 id="Hessenberg-form"><a class="docs-heading-anchor" href="#Hessenberg-form">Hessenberg form</a><a id="Hessenberg-form-1"></a><a class="docs-heading-anchor-permalink" href="#Hessenberg-form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix" href="#LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix"><code>LinearAlgebra.hessenberg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hessenberg(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the Hessenberg form of <span>$M$</span>, i.e. an upper Hessenberg matrix which is similar to <span>$M$</span>. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3981-L3988">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix" href="#AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem-matrix"><code>AbstractAlgebra.is_hessenberg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_hessenberg(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in Hessenberg form, otherwise returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L3996-L4000">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; R, = residue_ring(ZZ, 7);

julia&gt; M = matrix(R, 4, 4, [1 2 4 3; 2 5 1 0;6 1 3 2; 1 1 3 5])
[1   2   4   3]
[2   5   1   0]
[6   1   3   2]
[1   1   3   5]

julia&gt; A = hessenberg(M)
[1   5   5   3]
[2   1   1   0]
[0   1   3   2]
[0   0   2   2]

julia&gt; is_hessenberg(A)
true</code></pre><h3 id="Characteristic-polynomial"><a class="docs-heading-anchor" href="#Characteristic-polynomial">Characteristic polynomial</a><a id="Characteristic-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Characteristic-polynomial" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.charpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatrixElem{T}}} where T&lt;:RingElem" href="#AbstractAlgebra.charpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatrixElem{T}}} where T&lt;:RingElem"><code>AbstractAlgebra.charpoly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">charpoly(Y::MatrixElem{T}) where {T &lt;: RingElement}
charpoly(S::PolyRing{T}, Y::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the characteristic polynomial <span>$p$</span> of the square matrix <span>$Y$</span>. If a polynomial ring <span>$S$</span> over the same base ring as <span>$Y$</span> is supplied, the resulting polynomial is an element of it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, = residue_ring(ZZ, 7);

julia&gt; S = matrix_space(R, 4, 4)
Matrix space of 4 rows and 4 columns
  over residue ring of integers modulo 7

julia&gt; T, y = polynomial_ring(R, :y)
(Univariate polynomial ring in y over R, y)

julia&gt; M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);
              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])
[1   2   4   3]
[2   5   1   0]
[6   1   3   2]
[1   1   3   5]

julia&gt; A = charpoly(T, M)
y^4 + 2*y^2 + 6*y + 2

julia&gt; A = charpoly(M)
x^4 + 2*x^2 + 6*x + 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L4264-L4297">source</a></section></article><h3 id="Minimal-polynomial"><a class="docs-heading-anchor" href="#Minimal-polynomial">Minimal polynomial</a><a id="Minimal-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-polynomial" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.minpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatElem{T}, Bool}} where T&lt;:RingElem" href="#AbstractAlgebra.minpoly-Union{Tuple{T}, Tuple{PolyRing{T}, MatElem{T}, Bool}} where T&lt;:RingElem"><code>AbstractAlgebra.minpoly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minpoly(M::MatElem{T}) where {T &lt;: RingElement}
minpoly(S::PolyRing{T}, M::MatElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the minimal polynomial <span>$p$</span> of the square matrix <span>$M$</span>. If a polynomial ring <span>$S$</span> over the same base ring as <span>$Y$</span> is supplied, the resulting polynomial is an element of it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = GF(13)
Finite field F_13

julia&gt; S, y = polynomial_ring(R, :y)
(Univariate polynomial ring in y over R, y)

julia&gt; M = R[7 6 1;
             7 7 5;
             8 12 5]
[7    6   1]
[7    7   5]
[8   12   5]

julia&gt; A = minpoly(S, M)
y^2 + 10*y

julia&gt; A = minpoly(M)
x^2 + 10*x
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L4469-L4500">source</a></section></article><h3 id="Transforms"><a class="docs-heading-anchor" href="#Transforms">Transforms</a><a id="Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.similarity!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, T}} where T&lt;:RingElem" href="#AbstractAlgebra.similarity!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, T}} where T&lt;:RingElem"><code>AbstractAlgebra.similarity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similarity!(A::MatrixElem{T}, r::Int, d::T) where {T &lt;: RingElement}</code></pre><p>Applies a similarity transform to the <span>$n\times n$</span> matrix <span>$M$</span> in-place. Let <span>$P$</span> be the <span>$n\times n$</span> identity matrix that has had all zero entries of row <span>$r$</span> replaced with <span>$d$</span>, then the transform applied is equivalent to <span>$M = P^{-1}MP$</span>. We require <span>$M$</span> to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, = residue_ring(ZZ, 7);

julia&gt; S = matrix_space(R, 4, 4)
Matrix space of 4 rows and 4 columns
  over residue ring of integers modulo 7

julia&gt; M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);
              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])
[1   2   4   3]
[2   5   1   0]
[6   1   3   2]
[1   1   3   5]

julia&gt; similarity!(M, 1, R(3))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L6066-L6094">source</a></section></article><h3 id="Hermite-normal-form"><a class="docs-heading-anchor" href="#Hermite-normal-form">Hermite normal form</a><a id="Hermite-normal-form-1"></a><a class="docs-heading-anchor-permalink" href="#Hermite-normal-form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#AbstractAlgebra.hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.hnf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hnf(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the upper right row Hermite normal form of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5181-L5185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#AbstractAlgebra.hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.hnf_with_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hnf_with_transform(A)</code></pre><p>Return the tuple <span>$H, U$</span> consisting of the upper right row Hermite normal form <span>$H$</span> of <span>$A$</span> together with invertible matrix <span>$U$</span> such that <span>$UA = H$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5190-L5195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#AbstractAlgebra.is_hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.is_hnf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_hnf(M::MatrixElem{T}) where T &lt;: RingElement</code></pre><p>Return <code>true</code> if the matrix is in Hermite normal form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5200-L5204">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])
[ 2   3   -1]
[ 3   5    7]
[11   1   12]

julia&gt; H = hnf(A)
[1   0   255]
[0   1    17]
[0   0   281]

julia&gt; is_hnf(H)
true

julia&gt; H, U = hnf_with_transform(A)
([1 0 255; 0 1 17; 0 0 281], [-47 28 1; -3 2 0; -52 31 1])

julia&gt; U*A
[1   0   255]
[0   1    17]
[0   0   281]</code></pre><h3 id="Smith-normal-form"><a class="docs-heading-anchor" href="#Smith-normal-form">Smith normal form</a><a id="Smith-normal-form-1"></a><a class="docs-heading-anchor-permalink" href="#Smith-normal-form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_snf-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement" href="#AbstractAlgebra.is_snf-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_snf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_snf(A::MatrixElem{T}) where T &lt;: RingElement</code></pre><p>Return <code>true</code> if <span>$A$</span> is in Smith Normal Form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5254-L5258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#AbstractAlgebra.snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.snf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">snf(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the Smith normal form of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5404-L5408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#AbstractAlgebra.snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.snf_with_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">snf_with_transform(A)</code></pre><p>Return the tuple <span>$S, T, U$</span> consisting of the Smith normal form <span>$S$</span> of <span>$A$</span> together with invertible matrices <span>$T$</span> and <span>$U$</span> such that <span>$TAU = S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5413-L5418">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])
[ 2   3   -1]
[ 3   5    7]
[11   1   12]

julia&gt; S = snf(A)
[1   0     0]
[0   1     0]
[0   0   281]

julia&gt; S, T, U = snf_with_transform(A)
([1 0 0; 0 1 0; 0 0 281], [1 0 0; 7 1 0; 229 31 1], [0 -3 26; 0 2 -17; -1 0 1])

julia&gt; T*A*U
[1   0     0]
[0   1     0]
[0   0   281]</code></pre><h3 id="(Weak)-Popov-form"><a class="docs-heading-anchor" href="#(Weak)-Popov-form">(Weak) Popov form</a><a id="(Weak)-Popov-form-1"></a><a class="docs-heading-anchor-permalink" href="#(Weak)-Popov-form" title="Permalink"></a></h3><p>AbstractAlgebra.jl provides algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_weak_popov-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64}} where T&lt;:AbstractAlgebra.Generic.Poly" href="#AbstractAlgebra.is_weak_popov-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64}} where T&lt;:AbstractAlgebra.Generic.Poly"><code>AbstractAlgebra.is_weak_popov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_weak_popov(P::MatrixElem{T}, rank::Int) where T &lt;: PolyRingElem</code></pre><p>Return <code>true</code> if <span>$P$</span> is a matrix in weak Popov form of the given rank.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5429-L5433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.weak_popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem" href="#AbstractAlgebra.weak_popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem"><code>AbstractAlgebra.weak_popov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weak_popov(A::MatElem{T}) where {T &lt;: PolyRingElem}</code></pre><p>Return the weak Popov form of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5512-L5516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.weak_popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem" href="#AbstractAlgebra.weak_popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem"><code>AbstractAlgebra.weak_popov_with_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weak_popov_with_transform(A::MatElem{T}) where {T &lt;: PolyRingElem}</code></pre><p>Compute a tuple <span>$(P, U)$</span> where <span>$P$</span> is the weak Popov form of <span>$A$</span> and <span>$U$</span> is a transformation matrix so that <span>$P = UA$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5521-L5526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem" href="#AbstractAlgebra.popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem"><code>AbstractAlgebra.popov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popov(A::MatElem{T}) where {T &lt;: PolyRingElem}</code></pre><p>Return the Popov form of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5784-L5788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem" href="#AbstractAlgebra.popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:PolyRingElem"><code>AbstractAlgebra.popov_with_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popov_with_transform(A::MatElem{T}) where {T &lt;: PolyRingElem}</code></pre><p>Compute a tuple <span>$(P, U)$</span> where <span>$P$</span> is the Popov form of <span>$A$</span> and <span>$U$</span> is a transformation matrix so that <span>$P = UA$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/0fb17f555a3da28235d9d27a2269ac1bd4a982f7/src/Matrix.jl#L5793-L5798">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, :x);

julia&gt; A = matrix(R, map(R, Any[1 2 3 x; x 2*x 3*x x^2; x x^2+1 x^3+x^2 x^4+x^2+1]))
[1         2           3               x]
[x       2*x         3*x             x^2]
[x   x^2 + 1   x^3 + x^2   x^4 + x^2 + 1]

julia&gt; P = weak_popov(A)
[   1                        2                    3   x]
[   0                        0                    0   0]
[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]

julia&gt; P, U = weak_popov_with_transform(A)
([1 2 3 x; 0 0 0 0; -x^3 -2*x^3+x^2-2*x+1 -2*x^3+x^2-3*x 1], [1 0 0; -x 1 0; -x^3-x 0 1])

julia&gt; U*A
[   1                        2                    3   x]
[   0                        0                    0   0]
[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../matrix_spaces/">Matrix Spaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 24 September 2025 17:15">Wednesday 24 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
