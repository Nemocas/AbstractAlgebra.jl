<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ring functionality · AbstractAlgebra.jl</title><meta name="title" content="Ring functionality · AbstractAlgebra.jl"/><meta property="og:title" content="Ring functionality · AbstractAlgebra.jl"/><meta property="twitter:title" content="Ring functionality · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Ring functionality</a><ul class="internal"><li><a class="tocitem" href="#Abstract-types-for-rings"><span>Abstract types for rings</span></a></li><li><a class="tocitem" href="#Functions-for-types-and-parents-of-rings"><span>Functions for types and parents of rings</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Basic-functions"><span>Basic functions</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-inexact-rings-only"><span>Basic functionality for inexact rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-commutative-rings-only"><span>Basic functionality for commutative rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-noncommutative-rings-only"><span>Basic functionality for noncommutative rings only</span></a></li><li><a class="tocitem" href="#Unsafe-ring-operators"><span>Unsafe ring operators</span></a></li><li><a class="tocitem" href="#Random-generation"><span>Random generation</span></a></li><li><a class="tocitem" href="#Factorization"><span>Factorization</span></a></li></ul></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href>Ring functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ring functionality</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ring.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ring-functionality"><a class="docs-heading-anchor" href="#Ring-functionality">Ring functionality</a><a id="Ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-functionality" title="Permalink"></a></h1><p>AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.</p><h2 id="Abstract-types-for-rings"><a class="docs-heading-anchor" href="#Abstract-types-for-rings">Abstract types for rings</a><a id="Abstract-types-for-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types-for-rings" title="Permalink"></a></h2><p>All commutative ring types in AbstractAlgebra belong to the <code>Ring</code> abstract type and commutative ring elements belong to the <code>RingElem</code> abstract type.</p><p>Noncommutative ring types belong to the <code>NCRing</code> abstract type and their elements to <code>NCRingElem</code>.</p><p>As Julia types cannot belong to our <code>RingElem</code> type hierarchy, we also provide the union type <code>RingElement</code> which includes <code>RingElem</code> in union with the Julia types <code>Integer</code>, <code>Rational</code> and <code>AbstractFloat</code>.</p><p>Similarly <code>NCRingElement</code> includes the Julia types just mentioned in union with <code>NCRingElem</code>.</p><p>Note that</p><pre><code class="language-julia hljs">Ring &lt;: NCRing
RingElem &lt;: NCRingElem
RingElement &lt;: NCRingElement</code></pre><h2 id="Functions-for-types-and-parents-of-rings"><a class="docs-heading-anchor" href="#Functions-for-types-and-parents-of-rings">Functions for types and parents of rings</a><a id="Functions-for-types-and-parents-of-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-types-and-parents-of-rings" title="Permalink"></a></h2><pre><code class="language-julia hljs">parent_type(::Type{T}) where T &lt;: NCRingElement
elem_type(::Type{T}) where T &lt;: NCRing</code></pre><p>Return the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.</p><pre><code class="language-julia hljs">base_ring(R::NCRing)
base_ring(a::NCRingElement)</code></pre><p>For generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.</p><pre><code class="language-julia hljs">parent(a::NCRingElement)</code></pre><p>Return the parent of the given ring element.</p><pre><code class="language-julia hljs">is_domain_type(::Type{T}) where T &lt;: NCRingElement
is_exact_type(::Type{T}) where T &lt;: NCRingElement</code></pre><p>Return true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)</p><p>The following function is implemented where mathematically and algorithmically possible.</p><pre><code class="language-julia hljs">characteristic(R::NCRing)</code></pre><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>If <code>R</code> is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.</p><pre><code class="language-julia hljs">(R::NCRing)() # constructs zero
(R::NCRing)(c::Integer)
(R::NCRing)(c::elem_type(R))
(R::NCRing{T})(a::T) where T &lt;: RingElement</code></pre><h2 id="Basic-functions"><a class="docs-heading-anchor" href="#Basic-functions">Basic functions</a><a id="Basic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functions" title="Permalink"></a></h2><p>All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.</p><p>In addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.</p><pre><code class="language-julia hljs">zero(R::NCRing)
one(R::NCRing)
iszero(a::NCRingElement)
isone(a::NCRingElement)</code></pre><p>In addition, the following are implemented where it is mathematically/algorithmically viable to do so.</p><pre><code class="language-julia hljs">is_unit(a::NCRingElement)
is_zero_divisor(a::NCRingElement)
is_zero_divisor_with_annihilator(a::NCRingElement)</code></pre><p>The following standard Julia functions are also implemented for all ring elements.</p><pre><code class="language-julia hljs">hash(f::RingElement, h::UInt)
deepcopy_internal(a::RingElement, dict::IdDict)
show(io::IO, R::NCRing)
show(io::IO, a::NCRingElement)</code></pre><h2 id="Basic-functionality-for-inexact-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-inexact-rings-only">Basic functionality for inexact rings only</a><a id="Basic-functionality-for-inexact-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-inexact-rings-only" title="Permalink"></a></h2><p>By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.</p><pre><code class="language-julia hljs">isequal(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>For floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.</p><pre><code class="language-julia hljs">isapprox(a::T, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>Similarly, for a parameterised ring with type <code>MyElem{T}</code> over such an inexact ring we have the following.</p><pre><code class="language-julia hljs">isapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement
isapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>These notionally perform a coercion into the parameterised ring before doing the approximate equality test.</p><h2 id="Basic-functionality-for-commutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-commutative-rings-only">Basic functionality for commutative rings only</a><a id="Basic-functionality-for-commutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-commutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia hljs">divexact(a::T, b::T) where T &lt;: RingElement
inv(a::T)</code></pre><p>Return <code>a/b</code> or <code>1/a</code> respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia&#39;s floating point division operator.</p><h2 id="Basic-functionality-for-noncommutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-noncommutative-rings-only">Basic functionality for noncommutative rings only</a><a id="Basic-functionality-for-noncommutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-noncommutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia hljs">divexact_left(a::T, b::T) where T &lt;: NCRingElement
divexact_right(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>As per <code>divexact</code> above, except that division by <code>b</code> happens on the left or right, respectively, of <code>a</code>.</p><h2 id="Unsafe-ring-operators"><a class="docs-heading-anchor" href="#Unsafe-ring-operators">Unsafe ring operators</a><a id="Unsafe-ring-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-ring-operators" title="Permalink"></a></h2><p>To speed up polynomial arithmetic, various unsafe operators are provided, which mutate the output rather than create a new object.</p><pre><code class="language-julia hljs">zero!(a::NCRingElement)
mul!(a::T, b::T, c::T) where T &lt;: NCRingElement
add!(a::T, b::T, c::T) where T &lt;: NCRingElement
addeq!(a::T, b::T) where T &lt;: NCRingElement
addmul!(a::T, b::T, c::T, t::T) where T &lt;: NCRingElement</code></pre><p>In each case the mutated object is the leftmost parameter.</p><p>The <code>addeq!(a, b)</code> operation does the same thing as <code>add!(a, a, b)</code>. The optional <code>addmul!(a, b, c, t)</code> operation does the same thing as <code>mul!(t, b, c); addeq!(a, t)</code> where <code>t</code> is a temporary which can be mutated so that an addition allocation is not needed.</p><h2 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h2><p>The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. <code>-1:10</code> for the range of allowed degrees for a univariate polynomial.</p><pre><code class="language-julia hljs">rand(R::NCRing, v...)</code></pre><h2 id="Factorization"><a class="docs-heading-anchor" href="#Factorization">Factorization</a><a id="Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization" title="Permalink"></a></h2><p>For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_irreducible-Tuple{T} where T&lt;:RingElement" href="#AbstractAlgebra.is_irreducible-Tuple{T} where T&lt;:RingElement"><code>AbstractAlgebra.is_irreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_irreducible(a::RingElement)</code></pre><p>Return <code>true</code> if <span>$a$</span> is irreducible, else return <code>false</code>. Zero and units are by definition never irreducible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/algorithms/GenericFunctions.jl#L469-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_squarefree-Tuple{T} where T&lt;:RingElement" href="#AbstractAlgebra.is_squarefree-Tuple{T} where T&lt;:RingElement"><code>AbstractAlgebra.is_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_squarefree(a::RingElement)</code></pre><p>Return <code>true</code> if <span>$a$</span> is squarefree, else return <code>false</code>. An element is squarefree if it it is not divisible by any squares except the squares of units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/algorithms/GenericFunctions.jl#L482-L488">source</a></section></article><pre><code class="language-julia hljs">factor(a::T) where T &lt;: RingElement
factor_squarefree(a::T) where T &lt;: RingElement</code></pre><p>Return a factorization into irreducible or squarefree elements, respectively. The return is an object of type <code>Fac{T}</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Fac" href="#AbstractAlgebra.Fac"><code>AbstractAlgebra.Fac</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fac{T &lt;: RingElement}</code></pre><p>Type for factored ring elements. The structure holds a unit of type <code>T</code> and is an iterable collection of <code>T =&gt; Int</code> pairs for the factors and exponents.</p><p>See <a href="#AbstractAlgebra.unit-Tuple{Fac}"><code>unit(a::Fac)</code></a>, <a href="#AbstractAlgebra.evaluate-Tuple{Fac}"><code>evaluate(a::Fac)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/Factor.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.unit-Tuple{Fac}" href="#AbstractAlgebra.unit-Tuple{Fac}"><code>AbstractAlgebra.unit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unit(a::Fac{T}) -&gt; T</code></pre><p>Return the unit of the factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/Factor.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.evaluate-Tuple{Fac}" href="#AbstractAlgebra.evaluate-Tuple{Fac}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(a::Fac{T}) -&gt; T</code></pre><p>Multiply out the factorization into a single element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/Factor.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Fac, Any}" href="#Base.getindex-Tuple{Fac, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(a::Fac, b) -&gt; Int</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding exponent is returned. Otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/Factor.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}" href="#Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(a::Fac{T}, c::Int, b::T)</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding entry is set to <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/f97f91da137ce1ed67b2463215559b1f77010f65/src/Factor.jl#L93-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ring_introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../integer/">Integer ring »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 08:11">Tuesday 9 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
