<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ring functionality · AbstractAlgebra.jl</title><meta name="title" content="Ring functionality · AbstractAlgebra.jl"/><meta property="og:title" content="Ring functionality · AbstractAlgebra.jl"/><meta property="twitter:title" content="Ring functionality · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Ring functionality</a><ul class="internal"><li><a class="tocitem" href="#Abstract-types-for-rings"><span>Abstract types for rings</span></a></li><li><a class="tocitem" href="#Functions-for-types-and-parents-of-rings"><span>Functions for types and parents of rings</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Basic-functions"><span>Basic functions</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-inexact-rings-only"><span>Basic functionality for inexact rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-commutative-rings-only"><span>Basic functionality for commutative rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-noncommutative-rings-only"><span>Basic functionality for noncommutative rings only</span></a></li><li><a class="tocitem" href="#Unsafe-ring-operators"><span>Unsafe ring operators</span></a></li><li><a class="tocitem" href="#Random-generation"><span>Random generation</span></a></li><li><a class="tocitem" href="#Factorization"><span>Factorization</span></a></li><li><a class="tocitem" href="#Square-root"><span>Square root</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../ideal_interface/">Ideal Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href>Ring functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ring functionality</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ring.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ring-functionality"><a class="docs-heading-anchor" href="#Ring-functionality">Ring functionality</a><a id="Ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-functionality" title="Permalink"></a></h1><p>AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.</p><h2 id="Abstract-types-for-rings"><a class="docs-heading-anchor" href="#Abstract-types-for-rings">Abstract types for rings</a><a id="Abstract-types-for-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types-for-rings" title="Permalink"></a></h2><p>All commutative ring types in AbstractAlgebra belong to the <code>Ring</code> abstract type and commutative ring elements belong to the <code>RingElem</code> abstract type.</p><p>Noncommutative ring types belong to the <code>NCRing</code> abstract type and their elements to <code>NCRingElem</code>.</p><p>As Julia types cannot belong to our <code>RingElem</code> type hierarchy, we also provide the union type <code>RingElement</code> which includes <code>RingElem</code> in union with the Julia types <code>Integer</code>, <code>Rational</code> and <code>AbstractFloat</code>.</p><p>Similarly <code>NCRingElement</code> includes the Julia types just mentioned in union with <code>NCRingElem</code>.</p><p>Note that</p><pre><code class="language-julia hljs">Ring &lt;: NCRing
RingElem &lt;: NCRingElem
RingElement &lt;: NCRingElement</code></pre><h2 id="Functions-for-types-and-parents-of-rings"><a class="docs-heading-anchor" href="#Functions-for-types-and-parents-of-rings">Functions for types and parents of rings</a><a id="Functions-for-types-and-parents-of-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-types-and-parents-of-rings" title="Permalink"></a></h2><pre><code class="language-julia hljs">parent_type(::Type{T}) where T &lt;: NCRingElement
elem_type(::Type{T}) where T &lt;: NCRing</code></pre><p>Return the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.</p><pre><code class="language-julia hljs">base_ring(R::NCRing)
base_ring(a::NCRingElement)</code></pre><p>For generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.</p><pre><code class="language-julia hljs">parent(a::NCRingElement)</code></pre><p>Return the parent of the given ring element.</p><pre><code class="language-julia hljs">is_domain_type(::Type{T}) where T &lt;: NCRingElement
is_exact_type(::Type{T}) where T &lt;: NCRingElement</code></pre><p>Return true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)</p><p>The following function is implemented where mathematically and algorithmically possible.</p><article><details class="docstring"><summary id="AbstractAlgebra.characteristic-Tuple{NCRing}"><a class="docstring-binding" href="#AbstractAlgebra.characteristic-Tuple{NCRing}"><code>AbstractAlgebra.characteristic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">characteristic(R::NCRing)</code></pre><p>Return the characteristic of the ring <code>R</code>. If the characteristic is not known, an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/NCRings.jl#L206-L211">source</a></section></details></article><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>If <code>R</code> is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.</p><pre><code class="language-julia hljs">(R::NCRing)() # constructs zero
(R::NCRing)(c::Integer)
(R::NCRing)(c::elem_type(R))
(R::NCRing{T})(a::T) where T &lt;: RingElement</code></pre><h2 id="Basic-functions"><a class="docs-heading-anchor" href="#Basic-functions">Basic functions</a><a id="Basic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functions" title="Permalink"></a></h2><p>All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.</p><p>In addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.</p><pre><code class="language-julia hljs">zero(R::NCRing)
one(R::NCRing)
iszero(a::NCRingElement)
isone(a::NCRingElement)</code></pre><p>In addition, the following are implemented where it is mathematically/algorithmically viable to do so.</p><pre><code class="language-julia hljs">is_unit(a::NCRingElement)
is_zero_divisor(a::NCRingElement)
is_zero_divisor_with_annihilator(a::NCRingElement)</code></pre><p>The following standard Julia functions are also implemented for all ring elements.</p><pre><code class="language-julia hljs">hash(f::RingElement, h::UInt)
deepcopy_internal(a::RingElement, dict::IdDict)
show(io::IO, R::NCRing)
show(io::IO, a::NCRingElement)</code></pre><h2 id="Basic-functionality-for-inexact-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-inexact-rings-only">Basic functionality for inexact rings only</a><a id="Basic-functionality-for-inexact-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-inexact-rings-only" title="Permalink"></a></h2><p>By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.</p><pre><code class="language-julia hljs">isequal(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>For floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.</p><pre><code class="language-julia hljs">isapprox(a::T, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>Similarly, for a parameterised ring with type <code>MyElem{T}</code> over such an inexact ring we have the following.</p><pre><code class="language-julia hljs">isapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement
isapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>These notionally perform a coercion into the parameterised ring before doing the approximate equality test.</p><h2 id="Basic-functionality-for-commutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-commutative-rings-only">Basic functionality for commutative rings only</a><a id="Basic-functionality-for-commutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-commutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia hljs">divexact(a::T, b::T) where T &lt;: RingElement
inv(a::T)</code></pre><p>Return <code>a/b</code> or <code>1/a</code> respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia&#39;s floating point division operator.</p><h2 id="Basic-functionality-for-noncommutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-noncommutative-rings-only">Basic functionality for noncommutative rings only</a><a id="Basic-functionality-for-noncommutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-noncommutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia hljs">divexact_left(a::T, b::T) where T &lt;: NCRingElement
divexact_right(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>As per <code>divexact</code> above, except that division by <code>b</code> happens on the left or right, respectively, of <code>a</code>.</p><h2 id="Unsafe-ring-operators"><a class="docs-heading-anchor" href="#Unsafe-ring-operators">Unsafe ring operators</a><a id="Unsafe-ring-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-ring-operators" title="Permalink"></a></h2><p>To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.</p><p>For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don&#39;t have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.</p><p>Note the exclamation point is a convention, which indicates that the object may be mutated in-place.</p><p>To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!</p><p>The results of <code>deepcopy</code> and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.</p><div class="admonition is-info" id="Note-f207eddc89ec91da"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f207eddc89ec91da" title="Permalink"></a></header><div class="admonition-body"><p>It is important to recognise that <code>R(a)</code> where <code>R</code> is the ring <code>a</code> belongs to, does not create a new value. For this case, use <code>deepcopy(a)</code>.</p></div></div><article><details class="docstring"><summary id="AbstractAlgebra.zero!"><a class="docstring-binding" href="#AbstractAlgebra.zero!"><code>AbstractAlgebra.zero!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zero!(a)</code></pre><p>Return <code>zero(parent(a))</code>, possibly modifying the object <code>a</code> in the process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L358-L362">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.one!"><a class="docstring-binding" href="#AbstractAlgebra.one!"><code>AbstractAlgebra.one!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">one!(a)</code></pre><p>Return <code>one(parent(a))</code>, possibly modifying the object <code>a</code> in the process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L365-L369">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.add!"><a class="docstring-binding" href="#AbstractAlgebra.add!"><code>AbstractAlgebra.add!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add!(z, a, b)
add!(a, b)</code></pre><p>Return <code>a + b</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>add!(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L401-L408">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.sub!"><a class="docstring-binding" href="#AbstractAlgebra.sub!"><code>AbstractAlgebra.sub!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sub!(z, a, b)
sub!(a, b)</code></pre><p>Return <code>a - b</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>sub!(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L401-L408">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.mul!"><a class="docstring-binding" href="#AbstractAlgebra.mul!"><code>AbstractAlgebra.mul!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mul!(z, a, b)
mul!(a, b)</code></pre><p>Return <code>a * b</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>mul!(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L401-L408">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.neg!"><a class="docstring-binding" href="#AbstractAlgebra.neg!"><code>AbstractAlgebra.neg!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">neg!(z, a)
neg!(a)</code></pre><p>Return <code>-a</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The unary version is a shorthand for <code>neg!(a, a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L372-L379">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.inv!"><a class="docstring-binding" href="#AbstractAlgebra.inv!"><code>AbstractAlgebra.inv!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inv!(z, a)
inv!(a)</code></pre><p>Return <code>AbstractAlgebra.inv(a)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The unary version is a shorthand for <code>inv!(a, a)</code>.</p><div class="admonition is-info" id="Note-d1d06adb20339d11"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d1d06adb20339d11" title="Permalink"></a></header><div class="admonition-body"><p><code>AbstractAlgebra.inv</code> and <code>Base.inv</code> differ only in their behavior on julia types like <code>Integer</code> and <code>Rational{Int}</code>. The former makes it adhere to the Ring interface.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L383-L395">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.addmul!"><a class="docstring-binding" href="#AbstractAlgebra.addmul!"><code>AbstractAlgebra.addmul!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">addmul!(z, a, b, t)
addmul!(z, a, b)</code></pre><p>Return <code>z + a * b</code>, possibly modifying the objects <code>z</code> and <code>t</code> in the process.</p><p>The second version is usually a shorthand for <code>addmul!(z, a, b, parent(z)())</code>, but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L414-L423">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.submul!"><a class="docstring-binding" href="#AbstractAlgebra.submul!"><code>AbstractAlgebra.submul!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">submul!(z, a, b, t)
submul!(z, a, b)</code></pre><p>Return <code>z - a * b</code>, possibly modifying the objects <code>z</code> and <code>t</code> in the process.</p><p>The second version is usually a shorthand for <code>submul!(z, a, b, parent(z)())</code>, but in some cases may be more efficient. For multiple operations in a row that use temporary storage, it is still best to use the four argument version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L427-L436">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.divexact!"><a class="docstring-binding" href="#AbstractAlgebra.divexact!"><code>AbstractAlgebra.divexact!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">divexact!(z, a, b)
divexact!(a, b)</code></pre><p>Return <code>divexact(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>divexact(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L445-L452">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.div!"><a class="docstring-binding" href="#AbstractAlgebra.div!"><code>AbstractAlgebra.div!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">div!(z, a, b)
div!(a, b)</code></pre><p>Return <code>div(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>div(a, a, b)</code>.</p><div class="admonition is-info" id="Note-1b0bccbfbe87b718"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1b0bccbfbe87b718" title="Permalink"></a></header><div class="admonition-body"><p><code>AbstractAlgebra.div</code> and <code>Base.div</code> differ only in their behavior on julia types like <code>Integer</code> and <code>Rational{Int}</code>. The former makes it adhere to the Ring interface.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L458-L470">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.rem!"><a class="docstring-binding" href="#AbstractAlgebra.rem!"><code>AbstractAlgebra.rem!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rem!(z, a, b)
rem!(a, b)</code></pre><p>Return <code>rem(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>rem(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L445-L452">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.mod!"><a class="docstring-binding" href="#AbstractAlgebra.mod!"><code>AbstractAlgebra.mod!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mod!(z, a, b)
mod!(a, b)</code></pre><p>Return <code>mod(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>mod(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L445-L452">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.gcd!"><a class="docstring-binding" href="#AbstractAlgebra.gcd!"><code>AbstractAlgebra.gcd!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gcd!(z, a, b)
gcd!(a, b)</code></pre><p>Return <code>gcd(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>gcd(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L445-L452">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.lcm!"><a class="docstring-binding" href="#AbstractAlgebra.lcm!"><code>AbstractAlgebra.lcm!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lcm!(z, a, b)
lcm!(a, b)</code></pre><p>Return <code>lcm(a, b)</code>, possibly modifying the object <code>z</code> in the process. Aliasing is permitted. The two argument version is a shorthand for <code>lcm(a, a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/fundamental_interface.jl#L445-L452">source</a></section></details></article><h2 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h2><p>The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. <code>-1:10</code> for the range of allowed degrees for a univariate polynomial.</p><pre><code class="language-julia hljs">rand(R::NCRing, v...)</code></pre><h2 id="Factorization"><a class="docs-heading-anchor" href="#Factorization">Factorization</a><a id="Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization" title="Permalink"></a></h2><p>For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.</p><article><details class="docstring"><summary id="AbstractAlgebra.is_irreducible-Tuple{T} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_irreducible-Tuple{T} where T&lt;:RingElement"><code>AbstractAlgebra.is_irreducible</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_irreducible(a::RingElement)</code></pre><p>Return <code>true</code> if <span>$a$</span> is irreducible, else return <code>false</code>. Zero and units are by definition never irreducible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/algorithms/GenericFunctions.jl#L469-L474">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_squarefree-Tuple{T} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_squarefree-Tuple{T} where T&lt;:RingElement"><code>AbstractAlgebra.is_squarefree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_squarefree(a::RingElement)</code></pre><p>Return <code>true</code> if <span>$a$</span> is squarefree, else return <code>false</code>. An element is squarefree if it it is not divisible by any squares except the squares of units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/algorithms/GenericFunctions.jl#L482-L488">source</a></section></details></article><pre><code class="language-julia hljs">factor(a::T) where T &lt;: RingElement
factor_squarefree(a::T) where T &lt;: RingElement</code></pre><p>Return a factorization into irreducible or squarefree elements, respectively. The return is an object of type <code>Fac{T}</code>.</p><article><details class="docstring"><summary id="AbstractAlgebra.Fac"><a class="docstring-binding" href="#AbstractAlgebra.Fac"><code>AbstractAlgebra.Fac</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Fac{T &lt;: RingElement}</code></pre><p>Type for factored ring elements. The structure holds a unit of type <code>T</code> and is an iterable collection of <code>T =&gt; Int</code> pairs for the factors and exponents.</p><p>See <a href="#AbstractAlgebra.unit-Tuple{Fac}"><code>unit(a::Fac)</code></a>, <a href="#AbstractAlgebra.evaluate-Tuple{Fac}"><code>evaluate(a::Fac)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/Factor.jl#L13-L20">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.unit-Tuple{Fac}"><a class="docstring-binding" href="#AbstractAlgebra.unit-Tuple{Fac}"><code>AbstractAlgebra.unit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit(a::Fac{T}) -&gt; T</code></pre><p>Return the unit of the factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/Factor.jl#L63-L67">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.evaluate-Tuple{Fac}"><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Tuple{Fac}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate(a::Fac{T}) -&gt; T</code></pre><p>Multiply out the factorization into a single element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/Factor.jl#L72-L76">source</a></section></details></article><article><details class="docstring"><summary id="Base.getindex-Tuple{Fac, Any}"><a class="docstring-binding" href="#Base.getindex-Tuple{Fac, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(a::Fac, b) -&gt; Int</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding exponent is returned. Otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/Factor.jl#L112-L117">source</a></section></details></article><article><details class="docstring"><summary id="Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}"><a class="docstring-binding" href="#Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(a::Fac{T}, c::Int, b::T)</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding entry is set to <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/Factor.jl#L133-L137">source</a></section></details></article><h2 id="Square-root"><a class="docs-heading-anchor" href="#Square-root">Square root</a><a id="Square-root-1"></a><a class="docs-heading-anchor-permalink" href="#Square-root" title="Permalink"></a></h2><p>Rings may implement functionality for detecting and computing square roots.</p><p>The exact behaviour depends on the ring. Some rings provide both operations, while others only implement <code>is_square</code>.</p><article><details class="docstring"><summary id="AbstractAlgebra.is_square"><a class="docstring-binding" href="#AbstractAlgebra.is_square"><code>AbstractAlgebra.is_square</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_square(a::NCRingElement)</code></pre><p>Return <code>true</code> iff <code>a</code> is the square of a value in its own ring. See also <code>is_square(M::MatElem)</code> which tests whether a matrix has square shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/NCRings.jl#L181-L186">source</a></section><section><div><pre><code class="language-julia hljs">is_square(M::MatElem)</code></pre><p>Return <code>true</code> iff the matrix <code>M</code> has square shape. See also <code>is_square(a::T)  where {T &lt;: NCRingElement}</code> which tests whether the given value <code>a</code> is a square in its own ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/generic/Matrix.jl#L84-L89">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.sqrt-Tuple{NCRingElem}"><a class="docstring-binding" href="#AbstractAlgebra.sqrt-Tuple{NCRingElem}"><code>AbstractAlgebra.sqrt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sqrt(a::NCRingElem; check::Bool=true)</code></pre><p>Return a square root of <code>a</code>, if it exists. By default (<code>check=true</code>), implementations should raise an exception if <code>a</code> is not a square in its ring. If <code>check=false</code>, implementations may skip this verification.</p><p>See also <code>is_square</code> and <code>is_square_with_sqrt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/NCRings.jl#L189-L197">source</a></section></details></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><p>There are some miscellaneous functions for rings to ease up certain computations.</p><article><details class="docstring"><summary id="AbstractAlgebra.Generic.falling_factorial"><a class="docstring-binding" href="#AbstractAlgebra.Generic.falling_factorial"><code>AbstractAlgebra.Generic.falling_factorial</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">falling_factorial(x::RingElement, n::Integer)</code></pre><p>Return the falling factorial of <span>$x$</span>, i.e. <span>$x(x - 1)(x - 2)\cdots (x - n + 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = ZZ[:x];

julia&gt; falling_factorial(x, 1)
x

julia&gt; falling_factorial(x, 2)
x^2 - x

julia&gt; falling_factorial(4, 2)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/generic/Misc/Rings.jl#L31-L51">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.Generic.rising_factorial"><a class="docstring-binding" href="#AbstractAlgebra.Generic.rising_factorial"><code>AbstractAlgebra.Generic.rising_factorial</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rising_factorial(x::RingElement, n::Integer)</code></pre><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\cdots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = ZZ[:x];

julia&gt; rising_factorial(x, 1)
x

julia&gt; rising_factorial(x, 2)
x^2 + x

julia&gt; rising_factorial(4, 2)
20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/generic/Misc/Rings.jl#L54-L74">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.Generic.rising_factorial2"><a class="docstring-binding" href="#AbstractAlgebra.Generic.rising_factorial2"><code>AbstractAlgebra.Generic.rising_factorial2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rising_factorial2(x::RingElement, n::Integer)</code></pre><p>Return a tuple containing the rising factorial <span>$x(x + 1)\cdots (x + n - 1)$</span> and its derivative. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = ZZ[:x];

julia&gt; rising_factorial2(x, 1)
(x, 1)

julia&gt; rising_factorial2(x, 2)
(x^2 + x, 2*x + 1)

julia&gt; rising_factorial2(4, 2)
(20, 9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/06b8a79d7824f38c211a3526b10fa3cc913a05cb/src/generic/Misc/Rings.jl#L85-L106">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ring_introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../integer/">Integer ring »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 04:02">Tuesday 3 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
