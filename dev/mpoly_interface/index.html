<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate Polynomial Ring Interface · AbstractAlgebra.jl</title><meta name="title" content="Multivariate Polynomial Ring Interface · AbstractAlgebra.jl"/><meta property="og:title" content="Multivariate Polynomial Ring Interface · AbstractAlgebra.jl"/><meta property="twitter:title" content="Multivariate Polynomial Ring Interface · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li class="is-active"><a class="tocitem" href>Multivariate Polynomial Ring Interface</a><ul class="internal"><li><a class="tocitem" href="#Types-and-parents"><span>Types and parents</span></a></li><li><a class="tocitem" href="#Required-functionality-for-multivariate-polynomials"><span>Required functionality for multivariate polynomials</span></a></li><li><a class="tocitem" href="#Interface-for-sparse-distributed,-random-access-multivariates"><span>Interface for sparse distributed, random access multivariates</span></a></li><li><a class="tocitem" href="#Optional-functionality-for-multivariate-polynomials"><span>Optional functionality for multivariate polynomials</span></a></li></ul></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>Multivariate Polynomial Ring Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate Polynomial Ring Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mpoly_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-Polynomial-Ring-Interface"><a class="docs-heading-anchor" href="#Multivariate-Polynomial-Ring-Interface">Multivariate Polynomial Ring Interface</a><a id="Multivariate-Polynomial-Ring-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Polynomial-Ring-Interface" title="Permalink"></a></h1><p>Multivariate polynomial rings are supported in AbstractAlgebra.jl, and in addition to the standard Ring interface, numerous additional functions are provided.</p><p>Unlike other kinds of rings, even complex operations such as GCD depend heavily on the multivariate representation. Therefore AbstractAlgebra.jl cannot provide much in the way of additional functionality to external multivariate implementations.</p><p>This means that external libraries must be able to implement their multivariate formats in whatever way they see fit. The required interface here should be implemented, even if it is not optimal. But it can be extended, either by implementing one of the optional interfaces, or by extending the required interface in some other way.</p><p>Naturally, any multivariate polynomial ring implementation provides the full Ring interface, in order to be treated as a ring for the sake of AbstractAlgebra.jl.</p><p>Considerations which make it impossible for AbstractAlgebra.jl to provide generic functionality on top of an arbitrary multivariate module include:</p><ul><li>orderings (lexical, degree, weighted, block, arbitrary)</li><li>sparse or dense representation</li><li>distributed or recursive representation</li><li>packed or unpacked exponents</li><li>exponent bounds (and whether adaptive or not)</li><li>random access or iterators</li><li>whether monomials and polynomials have the same type</li><li>whether special cache aware data structures such as Geobuckets are used</li></ul><h2 id="Types-and-parents"><a class="docs-heading-anchor" href="#Types-and-parents">Types and parents</a><a id="Types-and-parents-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-parents" title="Permalink"></a></h2><p>AbstractAlgebra.jl provides two abstract types for multivariate polynomial rings and their elements:</p><ul><li><code>MPolyRing{T}</code> is the abstract type for multivariate polynomial ring parent types</li><li><code>MPolyRingElem{T}</code> is the abstract type for multivariate polynomial types</li></ul><p>We have that <code>MPolyRing{T} &lt;: Ring</code> and <code>MPolyRingElem{T} &lt;: RingElem</code>.</p><p>Note that both abstract types are parameterised. The type <code>T</code> should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of <span>$\mathbb{Z}[x, y]$</span> the type <code>T</code> would be the type of an integer, e.g. <code>BigInt</code>.</p><p>Multivariate polynomial rings should be made unique on the system by caching parent objects (unless an optional <code>cache</code> parameter is set to <code>false</code>). Multivariate polynomial rings should at least be distinguished based on their base (coefficient) ring and number of variables. But if they have the same base ring, symbols (for their variables/generators) and ordering, they should certainly have the same parent object.</p><p>See <code>src/generic/GenericTypes.jl</code> for an example of how to implement such a cache (which usually makes use of a dictionary).</p><h2 id="Required-functionality-for-multivariate-polynomials"><a class="docs-heading-anchor" href="#Required-functionality-for-multivariate-polynomials">Required functionality for multivariate polynomials</a><a id="Required-functionality-for-multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-multivariate-polynomials" title="Permalink"></a></h2><p>In addition to the required functionality for the Ring interface, the Multivariate Polynomial interface has the following required functions.</p><p>We suppose that <code>R</code> is a fictitious base ring (coefficient ring) and that <code>S</code> is a multivariate polynomial ring over <code>R</code> (i.e. <span>$S = R[x, y, \ldots]$</span>) with parent object <code>S</code> of type <code>MyMPolyRing{T}</code>. We also assume the polynomials in the ring have type <code>MyMPoly{T}</code>, where <code>T</code> is the type of elements of the base (coefficient) ring.</p><p>Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.</p><p>Note that the type <code>T</code> must (transitively) belong to the abstract type <code>RingElem</code> or more generally the union type <code>RingElement</code> which includes the Julia integer, rational and floating point types.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>To construct a multivariate polynomial ring, there is the following constructor.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}-mpoly_interface" href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}-mpoly_interface"><code>AbstractAlgebra.polynomial_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached=true, internal_ordering=:lex)</code></pre><p>Given a coefficient ring <code>R</code> and variable names, say <code>varnames = [:x1, :x2, ...]</code>, return a tuple <code>S, [x1, x2, ...]</code> of the polynomial ring <span>$S = R[x1, x2, \dots]$</span> and its generators <span>$x1, x2, \dots$</span>.</p><p>By default (<code>cached=true</code>), the output <code>S</code> will be cached, i.e. if <code>polynomial_ring</code> is invoked again with the same arguments, the same (<em>identical</em>) ring is returned. Setting <code>cached</code> to <code>false</code> ensures a distinct new ring is returned, and will also prevent it from being cached.</p><p>The monomial ordering used for the internal storage of polynomials in <code>S</code> can be set with <code>internal_ordering</code> and must be one of <code>:lex</code>, <code>:deglex</code> or <code>:degrevlex</code>.</p><p>See also: <a href="../mpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}"><code>polynomial_ring(::Ring, ::Vararg)</code></a>, <a href="../mpolynomial/#AbstractAlgebra.@polynomial_ring"><code>@polynomial_ring</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, generators = polynomial_ring(ZZ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2b92e83f0834eefa50e8cf105396c6797fabb746/src/MPoly.jl#L1482-L1505">source</a></section></article><p>Polynomials in a given ring can be constructed using the generators and basic polynomial arithmetic. However, this is inefficient and the following build context is provided for building polynomials term-by-term. It assumes the polynomial data type is random access, and so the constructor functions must be reimplemented for all other types of polynomials.</p><pre><code class="language-julia hljs">MPolyBuildCtx(R::MPolyRing)</code></pre><p>Return a build context for creating polynomials in the given polynomial ring.</p><pre><code class="language-julia hljs">push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})</code></pre><p>Add the term with coefficient <span>$c$</span> and exponent vector <span>$v$</span> to the polynomial under construction in the build context <span>$M$</span>.</p><pre><code class="language-julia hljs">finish(M::MPolyBuildCtx)</code></pre><p>Finish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.</p><h3 id="Data-type-and-parent-object-methods"><a class="docs-heading-anchor" href="#Data-type-and-parent-object-methods">Data type and parent object methods</a><a id="Data-type-and-parent-object-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Data-type-and-parent-object-methods" title="Permalink"></a></h3><pre><code class="language-julia hljs">symbols(S::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return an array of <code>Symbol</code>s representing the variables (generators) of the polynomial ring. Note that these are <code>Symbol</code>s not <code>String</code>s, though their string values will usually be used when printing polynomials.</p><pre><code class="language-julia hljs">number_of_variables(f::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return the number of variables of the polynomial ring.</p><pre><code class="language-julia hljs">gens(S::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return an array of all the generators (variables) of the given polynomial ring (as polynomials).</p><p>The first entry in the array will be the variable with most significance with respect to the ordering.</p><pre><code class="language-julia hljs">gen(S::MyMPolyRing{T}, i::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$i$</span>-th generator (variable) of the given polynomial ring (as a polynomial).</p><pre><code class="language-julia hljs">internal_ordering(S::MyMPolyRing{T})</code></pre><p>Return the ordering of the given polynomial ring as a symbol. Supported values currently include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code>.</p><h3 id="Basic-manipulation-of-rings-and-elements"><a class="docs-heading-anchor" href="#Basic-manipulation-of-rings-and-elements">Basic manipulation of rings and elements</a><a id="Basic-manipulation-of-rings-and-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation-of-rings-and-elements" title="Permalink"></a></h3><pre><code class="language-julia hljs">length(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the number of nonzero terms of the given polynomial. The length of the zero polynomial is defined to be <span>$0$</span>. The return value should be of type <code>Int</code>.</p><pre><code class="language-julia hljs">degrees(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an array of the degrees of the polynomial <span>$f$</span> in each of the variables.</p><pre><code class="language-julia hljs">total_degree(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the total degree of the polynomial <span>$f$</span>, i.e. the highest sum of exponents occurring in any term of <span>$f$</span>.</p><pre><code class="language-julia hljs">is_gen(x::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <code>true</code> if <span>$x$</span> is a generator of the polynomial ring.</p><pre><code class="language-julia hljs">coefficients(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the coefficients of the polynomial <span>$p$</span>, starting with the coefficient of the most significant term with respect to the ordering. Generic code will provide this function automatically for random access polynomials that implement the <code>coeff</code> function.</p><pre><code class="language-julia hljs">monomials(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the monomials of the polynomial <span>$p$</span>, starting with the monomial of the most significant term with respect to the ordering. Monomials in AbstractAlgebra are defined to have coefficient <span>$1$</span>. See the function <code>terms</code> if you also require the coefficients, however note that only monomials can be compared. Generic code will provide this function automatically for random access polynomials that implement the <code>monomial</code> function.</p><pre><code class="language-julia hljs">terms(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the terms of the polynomial <span>$p$</span>, starting with the most significant term with respect to the ordering. Terms in AbstractAlgebra include the coefficient. Generic code will provide this function automatically for random access polynomials that implement the <code>term</code> function.</p><pre><code class="language-julia hljs">exponent_vectors(a::MyMPoly{T}) where T &lt;: RingElement</code></pre><p>Return an iterator for the exponent vectors for each of the terms of the polynomial starting with the most significant term with respect to the ordering. Each exponent vector is an array of <code>Int</code>s, one for each variable, in the order given when the polynomial ring was created. Generic code will provide this function automatically for random access polynomials that implement the <code>exponent_vector</code> function.</p><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><p>For any ring that implements exact division, the following can be implemented.</p><pre><code class="language-julia hljs">divexact(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the exact quotient of <span>$f$</span> by <span>$g$</span> if it exists, otherwise throw an error.</p><pre><code class="language-julia hljs">divides(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <code>(flag, q)</code> where <code>flag</code> is <code>true</code> if <span>$g$</span> divides <span>$f$</span>, in which case <span>$q$</span> will be the exact quotient, or <code>flag</code> is false and <span>$q$</span> is set to zero.</p><pre><code class="language-julia hljs">remove(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <span>$(v, q)$</span> such that the highest power of <span>$g$</span> that divides <span>$f$</span> is <span>$g^v$</span> and the cofactor is <span>$q$</span>.</p><pre><code class="language-julia hljs">valuation(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <span>$v$</span> such that the highest power of <span>$g$</span> that divides <span>$f$</span> is <span>$g^v$</span>.</p><h3 id="Ad-hoc-exact-division"><a class="docs-heading-anchor" href="#Ad-hoc-exact-division">Ad hoc exact division</a><a id="Ad-hoc-exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Ad-hoc-exact-division" title="Permalink"></a></h3><p>For any ring that implements exact division, the following can be implemented.</p><pre><code class="language-julia hljs">divexact(f::MyMPoly{T}, c::Integer) where T &lt;: RingElem
divexact(f::MyMPoly{T}, c::Rational) where T &lt;: RingElem
divexact(f::MyMPoly{T}, c::T) where T &lt;: RingElem</code></pre><p>Divide the polynomial exactly by the constant <span>$c$</span>.</p><h3 id="Euclidean-division"><a class="docs-heading-anchor" href="#Euclidean-division">Euclidean division</a><a id="Euclidean-division-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-division" title="Permalink"></a></h3><p>Although multivariate polynomial rings are not in general Euclidean, it is possible to define a quotient with remainder function that depends on the polynomial ordering in the case that the quotient ring is a field or a Euclidean domain. In the case that a polynomial <span>$g$</span> divides a polynomial <span>$f$</span>, the result no longer depends on the ordering and the remainder is zero, with the quotient agreeing with the exact quotient.</p><pre><code class="language-julia hljs">divrem(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <span>$(q, r)$</span> such that <span>$f = qg + r$</span>, where the coefficients of terms of <span>$r$</span> whose monomials are divisible by the leading monomial of <span>$g$</span> are reduced modulo the leading coefficient of <span>$g$</span> (according to the Euclidean function on the coefficients).</p><p>Note that the result of this function depends on the ordering of the polynomial ring.</p><pre><code class="language-julia hljs">div(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>As per the <code>divrem</code> function, but returning the quotient only. Especially when the quotient happens to be exact, this function can be exceedingly fast.</p><h3 id="GCD"><a class="docs-heading-anchor" href="#GCD">GCD</a><a id="GCD-1"></a><a class="docs-heading-anchor-permalink" href="#GCD" title="Permalink"></a></h3><p>In cases where there is a meaningful Euclidean structure on the coefficient ring, it is possible to compute the GCD of multivariate polynomials.</p><pre><code class="language-julia hljs">gcd(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a greatest common divisor of <span>$f$</span> and <span>$g$</span>.</p><h3 id="Square-root"><a class="docs-heading-anchor" href="#Square-root">Square root</a><a id="Square-root-1"></a><a class="docs-heading-anchor-permalink" href="#Square-root" title="Permalink"></a></h3><p>Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.</p><pre><code class="language-julia hljs">sqrt(f::MyMPoly{T}, check::Bool=true) where T &lt;: RingElem</code></pre><p>Return the square root of the polynomial <span>$f$</span> and raise an exception if it is not a square. If <code>check</code> is set to <code>false</code>, the input is assumed to be a perfect square and this assumption is not fully checked. This can be significantly faster.</p><pre><code class="language-julia hljs">is_square(::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <code>true</code> if <span>$f$</span> is a square.</p><h2 id="Interface-for-sparse-distributed,-random-access-multivariates"><a class="docs-heading-anchor" href="#Interface-for-sparse-distributed,-random-access-multivariates">Interface for sparse distributed, random access multivariates</a><a id="Interface-for-sparse-distributed,-random-access-multivariates-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-sparse-distributed,-random-access-multivariates" title="Permalink"></a></h2><p>The following additional functions should be implemented by libraries that provide a sparse distributed polynomial format, stored in a representation for which terms can be accessed in constant time (e.g. where arrays are used to store coefficients and exponent vectors).</p><h3 id="Sparse-distributed,-random-access-constructors"><a class="docs-heading-anchor" href="#Sparse-distributed,-random-access-constructors">Sparse distributed, random access constructors</a><a id="Sparse-distributed,-random-access-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-distributed,-random-access-constructors" title="Permalink"></a></h3><p>In addition to the standard constructors, the following constructor, taking arrays of coefficients and exponent vectors, should be provided.</p><pre><code class="language-julia hljs">(S::MyMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T &lt;: RingElem</code></pre><p>Create the polynomial in the given ring with nonzero coefficients specified by the elements of <span>$A$</span> and corresponding exponent vectors given by the elements of <span>$m$</span>.</p><p>There is no assumption about coefficients being nonzero or terms being in order or unique. Zero terms are removed by the function, duplicate terms are combined (added) and the terms are sorted so that they are in the correct order.</p><p>Each exponent vector uses a separate integer for each exponent field, the first of which should be the exponent for the most significant variable with respect to the ordering. All exponents must be non-negative.</p><p>A library may also optionally provide an interface that makes use of <code>BigInt</code> (or any other big integer type) for exponents instead of <code>Int</code>.</p><h3 id="Sparse-distributed,-random-access-basic-manipulation"><a class="docs-heading-anchor" href="#Sparse-distributed,-random-access-basic-manipulation">Sparse distributed, random access basic manipulation</a><a id="Sparse-distributed,-random-access-basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-distributed,-random-access-basic-manipulation" title="Permalink"></a></h3><pre><code class="language-julia hljs">coeff(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the coefficient of the <span>$n$</span>-th term of <span>$f$</span>. The first term should be the most significant term with respect to the ordering.</p><pre><code class="language-julia hljs">coeff(a::MyMPoly{T}, exps::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return the coefficient of the term with the given exponent vector, or zero if there is no such term.</p><pre><code class="language-julia hljs">monomial(f::MyMPoly{T}, n::Int) where T &lt;: RingElem
monomial!(m::MyMPoly{T}, f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$n$</span>-th monomial of <span>$f$</span> or set <span>$m$</span> to the <span>$n$</span>-th monomial of <span>$f$</span>, respectively. The first monomial should be the most significant term with respect to the ordering. Monomials have coefficient <span>$1$</span> in AbstractAlgebra. See the function <code>term</code> if you also require the coefficient, however, note that only monomials can be compared.</p><pre><code class="language-julia hljs">term(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$n$</span>-th term of <span>$f$</span>. The first term should be the one whose monomial is most significant with respect to the ordering.</p><pre><code class="language-julia hljs">exponent(f::MyMPoly{T}, i::Int, j::Int) where T &lt;: RingElem</code></pre><p>Return the exponent of the <span>$j$</span>-th variable in the <span>$i$</span>-th term of the polynomial <span>$f$</span>. The first term is the one with whose monomial is most significant with respect to the ordering.</p><pre><code class="language-julia hljs">exponent_vector(a::MyMPoly{T}, i::Int) where T &lt;: RingElement</code></pre><p>Return a vector of exponents, corresponding to the exponent vector of the i-th term of the polynomial. Term numbering begins at <span>$1$</span> and the exponents are given in the order of the variables for the ring, as supplied when the ring was created.</p><pre><code class="language-julia hljs">setcoeff!(a::MyMPoly, exps::Vector{Int}, c::S) where S &lt;: RingElement</code></pre><p>Set the coefficient of the term with the given exponent vector to the given value <span>$c$</span>. If no such term exists (and <span>$c \neq 0$</span>), one will be inserted. This function takes <span>$O(\log n)$</span> operations if a term with the given exponent already exists and <span>$c \neq 0$</span>, or if the term is inserted at the end of the polynomial. Otherwise it can take <span>$O(n)$</span> operations in the worst case. This function must return the modified polynomial.</p><h3 id="Unsafe-functions"><a class="docs-heading-anchor" href="#Unsafe-functions">Unsafe functions</a><a id="Unsafe-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-functions" title="Permalink"></a></h3><p>The following functions must be provided, but are considered unsafe, as they may leave the polynomials in an inconsistent state and they mutate their inputs. As usual, such functions should only be applied on polynomials that have no references elsewhere in the system and are mainly intended to be used in carefully written library code, rather than by users.</p><p>Users should instead build polynomials using the constructors described above.</p><pre><code class="language-julia hljs">fit!(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Ensure that the polynomial <span>$f$</span> internally has space for <span>$n$</span> nonzero terms. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.</p><pre><code class="language-julia hljs">setcoeff!(a::MyMPoly{T}, i::Int, c::T) where T &lt;: RingElement
setcoeff!(a::MyMPoly{T}, i::Int, c::U) where {T &lt;: RingElement, U &lt;: Integer}</code></pre><p>Set the <span>$i$</span>-th coefficient of the polynomial <span>$a$</span> to <span>$c$</span>. No check is performed on the index <span>$i$</span> or for <span>$c = 0$</span>. It may be necessary to call <code>combine_like_terms</code> after calls to this function, to remove zero terms. The function must return the modified polynomial.</p><pre><code class="language-julia hljs">combine_like_terms!(a::MyMPoly{T}) where T &lt;: RingElement</code></pre><p>Remove zero terms and combine any adjacent terms with the same exponent vector (by adding them). It is assumed that all the exponent vectors are already in the correct order with respect to the ordering. The function must return the resulting polynomial.</p><pre><code class="language-julia hljs">set_exponent_vector!(a::MyMPoly{T}, i::Int, exps::Vector{Int}) where T &lt;: RingElement</code></pre><p>Set the <span>$i$</span>-th exponent vector to the given exponent vector. No check is performed on the index <span>$i$</span>, which is assumed to be valid (or that the polynomial has enough space allocated). No sorting of exponents is performed by this function. To sort the terms after setting any number of exponents with this function, run the <code>sort_terms!</code> function. The function must return the modified polynomial.</p><pre><code class="language-julia hljs">sort_terms!(a::MyMPoly{T}) where {T &lt;: RingElement}</code></pre><p>Sort the terms of the given polynomial according to the polynomial ring ordering. Zero terms and duplicate exponents are ignored. To deal with those call <code>combine_like_terms</code>. The sorted polynomial must be returned by the function.</p><h2 id="Optional-functionality-for-multivariate-polynomials"><a class="docs-heading-anchor" href="#Optional-functionality-for-multivariate-polynomials">Optional functionality for multivariate polynomials</a><a id="Optional-functionality-for-multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-multivariate-polynomials" title="Permalink"></a></h2><p>The following functions can optionally be implemented for multivariate polynomial types.</p><h3 id="Reduction-by-an-ideal"><a class="docs-heading-anchor" href="#Reduction-by-an-ideal">Reduction by an ideal</a><a id="Reduction-by-an-ideal-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-by-an-ideal" title="Permalink"></a></h3><pre><code class="language-julia hljs">divrem(f::MyMPoly{T}, G::Vector{MyMPoly{T}}) where T &lt;: RingElem</code></pre><p>As per the <code>divrem</code> function above, except that each term of <span>$r$</span> starting with the most significant term, is reduced modulo the leading terms of each of the polynomials in the array <span>$G$</span> for which the leading monomial is a divisor.</p><p>A tuple <span>$(Q, r)$</span> is returned from the function, where <span>$Q$</span> is an array of polynomials of the same length as <span>$G$</span>, and such that <span>$f = r + \sum Q[i]G[i]$</span>.</p><p>The result is again dependent on the ordering in general, but if the polynomials in <span>$G$</span> are over a field and the reduced generators of a Groebner basis, then the result is unique.</p><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><pre><code class="language-julia hljs">evaluate(a::MyMPoly{T}, A::Vector{T}) where T &lt;: RingElem</code></pre><p>Evaluate the polynomial at the given values in the coefficient ring of the polynomial. The result should be an element of the coefficient ring.</p><pre><code class="language-julia hljs">evaluate(f::MyMPoly{T}, A::Vector{U}) where {T &lt;: RingElem, U &lt;: Integer}</code></pre><p>Evaluate the polynomial <span>$f$</span> at the values specified by the entries of the array <span>$A$</span>.</p><pre><code class="language-julia hljs">(a::MyMPoly{T})(vals::Union{NCRingElem, RingElement}...) where T &lt;: RingElement</code></pre><p>Evaluate the polynomial at the given arguments. This provides functional notation for polynomial evaluation, i.e. <span>$f(a, b, c)$</span>. It must be defined for each supported polynomial type (Julia does not allow functional notation to be defined for an abstract type).</p><p>The code for this function in MPoly.jl can be used when implementing this as it provides the most general possible evaluation, which is much more general than the case of evaluation at elements of the same ring.</p><p>The evaluation should succeed for any set of values for which a multiplication is defined with the product of a coefficient and all the values before it.</p><div class="admonition is-info" id="Note-d92966231aed883e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d92966231aed883e" title="Permalink"></a></header><div class="admonition-body"><p>The values at which a polynomial is evaluated may be in non-commutative rings. Products are performed in the order of the variables in the polynomial ring that the polynomial belongs to, preceded by a multiplication by the coefficient on the left.</p></div></div><h3 id="Derivations"><a class="docs-heading-anchor" href="#Derivations">Derivations</a><a id="Derivations-1"></a><a class="docs-heading-anchor-permalink" href="#Derivations" title="Permalink"></a></h3><p>The following function allows to compute derivations of multivariate polynomials of type MPoly.</p><pre><code class="language-julia hljs">derivative(f::MyMPoly{T}, j::Int) where T &lt;: RingElem</code></pre><p>Compute the derivative of <span>$f$</span> with respect to the <span>$j$</span>-th variable of the polynomial ring.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../poly_interface/">« Univariate Polynomial Ring Interface</a><a class="docs-footer-nextpage" href="../series_interface/">Series Ring Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 29 May 2025 03:34">Thursday 29 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
