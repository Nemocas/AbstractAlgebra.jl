<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Field Interface · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../mpolynomial/">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li><a class="toctext" href="../series/">Generic power series</a></li><li><a class="toctext" href="../puiseux/">Generic Puiseux series</a></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li class="current"><a class="toctext" href>Field Interface</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#FieldElement-type-union-1">FieldElement type union</a></li><li><a class="toctext" href="#Parent-object-caches-1">Parent object caches</a></li><li><a class="toctext" href="#Required-functions-for-all-fields-1">Required functions for all fields</a></li></ul></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../module/">Module Interface</a></li><li><a class="toctext" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="toctext" href="../submodule/">Submodules</a></li><li><a class="toctext" href="../quotient_module/">Quotient modules</a></li><li><a class="toctext" href="../direct_sum/">Direct Sums</a></li><li><a class="toctext" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><a class="toctext" href="../types/">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Fields</li><li><a href>Field Interface</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/fields.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Field Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Field-Interface-1" href="#Field-Interface-1">Field Interface</a></h1><p>AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all fields. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their fields.</p><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>Most fields must supply two types:</p><ul><li>a type for the parent object (representing the field itself)</li><li>a type for elements of that field</li></ul><p>For example, the generic fraction field type in AbstractAlgebra.jl provides two  types in <code>generic/GenericTypes.jl</code>: </p><ul><li><code>Generic.FracField{T}</code> for the parent objects</li><li><code>Generic.Frac{T}</code> for the actual fractions</li></ul><p>The parent type must belong to <code>AbstractAlgebra.Field</code> and the element type must belong to <code>AbstractAlgebra.FieldElem</code>. Of course, the types may belong to these abstract types transitively.</p><p>For parameterised fields, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring.</p><p>There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.</p><h2><a class="nav-anchor" id="FieldElement-type-union-1" href="#FieldElement-type-union-1">FieldElement type union</a></h2><p>Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to <code>AbstractAlgebra.FieldElem</code>. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of fields we define a union type <code>AbstractAlgebra.FieldElement</code> in <code>src/julia/JuliaTypes</code>.</p><p>So far, in addition to <code>AbstractAlgebra.FieldElem</code> the  union type <code>AbstractAlgebra.FieldElement</code> includes the Julia types <code>Rational</code> and <code>AbstractFloat</code>.</p><p>Most of the generic code in AbstractAlgebra makes use of the union type <code>AbstractAlgebra.FieldElement</code> instead of <code>AbstractAlgebra.FieldElem</code> so that the generic functions also accept the Julia Base field types.</p><p>One must be careful when defining ad hoc binary operations for field element types. It is often necessary to define separate versions of the functions for <code>AbstractAlgebra.FieldElem</code> then for each of the Julia types separately in order to avoid ambiguity warnings.</p><p>Note that even though <code>AbstractAlgebra.FieldElement</code> is a union type we still have the following inclusion</p><pre><code class="language-julia">AbstractAlgebra.FieldElement &lt;: AbstractAlgebra.RingElement</code></pre><h2><a class="nav-anchor" id="Parent-object-caches-1" href="#Parent-object-caches-1">Parent object caches</a></h2><p>In many cases, it is desirable to have only one object in the system to represent each field. This means that if the same field is constructed twice, elements of the two fields will be compatible as far as arithmetic is concerned.</p><p>In order to facilitate this, global caches of fields are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the <code>Generic.FracField</code> parent objects are looked up in a dictionary <code>FracDict</code> to see if they have been previously defined.</p><p>Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn&#39;t desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two fields are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two fields if they were constructed from identical data.</p><p>If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value <code>cached</code> to the inner constructor of the parent object. See generic/GenericTypes.jl` for examples of how to construct and handle such caches.</p><h2><a class="nav-anchor" id="Required-functions-for-all-fields-1" href="#Required-functions-for-all-fields-1">Required functions for all fields</a></h2><p>In the following, we list all the functions that are required to be provided for fields in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.</p><p>We give this interface for fictitious types <code>MyParent</code> for the type of the field parent object <code>R</code> and <code>MyElem</code> for the type of the elements of the field.</p><p>Note that generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for fields that implement that additional functionality, and should be documented as such.</p><p>In the first place, all fields are rings and therefore any field type must implement all of the Ring interface. The functionality below is in addition to this basic functionality.</p><h3><a class="nav-anchor" id="Data-type-and-parent-object-methods-1" href="#Data-type-and-parent-object-methods-1">Data type and parent object methods</a></h3><pre><code class="language-julia">characteristic(R::MyParent)</code></pre><p>Return the characteristic of the field.</p><h3><a class="nav-anchor" id="Basic-manipulation-of-rings-and-elements-1" href="#Basic-manipulation-of-rings-and-elements-1">Basic manipulation of rings and elements</a></h3><pre><code class="language-julia">isunit(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is invertible, i.e. nonzero in the field.</p><footer><hr/><a class="previous" href="../residue/"><span class="direction">Previous</span><span class="title">Generic residue rings</span></a><a class="next" href="../fraction_fields/"><span class="direction">Next</span><span class="title">Fraction Field Interface</span></a></footer></article></body></html>
