<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix Spaces · AbstractAlgebra.jl</title><meta name="title" content="Matrix Spaces · AbstractAlgebra.jl"/><meta property="og:title" content="Matrix Spaces · AbstractAlgebra.jl"/><meta property="twitter:title" content="Matrix Spaces · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li class="is-active"><a class="tocitem" href>Matrix Spaces</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Space-Constructors"><span>Matrix Space Constructors</span></a></li><li><a class="tocitem" href="#Basic-matrix-space-functionality"><span>Basic matrix space functionality</span></a></li><li><a class="tocitem" href="#Inverses"><span>Inverses</span></a></li><li><a class="tocitem" href="#LU-factorisation"><span>LU factorisation</span></a></li><li><a class="tocitem" href="#Reduced-row-echelon-form"><span>Reduced row-echelon form</span></a></li><li><a class="tocitem" href="#Matrix-element-constructors"><span>Matrix element constructors</span></a></li></ul></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../ideal_interface/">Ideal Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Matrices</a></li><li class="is-active"><a href>Matrix Spaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix Spaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/matrix_spaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix-Spaces"><a class="docs-heading-anchor" href="#Matrix-Spaces">Matrix Spaces</a><a id="Matrix-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Spaces" title="Permalink"></a></h1><h2 id="Matrix-Space-Constructors"><a class="docs-heading-anchor" href="#Matrix-Space-Constructors">Matrix Space Constructors</a><a id="Matrix-Space-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Space-Constructors" title="Permalink"></a></h2><p>A matrix space in AbstractAlgebra.jl represents a collection of all matrices with given dimensions and base ring.</p><p>In order to construct matrices in AbstractAlgebra.jl, one can first construct the matrix space itself. This is accomplished with the following constructor. We discuss creation of matrix algebras separately in a dedicated section elsewhere in the documentation.</p><pre><code class="language-julia hljs">matrix_space(R::Ring, rows::Int, cols::Int)</code></pre><p>Construct the space of matrices with the given number of rows and columns over the given base ring.</p><p>Here are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S()
[0   0   0]
[0   0   0]
[0   0   0]

julia&gt; B = S(12)
[12    0    0]
[ 0   12    0]
[ 0    0   12]

julia&gt; C = S(R(11))
[11    0    0]
[ 0   11    0]
[ 0    0   11]
</code></pre><h2 id="Basic-matrix-space-functionality"><a class="docs-heading-anchor" href="#Basic-matrix-space-functionality">Basic matrix space functionality</a><a id="Basic-matrix-space-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-matrix-space-functionality" title="Permalink"></a></h2><article><details class="docstring"><summary id="AbstractAlgebra.number_of_rows-Tuple{MatSpace}"><a class="docstring-binding" href="#AbstractAlgebra.number_of_rows-Tuple{MatSpace}"><code>AbstractAlgebra.number_of_rows</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">number_of_rows(a::MatSpace)</code></pre><p>Return the number of rows of the given matrix space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L129-L133">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.number_of_columns-Tuple{MatSpace}"><a class="docstring-binding" href="#AbstractAlgebra.number_of_columns-Tuple{MatSpace}"><code>AbstractAlgebra.number_of_columns</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">number_of_columns(a::MatSpace)</code></pre><p>Return the number of columns of the given matrix space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L136-L140">source</a></section></details></article><article><details class="docstring"><summary id="Base.zero-Tuple{MatSpace}"><a class="docstring-binding" href="#Base.zero-Tuple{MatSpace}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">zero(a::MatSpace)</code></pre><p>Return the zero matrix in the given matrix space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L199-L203">source</a></section></details></article><article><details class="docstring"><summary id="Base.one-Tuple{MatSpace}"><a class="docstring-binding" href="#Base.one-Tuple{MatSpace}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">one(a::MatSpace)</code></pre><p>Return the identity matrix of given matrix space. The matrix space must contain square matrices or else an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L206-L211">source</a></section></details></article><pre><code class="language-julia-repl hljs">julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])
[ 2       3       1]
[ t   t + 1   t + 2]
[-1     t^2     t^3]

julia&gt; r = number_of_rows(B)
3

julia&gt; c = number_of_columns(B)
3

julia&gt; length(B)
9

julia&gt; isempty(B)
false

julia&gt; M = A + B
[  t + 3         t + 3                   2]
[t^2 + t       2*t + 1             2*t + 2]
[     -3   t^2 + t + 2   t^3 + t^2 + t + 1]

julia&gt; N = 2 + A
[t + 3       t             1]
[  t^2   t + 2             t]
[   -2   t + 2   t^2 + t + 3]

julia&gt; M1 = deepcopy(A)
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; A != B
true

julia&gt; isone(one(S))
true

julia&gt; V = A[1:2, :]
[t + 1   t   1]
[  t^2   t   t]

julia&gt; W = A^3
[    3*t^4 + 4*t^3 + t^2 - 3*t - 5            t^4 + 5*t^3 + 10*t^2 + 7*t + 4                 2*t^4 + 7*t^3 + 9*t^2 + 8*t + 1]
[t^5 + 4*t^4 + 3*t^3 - 7*t^2 - 4*t               4*t^4 + 8*t^3 + 7*t^2 + 2*t                 t^5 + 5*t^4 + 9*t^3 + 7*t^2 - t]
[  t^5 + 3*t^4 - 10*t^2 - 16*t - 2   t^5 + 6*t^4 + 12*t^3 + 11*t^2 + 5*t - 2   t^6 + 3*t^5 + 8*t^4 + 15*t^3 + 10*t^2 + t - 5]

julia&gt; Z = divexact(2*A, 2)
[t + 1       t             1]
[  t^2       t             t]
[   -2   t + 2   t^2 + t + 1]

julia&gt; M = matrix(ZZ, BigInt[2 3 0; 1 1 1])
[2   3   0]
[1   1   1]

julia&gt; M[1, 2] = BigInt(4)
4

julia&gt; c = M[1, 1]
2</code></pre><h2 id="Inverses"><a class="docs-heading-anchor" href="#Inverses">Inverses</a><a id="Inverses-1"></a><a class="docs-heading-anchor-permalink" href="#Inverses" title="Permalink"></a></h2><article><details class="docstring"><summary id="Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#Base.inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inv(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Given a non-singular <span>$n\times n$</span> matrix over a ring, return an <span>$n\times n$</span> matrix <span>$X$</span> such that <span>$MX = I_n$</span>, where <span>$I_n$</span> is the <span>$n\times n$</span> identity matrix. If <span>$M$</span> is not invertible over the base ring an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3682-L3689">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_invertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_invertible</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_invertible(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use <code>is_invertible_with_inverse</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3727-L3732">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_invertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_invertible_with_inverse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_invertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T &lt;: RingElement}</code></pre><p>Given an <span>$n \times m$</span> matrix <span>$A$</span> over a ring, return a tuple <code>(flag, B)</code>. If <code>side</code> is <code>:right</code> and <code>flag</code> is <code>true</code>, <span>$B$</span> is a right inverse of <span>$A$</span> i.e. <span>$A B$</span> is the <span>$n \times n$</span> unit matrix. If <code>side</code> is <code>:left</code> and <code>flag</code> is <code>true</code>, <span>$B$</span> is a left inverse of <span>$A$</span> i.e. <span>$B A$</span> is the <span>$m \times m$</span> unit matrix. If <code>flag</code> is <code>false</code>, no right or left inverse exists.</p><p>To get the space of all inverses, note that if <span>$B$</span> and <span>$C$</span> are both right inverses, then <span>$A (B - C) = 0$</span>, and similar for left inverses. Hence from one inverse one can find all by making suitable use of <a href="../linear_solving/#AbstractAlgebra.kernel-Tuple{Union{MatElem, AbstractAlgebra.Solve.SolveCtx}}"><code>kernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3703-L3715">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.pseudo_inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.pseudo_inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pseudo_inv(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Given a non-singular <span>$n\times n$</span> matrix <span>$M$</span> over a ring return a tuple <span>$X, d$</span> consisting of an <span>$n\times n$</span> matrix <span>$X$</span> and a denominator <span>$d$</span> such that <span>$MX = dI_n$</span>, where <span>$I_n$</span> is the <span>$n\times n$</span> identity matrix. The denominator will be the determinant of <span>$M$</span> up to sign. If <span>$M$</span> is singular an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3659-L3667">source</a></section></details></article><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, :x)
(Univariate polynomial ring in x over rationals, x)

julia&gt; K, = residue_field(R, x^3 + 3x + 1); a = K(x);

julia&gt; S = matrix_space(K, 3, 3)
Matrix space of 3 rows and 3 columns
  over residue field of R modulo x^3 + 3*x + 1

julia&gt; A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])
[            0   2*x + 3   x^2 + 1]
[      x^2 - 2     x - 1       2*x]
[x^2 + 3*x + 1       2*x         1]

julia&gt; X = inv(A)
[-343//7817*x^2 + 717//7817*x - 2072//7817   -4964//23451*x^2 + 2195//23451*x - 11162//23451    -232//23451*x^2 - 4187//23451*x - 1561//23451]
[ 128//7817*x^2 - 655//7817*x + 2209//7817      599//23451*x^2 - 2027//23451*x - 1327//23451   -1805//23451*x^2 + 2702//23451*x - 7394//23451]
[ 545//7817*x^2 + 570//7817*x + 2016//7817     -1297//23451*x^2 - 5516//23451*x - 337//23451   8254//23451*x^2 - 2053//23451*x + 16519//23451]

julia&gt; is_invertible(A)
true

julia&gt; is_invertible_with_inverse(A)
(true, [-343//7817*x^2+717//7817*x-2072//7817 -4964//23451*x^2+2195//23451*x-11162//23451 -232//23451*x^2-4187//23451*x-1561//23451; 128//7817*x^2-655//7817*x+2209//7817 599//23451*x^2-2027//23451*x-1327//23451 -1805//23451*x^2+2702//23451*x-7394//23451; 545//7817*x^2+570//7817*x+2016//7817 -1297//23451*x^2-5516//23451*x-337//23451 8254//23451*x^2-2053//23451*x+16519//23451])

julia&gt; R, x = polynomial_ring(ZZ, :x)
(Univariate polynomial ring in x over integers, x)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in x over integers

julia&gt; A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])
[            0   2*x + 3   x^2 + 1]
[      x^2 - 2     x - 1       2*x]
[x^2 + 3*x + 1       2*x         1]

julia&gt; X, d = pseudo_inv(A)
([4*x^2-x+1 -2*x^3+3 x^3-5*x^2-5*x-1; -2*x^3-5*x^2-2*x-2 x^4+3*x^3+2*x^2+3*x+1 -x^4+x^2+2; -x^3+2*x^2+2*x-1 -2*x^3-9*x^2-11*x-3 2*x^3+3*x^2-4*x-6], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)</code></pre><h2 id="LU-factorisation"><a class="docs-heading-anchor" href="#LU-factorisation">LU factorisation</a><a id="LU-factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#LU-factorisation" title="Permalink"></a></h2><article><details class="docstring"><summary id="LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:FieldElem"><a class="docstring-binding" href="#LinearAlgebra.lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:FieldElem"><code>LinearAlgebra.lu</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T &lt;: FieldElement}</code></pre><p>Return a tuple <span>$r, p, L, U$</span> consisting of the rank of <span>$A$</span>, a permutation <span>$p$</span> of <span>$A$</span> belonging to <span>$P$</span>, a lower triangular matrix <span>$L$</span> and an upper triangular matrix <span>$U$</span> such that <span>$p(A) = LU$</span>, where <span>$p(A)$</span> stands for the matrix whose rows are the given permutation <span>$p$</span> of the rows of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L1802-L1809">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:RingElem"><a class="docstring-binding" href="#AbstractAlgebra.fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T&lt;:RingElem"><code>AbstractAlgebra.fflu</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T &lt;: RingElement}</code></pre><p>Return a tuple <span>$r, d, p, L, U$</span> consisting of the rank of <span>$A$</span>, a denominator <span>$d$</span>, a permutation <span>$p$</span> of <span>$A$</span> belonging to <span>$P$</span>, a lower triangular matrix <span>$L$</span> and an upper triangular matrix <span>$U$</span> such that <span>$p(A) = LDU$</span>, where <span>$p(A)$</span> stands for the matrix whose rows are the given permutation <span>$p$</span> of the rows of <span>$A$</span> and such that <span>$D$</span> is the diagonal matrix diag<span>$(p_1, p_1p_2, \ldots, p_{n-2}p_{n-1}, p_{n-1}p_n)$</span> where the <span>$p_i$</span> are the inverses of the diagonal entries of <span>$L$</span>. The denominator <span>$d$</span> is set to <span>$\pm \mathrm{det}(S)$</span> where <span>$S$</span> is an appropriate submatrix of <span>$A$</span> (<span>$S = A$</span> if <span>$A$</span> is square and nonsingular) and the sign is decided by the parity of the permutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L1952-L1965">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, :x)
(Univariate polynomial ring in x over rationals, x)

julia&gt; K, = residue_field(R, x^3 + 3x + 1); a = K(x);

julia&gt; S = matrix_space(K, 3, 3)
Matrix space of 3 rows and 3 columns
  over residue field of R modulo x^3 + 3*x + 1

julia&gt; A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])
[      0   2*x + 3   x^2 + 1]
[x^2 - 2     x - 1       2*x]
[x^2 - 2     x - 1       2*x]

julia&gt; r, P, L, U = lu(A)
(2, (1,2), [1 0 0; 0 1 0; 1 0 1], [x^2-2 x-1 2*x; 0 2*x+3 x^2+1; 0 0 0])

julia&gt; r, d, P, L, U = fflu(A)
(2, 3*x^2 - 10*x - 8, (1,2), [x^2-2 0 0; 0 3*x^2-10*x-8 0; x^2-2 0 1], [x^2-2 x-1 2*x; 0 3*x^2-10*x-8 -4*x^2-x-2; 0 0 0])</code></pre><h2 id="Reduced-row-echelon-form"><a class="docs-heading-anchor" href="#Reduced-row-echelon-form">Reduced row-echelon form</a><a id="Reduced-row-echelon-form-1"></a><a class="docs-heading-anchor-permalink" href="#Reduced-row-echelon-form" title="Permalink"></a></h2><article><details class="docstring"><summary id="AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><a class="docstring-binding" href="#AbstractAlgebra.rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.rref_rational</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rref_rational(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return a tuple <span>$(r, A, d)$</span> consisting of the rank <span>$r$</span> of <span>$M$</span> and a denominator <span>$d$</span> in the base ring of <span>$M$</span> and a matrix <span>$A$</span> such that <span>$A/d$</span> is the reduced row echelon form of <span>$M$</span>. Note that the denominator is not usually minimal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L2070-L2077">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><a class="docstring-binding" href="#AbstractAlgebra.rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>AbstractAlgebra.rref</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rref(M::MatrixElem{T}) where {T &lt;: FieldElement}</code></pre><p>Return a tuple <span>$(r, A)$</span> consisting of the rank <span>$r$</span> of <span>$M$</span> and a reduced row echelon form <span>$A$</span> of <span>$M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L2144-L2149">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><a class="docstring-binding" href="#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.is_rref</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L2156-L2161">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><a class="docstring-binding" href="#AbstractAlgebra.is_rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>AbstractAlgebra.is_rref</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L2156-L2161">source</a></section><section><div><pre><code class="language-julia hljs">is_rref(M::MatrixElem{T}) where {T &lt;: FieldElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in reduced row echelon form, otherwise return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L2186-L2191">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, :x)
(Univariate polynomial ring in x over rationals, x)

julia&gt; K, = residue_field(R, x^3 + 3x + 1); a = K(x);

julia&gt; S = matrix_space(K, 3, 3)
Matrix space of 3 rows and 3 columns
  over residue field of R modulo x^3 + 3*x + 1

julia&gt; M = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])
[            0   2*x + 3   x^2 + 1]
[      x^2 - 2     x - 1       2*x]
[x^2 + 3*x + 1       2*x         1]

julia&gt; r, A = rref(M)
(3, [1 0 0; 0 1 0; 0 0 1])

julia&gt; is_rref(A)
true

julia&gt; R, x = polynomial_ring(ZZ, :x)
(Univariate polynomial ring in x over integers, x)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in x over integers

julia&gt; M = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])
[            0   2*x + 3   x^2 + 1]
[      x^2 - 2     x - 1       2*x]
[x^2 + 3*x + 1       2*x         1]

julia&gt; r, A, d = rref_rational(M)
(3, [-x^5-2*x^4-15*x^3-18*x^2-8*x-7 0 0; 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7 0; 0 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)

julia&gt; is_rref(A)
true</code></pre><h2 id="Matrix-element-constructors"><a class="docs-heading-anchor" href="#Matrix-element-constructors">Matrix element constructors</a><a id="Matrix-element-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-element-constructors" title="Permalink"></a></h2><p>There are a few ways to construct matrices other than by coercing elements as shown above. The first method is from an array of elements.</p><p>This can be done with either two or one dimensional arrays.</p><pre><code class="language-julia hljs">(S::MatSpace{T})(A::Matrix{S}) where {S &lt;: RingElement, T &lt;: RingElement}
(S::MatRing{T})(A::Matrix{S}) where {S &lt;: RingElement, T &lt;: RingElement}</code></pre><p>Create the matrix in the given space/algebra whose <span>$(i, j)$</span> entry is given by <code>A[i, j]</code>, where <code>S</code> is the type of elements that can be coerced into the base ring of the matrix.</p><pre><code class="language-julia hljs">(S::MyMatSpace{T})(A::Vector{S}) where {S &lt;: RingElem, T &lt;: RingElem}
(S::MyMatAlgebra{T})(A::Vector{S}) where {S &lt;: RingElem, T &lt;: RingElem}</code></pre><p>Create the matrix in the given space/algebra of matrices (with dimensions <span>$m\times n$</span> say), whose <span>$(i, j)$</span> entry is given by <code>A[i*(n - 1) + j]</code> and where <code>S</code> is the type of elements that can be coerced into the base ring of the matrix.</p><p>We also provide the following syntax for constructing literal matrices (similar to how Julia arrays can be be constructed).</p><pre><code class="language-julia hljs">R[a b c...;...]</code></pre><p>Create the matrix over the base ring <span>$R$</span> consisting of the given rows (separated by semicolons). Each entry is coerced into <span>$R$</span>  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. <code>R[1 2; 2 (- 3)]</code>.</p><p>Also see the Matrix interface for a list of other ways to create matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = matrix_space(QQ, 2, 3)
Matrix space of 2 rows and 3 columns
  over rationals

julia&gt; T = matrix_ring(QQ, 2)
Matrix ring of degree 2
  over rationals

julia&gt; M1 = S(Rational{BigInt}[2 3 1; 1 0 4])
[2//1   3//1   1//1]
[1//1   0//1   4//1]

julia&gt; M2 = S(BigInt[2 3 1; 1 0 4])
[2//1   3//1   1//1]
[1//1   0//1   4//1]

julia&gt; M3 = S(BigInt[2, 3, 1, 1, 0, 4])
[2//1   3//1   1//1]
[1//1   0//1   4//1]

julia&gt; N1 = T(Rational{BigInt}[2 3; 1 0])
[2//1   3//1]
[1//1   0//1]

julia&gt; N2 = T(BigInt[2 3; 1 0])
[2//1   3//1]
[1//1   0//1]

julia&gt; N3 = T(BigInt[2, 3, 1, 1])
[2//1   3//1]
[1//1   1//1]

julia&gt; R, t = polynomial_ring(QQ, :t)
(Univariate polynomial ring in t over rationals, t)

julia&gt; S = matrix_space(R, 3, 3)
Matrix space of 3 rows and 3 columns
  over univariate polynomial ring in t over rationals

julia&gt; M = R[t + 1 1; t^2 0]
[t + 1   1]
[  t^2   0]

julia&gt; N = R[t + 1 2 t] # create a row vector
[t + 1   2   t]

julia&gt; P = R[1; 2; t] # create a column vector
[1]
[2]
[t]</code></pre><h3 id="Hessenberg-form"><a class="docs-heading-anchor" href="#Hessenberg-form">Hessenberg form</a><a id="Hessenberg-form-1"></a><a class="docs-heading-anchor-permalink" href="#Hessenberg-form" title="Permalink"></a></h3><article><details class="docstring"><summary id="LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><a class="docstring-binding" href="#LinearAlgebra.hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>LinearAlgebra.hessenberg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hessenberg(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the Hessenberg form of <span>$M$</span>, i.e. an upper Hessenberg matrix which is similar to <span>$M$</span>. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3940-L3947">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><a class="docstring-binding" href="#AbstractAlgebra.is_hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>AbstractAlgebra.is_hessenberg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_hessenberg(A::MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <code>true</code> if <span>$M$</span> is in Hessenberg form, otherwise returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/2627b5e34654c08482dfbdc6676895860c825de9/src/Matrix.jl#L3955-L3959">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, = residue_ring(ZZ, 7);

julia&gt; S = matrix_space(R, 4, 4)
Matrix space of 4 rows and 4 columns
  over residue ring of integers modulo 7

julia&gt; M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);
              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])
[1   2   4   3]
[2   5   1   0]
[6   1   3   2]
[1   1   3   5]

julia&gt; A = hessenberg(M)
[1   5   5   3]
[2   1   1   0]
[0   1   3   2]
[0   0   2   2]

julia&gt; is_hessenberg(A)
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix/">« Matrix functionality</a><a class="docs-footer-nextpage" href="../matrix_implementation/">Matrix implementation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 9 December 2025 20:20">Tuesday 9 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
