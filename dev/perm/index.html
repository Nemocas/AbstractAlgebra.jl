<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutations and Symmetric groups · AbstractAlgebra.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li class="is-active"><a class="tocitem" href>Permutations and Symmetric groups</a><ul class="internal"><li><a class="tocitem" href="#Permutations-constructors"><span>Permutations constructors</span></a></li><li><a class="tocitem" href="#Permutation-interface"><span>Permutation interface</span></a></li><li><a class="tocitem" href="#Basic-manipulation"><span>Basic manipulation</span></a></li><li><a class="tocitem" href="#Arithmetic-operators"><span>Arithmetic operators</span></a></li><li><a class="tocitem" href="#Coercion"><span>Coercion</span></a></li><li><a class="tocitem" href="#Comparison"><span>Comparison</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Groups</a></li><li class="is-active"><a href>Permutations and Symmetric groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Permutations and Symmetric groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/perm.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Permutations-and-Symmetric-groups"><a class="docs-heading-anchor" href="#Permutations-and-Symmetric-groups">Permutations and Symmetric groups</a><a id="Permutations-and-Symmetric-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-and-Symmetric-groups" title="Permalink"></a></h1><p>AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in <code>src/generic/PermGroups.jl</code>). All functionality of permutations is accessible in the <code>Generic</code> submodule.</p><p>Permutations are represented internally via vector of integers, wrapped in type <code>Perm{T}</code>, where <code>T&lt;:Integer</code> carries the information on the type of elements of a permutation. Symmetric groups are singleton parent objects of type <code>SymmetricGroup{T}</code> and are used mostly to store the length of a permutation, since it is not included in the permutation type.</p><p>Symmetric groups are created using the <code>SymmetricGroup</code> (inner) constructor.</p><p>Both <code>SymmetricGroup</code> and <code>Perm</code> and can be parametrized by any type <code>T&lt;:Integer</code> . By default the parameter is the <code>Int</code>-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as <code>Int32</code>, <code>UInt16</code>, or even <code>Int8</code>), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticeable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.</p><p>All the permutation group types belong to the <code>Group</code> abstract type and the corresponding permutation element types belong to the <code>GroupElem</code> abstract type.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.setpermstyle" href="#AbstractAlgebra.Generic.setpermstyle"><code>AbstractAlgebra.Generic.setpermstyle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setpermstyle(format::Symbol)</code></pre><p>Select the style in which permutations are displayed (in the REPL or in general as strings). This can be either</p><ul><li><code>:array</code> - as vector of integers whose <span>$n$</span>-th position represents the value at <span>$n$</span>), or</li><li><code>:cycles</code> - as, more familiar for mathematicians, decomposition into disjoint cycles, where the value at <span>$n$</span> is represented by the entry immediately following <span>$n$</span> in a cycle (the default).</li></ul><p>The difference is purely esthetical.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setpermstyle(:array)
:array

julia&gt; Perm([2,3,1,5,4])
[2, 3, 1, 5, 4]

julia&gt; setpermstyle(:cycles)
:cycles

julia&gt; Perm([2,3,1,5,4])
(1,2,3)(4,5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L289-L316">source</a></section></article><h2 id="Permutations-constructors"><a class="docs-heading-anchor" href="#Permutations-constructors">Permutations constructors</a><a id="Permutations-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-constructors" title="Permalink"></a></h2><p>There are several methods to construct permutations in AbstractAlgebra.jl.</p><ul><li>The easiest way is to directly call to the <code>Perm</code> (inner) constructor:</li></ul><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Perm" href="#AbstractAlgebra.Perm"><code>AbstractAlgebra.Perm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Perm{T&lt;:Integer}</code></pre><p>The type of permutations. Fieldnames:</p><ul><li><code>d::Vector{T}</code> - vector representing the permutation</li><li><code>modified::Bool</code> - bit to check the validity of cycle decomposition</li><li><code>cycles::CycleDec{T}</code> - (cached) cycle decomposition</li></ul><p>A permutation <span>$p$</span> consists of a vector (<code>p.d</code>) of <span>$n$</span> integers from <span>$1$</span> to <span>$n$</span>. If the <span>$i$</span>-th entry of the vector is <span>$j$</span>, this corresponds to <span>$p$</span> sending <span>$i \to j$</span>. The cycle decomposition (<code>p.cycles</code>) is computed on demand and should never be accessed directly. Use <a href="#AbstractAlgebra.Generic.cycles-Tuple{Perm}"><code>cycles(p)</code></a> instead.</p><p>There are two inner constructors of <code>Perm</code>:</p><ul><li><code>Perm(n::T)</code> constructs the trivial <code>Perm{T}</code>-permutation of length <span>$n$</span>.</li><li><code>Perm(v::AbstractVector{&lt;:Integer} [,check=true])</code> constructs a permutation represented by <code>v</code>. By default <code>Perm</code> constructor checks if the vector constitutes a valid permutation. To skip the check call <code>Perm(v, false)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Perm([1,2,3])
()
   
julia&gt; g = Perm(Int32[2,3,1])
(1,2,3)

julia&gt; typeof(g)
Perm{Int32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/CommonTypes.jl#L21-L53">source</a></section></article><p>Since the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitly constructing the parent object.</p><ul><li>The other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor <code>SymmetricGroup(n::Integer)</code> which constructs the permutation group on <span>$n$</span> symbols and returns the parent object representing the group.</li></ul><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.SymmetricGroup" href="#AbstractAlgebra.Generic.SymmetricGroup"><code>AbstractAlgebra.Generic.SymmetricGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricGroup{T&lt;:Integer}</code></pre><p>The full symmetric group singleton type. <code>SymmetricGroup(n)</code> constructs the full symmetric group <span>$S_n$</span> on <span>$n$</span>-symbols. The type of elements of the group is inferred from the type of <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = SymmetricGroup(5)
Full symmetric group over 5 elements

julia&gt; elem_type(G)
Perm{Int64}

julia&gt; H = SymmetricGroup(UInt16(5))
Full symmetric group over 5 elements

julia&gt; elem_type(H)
Perm{UInt16}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/GenericTypes.jl#L13-L33">source</a></section></article><p>A vector of integers can be then coerced to a permutation by calling a parent permutation group on it.   The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = SymmetricGroup(BigInt(5)); p = G([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(p)
Perm{BigInt}

julia&gt; H = SymmetricGroup(UInt16(5)); r = H([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(r)
Perm{UInt16}

julia&gt; one(H)
()</code></pre><p>By default the coercion checks for non-unique values in the vector, but this can be switched off with <code>G([2,3,1,5,4], false)</code>.</p><ul><li>Finally there is a <code>perm&quot;...&quot;</code> string macro to construct a permutation from a string input.</li></ul><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.@perm_str" href="#AbstractAlgebra.Generic.@perm_str"><code>AbstractAlgebra.Generic.@perm_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">perm&quot;...&quot;</code></pre><p>String macro to parse disjoint cycles into <code>Perm{Int}</code>.</p><p>Strings for the output of GAP could be copied directly into <code>perm&quot;...&quot;</code>. Cycles of length <span>$1$</span> are not necessary, but can be included. A permutation of the minimal support is constructed, i.e. the maximal <span>$n$</span> in the decomposition determines the parent group <span>$S_n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = perm&quot;(1,3)(2,4)&quot;
(1,3)(2,4)

julia&gt; typeof(p)
Perm{Int64}

julia&gt; parent(p) == SymmetricGroup(4)
true

julia&gt; p = perm&quot;(1,3)(2,4)(10)&quot;
(1,3)(2,4)

julia&gt; parent(p) == SymmetricGroup(10)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L854-L881">source</a></section></article><h2 id="Permutation-interface"><a class="docs-heading-anchor" href="#Permutation-interface">Permutation interface</a><a id="Permutation-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-interface" title="Permalink"></a></h2><p>The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide the group element arithmetic and comparison.</p><p>A custom implementation also needs to implement <code>hash(::Perm, ::UInt)</code> and (possibly) <code>deepcopy_internal(::Perm, ::IdDict)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Permutation group elements are mutable and so returning shallow copies is not sufficient.</p></div></div><pre><code class="language-julia hljs">getindex(a::Perm, n::Integer)</code></pre><p>Allow access to entry <span>$n$</span> of the given permutation via the syntax <code>a[n]</code>. Note that entries are <span>$1$</span>-indexed.</p><pre><code class="language-julia hljs">setindex!(a::Perm, d::Integer, n::Integer)</code></pre><p>Set the <span>$n$</span>-th entry of the given permutation to <span>$d$</span>. This allows Julia to provide the syntax <code>a[n] = d</code> for setting entries of a permutation. Entries are <span>$1$</span>-indexed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using <code>setindex!</code> invalidates the cycle decomposition cached in a permutation, which will be computed the next time it is needed.</p></div></div><p>Given the parent object <code>G</code> for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.</p><pre><code class="language-julia hljs">one(G)</code></pre><p>Return the identity permutation.</p><pre><code class="language-julia hljs">G(A::Vector{&lt;:Integer})</code></pre><p>Return the permutation whose entries are given by the elements of the supplied vector.</p><pre><code class="language-julia hljs">G(p::Perm)</code></pre><p>Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.</p><h2 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h2><p>Numerous functions are provided to manipulate permutation group elements.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.cycles-Tuple{Perm}" href="#AbstractAlgebra.Generic.cycles-Tuple{Perm}"><code>AbstractAlgebra.Generic.cycles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cycles(g::Perm)</code></pre><p>Decompose permutation <code>g</code> into disjoint cycles.</p><p>Return a <code>CycleDec</code> object which iterates over disjoint cycles of <code>g</code>. The ordering of cycles is not guaranteed, and the order within each cycle is computed up to a cyclic permutation. The cycle decomposition is cached in <code>g</code> and used in future computation of <code>permtype</code>, <code>parity</code>, <code>sign</code>, <code>order</code> and <code>^</code> (powering).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; collect(cycles(g))
3-element Vector{Vector{Int64}}:
 [1, 3, 5]
 [2, 4]
 [6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L175-L197">source</a></section></article><p>Cycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.parity-Tuple{Perm}" href="#AbstractAlgebra.Generic.parity-Tuple{Perm}"><code>AbstractAlgebra.Generic.parity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parity(g::Perm)</code></pre><p>Return the parity of the given permutation, i.e. the parity of the number of transpositions in any decomposition of <code>g</code> into transpositions.</p><p><code>parity</code> returns <span>$1$</span> if the number is odd and <span>$0$</span> otherwise. <code>parity</code> uses cycle decomposition of <code>g</code> if already available, but will not compute it on demand. Since cycle structure is cached in <code>g</code> you may call <code>cycles(g)</code> before calling <code>parity</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,1,2,5])
(1,3)(2,4)

julia&gt; parity(g)
0

julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; parity(g)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L63-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{Perm}" href="#Base.sign-Tuple{Perm}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(g::Perm)</code></pre><p>Return the sign of a permutation.</p><p><code>sign</code> returns <span>$1$</span> if <code>g</code> is even and <span>$-1$</span> if <code>g</code> is odd. <code>sign</code> represents the homomorphism from the permutation group to the unit group of <span>$\mathbb{Z}$</span> whose kernel is the alternating group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,1,2,5])
(1,3)(2,4)

julia&gt; sign(g)
1

julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; sign(g)
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L109-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.permtype-Tuple{Perm}" href="#AbstractAlgebra.Generic.permtype-Tuple{Perm}"><code>AbstractAlgebra.Generic.permtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permtype(g::Perm)</code></pre><p>Return the type of permutation <code>g</code>, i.e. lengths of disjoint cycles in cycle decomposition of <code>g</code>.</p><p>The lengths are sorted in decreasing order by default. <code>permtype(g)</code> fully determines the conjugacy class of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; permtype(g)
3-element Vector{Int64}:
 3
 2
 1

julia&gt; e = one(g)
()

julia&gt; permtype(e)
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L238-L270">source</a></section></article><p>Additionally <a href="https://github.com/kalmarek/GroupsCore.jl"><code>GroupsCore.jl</code></a> package provides more functionality, notably functions <code>gens</code> and <code>order</code>. You may consult its <a href="https://kalmarek.github.io/GroupsCore.jl/stable/">documentation</a>. Note that even an <code>Int64</code> can be easily overflowed when computing with symmetric groups. Thus, by default, <code>order</code> returns (always correct) <code>BigInt</code>s. If you are sure that the computation will not overflow, you may use <code>order(::Type{T}, ...)</code> to perform computations with machine integers. Julia&#39;s standard promotion rules apply for the returned value.</p><p>Since <code>SymmetricGroup</code> implements the iterator protocol, you may iterate over all permutations via a simple loop:</p><pre><code class="nohighlight hljs">for p in SymmetricGroup(n)
   ...
end</code></pre><p>Iteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when <span>$n ≤ 13$</span>.</p><p>You may also use the non-allocating <code>Generic.elements!</code> function for <span>$n ≤ 14$</span> (or even <span>$15$</span> if you are patient enough), which is an order of magnitude faster.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}" href="#AbstractAlgebra.Generic.elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}"><code>AbstractAlgebra.Generic.elements!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Generic.elements!(G::SymmetricGroup)</code></pre><p>Return an unsafe iterator over all permutations in <code>G</code>. Only one permutation is allocated and then modified in-place using the non-recursive <a href="https://en.wikipedia.org/wiki/Heap&#39;s_algorithm">Heaps algorithm</a>.</p><p>Note: you need to explicitly copy permutations intended to be stored or modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; elts = Generic.elements!(SymmetricGroup(5));


julia&gt; length(elts)
120

julia&gt; for p in Generic.elements!(SymmetricGroup(3))
         println(p)
       end
()
(1,2)
(1,3,2)
(2,3)
(1,2,3)
(1,3)

julia&gt; A = collect(Generic.elements!(SymmetricGroup(3))); A
6-element Vector{Perm{Int64}}:
 (1,3)
 (1,3)
 (1,3)
 (1,3)
 (1,3)
 (1,3)

julia&gt; unique(A)
1-element Vector{Perm{Int64}}:
 (1,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L585-L626">source</a></section></article><p>However, since all permutations yielded by <code>elements!</code> are aliased (modified &quot;in-place&quot;), <code>collect(Generic.elements!(SymmetricGroup(n)))</code> returns a vector of identical permutations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you intend to use or store elements yielded by <code>elements!</code> you need to <strong>deepcopy</strong> them explicitly.</p></div></div><h2 id="Arithmetic-operators"><a class="docs-heading-anchor" href="#Arithmetic-operators">Arithmetic operators</a><a id="Arithmetic-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T" href="#Base.:*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(g::Perm, h::Perm)</code></pre><p>Return the composition <span>$h ∘ g$</span> of two permutations.</p><p>This corresponds to the action of permutation group on the set <code>[1..n]</code> <strong>on the right</strong> and follows the convention of GAP.</p><p>If <code>g</code> and <code>h</code> are parametrized by different types, the result is promoted accordingly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Perm([2,3,1,4])*Perm([1,3,4,2]) # (1,2,3)*(2,3,4)
(1,3)(2,4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L421-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{Perm, Integer}" href="#Base.:^-Tuple{Perm, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(g::Perm, n::Integer)</code></pre><p>Return the <span>$n$</span>-th power of a permutation <code>g</code>.</p><p>By default <code>g^n</code> is computed by cycle decomposition of <code>g</code> if <code>n &gt; 3</code>. <code>Generic.power_by_squaring</code> provides a different method for powering which may or may not be faster, depending on the particular case. Due to caching of the cycle structure, repeated powering of <code>g</code> will be faster with the default method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([2,3,4,5,1])
(1,2,3,4,5)

julia&gt; g^3
(1,4,2,5,3)

julia&gt; g^5
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L441-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Perm}" href="#Base.inv-Tuple{Perm}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.inv(g::Perm)</code></pre><p>Return the inverse of the given permutation, i.e. the permutation <span>$g^{-1}$</span> such that <span>$g ∘ g^{-1} = g^{-1} ∘ g$</span> is the identity permutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L528-L533">source</a></section></article><p>Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:</p><pre><code class="language-julia hljs">g = rand(SymmetricGroup(Int8(5)));
h = rand(SymmetricGroup(UInt32(5)));
typeof(g*h)

# output
Perm{UInt32}</code></pre><h2 id="Coercion"><a class="docs-heading-anchor" href="#Coercion">Coercion</a><a id="Coercion-1"></a><a class="docs-heading-anchor-permalink" href="#Coercion" title="Permalink"></a></h2><p>The following coercions are available for <code>G::SymmetricGroup</code> parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">(G::SymmetricGroup)(::AbstractVector{&lt;:Integer}[, check=true])</code></pre><blockquote><p>Turn a vector of integers into a permutation (performing conversion, if necessary).</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup)(::Perm[, check=true])</code></pre><blockquote><p>Coerce a permutation <code>p</code> into group <code>G</code> (performing the conversion, if necessary). If <code>p</code> is already an element of <code>G</code> no copy is performed.</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup)(::String[, check=true])</code></pre><blockquote><p>Parse the string input e.g. copied from the output of GAP. The method uses the same logic as the <code>perm&quot;...&quot;</code> macro. The string is sanitized and checked for disjoint cycles. Both <code>string(p::Perm)</code> (if <code>setpermstyle(:cycles)</code>) and <code>string(cycles(p::Perm))</code> are valid input for this method.</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup{T})(::CycleDec{T}[, check=true]) where T</code></pre><blockquote><p>Turn a cycle decomposition object into a permutation.</p></blockquote><h2 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Perm, Perm}" href="#Base.:==-Tuple{Perm, Perm}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(g::Perm, h::Perm)</code></pre><p>Return <code>true</code> if permutations are equal, otherwise return <code>false</code>.</p><p>Permutations parametrized by different integer types are considered equal if they define the same permutation in the abstract permutation group.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; g = Perm(Int8[2,3,1])
(1,2,3)

julia&gt; h = perm&quot;(3,1,2)&quot;
(1,2,3)

julia&gt; g == h
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L362-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}" href="#Base.:==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(G::SymmetricGroup, H::SymmetricGroup)</code></pre><p>Return <code>true</code> if permutation groups are equal, otherwise return <code>false</code>.</p><p>Permutation groups on the same number of letters, but parametrized by different integer types are considered different.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; G = SymmetricGroup(UInt(5))
Permutation group over 5 elements

julia&gt; H = SymmetricGroup(5)
Permutation group over 5 elements

julia&gt; G == H
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L384-L403">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}" href="#Base.rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand([rng=GLOBAL_RNG,] G::SymmetricGroup)</code></pre><p>Return a random permutation from <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L747-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.matrix_repr-Tuple{Perm}" href="#AbstractAlgebra.Generic.matrix_repr-Tuple{Perm}"><code>AbstractAlgebra.Generic.matrix_repr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_repr(a::Perm)</code></pre><p>Return the permutation matrix as a sparse matrix representing <code>a</code> via natural embedding of the permutation group into the general linear group over <span>$\mathbb{Z}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,3,1])
(1,2,3)

julia&gt; matrix_repr(p)
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 ⋅  1  ⋅
 ⋅  ⋅  1
 1  ⋅  ⋅

julia&gt; Array(ans)
3×3 Matrix{Int64}:
 0  1  0
 0  0  1
 1  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L673-L696">source</a></section><section><div><pre><code class="nohighlight hljs">matrix_repr(Y::YoungTableau)</code></pre><p>Construct sparse integer matrix representing the tableau.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1]);


julia&gt; matrix_repr(y)
3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 1  2  3  4
 5  6  7  ⋅
 8  ⋅  ⋅  ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/YoungTabs.jl#L532-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}" href="#AbstractAlgebra.Generic.emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}"><code>AbstractAlgebra.Generic.emb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emb(G::SymmetricGroup, V::Vector{Int}, check::Bool=true)</code></pre><p>Return the natural embedding of a permutation group into <code>G</code> as the subgroup permuting points indexed by <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,3,1])
(1,2,3)

julia&gt; f = Generic.emb(SymmetricGroup(5), [3,2,5]);


julia&gt; f(p)
(2,5,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L721-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.emb!-Tuple{Perm, Perm, Any}" href="#AbstractAlgebra.Generic.emb!-Tuple{Perm, Perm, Any}"><code>AbstractAlgebra.Generic.emb!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emb!(result::Perm, p::Perm, V)</code></pre><p>Embed permutation <code>p</code> into permutation <code>result</code> on the indices given by <code>V</code>.</p><p>This corresponds to the natural embedding of <span>$S_k$</span> into <span>$S_n$</span> as the subgroup permuting points indexed by <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,1,4,3])
(1,2)(3,4)

julia&gt; Generic.emb!(Perm(collect(1:5)), p, [3,1,4,5])
(1,3)(4,5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/6299c95b48966e2387492ebaaafef60c3576ce7b/src/generic/PermGroups.jl#L699-L715">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../numberfield/">« Number fields</a><a class="docs-footer-nextpage" href="../ytabs/">Partitions and Young tableaux »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 5 September 2023 09:40">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
