<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Miscellaneous · AbstractAlgebra.jl</title><meta name="title" content="Miscellaneous · AbstractAlgebra.jl"/><meta property="og:title" content="Miscellaneous · AbstractAlgebra.jl"/><meta property="twitter:title" content="Miscellaneous · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li class="is-active"><a class="tocitem" href>Miscellaneous</a><ul class="internal"><li><a class="tocitem" href="#Printing-options"><span>Printing options</span></a></li><li><a class="tocitem" href="#Updating-the-type-diagrams"><span>Updating the type diagrams</span></a></li><li><a class="tocitem" href="#Attributes"><span>Attributes</span></a></li><li><a class="tocitem" href="#Advanced-printing"><span>Advanced printing</span></a></li><li><a class="tocitem" href="#Linear-solving-interface-for-developers"><span>Linear solving interface for developers</span></a></li></ul></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../ideal_interface/">Ideal Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Miscellaneous</a></li><li class="is-active"><a href>Miscellaneous</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Miscellaneous</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/misc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h1><h2 id="Printing-options"><a class="docs-heading-anchor" href="#Printing-options">Printing options</a><a id="Printing-options-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-options" title="Permalink"></a></h2><p>AbstractAlgebra supports printing to LaTeX using the MIME type &quot;text/latex&quot;. To enable LaTeX rendering in Jupyter notebooks and query for the current state, use the following functions:</p><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.set_html_as_latex"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.set_html_as_latex"><code>AbstractAlgebra.PrettyPrinting.set_html_as_latex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_html_as_latex(fl::Bool)</code></pre><p>Toggles whether MIME type <code>text/html</code> should be printed as <code>text/latex</code>. Note that this is a global option. The return value is the old value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L160-L165">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.get_html_as_latex"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.get_html_as_latex"><code>AbstractAlgebra.PrettyPrinting.get_html_as_latex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_html_as_latex()</code></pre><p>Returns whether MIME type <code>text/html</code> is printed as <code>text/latex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L153-L157">source</a></section></details></article><h2 id="Updating-the-type-diagrams"><a class="docs-heading-anchor" href="#Updating-the-type-diagrams">Updating the type diagrams</a><a id="Updating-the-type-diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-type-diagrams" title="Permalink"></a></h2><p>Updating the diagrams of the documentation can be done by modifying and running the script <code>docs/create_type_diagrams.jl</code>. Note that this requires the package <code>Kroki</code>.</p><h2 id="Attributes"><a class="docs-heading-anchor" href="#Attributes">Attributes</a><a id="Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes" title="Permalink"></a></h2><p>Often it is desirable to have a flexible way to attach additional data to mathematical structures such as groups, rings, fields, etc. beyond what the original implementation covers. To facilitate this, we provide an <em>attributes</em> system: for objects of suitable types, one may use <code>set_attribute!</code> to attach key-value pairs to the object, and query them using <code>has_attribute</code>, <code>get_attribute</code> and <code>get_attribute!</code>.</p><p>Attributes are supported for all singletons (i.e., instances of an empty <code>struct</code> type), as well as for instances of mutable struct type for which attribute storage was enabled. There are two ways to enable attribute storage for such types:</p><ol><li>By applying <code>@attributes</code> to a mutable struct declaration, storage is reserved inside that struct type itself (this increases the size of each struct by 8 bytes if no attributes are set).</li><li>By applying <code>@attributes</code> to the name of a mutable struct type, methods are installed which store attributes to instances of the type in a <code>WeakKeyDict</code> outside the struct.</li></ol><article><details class="docstring"><summary id="AbstractAlgebra.@attributes"><a class="docstring-binding" href="#AbstractAlgebra.@attributes"><code>AbstractAlgebra.@attributes</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@attributes typedef</code></pre><p>This is a helper macro that ensures that there is storage for attributes in the type declared in the expression <code>typedef</code>, which must be either a <code>mutable struct</code> definition expression, or the name of a <code>mutable struct</code> type.</p><p>The latter variant is useful to enable attribute storage for types defined in other packages. Note that <code>@attributes</code> is idempotent: when applied to a type for which attribute storage is already available, it does nothing.</p><p>For singleton types, attribute storage is also supported, and in fact always enabled. Thus it is not necessary to apply this macro to such a type.</p><div class="admonition is-info" id="Note-4197455161d57756"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4197455161d57756" title="Permalink"></a></header><div class="admonition-body"><p>When applied to a struct definition this macro adds a new field to the struct. For structs without constructor, this will change the signature of the default inner constructor, which requires explicit values for every field, including the attribute storage field this macro adds. Usually it is thus preferable to add an explicit default constructor, as in the example below.</p></div></div><p><strong>Examples</strong></p><p>Applying the macro to a struct definition results in internal storage of the attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; @attributes mutable struct MyGroup
           order::Int
           MyGroup(order::Int) = new(order)
       end

julia&gt; G = MyGroup(5)
MyGroup(5, #undef)

julia&gt; set_attribute!(G, :isfinite, :true)

julia&gt; get_attribute(G, :isfinite)
true</code></pre><p>Applying the macro to a typename results in external storage of the attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct MyOtherGroup
           order::Int
           MyOtherGroup(order::Int) = new(order)
       end

julia&gt; @attributes MyOtherGroup

julia&gt; G = MyOtherGroup(5)
MyOtherGroup(5)

julia&gt; set_attribute!(G, :isfinite, :true)

julia&gt; get_attribute(G, :isfinite)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L5-L64">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.@attr"><a class="docstring-binding" href="#AbstractAlgebra.@attr"><code>AbstractAlgebra.@attr</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@attr RetType funcdef</code></pre><p>This macro is applied to the definition of a unary function, and enables caching (&quot;memoization&quot;) of its return values based on the argument. This assumes the argument supports attribute storing (see <a href="#AbstractAlgebra.@attributes"><code>@attributes</code></a>) via <a href="#AbstractAlgebra.get_attribute!"><code>get_attribute!</code></a>.</p><p>The name of the function is used as name for the underlying attribute.</p><p>The macro works the same for unary functions with keyword arguments, but ignores the keyword arguments when caching the result, i.e. different calls with different keyword arguments will return the identical (cached) result. In case that there is no result cached yet, the function is called with the given keyword arguments.</p><p>Effectively, this turns code like this:</p><pre><code class="language-julia hljs">@attr RetType function myattr(obj::Foo)
   # ... expensive computation
   return result
end</code></pre><p>into something essentially equivalent to this:</p><pre><code class="language-julia hljs">function myattr(obj::Foo)
  return get_attribute!(obj, :myattr) do
    # ... expensive computation
    return result
  end::RetType
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @attributes mutable struct Foo
           x::Int
           Foo(x::Int) = new(x)
       end;

julia&gt; @attr Int function myattr(obj::Foo)
                println(&quot;Performing expensive computation&quot;)
                return factorial(obj.x)
             end;

julia&gt; obj = Foo(5);

julia&gt; myattr(obj)
Performing expensive computation
120

julia&gt; myattr(obj) # second time uses the cached result
120
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L283-L338">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.has_attribute"><a class="docstring-binding" href="#AbstractAlgebra.has_attribute"><code>AbstractAlgebra.has_attribute</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_attribute(G::Any, attr::Symbol)</code></pre><p>Return a boolean indicating whether <code>G</code> has a value stored for the attribute <code>attr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L169-L173">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.get_attribute"><a class="docstring-binding" href="#AbstractAlgebra.get_attribute"><code>AbstractAlgebra.get_attribute</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_attribute(f::Function, G::Any, attr::Symbol)</code></pre><p>Return the value stored for the attribute <code>attr</code>, or if no value has been set, return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax.</p><pre><code class="language-julia hljs">get_attribute(obj, attr) do
    # default value calculated here if needed
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L179-L193">source</a></section><section><div><pre><code class="language-julia hljs">get_attribute(G::Any, attr::Symbol, default::Any = nothing)</code></pre><p>Return the value stored for the attribute <code>attr</code>, or if no value has been set, return <code>default</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L200-L205">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.get_attribute!"><a class="docstring-binding" href="#AbstractAlgebra.get_attribute!"><code>AbstractAlgebra.get_attribute!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_attribute!(f::Function, G::Any, attr::Symbol)</code></pre><p>Return the value stored for the attribute <code>attr</code> of <code>G</code>, or if no value has been set, store <code>key =&gt; f()</code> and return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax.</p><pre><code class="language-julia hljs">get_attribute!(obj, attr) do
    # default value calculated here if needed
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L220-L234">source</a></section><section><div><pre><code class="language-julia hljs">get_attribute!(G::Any, attr::Symbol, default::Any)</code></pre><p>Return the value stored for the attribute <code>attr</code> of <code>G</code>, or if no value has been set, store <code>key =&gt; default</code>, and return <code>default</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L240-L245">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.set_attribute!"><a class="docstring-binding" href="#AbstractAlgebra.set_attribute!"><code>AbstractAlgebra.set_attribute!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_attribute!(G::Any, data::Pair{Symbol, &lt;:Any}...)</code></pre><p>Attach the given sequence of <code>key=&gt;value</code> pairs as attributes of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L258-L262">source</a></section><section><div><pre><code class="language-julia hljs">set_attribute!(G::Any, attr::Symbol, value::Any)</code></pre><p>Attach the given <code>value</code> as attribute <code>attr</code> of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L271-L275">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_attribute_storing"><a class="docstring-binding" href="#AbstractAlgebra.is_attribute_storing"><code>AbstractAlgebra.is_attribute_storing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_attribute_storing(G::Any)</code></pre><p>Return a boolean indicating whether <code>G</code> has the ability to store attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L154-L158">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_attribute_storing_type"><a class="docstring-binding" href="#AbstractAlgebra.is_attribute_storing_type"><code>AbstractAlgebra.is_attribute_storing_type</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_attribute_storing_type(T::Type)</code></pre><p>Return a boolean indicating whether instances of type <code>T</code> have the ability to store attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/Attributes.jl#L161-L166">source</a></section></details></article><h2 id="Advanced-printing"><a class="docs-heading-anchor" href="#Advanced-printing">Advanced printing</a><a id="Advanced-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-printing" title="Permalink"></a></h2><h3 id="Self-given-names"><a class="docs-heading-anchor" href="#Self-given-names">Self-given names</a><a id="Self-given-names-1"></a><a class="docs-heading-anchor-permalink" href="#Self-given-names" title="Permalink"></a></h3><p>We provide macros <code>@show_name</code>, <code>@show_special</code> and <code>@show_special_elem</code> to change the way certain objects are printed.</p><p>In compact and terse printing mode, <code>@show_name</code> tries to determine a suitable name to print instead of the object (see <a href="#AbstractAlgebra.PrettyPrinting.get_name"><code>AbstractAlgebra.get_name</code></a>).</p><p><code>@show_special</code> checks if an attribute <code>:show</code> is present. If so, it has to be a function taking <code>IO</code>, optionally a MIME-type, and the object. This is then called instead of the usual <code>show</code> function.</p><p>Similarly, <code>@show_special_elem</code> checks if an attribute <code>:show_elem</code> is present in the object&#39;s parent. The semantics are the same as for <code>@show_special</code>.</p><p>All are supposed to be used within the usual <code>show</code> function, where <code>@show_special_elem</code> is only relevant for element types of algebraic structures.</p><pre><code class="language-julia hljs">@attributes MyObj

function show(io::IO, A::MyObj)
   @show_name(io, A)
   @show_special(io, A)

   # ... usual stuff
end

function show(io::IO, mime::MIME&quot;text/plain&quot;, A::MyObj)
   @show_name(io, A)
   @show_special(io, mime, A)

   # ... usual stuff
end

function show(io::IO, A::MyObjElem)
   @show_name(io, A)
   @show_special_elem(io, A)

   # ... usual stuff
end

function show(io::IO, mime::MIME&quot;text/plain&quot;, A::MyObjElem)
   @show_name(io, A)
   @show_special_elem(io, mime, A)

   # ... usual stuff
end</code></pre><h4 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h4><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.@show_special"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.@show_special"><code>AbstractAlgebra.PrettyPrinting.@show_special</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@show_special(io::IO, obj)</code></pre><p>If the <code>obj</code> has a <code>show</code> attribute, this gets called with <code>io</code> and <code>obj</code> and returns from the current scope. Otherwise, does nothing.</p><p>If <code>obj</code> does not have attribute storage available, this macro does nothing.</p><p>It is supposed to be used at the start of <code>show</code> methods as shown in the documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(QQ, :x; cached=false)
Univariate polynomial ring in x over rationals

julia&gt; AbstractAlgebra.@show_special(stdout, R)

julia&gt; set_attribute!(R, :show, (i,o) -&gt; print(i, &quot;=&gt; The One True Ring &lt;=&quot;))

julia&gt; AbstractAlgebra.@show_special(stdout, R)
=&gt; The One True Ring &lt;=

julia&gt; R   # show for R uses @show_special, so we can observe the effect directly
=&gt; The One True Ring &lt;=</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1603-L1629">source</a></section><section><div><pre><code class="language-julia hljs">@show_special(io::IO, mime, obj)</code></pre><p>If the <code>obj</code> has a <code>show</code> attribute, this gets called with <code>io</code>, <code>mime</code> and <code>obj</code> (if applicable) and <code>io</code> and <code>obj</code> otherwise, and returns from the current scope. Otherwise, does nothing.</p><p>If <code>obj</code> does not have attribute storage available, this macro does nothing.</p><p>It is supposed to be used at the start of <code>show</code> methods as shown in the documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(QQ, :x; cached=false)
Univariate polynomial ring in x over rationals

julia&gt; AbstractAlgebra.@show_special(stdout, MIME&quot;text/plain&quot;(), R)

julia&gt; myshow(i,o) = print(i, &quot;=&gt; The One True Ring &lt;=&quot;);

julia&gt; myshow(i,m,o) = print(i, &quot;=&gt; The One True Ring with mime type $m &lt;=&quot;);

julia&gt; set_attribute!(R, :show, myshow)

julia&gt; AbstractAlgebra.@show_special(stdout, MIME&quot;text/plain&quot;(), R)
=&gt; The One True Ring with mime type text/plain &lt;=

julia&gt; R   # show for R uses @show_special, so we can observe the effect directly
=&gt; The One True Ring &lt;=</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1646-L1676">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.@show_special_elem"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.@show_special_elem"><code>AbstractAlgebra.PrettyPrinting.@show_special_elem</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@show_special_elem(io::IO, obj)</code></pre><p>If the <code>parent</code> of <code>obj</code> has a <code>show_elem</code> attribute, this gets called with <code>io</code> and <code>obj</code> and returns from the current scope. Otherwise, does nothing.</p><p>If <code>parent(obj)</code> does not have attribute storage available, this macro does nothing.</p><p>It is supposed to be used at the start of <code>show</code> methods as shown in the documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(QQ, :x; cached=false)
Univariate polynomial ring in x over rationals

julia&gt; AbstractAlgebra.@show_special_elem(stdout, x)

julia&gt; set_attribute!(R, :show_elem, (i,o) -&gt; print(i, &quot;=&gt; $o &lt;=&quot;))

julia&gt; AbstractAlgebra.@show_special_elem(stdout, x)
=&gt; x &lt;=

julia&gt; x   # show for x does not uses @show_special_elem, so x prints as before
x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1698-L1724">source</a></section><section><div><pre><code class="language-julia hljs">@show_special_elem(io::IO, mime, obj)</code></pre><p>If the <code>parent</code> of <code>obj</code> has a <code>show_elem</code> attribute, this gets called with <code>io</code>, <code>mime</code> and <code>obj</code> (if applicable) and <code>io</code> and <code>obj</code> otherwise, and returns from the current scope. Otherwise, does nothing.</p><p>If <code>parent(obj)</code> does not have attribute storage available, this macro does nothing.</p><p>It is supposed to be used at the start of <code>show</code> methods as shown in the documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(QQ, :x; cached=false)
Univariate polynomial ring in x over rationals

julia&gt; AbstractAlgebra.@show_special_elem(stdout, MIME&quot;text/plain&quot;(), x)

julia&gt; set_attribute!(R, :show_elem, (i,m,o) -&gt; print(i, &quot;=&gt; $o with mime type $m &lt;=&quot;))

julia&gt; AbstractAlgebra.@show_special_elem(stdout, MIME&quot;text/plain&quot;(), x)
=&gt; x with mime type text/plain &lt;=

julia&gt; x   # show for x does not uses @show_special_elem, so x prints as before
x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1742-L1768">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.@show_name"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.@show_name"><code>AbstractAlgebra.PrettyPrinting.@show_name</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@show_name(io::IO, obj)</code></pre><p>If either <code>is_terse(io)</code> is true or property <code>:compact</code> is set to <code>true</code> for <code>io</code> (see <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.IOContext"><code>IOContext</code></a>), print the name <a href="#AbstractAlgebra.PrettyPrinting.get_name"><code>get_name(obj)</code></a> of the object <code>obj</code> to the <code>io</code> stream, then return from the current scope. Otherwise, do nothing.</p><p>It is supposed to be used at the start of <code>show</code> methods as shown in the documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1574-L1583">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.get_name"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.get_name"><code>AbstractAlgebra.PrettyPrinting.get_name</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_name(obj) -&gt; Union{String,Nothing}</code></pre><p>Returns the name of the object <code>obj</code> if it is set, or <code>nothing</code> otherwise. This function tries to find a name in the following order:</p><ol><li>The name set by <a href="#AbstractAlgebra.PrettyPrinting.set_name!"><code>AbstractAlgebra.set_name!</code></a>.</li><li>The name of a variable in global (<code>Main</code> module) namespace with value bound to the object <code>obj</code> (see <a href="#AbstractAlgebra.PrettyPrinting.find_name"><code>AbstractAlgebra.PrettyPrinting.find_name</code></a>).</li><li>The name returned by <a href="#AbstractAlgebra.PrettyPrinting.extra_name"><code>AbstractAlgebra.extra_name</code></a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1550-L1558">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.set_name!"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.set_name!"><code>AbstractAlgebra.PrettyPrinting.set_name!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_name!(obj, name::String; override::Bool=true)</code></pre><p>Sets the name of the object <code>obj</code> to <code>name</code>. This name is used for printing using <a href="#AbstractAlgebra.PrettyPrinting.@show_name"><code>AbstractAlgebra.@show_name</code></a>. If <code>override</code> is <code>false</code>, the name is only set if there is no name already set.</p><p>This function errors if <code>obj</code> does not support attribute storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1452-L1460">source</a></section><section><div><pre><code class="language-julia hljs">set_name!(obj; override::Bool=true)</code></pre><p>Sets the name of the object <code>obj</code> to the name of a variable in global (<code>Main</code> module) namespace with value bound to the object <code>obj</code>, if such a variable exists (see <a href="#AbstractAlgebra.PrettyPrinting.find_name"><code>AbstractAlgebra.PrettyPrinting.find_name</code></a>). This name is used for printing using <a href="#AbstractAlgebra.PrettyPrinting.@show_name"><code>AbstractAlgebra.@show_name</code></a>. If <code>override</code> is <code>false</code>, the name is only set if there is no name already set.</p><p>This function errors if <code>obj</code> does not support attribute storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1466-L1475">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.extra_name"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.extra_name"><code>AbstractAlgebra.PrettyPrinting.extra_name</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extra_name(obj) -&gt; Union{String,Nothing}</code></pre><p>May be overloaded to provide a fallback name for the object <code>obj</code> in <a href="#AbstractAlgebra.PrettyPrinting.get_name"><code>AbstractAlgebra.get_name</code></a>. The default implementation returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1483-L1488">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.find_name"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.find_name"><code>AbstractAlgebra.PrettyPrinting.find_name</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_name(obj, M = Main; all::Bool = false) -&gt; Union{String,Nothing}</code></pre><p>Return name of a variable in <code>M</code>&#39;s namespace with value bound to the object <code>obj</code>, or <code>nothing</code> if no such variable exists. If <code>all</code> is <code>true</code>, private and non-exported variables are also searched.</p><div class="admonition is-info" id="Note-1b432b5fcefccab4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1b432b5fcefccab4" title="Permalink"></a></header><div class="admonition-body"><p>If the object is stored in several variables, the first one will be used, but a name returned once is kept until the variable no longer contains this object.</p></div></div><p>For this to work in doctests, one should call <code>AbstractAlgebra.set_current_module(@__MODULE__)</code> in the <code>value</code> argument of <code>Documenter.DocMeta.setdocmeta!</code> and keep the default value of <code>M = Main</code> here.</p><div class="admonition is-warning" id="Warning-a600f2874972bb9b"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a600f2874972bb9b" title="Permalink"></a></header><div class="admonition-body"><p>This function should not be used directly, but rather through <a href="#AbstractAlgebra.PrettyPrinting.get_name"><code>AbstractAlgebra.get_name</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1491-L1508">source</a></section></details></article><h3 id="Indentation-and-Decapitalization"><a class="docs-heading-anchor" href="#Indentation-and-Decapitalization">Indentation and Decapitalization</a><a id="Indentation-and-Decapitalization-1"></a><a class="docs-heading-anchor-permalink" href="#Indentation-and-Decapitalization" title="Permalink"></a></h3><p>To facilitate printing of nested mathematical structures, we provide a modified <code>IOCustom</code> object, that supports indentation and decapitalization.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>We illustrate this with an example</p><pre><code class="nohighlight hljs">struct A{T}
  x::T
end

function Base.show(io::IO, a::A)
  io = AbstractAlgebra.pretty(io)
  println(io, &quot;Something of type A&quot;)
  print(io, AbstractAlgebra.Indent(), &quot;over &quot;, AbstractAlgebra.Lowercase(), a.x)
  print(io, AbstractAlgebra.Dedent()) # don&#39;t forget to undo the indentation!
end

struct B
end

function Base.show(io::IO, b::B)
  io = AbstractAlgebra.pretty(io)
  print(io, LowercaseOff(), &quot;Hilbert thing&quot;)
end</code></pre><p>At the REPL, this will then be printed as follows:</p><pre><code class="nohighlight hljs">julia&gt; A(2)
Something of type A
  over 2

julia&gt; A(A(2))
Something of type A
  over something of type A
    over 2

julia&gt; A(B())
Something of type A
  over Hilbert thing</code></pre><h4 id="Documentation-2"><a class="docs-heading-anchor" href="#Documentation-2">Documentation</a><a class="docs-heading-anchor-permalink" href="#Documentation-2" title="Permalink"></a></h4><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.pretty"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.pretty"><code>AbstractAlgebra.PrettyPrinting.pretty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pretty(io::IO) -&gt; IOCustom</code></pre><p>Wrap <code>io</code> into an <code>IOCustom</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-repl hljs">julia&gt; io = AbstractAlgebra.pretty(stdout);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L2168-L2178">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.Indent"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.Indent"><code>AbstractAlgebra.PrettyPrinting.Indent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Indent</code></pre><p>When printed to an <code>IOCustom</code> object, increases the indentation level by one.</p><p><strong>Examples</strong></p><pre><code class="language-repl hljs">julia&gt; io = AbstractAlgebra.pretty(stdout);

julia&gt; print(io, AbstractAlgebra.Indent(), &quot;This is indented&quot;)
  This is indented</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1878-L1891">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.Dedent"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.Dedent"><code>AbstractAlgebra.PrettyPrinting.Dedent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Dedent</code></pre><p>When printed to an <code>IOCustom</code> object, decreases the indentation level by one.</p><p><strong>Examples</strong></p><pre><code class="language-repl hljs">julia&gt; io = AbstractAlgebra.pretty(stdout);

julia&gt; print(io, AbstractAlgebra.Indent(), AbstractAlgebra.Dedent(), &quot;This is indented&quot;)
This is indented</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1894-L1907">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.Lowercase"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.Lowercase"><code>AbstractAlgebra.PrettyPrinting.Lowercase</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Lowercase</code></pre><p>When printed to an <code>IOCustom</code> object, the next letter printed will be lowercase.</p><p><strong>Examples</strong></p><pre><code class="language-repl hljs">julia&gt; io = AbstractAlgebra.pretty(stdout);

julia&gt; print(io, AbstractAlgebra.Lowercase(), &quot;Foo&quot;)
foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1910-L1923">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.LowercaseOff"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.LowercaseOff"><code>AbstractAlgebra.PrettyPrinting.LowercaseOff</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LowercaseOff</code></pre><p>When printed to an <code>IOCustom</code> object, the case of the next letter will not be changed when printed.</p><p><strong>Examples</strong></p><pre><code class="language-repl hljs">julia&gt; io = AbstractAlgebra.pretty(stdout);

julia&gt; print(io, AbstractAlgebra.Lowercase(), AbstractAlgebra.LowercaseOff(), &quot;Foo&quot;)
Foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L1926-L1940">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.terse"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.terse"><code>AbstractAlgebra.PrettyPrinting.terse</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">terse(io::IO) -&gt; IO</code></pre><p>Return a new IO objects derived from <code>io</code> for which &quot;terse&quot; printing mode has been enabled.</p><p>See <a href="https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/">https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/</a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AbstractAlgebra.is_terse(stdout)
false

julia&gt; io = AbstractAlgebra.terse(stdout);

julia&gt; AbstractAlgebra.is_terse(io)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L2196-L2216">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.PrettyPrinting.is_terse"><a class="docstring-binding" href="#AbstractAlgebra.PrettyPrinting.is_terse"><code>AbstractAlgebra.PrettyPrinting.is_terse</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_terse(io::IO) -&gt; Bool</code></pre><p>Test whether &quot;terse&quot; printing mode is enabled for <code>io</code>.</p><p>See <a href="https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/">https://docs.oscar-system.org/stable/DeveloperDocumentation/printing_details/</a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AbstractAlgebra.is_terse(stdout)
false

julia&gt; io = AbstractAlgebra.terse(stdout);

julia&gt; AbstractAlgebra.is_terse(io)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/1027804adb15dbd8361bcf95d6073e719e161ef7/src/PrettyPrinting.jl#L2220-L2239">source</a></section></details></article><h2 id="Linear-solving-interface-for-developers"><a class="docs-heading-anchor" href="#Linear-solving-interface-for-developers">Linear solving interface for developers</a><a id="Linear-solving-interface-for-developers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solving-interface-for-developers" title="Permalink"></a></h2><p>AbstractAlgebra has a generic interface for linear solving and we describe here how one may extend this interface. For the user-facing functionality of linear solving, see <a href="../linear_solving/#solving_chapter">Linear Solving</a>.</p><p>Notice that the functionality is implemented in the module <code>AbstractAlgebra.Solve</code> and the internal functions are not exported from there.</p><h3 id="Matrix-normal-forms"><a class="docs-heading-anchor" href="#Matrix-normal-forms">Matrix normal forms</a><a id="Matrix-normal-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-normal-forms" title="Permalink"></a></h3><p>To distinguish between different algorithms, we use type traits of abstract type <code>MatrixNormalFormTrait</code> which usually correspond to a certain matrix normal form. The available algorithms/normal forms are</p><ul><li><code>HowellFormTrait</code>: uses a Howell form;</li><li><code>HermiteFormTrait</code>: uses a Hermite normal form;</li><li><code>RREFTrait</code>: uses a row-reduced echelon form over fields;</li><li><code>LUTrait</code>: uses a LU factoring of the matrix;</li><li><code>FFLUTrait</code>: uses a &quot;fraction-free&quot; LU factoring of the matrix over fraction   fields;</li><li><code>MatrixInterpolateTrait</code>: uses interpolation of polynomials for fraction   fields of polynomial rings.</li></ul><p>To select a normal form type for rings of type <code>NewRing</code>, implement the function</p><pre><code class="language-julia hljs">Solve.matrix_normal_form_type(::NewRing) = Bla()</code></pre><p>where <code>Bla &lt;: MatrixNormalFormTrait</code>. A new type trait can be added via</p><pre><code class="language-julia hljs">struct NewTrait &lt;: Solve.MatrixNormalFormTrait end</code></pre><h3 id="Internal-solving-functionality"><a class="docs-heading-anchor" href="#Internal-solving-functionality">Internal solving functionality</a><a id="Internal-solving-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-solving-functionality" title="Permalink"></a></h3><p>If a new ring type <code>NewRing</code> can make use of one of the available <code>MatrixNormalFormTrait</code>s, then it suffices to specify this normal form as described above to use the generic solving functionality. (However, for example <code>HermiteFormTrait</code> requires that the function <code>hermite_form_with_transformation</code> is implemented.)</p><p>For a new trait <code>NewTrait &lt;: MatrixNormalFormTrait</code>, one needs to implement the function</p><pre><code class="language-julia hljs">Solve._can_solve_internal_no_check(
  ::NewTrait, A::MatElem{T}, b::MatElem{T}, task::Symbol; side::Symbol = :left
  ) where T</code></pre><p>Inside this function, one can assume that <code>A</code> and <code>b</code> have the same base ring and have compatible dimensions. Further, <code>task</code> and <code>side</code> are set to &quot;legal&quot; options. (All this is checked in <code>Solve._can_solve_internal</code>.) This function should then (try to) solve <code>Ax = b</code> (<code>side == :right</code>) or <code>xA = b</code> (<code>side == :left</code>) possibly with kernel. The function must always return a tuple <code>(::Bool, ::MatElem{T}, ::MatElem{T})</code> consisting of:</p><ul><li><code>true</code>/<code>false</code> whether a solution exists or not</li><li>the solution (or a placeholder if no solution exists or a solution is not requested)</li><li>the kernel (or a placeholder if the kernel is not requested)</li></ul><p>The input <code>task</code> may be:</p><ul><li><code>:only_check</code>: Only test whether there is a solution, the second and third return value are only for type stability;</li><li><code>:with_solution</code>: Compute a solution, if it exists, the last return value is only for type stability;</li><li><code>:with_kernel</code>: Compute a solution and a kernel.</li></ul><p>One should further implement the function</p><pre><code class="language-julia hljs">kernel(::NewTrait, A::MatElem; side::Symbol = :left)</code></pre><p>which computes a left (or right) kernel of <code>A</code>.</p><h3 id="Internal-solve-context-functionality"><a class="docs-heading-anchor" href="#Internal-solve-context-functionality">Internal solve context functionality</a><a id="Internal-solve-context-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-solve-context-functionality" title="Permalink"></a></h3><p>To efficiently solve several linear systems with the same matrix <code>A</code>, we provide the &quot;solve contexts objects&quot; of type <code>Solve.SolveCtx</code>. These can be extended for a ring of type <code>NewRing</code> as follows.</p><h4 id="Solve-context-type"><a class="docs-heading-anchor" href="#Solve-context-type">Solve context type</a><a id="Solve-context-type-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-context-type" title="Permalink"></a></h4><p>For a new ring type, one may have to define the type parameters of a <code>Solve.SolveCtx</code> object. First of all, one needs to implement the function</p><pre><code class="language-julia hljs">function Solve.solve_context_type(::NewRing)
  return Solve.solve_context_type(::NormalFormTrait, elem_type(NewRing))
end</code></pre><p>to pick a <code>MatrixNormalFormTrait</code>.</p><p>Usually, nothing else should be necessary. However, if for example the normal form of a matrix does not live over the same ring as the matrix itself, one might also need to implement</p><pre><code class="language-julia hljs">function Solve.solve_context_type(NF::NormalFormTrait, T::Type{NewRingElem})
  return Solve.SolveCtx{T, typeof(NF), MatType, RedMatType, TranspMatType}
end</code></pre><p>where <code>MatType</code> is the dense matrix type over <code>NewRing</code>, <code>RedMatType</code> the type of a matrix in reduced/normal form and <code>TranspMatType</code> the type of the reduced/normal form of the transposed matrix.</p><h4 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h4><p>To initialize the solve context functionality for a new normal form <code>NewTrait</code>, one needs to implement the functions</p><pre><code class="language-julia hljs">Solve._init_reduce(C::Solve.SolveCtx{T, NewTrait}) where T
Solve._init_reduce_transpose(C::Solve.SolveCtx{T, NewTrait}) where T</code></pre><p>These should fill the corresponding fields of the solve context <code>C</code> with a &quot;reduced matrix&quot; (that is, a matrix in normal form) of <code>matrix(C)</code>, respectively <code>transpose(matrix(C))</code>, and other information necessary to solve a linear system. The fields can be accessed via <code>reduced_matrix</code>, <code>reduced_matrix_of_transpose</code>, etc. New fields may also be added via attributes.</p><h4 id="Internal-solving-functionality-2"><a class="docs-heading-anchor" href="#Internal-solving-functionality-2">Internal solving functionality</a><a class="docs-heading-anchor-permalink" href="#Internal-solving-functionality-2" title="Permalink"></a></h4><p>As above, one finally needs to implement the functions</p><pre><code class="language-julia hljs">Solve._can_solve_internal_no_check(
  ::NewTrait, C::Solve.SolveCtx{T, NewTrait}, b::MatElem{T}, task::Symbol;
  side::Symbol = :left
  ) where T</code></pre><p>and</p><pre><code class="language-julia hljs">kernel(::NewTrait, C::Solve.SolveCtx{T, NewTrait}; side::Symbol = :left)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../map_with_inverse/">« Map with inverse</a><a class="docs-footer-nextpage" href="../assertions/">Assertion and Verbosity Macros »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 27 January 2026 03:49">Tuesday 27 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
