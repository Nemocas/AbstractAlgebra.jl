<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Miscellaneous · AbstractAlgebra.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li class="is-active"><a class="tocitem" href>Miscellaneous</a><ul class="internal"><li><a class="tocitem" href="#Printing-options"><span>Printing options</span></a></li><li><a class="tocitem" href="#Updating-the-type-diagrams"><span>Updating the type diagrams</span></a></li><li><a class="tocitem" href="#Attributes"><span>Attributes</span></a></li></ul></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Miscellaneous</a></li><li class="is-active"><a href>Miscellaneous</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Miscellaneous</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/misc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h1><h2 id="Printing-options"><a class="docs-heading-anchor" href="#Printing-options">Printing options</a><a id="Printing-options-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-options" title="Permalink"></a></h2><p>AbstractAlgebra supports printing to LaTeX using the MIME type &quot;text/latex&quot;. To enable LaTeX rendering in Jupyter notebooks and query for the current state, use the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.PrettyPrinting.set_html_as_latex" href="#AbstractAlgebra.PrettyPrinting.set_html_as_latex"><code>AbstractAlgebra.PrettyPrinting.set_html_as_latex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_html_as_latex(fl::Bool)</code></pre><p>Toggles whether MIME type <code>text/html</code> should be printed as <code>text/latex</code>. Note that this is a global option. The return value is the old value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/PrettyPrinting.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.PrettyPrinting.get_html_as_latex" href="#AbstractAlgebra.PrettyPrinting.get_html_as_latex"><code>AbstractAlgebra.PrettyPrinting.get_html_as_latex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_html_as_latex()</code></pre><p>Returns whether MIME type <code>text/html</code> is printed as <code>text/latex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/PrettyPrinting.jl#L98">source</a></section></article><h2 id="Updating-the-type-diagrams"><a class="docs-heading-anchor" href="#Updating-the-type-diagrams">Updating the type diagrams</a><a id="Updating-the-type-diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-type-diagrams" title="Permalink"></a></h2><p>Updating the diagrams of the documentation can be done by modifying and running the script <code>docs/create_type_diagrams.jl</code>. Note that this requires the package <code>Kroki</code>.</p><h2 id="Attributes"><a class="docs-heading-anchor" href="#Attributes">Attributes</a><a id="Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes" title="Permalink"></a></h2><p>Often it is desirable to have a flexible way to attach additional data to mathematical structures such as groups, rings, fields, etc. beyond what the original implementation covers. To facilitate this, we provide an <em>attributes</em> system: for objects of suitable types, one may use <code>set_attribute!</code> to attach key-value pairs to the object, and query them using <code>has_attribute</code>, <code>get_attribute</code> and <code>get_attribute!</code>.</p><p>Attributes are supported for all singletons (i.e., instances of an empty <code>struct</code> type), as well as for instances of mutable struct type for which attribute storage was enabled. There are two ways to enable attribute storage for such types:</p><ol><li>By applying <code>@attributes</code> to a mutable struct declaration, storage is reserved inside that struct type itself (this increases the size of each struct by 8 bytes if no attributes are set).</li><li>By applying <code>@attributes</code> to the name of a mutable struct type, methods are installed which store attributes to instances of the type in a <code>WeakKeyDict</code> outside the struct.</li></ol><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.@attributes" href="#AbstractAlgebra.@attributes"><code>AbstractAlgebra.@attributes</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@attributes typedef</code></pre><p>This is a helper macro that ensures that there is storage for attributes in the type declared in the expression <code>typedef</code>, which must be either a <code>mutable struct</code> definition expression, or the name of a <code>mutable struct</code> type.</p><p>The latter variant is useful to enable attribute storage for types defined in other packages. Note that <code>@attributes</code> is idempotent: when applied to a type for which attribute storage is already available, it does nothing.</p><p>For singleton types, attribute storage is also supported, and in fact always enabled. Thus it is not necessary to apply this macro to such a type.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When applied to a struct definition this macro adds a new field to the struct. For structs without constructor, this will change the signature of the default inner constructor, which requires explicit values for every field, including the attribute storage field this macro adds. Usually it is thus preferable to add an explicit default constructor, as in the example below.</p></div></div><p><strong>Examples</strong></p><p>Applying the macro to a struct definition results in internal storage of the attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; @attributes mutable struct MyGroup
           order::Int
           MyGroup(order::Int) = new(order)
       end

julia&gt; G = MyGroup(5)
MyGroup(5, #undef)

julia&gt; set_attribute!(G, :isfinite, :true)

julia&gt; get_attribute(G, :isfinite)
true</code></pre><p>Applying the macro to a typename results in external storage of the attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct MyOtherGroup
           order::Int
           MyOtherGroup(order::Int) = new(order)
       end

julia&gt; @attributes MyOtherGroup

julia&gt; G = MyOtherGroup(5)
MyOtherGroup(5)

julia&gt; set_attribute!(G, :isfinite, :true)

julia&gt; get_attribute(G, :isfinite)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L13-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.@attr" href="#AbstractAlgebra.@attr"><code>AbstractAlgebra.@attr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@attr [RetType] funcdef</code></pre><p>This macro is applied to the definition of a unary function, and enables caching (&quot;memoization&quot;) of its return values based on the argument. This assumes the argument supports attribute storing (see <a href="#AbstractAlgebra.@attributes"><code>@attributes</code></a>) via <a href="#AbstractAlgebra.get_attribute!"><code>get_attribute!</code></a>.</p><p>The name of the function is used as name for the underlying attribute.</p><p>Effectively, this turns code like this:</p><pre><code class="language-julia hljs">@attr function RetType myattr(obj::Foo)
   # ... expensive computation
   return result
end</code></pre><p>into something essentially equivalent to this:</p><pre><code class="language-julia hljs">function myattr(obj::Foo)
  return get_attribute!(obj, :myattr) do
    # ... expensive computation
    return result
  end::RetType
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @attributes mutable struct Foo
           x::Int
           Foo(x::Int) = new(x)
       end;

julia&gt; @attr Int function myattr(obj::Foo)
                println(&quot;Performing expensive computation&quot;)
                return factorial(obj.x)
             end;

julia&gt; obj = Foo(5);

julia&gt; myattr(obj)
Performing expensive computation
120

julia&gt; myattr(obj) # second time uses the cached result
120
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L261-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.has_attribute" href="#AbstractAlgebra.has_attribute"><code>AbstractAlgebra.has_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_attribute(G::Any, attr::Symbol)</code></pre><p>Return a boolean indicating whether <code>G</code> has a value stored for the attribute <code>attr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.get_attribute" href="#AbstractAlgebra.get_attribute"><code>AbstractAlgebra.get_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_attribute(f::Function, G::Any, attr::Symbol)</code></pre><p>Return the value stored for the attribute <code>attr</code>, or if no value has been set, return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax.</p><pre><code class="language-julia hljs">get_attribute(obj, attr) do
    # default value calculated here if needed
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L172-L186">source</a></section><section><div><pre><code class="nohighlight hljs">get_attribute(G::Any, attr::Symbol, default::Any = nothing)</code></pre><p>Return the value stored for the attribute <code>attr</code>, or if no value has been set, return <code>default</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.get_attribute!" href="#AbstractAlgebra.get_attribute!"><code>AbstractAlgebra.get_attribute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_attribute!(f::Function, G::Any, attr::Symbol)</code></pre><p>Return the value stored for the attribute <code>attr</code> of <code>G</code>, or if no value has been set, store <code>key =&gt; f()</code> and return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax.</p><pre><code class="language-julia hljs">get_attribute!(obj, attr) do
    # default value calculated here if needed
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L205-L219">source</a></section><section><div><pre><code class="nohighlight hljs">get_attribute!(G::Any, attr::Symbol, default::Any)</code></pre><p>Return the value stored for the attribute <code>attr</code> of <code>G</code>, or if no value has been set, store <code>key =&gt; default</code>, and return <code>default</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.set_attribute!" href="#AbstractAlgebra.set_attribute!"><code>AbstractAlgebra.set_attribute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_attribute!(G::Any, data::Pair{Symbol, &lt;:Any}...)</code></pre><p>Attach the given sequence of <code>key=&gt;value</code> pairs as attributes of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L236-L240">source</a></section><section><div><pre><code class="nohighlight hljs">set_attribute!(G::Any, attr::Symbol, value::Any)</code></pre><p>Attach the given <code>value</code> as attribute <code>attr</code> of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/7106020783153965fb0d894d72cd3429d9cd3142/src/Attributes.jl#L249-L253">source</a></section></article><p>The attributes system can be utilized to change the way certain objects are printed. We provide macros <code>@show_special</code> and <code>@show_name</code> for this purpose, both are called with the same argument as <code>show</code>: an <code>IO</code>-object and the object itself. Both are supposed to be used within the usual <code>show</code> function:</p><pre><code class="nohighlight hljs">function show(io::IO, A::MyObj)
   @show_name(io, A)
   @show_special(io, A)

   ... usual stuff</code></pre><p><code>@show_special</code> checks if an attribute <code>:show_special</code> is present. If so, it has to be a function taking <code>IO</code> and the object. This is then called instead of the usual <code>show</code> function.</p><p><code>@show_name</code> will check if there is a variable in global (<code>Main</code> module) namespace with value bound to the object. In compact printing mode, the name is then shown instead of the object.</p><p>Note: if the object is stored in several variable, the first one will be used. Also the name, once used for printing, is stored in the object - hence will not change anymore.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../map_with_inverse/">« Map with inverse</a><a class="docs-footer-nextpage" href="../interface_introduction/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 March 2023 15:33">Friday 17 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
