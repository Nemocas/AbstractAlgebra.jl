<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Partitions and Young tableaux · AbstractAlgebra.jl</title><meta name="title" content="Partitions and Young tableaux · AbstractAlgebra.jl"/><meta property="og:title" content="Partitions and Young tableaux · AbstractAlgebra.jl"/><meta property="twitter:title" content="Partitions and Young tableaux · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li class="is-active"><a class="tocitem" href>Partitions and Young tableaux</a><ul class="internal"><li><a class="tocitem" href="#Partitions"><span>Partitions</span></a></li><li><a class="tocitem" href="#Young-Diagrams-and-Young-Tableaux"><span>Young Diagrams and Young Tableaux</span></a></li><li><a class="tocitem" href="#Characters-of-permutation-groups"><span>Characters of permutation groups</span></a></li><li><a class="tocitem" href="#Skew-Diagrams"><span>Skew Diagrams</span></a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Groups</a></li><li class="is-active"><a href>Partitions and Young tableaux</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Partitions and Young tableaux</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ytabs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Partitions-and-Young-tableaux"><a class="docs-heading-anchor" href="#Partitions-and-Young-tableaux">Partitions and Young tableaux</a><a id="Partitions-and-Young-tableaux-1"></a><a class="docs-heading-anchor-permalink" href="#Partitions-and-Young-tableaux" title="Permalink"></a></h1><p>AbstractAlgebra.jl provides basic support for computations with Young tableaux, skew diagrams and the characters of permutation groups (implemented <code>src/generic/YoungTabs.jl</code>). All functionality of permutations is accessible in the <code>Generic</code> submodule.</p><h2 id="Partitions"><a class="docs-heading-anchor" href="#Partitions">Partitions</a><a id="Partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Partitions" title="Permalink"></a></h2><p>The basic underlying object for those concepts is <code>Partition</code> of a number <span>$n$</span>, i.e. a sequence of positive integers <span>$n_1, \ldots, n_k$</span> which sum to <span>$n$</span>. Partitions in AbstractAlgebra.jl are represented internally by non-increasing <code>Vector</code>s of <code>Int</code>s. Partitions are printed using the standard notation, i.e. <span>$9 = 4 + 2 + 1 + 1 + 1$</span> is shown as <span>$4_1 2_1 1_3$</span> with the subscript indicating the count of a summand in the partition.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.Partition" href="#AbstractAlgebra.Generic.Partition"><code>AbstractAlgebra.Generic.Partition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Partition(part::Vector{&lt;:Integer}[, check::Bool=true]) &lt;: AbstractVector{Int}</code></pre><p>Represent integer partition in the non-increasing order.</p><p><code>part</code> will be sorted, if necessary. Checks for validity of input can be skipped by calling the (inner) constructor with <code>false</code> as the second argument.</p><p>Functionally <code>Partition</code> is a thin wrapper over <code>Vector{Int}</code>.</p><p>Fieldnames:</p><ul><li><code>n::Int</code> - the partitioned number</li><li><code>part::Vector{Int}</code> - a non-increasing sequence of summands of <code>n</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Partition([4,2,1,1,1])
4₁2₁1₃

julia&gt; p.n == sum(p.part)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/GenericTypes.jl#L67-L88">source</a></section></article><h3 id="Array-interface"><a class="docs-heading-anchor" href="#Array-interface">Array interface</a><a id="Array-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Array-interface" title="Permalink"></a></h3><p><code>Partition</code> is a concrete (immutable) subtype of <code>AbstractVector{Integer}</code> and implements the standard Array interface.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{AbstractAlgebra.Generic.Partition}" href="#Base.size-Tuple{AbstractAlgebra.Generic.Partition}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(p::Partition)</code></pre><p>Return the size of the vector which represents the partition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Partition([4,3,1]); size(p)
(3,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractAlgebra.Generic.Partition, Integer}" href="#Base.getindex-Tuple{AbstractAlgebra.Generic.Partition, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(p::Partition, i::Integer)</code></pre><p>Return the <code>i</code>-th part (in non-increasing order) of the partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L20-L24">source</a></section></article><p>These functions work on the level of <code>p.part</code> vector.</p><p>One can easily iterate over all partitions of <span>$n$</span> using the <code>Generic.partitions</code> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.partitions" href="#AbstractAlgebra.Generic.partitions"><code>AbstractAlgebra.Generic.partitions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partitions(n::Integer)</code></pre><p>Return the vector of all permutations of <code>n</code>. For an unsafe generator version see <code>partitions!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Generic.partitions(5)
7-element Vector{AbstractAlgebra.Generic.Partition{Int64}}:
 1₅
 2₁1₃
 3₁1₂
 2₂1₁
 4₁1₁
 3₁2₁
 5₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L134-L151">source</a></section></article><p>You may also have a look at <a href="https://github.com/ulthiel/JuLie.jl">JuLie.jl</a> package for more utilities related to partitions.</p><p>The number of all partitions can be computed by the hidden function <code>_numpart</code>. Much faster implementation is available in <a href="https://nemocas.github.io/Nemo.jl/dev/arb.html#Nemo.numpart-Tuple{Int64,ArbField}">Nemo.jl</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic._numpart" href="#AbstractAlgebra.Generic._numpart"><code>AbstractAlgebra.Generic._numpart</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_numpart(n::Integer)</code></pre><p>Return the number of all distinct integer partitions of <code>n</code>. The function uses Euler pentagonal number theorem for recursive formula. For more details see OEIS sequence <a href="https://oeis.org/A000041">A000041</a>. Note that <code>_numpart(0) = 1</code> by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L61-L68">source</a></section></article><p>Since <code>Partition</code> is a subtype of <code>AbstractVector</code> generic functions which operate on vectors should work in general. However the meaning of <code>conj</code> has been changed to agree with the traditional understanding of conjugation of <code>Partitions</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{AbstractAlgebra.Generic.Partition}" href="#Base.conj-Tuple{AbstractAlgebra.Generic.Partition}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(part::Partition)</code></pre><p>Return the conjugated partition of <code>part</code>, i.e. the partition corresponding to the Young diagram of <code>part</code> reflected through the main diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Partition([4,2,1,1,1])
4₁2₁1₃

julia&gt; conj(p)
5₁2₁1₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L155-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{AbstractAlgebra.Generic.Partition, Vector}" href="#Base.conj-Tuple{AbstractAlgebra.Generic.Partition, Vector}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(part::Partition, v::Vector)</code></pre><p>Return the conjugated partition of <code>part</code> together with permuted vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L183-L187">source</a></section></article><h2 id="Young-Diagrams-and-Young-Tableaux"><a class="docs-heading-anchor" href="#Young-Diagrams-and-Young-Tableaux">Young Diagrams and Young Tableaux</a><a id="Young-Diagrams-and-Young-Tableaux-1"></a><a class="docs-heading-anchor-permalink" href="#Young-Diagrams-and-Young-Tableaux" title="Permalink"></a></h2><p>Mathematically speaking Young diagram is a diagram which consists of rows of square boxes such that the number of boxes in each row is no less than the number of boxes in the previous row. For example partition <span>$4_1 3_2 1$</span> represents the following diagram.</p><pre><code class="nohighlight hljs">┌───┬───┬───┬───┐
│   │   │   │   │
├───┼───┼───┼───┘
│   │   │   │
├───┼───┼───┤
│   │   │   │
├───┼───┴───┘
│   │
└───┘</code></pre><p>Young Tableau is formally a bijection between the set of boxes of a Young Diagram and the set <span>$\{1, \ldots, n\}$</span>. If a bijection is increasing along rows and columns of the diagram it is referred to as <strong>standard</strong>. For example</p><pre><code class="nohighlight hljs">┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┼───┤
│ 8 │ 9 │10 │
├───┼───┴───┘
│11 │
└───┘</code></pre><p>is a standard Young tableau of <span>$4_1 3_2 1$</span> where the bijection assigns consecutive natural numbers to consecutive (row-major) cells.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>In AbstractAlgebra.jl Young tableau are implemented as essentially row-major sparse matrices, i.e. <code>YoungTableau &lt;: AbstractMatrix{Int}</code> but only the defining <code>Partition</code> and the (row-major) fill-vector is stored.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.YoungTableau" href="#AbstractAlgebra.Generic.YoungTableau"><code>AbstractAlgebra.Generic.YoungTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YoungTableau(part::Partition[, fill::Vector{Int}=collect(1:sum(part))])  &lt;: AbstractMatrix{Int}</code></pre><p>Return the Young tableaux of partition <code>part</code>, filled linearly by <code>fill</code> vector. Note that <code>fill</code> vector is in <strong>row-major</strong> format.</p><p>Fields:</p><ul><li><code>part</code> - the partition defining Young diagram</li><li><code>fill</code> - the row-major fill vector: the entries of the diagram.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Partition([4,3,1]); y = YoungTableau(p)
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; y.part
4₁3₁1₁

julia&gt; y.fill
8-element Vector{Int64}:
 1
 2
 3
 4
 5
 6
 7
 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/GenericTypes.jl#L206-L241">source</a></section></article><p>For convenience there exists an alternative constructor of <code>YoungTableau</code>, which accepts a vector of integers and constructs <code>Partition</code> internally.</p><pre><code class="nohighlight hljs">YoungTableau(p::Vector{Integer}[, fill=collect(1:sum(p))])</code></pre><h3 id="Array-interface-2"><a class="docs-heading-anchor" href="#Array-interface-2">Array interface</a><a class="docs-heading-anchor-permalink" href="#Array-interface-2" title="Permalink"></a></h3><p>To make <code>YoungTableaux</code> array-like we implement the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{AbstractAlgebra.Generic.YoungTableau}" href="#Base.size-Tuple{AbstractAlgebra.Generic.YoungTableau}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(Y::YoungTableau)</code></pre><p>Return <code>size</code> of the smallest array containing <code>Y</code>, i.e. the tuple of the number of rows and the number of columns of <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1]); size(y)
(3, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L310-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractAlgebra.Generic.YoungTableau, Integer}" href="#Base.getindex-Tuple{AbstractAlgebra.Generic.YoungTableau, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(Y::YoungTableau, n::Integer)</code></pre><p>Return the column-major linear index into the <code>size(Y)</code>-array. If a box is outside of the array return <code>0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; y[1]
1

julia&gt; y[2]
5

julia&gt; y[4]
2

julia&gt; y[6]
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L333-L362">source</a></section></article><p>Also the double-indexing corresponds to <code>(row, column)</code> access to an abstract array.</p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; y[1,2]
2

julia&gt; y[2,3]
7

julia&gt; y[3,2]
0</code></pre><p>Functions defined for <code>AbstractArray</code> type based on those (e.g. <code>length</code>) should work. Again, as in the case of <code>Partition</code> the meaning of <code>conj</code> is altered to reflect the usual meaning for Young tableaux:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{AbstractAlgebra.Generic.YoungTableau}" href="#Base.conj-Tuple{AbstractAlgebra.Generic.YoungTableau}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(Y::YoungTableau)</code></pre><p>Return the conjugated tableau, i.e. the tableau reflected through the main diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; conj(y)
┌───┬───┬───┐
│ 1 │ 5 │ 8 │
├───┼───┼───┘
│ 2 │ 6 │
├───┼───┤
│ 3 │ 7 │
├───┼───┘
│ 4 │
└───┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L587-L615">source</a></section></article><h3 id="Pretty-printing"><a class="docs-heading-anchor" href="#Pretty-printing">Pretty-printing</a><a id="Pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Pretty-printing" title="Permalink"></a></h3><p>Similarly to permutations we have two methods of displaying Young Diagrams:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.setyoungtabstyle" href="#AbstractAlgebra.Generic.setyoungtabstyle"><code>AbstractAlgebra.Generic.setyoungtabstyle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setyoungtabstyle(format::Symbol)</code></pre><p>Select the style in which Young tableaux are displayed (in REPL or in general as string). This can be either</p><ul><li><code>:array</code> - as matrices of integers, or</li><li><code>:diagram</code> - as filled Young diagrams (the default).</li></ul><p>The difference is purely esthetical.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Generic.setyoungtabstyle(:array)
:array

julia&gt; p = Partition([4,3,1]); YoungTableau(p)
 1  2  3  4
 5  6  7
 8

julia&gt; Generic.setyoungtabstyle(:diagram)
:diagram

julia&gt; YoungTableau(p)
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L474-L506">source</a></section></article><h3 id="Ulitility-functions"><a class="docs-heading-anchor" href="#Ulitility-functions">Ulitility functions</a><a id="Ulitility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Ulitility-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.YoungTableau}" href="#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.YoungTableau}"><code>AbstractAlgebra.Generic.matrix_repr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_repr(a::Perm)</code></pre><p>Return the permutation matrix as a sparse matrix representing <code>a</code> via natural embedding of the permutation group into the general linear group over <span>$\mathbb{Z}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,3,1])
(1,2,3)

julia&gt; matrix_repr(p)
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 ⋅  1  ⋅
 ⋅  ⋅  1
 1  ⋅  ⋅

julia&gt; Array(ans)
3×3 Matrix{Int64}:
 0  1  0
 0  0  1
 1  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/PermGroups.jl#L683-L706">source</a></section><section><div><pre><code class="language-julia hljs">matrix_repr(Y::YoungTableau)</code></pre><p>Construct sparse integer matrix representing the tableau.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1]);


julia&gt; matrix_repr(y)
3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 1  2  3  4
 5  6  7  ⋅
 8  ⋅  ⋅  ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L527-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill!-Tuple{AbstractAlgebra.Generic.YoungTableau, AbstractVector{&lt;:Integer}}" href="#Base.fill!-Tuple{AbstractAlgebra.Generic.YoungTableau, AbstractVector{&lt;:Integer}}"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill!(Y::YoungTableaux, V::Vector{&lt;:Integer})</code></pre><p>Replace the fill vector <code>Y.fill</code> by <code>V</code>. No check if the resulting tableau is standard (i.e. increasing along rows and columns) is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; fill!(y, [2:9...])
┌───┬───┬───┬───┐
│ 2 │ 3 │ 4 │ 5 │
├───┼───┼───┼───┘
│ 6 │ 7 │ 8 │
├───┼───┴───┘
│ 9 │
└───┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L554-L580">source</a></section></article><h2 id="Characters-of-permutation-groups"><a class="docs-heading-anchor" href="#Characters-of-permutation-groups">Characters of permutation groups</a><a id="Characters-of-permutation-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Characters-of-permutation-groups" title="Permalink"></a></h2><p>Irreducible characters (at least over field of characteristic <span>$0$</span>) of the full group of permutations <span>$S_n$</span> correspond via <a href="https://en.wikipedia.org/wiki/Specht_module">Specht modules</a> to partitions of <span>$n$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition}" href="#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition}"><code>AbstractAlgebra.Generic.character</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">character(lambda::Partition)</code></pre><p>Return the <span>$\lambda$</span>-th irreducible character of permutation group on <code>sum(lambda)</code> symbols. The returned character function is of the following signature:</p><blockquote><p><code>chi(p::Perm[, check::Bool=true]) -&gt; BigInt</code></p></blockquote><p>The function checks (if <code>p</code> belongs to the appropriate group) can be switched off by calling <code>chi(p, false)</code>. The values computed by <span>$\chi$</span> are cached in look-up table.</p><p>The computation follows the Murnaghan-Nakayama formula: <span>$\chi_\lambda(\sigma) = \sum_{\text{rimhook }\xi\subset \lambda}(-1)^{ll(\lambda\backslash\xi)} \chi_{\lambda \backslash\xi}(\tilde\sigma)$</span> where <span>$\lambda\backslash\xi$</span> denotes the skew diagram of <span>$\lambda$</span> with <span>$\xi$</span> removed, <span>$ll$</span> denotes the leg-length (i.e. number of rows - 1) and <span>$\tilde\sigma$</span> is permutation obtained from <span>$\sigma$</span> by the removal of the longest cycle.</p><p>For more details see e.g. Chapter 2.8 of <em>Group Theory and Physics</em> by S.Sternberg.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = SymmetricGroup(4)
Full symmetric group over 4 elements

julia&gt; chi = character(Partition([3,1])); # character of the regular representation


julia&gt; chi(one(G))
3

julia&gt; chi(perm&quot;(1,3)(2,4)&quot;)
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/PermGroups.jl#L920-L954">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, Perm}" href="#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, Perm}"><code>AbstractAlgebra.Generic.character</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">character(lambda::Partition, p::Perm, check::Bool=true) -&gt; BigInt</code></pre><p>Return the value of <code>lambda</code>-th irreducible character of the permutation group on permutation <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/PermGroups.jl#L968-L973">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, AbstractAlgebra.Generic.Partition}" href="#AbstractAlgebra.Generic.character-Tuple{AbstractAlgebra.Generic.Partition, AbstractAlgebra.Generic.Partition}"><code>AbstractAlgebra.Generic.character</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">character(lambda::Partition, mu::Partition, check::Bool=true) -&gt; BigInt</code></pre><p>Return the value of <code>lambda-th</code> irreducible character on the conjugacy class represented by partition <code>mu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/PermGroups.jl#L985-L990">source</a></section></article><p>The values computed by characters are cached in an internal dictionary <code>Dict{Tuple{BitVector,Vector{Int}}, BigInt}</code>. Note that all of the above functions return <code>BigInts</code>. If you are sure that the computations do not overflow, variants of the last two functions using <code>Int</code> are available:</p><pre><code class="nohighlight hljs">character(::Type{Int}, lambda::Partition, p::Perm[, check::Bool=true])
character(::Type{Int}, lambda::Partition, mu::Partition[, check::Bool=true])</code></pre><p>The dimension <span>$\dim \lambda$</span> of the irreducible module corresponding to partition <span>$\lambda$</span> can be computed using <a href="https://en.wikipedia.org/wiki/Hook_length_formula">Hook length formula</a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.rowlength" href="#AbstractAlgebra.Generic.rowlength"><code>AbstractAlgebra.Generic.rowlength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rowlength(Y::YoungTableau, i, j)</code></pre><p>Return the row length of <code>Y</code> at box <code>(i,j)</code>, i.e. the number of boxes in the <code>i</code>-th row of the diagram of <code>Y</code> located to the right of the <code>(i,j)</code>-th box.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; Generic.rowlength(y, 1,2)
2

julia&gt; Generic.rowlength(y, 2,3)
0

julia&gt; Generic.rowlength(y, 3,3)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L618-L644">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.collength" href="#AbstractAlgebra.Generic.collength"><code>AbstractAlgebra.Generic.collength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collength(Y::YoungTableau, i, j)</code></pre><p>Return the column length of <code>Y</code> at box <code>(i,j)</code>, i.e. the number of boxes in the <code>j</code>-th column of the diagram of <code>Y</code> located below of the <code>(i,j)</code>-th box.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; Generic.collength(y, 1,1)
2

julia&gt; Generic.collength(y, 1,3)
1

julia&gt; Generic.collength(y, 2,4)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L647-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.hooklength" href="#AbstractAlgebra.Generic.hooklength"><code>AbstractAlgebra.Generic.hooklength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hooklength(Y::YoungTableau, i, j)</code></pre><p>Return the hook-length of an element in <code>Y</code> at position <code>(i,j)</code>, i.e the number of cells in the <code>i</code>-th row to the right of <code>(i,j)</code>-th box, plus the number of cells in the <code>j</code>-th column below the <code>(i,j)</code>-th box, plus <code>1</code>.</p><p>Return <code>0</code> for <code>(i,j)</code> not in the tableau <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; hooklength(y, 1,1)
6

julia&gt; hooklength(y, 1,3)
3

julia&gt; hooklength(y, 2,4)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L676-L705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.dim-Tuple{AbstractAlgebra.Generic.YoungTableau}" href="#AbstractAlgebra.Generic.dim-Tuple{AbstractAlgebra.Generic.YoungTableau}"><code>AbstractAlgebra.Generic.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(Y::YoungTableau) -&gt; BigInt</code></pre><p>Return the dimension (using hook-length formula) of the irreducible representation of permutation group <span>$S_n$</span> associated the partition <code>Y.part</code>.</p><p>Since the computation overflows easily <code>BigInt</code> is returned. You may perform the computation of the dimension in different type by calling <code>dim(Int, Y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dim(YoungTableau([4,3,1]))
70

julia&gt; dim(YoungTableau([3,1])) # the regular representation of S_4
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L714-L731">source</a></section></article><p>The character associated with <code>Y.part</code> can also be used to compute the dimension, but as it is expected the Murnaghan-Nakayama is much slower even though (due to caching) consecutive calls are fast:</p><pre><code class="language-julia hljs">julia&gt; λ = Partition(collect(12:-1:1))
12₁11₁10₁9₁8₁7₁6₁5₁4₁3₁2₁1₁

julia&gt; @time dim(YoungTableau(λ))
  0.224430 seconds (155.77 k allocations: 7.990 MiB)
9079590132732747656880081324531330222983622187548672000

julia&gt; @time dim(YoungTableau(λ))
  0.000038 seconds (335 allocations: 10.734 KiB)
9079590132732747656880081324531330222983622187548672000

julia&gt; G = SymmetricGroup(sum(λ))
Full symmetric group over 78 elements

julia&gt; @time character(λ, one(G))
  0.000046 seconds (115 allocations: 16.391 KiB)
9079590132732747656880081324531330222983622187548672000

julia&gt; @time character(λ, one(G))
  0.001439 seconds (195 allocations: 24.453 KiB)
9079590132732747656880081324531330222983622187548672000</code></pre><h3 id="Low-level-functions-and-characters"><a class="docs-heading-anchor" href="#Low-level-functions-and-characters">Low-level functions and characters</a><a id="Low-level-functions-and-characters-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-functions-and-characters" title="Permalink"></a></h3><p>As mentioned above <code>character</code> functions use the Murnaghan-Nakayama rule for evaluation. The implementation follows</p><blockquote><p>Dan Bernstein, The computational complexity of rules for the character table of <span>$S_n$</span> <em>Journal of Symbolic Computation</em>, <strong>37</strong> (6), 2004, p. 727-748,</p></blockquote><p>implementing the following functions. For precise definitions and meaning please consult the paper cited.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.partitionseq" href="#AbstractAlgebra.Generic.partitionseq"><code>AbstractAlgebra.Generic.partitionseq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partitionseq(lambda::Partition)</code></pre><p>Return a sequence (as <code>BitVector</code>) of <code>false</code>s and <code>true</code>s constructed from <code>lambda</code>: tracing the lower contour of the Young Diagram associated to <code>lambda</code> from left to right a <code>true</code> is inserted for every horizontal and <code>false</code> for every vertical step. The sequence always starts with <code>true</code> and ends with <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L216-L224">source</a></section><section><div><pre><code class="language-julia hljs">partitionseq(seq::BitVector)</code></pre><p>Return the essential part of the sequence <code>seq</code>, i.e. a subsequence starting at first <code>true</code> and ending at last <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.is_rimhook-Tuple{BitVector, Int64, Int64}" href="#AbstractAlgebra.Generic.is_rimhook-Tuple{BitVector, Int64, Int64}"><code>AbstractAlgebra.Generic.is_rimhook</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_rimhook(R::BitVector, idx::Integer, len::Integer)</code></pre><p><code>R[idx:idx+len]</code> forms a rim hook in the Young Diagram of partition corresponding to <code>R</code> iff <code>R[idx] == true</code> and <code>R[idx+len] == false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.MN1inner" href="#AbstractAlgebra.Generic.MN1inner"><code>AbstractAlgebra.Generic.MN1inner</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MN1inner(R::BitVector, mu::Partition, t::Integer, charvals)</code></pre><p>Return the value of <span>$\lambda$</span>-th irreducible character on conjugacy class of permutations represented by partition <code>mu</code>, where <code>R</code> is the (binary) partition sequence representing <span>$\lambda$</span>. Values already computed are stored in <code>charvals::Dict{Tuple{BitVector,Vector{Int}}, Int}</code>. This is an implementation (with slight modifications) of the Murnaghan-Nakayama formula as described in</p><pre><code class="nohighlight hljs">Dan Bernstein,
&quot;The computational complexity of rules for the character table of Sn&quot;
_Journal of Symbolic Computation_, 37(6), 2004, p. 727-748.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L256-L269">source</a></section></article><h2 id="Skew-Diagrams"><a class="docs-heading-anchor" href="#Skew-Diagrams">Skew Diagrams</a><a id="Skew-Diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Skew-Diagrams" title="Permalink"></a></h2><p>Skew diagrams are formally differences of two Young diagrams. Given <span>$\lambda$</span> and <span>$\mu$</span>, two partitions of <span>$n+m$</span> and <span>$m$</span> (respectively). Suppose that each of cells of <span>$\mu$</span> is a cell of <span>$\lambda$</span> (i.e. parts of <span>$\mu$</span> are no greater than the corresponding parts of <span>$\lambda$</span>). Then the skew diagram denoted by <span>$\lambda/\mu$</span> is the set theoretic difference the of sets of boxes, i.e. is a diagram with exactly <span>$n$</span> boxes:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.SkewDiagram" href="#AbstractAlgebra.Generic.SkewDiagram"><code>AbstractAlgebra.Generic.SkewDiagram</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SkewDiagram(lambda::Partition, mu::Partition) &lt;: AbstractMatrix{Int}</code></pre><p>Implements a skew diagram, i.e. a difference of two Young diagrams represented by partitions <code>lambda</code> and <code>mu</code>. (below dots symbolise the removed entries)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; l = Partition([4,3,2])
4₁3₁2₁

julia&gt; m = Partition([3,1,1])
3₁1₂

julia&gt; xi = SkewDiagram(l,m)
3×4 AbstractAlgebra.Generic.SkewDiagram{Int64}:
 ⋅  ⋅  ⋅  1
 ⋅  1  1
 ⋅  1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/GenericTypes.jl#L159-L181">source</a></section></article><p><code>SkewDiagram</code> implements array interface with the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{AbstractAlgebra.Generic.SkewDiagram}" href="#Base.size-Tuple{AbstractAlgebra.Generic.SkewDiagram}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(xi::SkewDiagram)</code></pre><p>Return the size of array where <code>xi</code> is minimally contained. See <code>size(Y::YoungTableau)</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L750-L755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Tuple{Integer, Integer}, AbstractAlgebra.Generic.SkewDiagram}" href="#Base.in-Tuple{Tuple{Integer, Integer}, AbstractAlgebra.Generic.SkewDiagram}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">in(t::Tuple{Integer,Integer}, xi::SkewDiagram)</code></pre><p>Check if box at position <code>(i,j)</code> belongs to the skew diagram <code>xi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L760-L764">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractAlgebra.Generic.SkewDiagram, Integer}" href="#Base.getindex-Tuple{AbstractAlgebra.Generic.SkewDiagram, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(xi::SkewDiagram, n::Integer)</code></pre><p>Return <code>1</code> if linear index <code>n</code> corresponds to (column-major) entry in <code>xi.lam</code> which is not contained in <code>xi.mu</code>. Otherwise return <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L778-L783">source</a></section></article><p>The support for skew diagrams is very rudimentary. The following functions are available:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.is_rimhook-Tuple{AbstractAlgebra.Generic.SkewDiagram}" href="#AbstractAlgebra.Generic.is_rimhook-Tuple{AbstractAlgebra.Generic.SkewDiagram}"><code>AbstractAlgebra.Generic.is_rimhook</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_rimhook(xi::SkewDiagram)</code></pre><p>Check if <code>xi</code> represents a rim-hook diagram, i.e. its diagram is edge-connected and contains no <span>$2\times 2$</span> squares.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L858-L863">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.leglength" href="#AbstractAlgebra.Generic.leglength"><code>AbstractAlgebra.Generic.leglength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leglength(xi::SkewDiagram[, check::Bool=true])</code></pre><p>Compute the leglength of a rim-hook <code>xi</code>, i.e. the number of rows with non-zero entries minus one. If <code>check</code> is <code>false</code> function will not check whether <code>xi</code> is actually a rim-hook.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L891-L897">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.SkewDiagram}" href="#AbstractAlgebra.Generic.matrix_repr-Tuple{AbstractAlgebra.Generic.SkewDiagram}"><code>AbstractAlgebra.Generic.matrix_repr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_repr(xi::SkewDiagram)</code></pre><p>Return a sparse representation of the diagram <code>xi</code>, i.e. a sparse array <code>A</code> where <code>A[i,j] == 1</code> if and only if <code>(i,j)</code> is in <code>xi.lam</code> but not in <code>xi.mu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/3abc3d0e134fe8f94f7bb1d8cc2494f11be9f525/src/generic/YoungTabs.jl#L815-L820">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../perm/">« Permutations and Symmetric groups</a><a class="docs-footer-nextpage" href="../module_introduction/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Sunday 22 June 2025 03:40">Sunday 22 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
