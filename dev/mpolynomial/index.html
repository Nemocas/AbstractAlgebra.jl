<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse distributed multivariate polynomials · AbstractAlgebra.jl</title><meta name="title" content="Sparse distributed multivariate polynomials · AbstractAlgebra.jl"/><meta property="og:title" content="Sparse distributed multivariate polynomials · AbstractAlgebra.jl"/><meta property="twitter:title" content="Sparse distributed multivariate polynomials · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li class="is-active"><a class="tocitem" href>Sparse distributed multivariate polynomials</a><ul class="internal"><li><a class="tocitem" href="#Generic-sparse-distributed-multivariable-polynomial-types"><span>Generic sparse distributed multivariable polynomial types</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Polynomial-ring-constructors"><span>Polynomial ring constructors</span></a></li><li><a class="tocitem" href="#Polynomial-constructors"><span>Polynomial constructors</span></a></li><li><a class="tocitem" href="#Functions-for-types-and-parents-of-multivariate-polynomial-rings"><span>Functions for types and parents of multivariate polynomial rings</span></a></li><li><a class="tocitem" href="#Polynomial-functions"><span>Polynomial functions</span></a></li><li><a class="tocitem" href="#Random-generation"><span>Random generation</span></a></li></ul></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../ideal_interface/">Ideal Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href>Sparse distributed multivariate polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse distributed multivariate polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mpolynomial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-distributed-multivariate-polynomials"><a class="docs-heading-anchor" href="#Sparse-distributed-multivariate-polynomials">Sparse distributed multivariate polynomials</a><a id="Sparse-distributed-multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-distributed-multivariate-polynomials" title="Permalink"></a></h1><p>AbstractAlgebra.jl provides a module, implemented in <code>src/MPoly.jl</code> for sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.</p><h2 id="Generic-sparse-distributed-multivariable-polynomial-types"><a class="docs-heading-anchor" href="#Generic-sparse-distributed-multivariable-polynomial-types">Generic sparse distributed multivariable polynomial types</a><a id="Generic-sparse-distributed-multivariable-polynomial-types-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-sparse-distributed-multivariable-polynomial-types" title="Permalink"></a></h2><p>AbstractAlgebra provides a generic multivariate polynomial type <code>Generic.MPoly{T}</code> where <code>T</code> is the type of elements of the coefficient ring.</p><p>The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of <code>UInt</code>s for the exponent vectors. Note that exponent <span>$n$</span> is represented by the <span>$n$</span>-th column of the exponent array, not the <span>$n$</span>-th row. This is because Julia uses a column major representation. See the file <code>src/generic/GenericTypes.jl</code> for details.</p><p>The top bit of each <code>UInt</code> is reserved for overflow detection.</p><p>Parent objects of such polynomials have type <code>Generic.MPolyRing{T}</code>.</p><p>The string representation of the variables of the polynomial ring and the base/coefficient ring <span>$R$</span> and the ordering are stored in the parent object.</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>The polynomial element types belong to the abstract type <code>MPolyRingElem{T}</code> and the polynomial ring types belong to the abstract type <code>MPolyRing{T}</code>.</p><div class="admonition is-info" id="Note-1d99781a2c3f0f52"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1d99781a2c3f0f52" title="Permalink"></a></header><div class="admonition-body"><p>Note that both the generic polynomial ring type <code>Generic.MPolyRing{T}</code> and the abstract type it belongs to, <code>MPolyRing{T}</code> are both called <code>MPolyRing</code>. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type <code>T</code>. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).</p></div></div><h2 id="Polynomial-ring-constructors"><a class="docs-heading-anchor" href="#Polynomial-ring-constructors">Polynomial ring constructors</a><a id="Polynomial-ring-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-ring-constructors" title="Permalink"></a></h2><p>In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructors.</p><article><details class="docstring"><summary id="AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}"><a class="docstring-binding" href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}"><code>AbstractAlgebra.polynomial_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polynomial_ring(R::Ring, varnames::Vector{Symbol}; cached=true, internal_ordering=:lex)</code></pre><p>Given a coefficient ring <code>R</code> and variable names, say <code>varnames = [:x1, :x2, ...]</code>, return a tuple <code>S, [x1, x2, ...]</code> of the polynomial ring <span>$S = R[x1, x2, \dots]$</span> and its generators <span>$x1, x2, \dots$</span>.</p><p>By default (<code>cached=true</code>), the output <code>S</code> will be cached, i.e. if <code>polynomial_ring</code> is invoked again with the same arguments, the same (<em>identical</em>) ring is returned. Setting <code>cached</code> to <code>false</code> ensures a distinct new ring is returned, and will also prevent it from being cached.</p><p>The monomial ordering used for the internal storage of polynomials in <code>S</code> can be set with <code>internal_ordering</code> and must be one of <code>:lex</code>, <code>:deglex</code> or <code>:degrevlex</code>.</p><p>See also: <a href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}"><code>polynomial_ring(::Ring, ::Vararg)</code></a>, <a href="#AbstractAlgebra.@polynomial_ring"><code>@polynomial_ring</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, generators = polynomial_ring(ZZ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1590-L1613">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}"><a class="docstring-binding" href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}"><code>AbstractAlgebra.polynomial_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)
polynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)</code></pre><p>Like <a href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}"><code>polynomial_ring(::Ring, ::Vector{Symbol})</code></a> with more ways to give <code>varnames</code> as specified in <a href="../constructors/#AbstractAlgebra.variable_names"><code>variable_names</code></a>.</p><p>Return a tuple <code>S, generators...</code> with <code>generators[i]</code> corresponding to <code>varnames[i]</code>.</p><div class="admonition is-info" id="Note-4c60d5dc2dfca296"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4c60d5dc2dfca296" title="Permalink"></a></header><div class="admonition-body"><p>In the first method, <code>varnames</code> must not be empty, and if it consists of only one name, the univariate <a href="../ncpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{NCRing, Union{Char, AbstractString, Symbol}}"><code>polynomial_ring(R::NCRing, s::VarName)</code></a> method is called instead.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])

julia&gt; S, x, y = polynomial_ring(ZZ, :x =&gt; (1:2, 1:2), :y =&gt; 1:3);

julia&gt; S
Multivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]
  over integers

julia&gt; x
2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:
 x[1, 1]  x[1, 2]
 x[2, 1]  x[2, 2]

julia&gt; y
3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:
 y[1]
 y[2]
 y[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1621-L1658">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.polynomial_ring-Tuple{Ring, Int64}"><a class="docstring-binding" href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Int64}"><code>AbstractAlgebra.polynomial_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)
polynomial_ring(R::Ring, varnames::Tuple; cached=true, internal_ordering=:lex)</code></pre><p>Like <a href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}"><code>polynomial_ring(::Ring, ::Vector{Symbol})</code></a> with more ways to give <code>varnames</code> as specified in <a href="../constructors/#AbstractAlgebra.variable_names"><code>variable_names</code></a>.</p><p>Return a tuple <code>S, generators...</code> with <code>generators[i]</code> corresponding to <code>varnames[i]</code>.</p><div class="admonition is-info" id="Note-4c60d5dc2dfca296"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4c60d5dc2dfca296" title="Permalink"></a></header><div class="admonition-body"><p>In the first method, <code>varnames</code> must not be empty, and if it consists of only one name, the univariate <a href="../ncpolynomial/#AbstractAlgebra.polynomial_ring-Tuple{NCRing, Union{Char, AbstractString, Symbol}}"><code>polynomial_ring(R::NCRing, s::VarName)</code></a> method is called instead.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (a, b, c) = polynomial_ring(ZZ, [:a, :b, :c])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[a, b, c])

julia&gt; S, x, y = polynomial_ring(ZZ, :x =&gt; (1:2, 1:2), :y =&gt; 1:3);

julia&gt; S
Multivariate polynomial ring in 7 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., y[3]
  over integers

julia&gt; x
2×2 Matrix{AbstractAlgebra.Generic.MPoly{BigInt}}:
 x[1, 1]  x[1, 2]
 x[2, 1]  x[2, 2]

julia&gt; y
3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:
 y[1]
 y[2]
 y[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1621-L1658">source</a></section><section><div><pre><code class="language-julia hljs">polynomial_ring(R::Ring, n::Int, s::Symbol=:x; cached=true, internal_ordering=:lex)</code></pre><p>Same as <a href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vector{Symbol}}"><code>polynomial_ring(::Ring, [&quot;s$i&quot; for i in 1:n])</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, x = polynomial_ring(ZZ, 3)
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x1, x2, x3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1661-L1672">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.@polynomial_ring"><a class="docstring-binding" href="#AbstractAlgebra.@polynomial_ring"><code>AbstractAlgebra.@polynomial_ring</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@polynomial_ring(R::Ring, varnames...; cached=true, internal_ordering=:lex)</code></pre><p>Return polynomial ring from <a href="#AbstractAlgebra.polynomial_ring-Tuple{Ring, Vararg}"><code>polynomial_ring(::Ring, ::Vararg)</code></a> and introduce the generators into the current scope.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = @polynomial_ring(ZZ, &quot;x#&quot; =&gt; (1:2, 1:2), &quot;y#&quot; =&gt; 1:3)
Multivariate polynomial ring in 7 variables x11, x21, x12, x22, ..., y3
  over integers

julia&gt; x11, x21, x12, x22
(x11, x21, x12, x22)

julia&gt; y1, y2, y3
(y1, y2, y3)

julia&gt; (S, [x11 x12; x21 x22], [y1, y2, y3]) == polynomial_ring(ZZ, &quot;x#&quot; =&gt; (1:2, 1:2), &quot;y#&quot; =&gt; 1:3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1675-L1697">source</a></section></details></article><p>Like for univariate polynomials, a shorthand constructor is provided when the number of generators is greater than <code>1</code>: given a base ring <code>R</code>, we abbreviate the constructor as follows:</p><pre><code class="language-julia hljs">R[:x, :y, ...]</code></pre><p>In addition to that, it is also possible to construct univariate polynomial rings over other univariate polynomial rings in a similar fashion:</p><pre><code class="language-julia hljs">R[:x][:y]...</code></pre><p>Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y]; internal_ordering=:deglex)
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; T, (z, t) = QQ[:z, :t]
(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[z, t])

julia&gt; f = R()
0

julia&gt; g = R(123)
123

julia&gt; h = R(BigInt(1234))
1234

julia&gt; k = R(x + 1)
x + 1

julia&gt; m = R(x + y + 1)
x + y + 1

julia&gt; derivative(k, 1)
1

julia&gt; derivative(k, 2)
0

julia&gt; R, x = polynomial_ring(ZZ, 10); R
Multivariate polynomial ring in 10 variables x1, x2, x3, x4, ..., x10
  over integers

julia&gt; T, (z, t) = QQ[:z][:t]
(Univariate polynomial ring in t over univariate polynomial ring, AbstractAlgebra.Generic.Poly{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}[z, t])
</code></pre><h2 id="Polynomial-constructors"><a class="docs-heading-anchor" href="#Polynomial-constructors">Polynomial constructors</a><a id="Polynomial-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-constructors" title="Permalink"></a></h2><p>Multivariate polynomials can be constructed from the generators in the usual way using arithmetic operations.</p><p>Also, all of the standard ring element constructors may be used to construct multivariate polynomials.</p><pre><code class="language-julia hljs">(R::MPolyRing{T})() where T &lt;: RingElement
(R::MPolyRing{T})(c::Integer) where T &lt;: RingElement
(R::MPolyRing{T})(a::elem_type(R)) where T &lt;: RingElement
(R::MPolyRing{T})(a::T) where T &lt;: RingElement</code></pre><p>For more efficient construction of multivariate polynomial, one can use the <code>MPoly</code> build context, where terms (coefficient followed by an exponent vector) are pushed onto a context one at a time and then the polynomial constructed from those terms in one go using the <code>finish</code> function.</p><article><details class="docstring"><summary id="AbstractAlgebra.Generic.MPolyBuildCtx-Tuple{MPolyRing}"><a class="docstring-binding" href="#AbstractAlgebra.Generic.MPolyBuildCtx-Tuple{MPolyRing}"><code>AbstractAlgebra.Generic.MPolyBuildCtx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MPolyBuildCtx(R::MPolyRing)</code></pre><p>Return a build context for creating polynomials in the given ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L3792-L3796">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.Generic.push_term!-Tuple{MPolyBuildCtx, RingElem, Vector{Int64}}"><a class="docstring-binding" href="#AbstractAlgebra.Generic.push_term!-Tuple{MPolyBuildCtx, RingElem, Vector{Int64}}"><code>AbstractAlgebra.Generic.push_term!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})</code></pre><p>Add the term with coefficient <code>c</code> and exponent vector <code>v</code> to the polynomial under construction in the build context <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L3806-L3811">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.Generic.finish-Tuple{MPolyBuildCtx}"><a class="docstring-binding" href="#AbstractAlgebra.Generic.finish-Tuple{MPolyBuildCtx}"><code>AbstractAlgebra.Generic.finish</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">finish(M::MPolyBuildCtx)</code></pre><p>Finish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L3829-L3834">source</a></section></details></article><p>Note that the <code>finish</code> function resets the build context so that it can be used to construct multiple polynomials..</p><p>When a multivariate polynomial type has a representation that allows constant time access (e.g. it is represented internally by arrays), the following additional constructor is available. It takes and array of coefficients and and array of exponent vectors.</p><pre><code class="language-julia hljs">(S::MPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T &lt;: RingElem</code></pre><p>Create the polynomial in the given ring with nonzero coefficients specified by the elements of <span>$A$</span> and corresponding exponent vectors given by the elements of <span>$m$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; C = MPolyBuildCtx(R)
Builder for an element of R

julia&gt; push_term!(C, ZZ(3), [1, 2]);


julia&gt; push_term!(C, ZZ(2), [1, 1]);


julia&gt; push_term!(C, ZZ(4), [0, 0]);


julia&gt; f = finish(C)
3*x*y^2 + 2*x*y + 4

julia&gt; push_term!(C, ZZ(4), [1, 1]);


julia&gt; f = finish(C)
4*x*y

julia&gt; S, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])

julia&gt; f = S(Rational{BigInt}[2, 3, 1], [[3, 2], [1, 0], [0, 1]])
2*x^3*y^2 + 3*x + y</code></pre><h2 id="Functions-for-types-and-parents-of-multivariate-polynomial-rings"><a class="docs-heading-anchor" href="#Functions-for-types-and-parents-of-multivariate-polynomial-rings">Functions for types and parents of multivariate polynomial rings</a><a id="Functions-for-types-and-parents-of-multivariate-polynomial-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-types-and-parents-of-multivariate-polynomial-rings" title="Permalink"></a></h2><pre><code class="language-julia hljs">base_ring(R::MPolyRing)
base_ring(a::MPolyRingElem)</code></pre><p>Return the coefficient ring of the given polynomial ring or polynomial, respectively.</p><pre><code class="language-julia hljs">parent(a::MPolyRingElem)</code></pre><p>Return the polynomial ring of the given polynomial.</p><h2 id="Polynomial-functions"><a class="docs-heading-anchor" href="#Polynomial-functions">Polynomial functions</a><a id="Polynomial-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-functions" title="Permalink"></a></h2><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><p>All the standard ring functions are available, including the following.</p><pre><code class="language-julia hljs">zero(R::MPolyRing)
one(R::MPolyRing)
iszero(a::MPolyRingElem)
isone(a::MPolyRingElem)</code></pre><pre><code class="nohighlight hljs">divexact(a::T, b::T) where T &lt;: MPolyRingElem</code></pre><p>All basic functions from the Multivariate Polynomial interface are provided.</p><pre><code class="language-julia hljs">symbols(S::MPolyRing)
number_of_variables(f::MPolyRing)
gens(S::MPolyRing)
gen(S::MPolyRing, i::Int)</code></pre><pre><code class="language-julia hljs">internal_ordering(S::MPolyRing{T})</code></pre><p>Note that the currently supported orderings are <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code>.</p><pre><code class="language-julia hljs">length(f::MPolyRingElem)
degrees(f::MPolyRingElem)
total_degree(f::MPolyRingElem)</code></pre><pre><code class="language-julia hljs">is_gen(x::MPolyRingElem)</code></pre><pre><code class="language-julia hljs">divexact(f::T, g::T) where T &lt;: MPolyRingElem</code></pre><p>For multivariate polynomial types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.</p><pre><code class="language-julia hljs">coeff(f::MPolyRingElem, n::Int)
coeff(a::MPolyRingElem, exps::Vector{Int})</code></pre><p>Access a coefficient by term number or exponent vector.</p><pre><code class="language-julia hljs">monomial(f::MPolyRingElem, n::Int)
monomial!(m::T, f::T, n::Int) where T &lt;: MPolyRingElem</code></pre><p>The second version writes the result into a preexisting polynomial object to save an allocation.</p><pre><code class="language-julia hljs">term(f::MPolyRingElem, n::Int)</code></pre><pre><code class="language-julia hljs">exponent(f::MyMPolyRingElem, i::Int, j::Int)</code></pre><p>Return the exponent of the <span>$j$</span>-th variable in the <span>$i$</span>-th term of the polynomial <span>$f$</span>.</p><pre><code class="language-julia hljs">exponent_vector(a::MPolyRingElem, i::Int)</code></pre><pre><code class="language-julia hljs">setcoeff!(a::MPolyRingElem{T}, exps::Vector{Int}, c::T) where T &lt;: RingElement</code></pre><p>Although multivariate polynomial rings are not usually Euclidean, the following functions from the Euclidean interface are often provided.</p><pre><code class="language-julia hljs">divides(f::T, g::T) where T &lt;: MPolyRingElem
remove(f::T, g::T) where T &lt;: MPolyRingElem
valuation(f::T, g::T) where T &lt;: MPolyRingElem</code></pre><pre><code class="language-julia hljs">divrem(f::T, g::T) where T &lt;: MPolyRingElem
div(f::T, g::T) where T &lt;: MPolyRingElem</code></pre><p>Compute a tuple <span>$(q, r)$</span> such that <span>$f = qg + r$</span>, where the coefficients of terms of <span>$r$</span> whose monomials are divisible by the leading monomial of <span>$g$</span> are reduced modulo the leading coefficient of <span>$g$</span> (according to the Euclidean function on the coefficients). The <code>divrem</code> version returns both quotient and remainder whilst the <code>div</code> version only returns the quotient.</p><p>Note that the result of these functions depend on the ordering of the polynomial ring.</p><pre><code class="language-julia hljs">gcd(f::T, g::T) where T &lt;: MPolyRingElem</code></pre><p>The following functionality is also provided for all multivariate polynomials.</p><article><details class="docstring"><summary id="AbstractAlgebra.is_univariate-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_univariate-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_univariate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_univariate(R::MPolyRing)</code></pre><p>Returns <code>true</code> if <span>$R$</span> is a univariate polynomial ring, i.e. has exactly one variable, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1271-L1276">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.var_indices-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.var_indices-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.var_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_indices(p::MPolyRingElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the indices of the variables actually occurring in <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L93-L97">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.vars-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.vars-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.vars</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vars(p::MPolyRingElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the variables actually occurring in <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L106-L110">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.var_index-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.var_index-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.var_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_index(x::MPolyRingElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the index of the given variable <span>$x$</span>. If <span>$x$</span> is not a variable in a multivariate polynomial ring, an exception is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L116-L121">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Int64}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Int64}} where T&lt;:RingElement"><code>AbstractAlgebra.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(f::MPolyRingElem{T}, i::Int) where T &lt;: RingElement</code></pre><p>Return the degree of the polynomial <span>$f$</span> in terms of the i-th variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L362-L366">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.degree-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Return the degree of the polynomial <span>$f$</span> in terms of the variable <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L384-L388">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.degrees-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.degrees-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.degrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degrees(f::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Return an array of the degrees of the polynomial <span>$f$</span> in terms of each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L393-L397">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_constant-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_constant-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_constant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_constant(x::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Return <code>true</code> if <code>x</code> is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L473-L478">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_term(x::MPolyRingElem)</code></pre><p>Return <code>true</code> if the given polynomial has precisely one term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L484-L488">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_monomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_monomial(x::MPolyRingElem)</code></pre><p>Return <code>true</code> if the given polynomial has precisely one term whose coefficient is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L491-L495">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.is_univariate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.is_univariate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.is_univariate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_univariate(p::MPolyRingElem)</code></pre><p>Returns <code>true</code> if <span>$p$</span> is a univariate polynomial, i.e. involves at most one variable (thus constant polynomials are considered univariate), and <code>false</code> otherwise. The result depends on the terms of the polynomial, not simply on the number of variables in the polynomial ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1259-L1266">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.coeff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff(f::MPolyRingElem{T}, m::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Return the coefficient of the monomial <span>$m$</span> of the polynomial <span>$f$</span>. If there is no such monomial, zero is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L241-L246">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x^2 + 2x + 1
x^2 + 2*x + 1

julia&gt; V = vars(f)
1-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:
 x

julia&gt; var_index(y) == 2
true

julia&gt; degree(f, x) == 2
true

julia&gt; degree(f, 2) == 0
true

julia&gt; d = degrees(f)
2-element Vector{Int64}:
 2
 0

julia&gt; is_constant(R(1))
true

julia&gt; is_term(2x)
true

julia&gt; is_monomial(y)
true

julia&gt; is_unit(R(1))
true

julia&gt; S, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x^3*y + 3x*y^2 + 1
x^3*y + 3*x*y^2 + 1

julia&gt; c1 = coeff(f, 1)
1

julia&gt; c2 = coeff(f, x^3*y)
1

julia&gt; m = monomial(f, 2)
x*y^2

julia&gt; e1 = exponent(f, 1, 1)
3

julia&gt; v1 = exponent_vector(f, 1)
2-element Vector{Int64}:
 3
 1

julia&gt; t1 = term(f, 1)
x^3*y

julia&gt; setcoeff!(f, [3, 1], 12)
12*x^3*y + 3*x*y^2 + 1

julia&gt; S, (x, y) = polynomial_ring(QQ, [:x, :y]; internal_ordering=:deglex)
(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])

julia&gt; V = symbols(S)
2-element Vector{Symbol}:
 :x
 :y

julia&gt; X = gens(S)
2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x
 y

julia&gt; ord = internal_ordering(S)
:deglex

julia&gt; S, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x^3*y + 3x*y^2 + 1
x^3*y + 3*x*y^2 + 1

julia&gt; n = length(f)
3

julia&gt; is_gen(y)
true

julia&gt; number_of_variables(S) == 2
true

julia&gt; d = total_degree(f)
4

julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = 2x^2*y + 2x + y + 1
2*x^2*y + 2*x + y + 1

julia&gt; g = x^2*y^2 + 1
x^2*y^2 + 1

julia&gt; flag, q = divides(f*g, f)
(true, x^2*y^2 + 1)

julia&gt; d = divexact(f*g, f)
x^2*y^2 + 1

julia&gt; v, q = remove(f*g^3, g)
(3, 2*x^2*y + 2*x + y + 1)

julia&gt; n = valuation(f*g^3, g)
3

julia&gt; R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])

julia&gt; f = 3x^2*y^2 + 2x + 1
3*x^2*y^2 + 2*x + 1

julia&gt; f1 = divexact(f, 5)
3//5*x^2*y^2 + 2//5*x + 1//5

julia&gt; f2 = divexact(f, QQ(2, 3))
9//2*x^2*y^2 + 3*x + 3//2</code></pre><h3 id="Square-root"><a class="docs-heading-anchor" href="#Square-root">Square root</a><a id="Square-root-1"></a><a class="docs-heading-anchor-permalink" href="#Square-root" title="Permalink"></a></h3><p>Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.</p><pre><code class="language-julia hljs">sqrt(f::MPolyRingElem, check::Bool=true)
is_square(::MPolyRingElem)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = -4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4
-4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4

julia&gt; sqrt(f^2)
4*x^5*y^4 - 5*x^5*y^3 - 4*x^4 + x^3*y^4

julia&gt; is_square(f)
false</code></pre><h3 id="Iterators"><a class="docs-heading-anchor" href="#Iterators">Iterators</a><a id="Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators" title="Permalink"></a></h3><p>The following iterators are provided for multivariate polynomials.</p><pre><code class="language-julia hljs">coefficients(p::MPoly)
monomials(p::MPoly)
terms(p::MPoly)
exponent_vectors(a::MPoly)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x^3*y + 3x*y^2 + 1
x^3*y + 3*x*y^2 + 1

julia&gt; C = collect(coefficients(f))
3-element Vector{BigInt}:
 1
 3
 1

julia&gt; M = collect(monomials(f))
3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:
 x^3*y
 x*y^2
 1

julia&gt; T = collect(terms(f))
3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:
 x^3*y
 3*x*y^2
 1

julia&gt; V = collect(exponent_vectors(f))
3-element Vector{Vector{Int64}}:
 [3, 1]
 [1, 2]
 [0, 0]</code></pre><h3 id="Changing-base-(coefficient)-rings"><a class="docs-heading-anchor" href="#Changing-base-(coefficient)-rings">Changing base (coefficient) rings</a><a id="Changing-base-(coefficient)-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-base-(coefficient)-rings" title="Permalink"></a></h3><p>In order to substitute the variables of a polynomial <span>$f$</span> over a ring <span>$T$</span> by elements in a <span>$T$</span>-algebra <span>$S$</span>, you first have to change the base ring of <span>$f$</span> using the following function, where <span>$g$</span> is a function representing the structure homomorphism of the <span>$T$</span>-algebra <span>$S$</span>.</p><article><details class="docstring"><summary id="AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.change_base_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.change_base_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_base_ring(R::Ring, p::MPolyRingElem{&lt;: RingElement}; parent::MPolyRing, cached::Bool=true)</code></pre><p>Return the polynomial obtained by coercing the non-zero coefficients of <code>p</code> into <code>R</code>.</p><p>If the optional <code>parent</code> keyword is provided, the polynomial will be an element of <code>parent</code>. The caching of the parent object can be controlled via the <code>cached</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1386-L1395">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.change_coefficient_ring-Union{Tuple{T}, Tuple{Ring, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.change_coefficient_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_coefficient_ring(R::Ring, p::MPolyRingElem{&lt;: RingElement}; parent::MPolyRing, cached::Bool=true)</code></pre><p>Return the polynomial obtained by coercing the non-zero coefficients of <code>p</code> into <code>R</code>.</p><p>If the optional <code>parent</code> keyword is provided, the polynomial will be an element of <code>parent</code>. The caching of the parent object can be controlled via the <code>cached</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1401-L1410">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.map_coefficients-Tuple{Any, MPolyRingElem}"><a class="docstring-binding" href="#AbstractAlgebra.map_coefficients-Tuple{Any, MPolyRingElem}"><code>AbstractAlgebra.map_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">map_coefficients(f, p::MPolyRingElem{&lt;: RingElement}; parent::MPolyRing)</code></pre><p>Transform the polynomial <code>p</code> by applying <code>f</code> on each non-zero coefficient.</p><p>If the optional <code>parent</code> keyword is provided, the polynomial will be an element of <code>parent</code>. The caching of the parent object can be controlled via the <code>cached</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1421-L1429">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; fz = x^2*y^2 + x + 1
x^2*y^2 + x + 1

julia&gt; fq = change_base_ring(QQ, fz)
x^2*y^2 + x + 1

julia&gt; fq = change_coefficient_ring(QQ, fz)
x^2*y^2 + x + 1
</code></pre><p>In case a specific parent ring is constructed, it can also be passed to the function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; S,  = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])

julia&gt; fz = x^5 + y^3 + 1
x^5 + y^3 + 1

julia&gt; fq = change_base_ring(QQ, fz, parent=S)
x^5 + y^3 + 1</code></pre><h3 id="Multivariate-coefficients"><a class="docs-heading-anchor" href="#Multivariate-coefficients">Multivariate coefficients</a><a id="Multivariate-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-coefficients" title="Permalink"></a></h3><p>In order to return the &quot;coefficient&quot; (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.</p><article><details class="docstring"><summary id="AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><code>AbstractAlgebra.coeff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff(a::MPolyRingElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return the &quot;coefficient&quot; of <span>$a$</span> (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. <code>coeff(f, [1, 3], [0, 2])</code> returns the coefficient of <span>$x^0*z^2$</span> in the polynomial <span>$f$</span> (assuming variables <span>$x, y, z$</span> in that order).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L157-L166">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}}} where T&lt;:MPolyRingElem"><a class="docstring-binding" href="#AbstractAlgebra.coeff-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}}} where T&lt;:MPolyRingElem"><code>AbstractAlgebra.coeff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T &lt;: MPolyRingElem</code></pre><p>Return the &quot;coefficient&quot; of <span>$a$</span> (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. <code>coeff(f, [x, z], [0, 2])</code> returns the coefficient of <span>$x^0*z^2$</span> in the polynomial <span>$f$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L194-L202">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])

julia&gt; f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1
x^4*y^2*z^2 - 2*x^4*y*z^2 + 4*x^4*z^2 + 2*x^2*y^2 + x + 1

julia&gt; coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])
true
</code></pre><h3 id="Inflation/deflation"><a class="docs-heading-anchor" href="#Inflation/deflation">Inflation/deflation</a><a id="Inflation/deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Inflation/deflation" title="Permalink"></a></h3><article><details class="docstring"><summary id="AbstractAlgebra.deflation-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.deflation-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.deflation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflation(f::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Compute deflation parameters for the exponents of the polynomial <span>$f$</span>. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L673-L682">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><code>AbstractAlgebra.deflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been reduced by the given shifts (supplied as an array of shifts, one for each variable), then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of <span>$0$</span> by <span>$1$</span>, to avoid division by <span>$0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L704-L713">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T&lt;:RingElement"><code>AbstractAlgebra.deflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been deflated (divided) by the given exponents (supplied as an array of deflation factors, one for each variable).</p><p>The algorithm automatically replaces a deflation of <span>$0$</span> by <span>$1$</span>, to avoid division by <span>$0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L733-L742">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.deflate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.deflate-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.deflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been deflated maximally, i.e. with each exponent divide by the largest integer which divides the degrees of all exponents of that variable in <span>$f$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L747-L753">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.deflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#AbstractAlgebra.deflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>AbstractAlgebra.deflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but where exponents of some variables (supplied as an array of variable indices) have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of <span>$0$</span> by <span>$1$</span>, to avoid division by <span>$0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L773-L782">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:MPolyRingElem"><a class="docstring-binding" href="#AbstractAlgebra.deflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:MPolyRingElem"><code>AbstractAlgebra.deflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T &lt;: MPolyRingElem</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but where the exponents of the given variables have been reduced by the given shifts (supplied as an array of shifts), then deflated (divided) by the given exponents (again supplied as an array of deflation factors). The algorithm automatically replaces a deflation of <span>$0$</span> by <span>$1$</span>, to avoid division by <span>$0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L788-L796">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:RingElement"><code>AbstractAlgebra.inflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inflate(f::MPolyRingElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then increased by the given shifts (again supplied as an array of shifts, one for each variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L803-L811">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}}} where T&lt;:RingElement"><code>AbstractAlgebra.inflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inflate(f::MPolyRingElem{T}, defl::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L826-L832">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.inflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#AbstractAlgebra.inflate-Tuple{MPolyRingElem, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>AbstractAlgebra.inflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inflate(f::MPolyRingElem, vars::Vector{Int}, shift::Vector{Int}, defl::Vector{Int})</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but where exponents of some variables (supplied as an array of variable indices) have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L837-L845">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:MPolyRingElem"><a class="docstring-binding" href="#AbstractAlgebra.inflate-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}, Vector{Int64}}} where T&lt;:MPolyRingElem"><code>AbstractAlgebra.inflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inflate(f::T, vars::Vector{T}, shift::Vector{Int}, defl::Vector{Int}) where T &lt;: MPolyRingElem</code></pre><p>Return a polynomial with the same coefficients as <span>$f$</span> but where the exponents of the given variables have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors) and then increased by the given shifts (again supplied as an array of shifts).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L851-L858">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2
x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2

julia&gt; def, shift = deflation(f)
([1, 2], [3, 3])

julia&gt; f1 = deflate(f, def, shift)
x^2*y^2 + 3*x*y^2 - x + 5*y - 1

julia&gt; f2 = inflate(f1, def, shift)
x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2

julia&gt; f2 == f
true

julia&gt; g = (x+y+1)^2
x^2 + 2*x*y + 2*x + y^2 + 2*y + 1

julia&gt; g0 = coeff(g, [y], [0])
x^2 + 2*x + 1

julia&gt; g1 = deflate(g - g0, [y], [1], [1])
2*x + y + 2

julia&gt; g == g0 + y * g1
true
</code></pre><h3 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h3><article><details class="docstring"><summary id="AbstractAlgebra.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.to_univariate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_univariate(R::PolyRing{T}, p::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Assuming the polynomial <span>$p$</span> is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring <span>$R$</span>. An exception is raised if the polynomial <span>$p$</span> involves more than one variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1190-L1197">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; S, z = polynomial_ring(ZZ, :z)
(Univariate polynomial ring in z over integers, z)

julia&gt; f = 2x^5 + 3x^4 - 2x^2 - 1
2*x^5 + 3*x^4 - 2*x^2 - 1

julia&gt; g = to_univariate(S, f)
2*z^5 + 3*z^4 - 2*z^2 - 1
</code></pre><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><p>The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.</p><article><details class="docstring"><summary id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T&lt;:RingElement, U&lt;:RingElement}"><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T&lt;:RingElement, U&lt;:RingElement}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><p>Evaluate the polynomial expression by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of the supplied vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L926-L933">source</a></section></details></article><p>The following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.</p><article><details class="docstring"><summary id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:RingElement}"><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:RingElement}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate(a::MPolyRingElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><p>Evaluate the polynomial expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables with indices given by the array <code>vars</code>. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of <code>vals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L984-L991">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S, Vector{S}, Vector{U}}} where {T&lt;:RingElement, S&lt;:MPolyRingElem{T}, U&lt;:RingElement}"><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S, Vector{S}, Vector{U}}} where {T&lt;:RingElement, S&lt;:MPolyRingElem{T}, U&lt;:RingElement}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S &lt;: MPolyRingElem{T}, U &lt;: RingElement} where T &lt;: RingElement</code></pre><p>Evaluate the polynomial expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables (supplied as polynomials) given by the array <code>vars</code>. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of <code>vals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1108-L1115">source</a></section></details></article><p>The following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.</p><article><details class="docstring"><summary id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T&lt;:RingElement, U&lt;:NCRingElem}"><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyRingElem{T}, Vector{U}}} where {T&lt;:RingElement, U&lt;:NCRingElem}"><code>AbstractAlgebra.evaluate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate(a::MPolyRingElem{T}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: NCRingElem}</code></pre><p>Evaluate the polynomial expression at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which <span>$a$</span> belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1121-L1129">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = 2x^2*y^2 + 3x + y + 1
2*x^2*y^2 + 3*x + y + 1

julia&gt; evaluate(f, BigInt[1, 2])
14

julia&gt; evaluate(f, [QQ(1), QQ(2)])
14//1

julia&gt; evaluate(f, [1, 2])
14

julia&gt; f(1, 2) == 14
true

julia&gt; evaluate(f, [x + y, 2y - x])
2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1

julia&gt; f(x + y, 2y - x)
2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1

julia&gt; R, (x, y, z) = polynomial_ring(ZZ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])

julia&gt; f = x^2*y^2 + 2x*z + 3y*z + z + 1
x^2*y^2 + 2*x*z + 3*y*z + z + 1

julia&gt; evaluate(f, [1, 3], [3, 4])
9*y^2 + 12*y + 29

julia&gt; evaluate(f, [x, z], [3, 4])
9*y^2 + 12*y + 29

julia&gt; evaluate(f, [1, 2], [x + z, x - z])
x^4 - 2*x^2*z^2 + 5*x*z + z^4 - z^2 + z + 1

julia&gt; S = matrix_ring(ZZ, 2)
Matrix ring of degree 2
  over integers

julia&gt; M1 = S([1 2; 3 4])
[1   2]
[3   4]

julia&gt; M2 = S([2 3; 1 -1])
[2    3]
[1   -1]

julia&gt; M3 = S([-1 1; 1 1])
[-1   1]
[ 1   1]

julia&gt; evaluate(f, [M1, M2, M3])
[ 64    83]
[124   149]</code></pre><h3 id="Leading-and-constant-coefficients,-leading-monomials-and-leading-terms"><a class="docs-heading-anchor" href="#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms">Leading and constant coefficients, leading monomials and leading terms</a><a id="Leading-and-constant-coefficients,-leading-monomials-and-leading-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms" title="Permalink"></a></h3><p>The leading and trailing coefficient, constant coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:</p><article><details class="docstring"><summary id="AbstractAlgebra.leading_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.leading_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.leading_coefficient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_coefficient(p::MPolyRingElem)</code></pre><p>Return the leading coefficient of the polynomial <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L259-L263">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.trailing_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.trailing_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.trailing_coefficient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trailing_coefficient(p::MPolyRingElem)</code></pre><p>Return the trailing coefficient of the polynomial <span>$p$</span>, i.e. the coefficient of the last nonzero term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L269-L274">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.leading_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.leading_monomial-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.leading_monomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_monomial(p::MPolyRingElem)</code></pre><p>Return the leading monomial of <span>$p$</span>. This function throws an <code>ArgumentError</code> if <span>$p$</span> is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L328-L333">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.leading_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.leading_term-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.leading_term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_term(p::MPolyRingElem)</code></pre><p>Return the leading term of the polynomial p. This function throws an <code>ArgumentError</code> if <span>$p$</span> is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L351-L356">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.constant_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.constant_coefficient-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.constant_coefficient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">constant_coefficient(p::MPolyRingElem)</code></pre><p>Return the constant coefficient of the polynomial <span>$p$</span> or zero if it doesn&#39;t have one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L303-L308">source</a></section></details></article><article><details class="docstring"><summary id="AbstractAlgebra.tail-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.tail-Union{Tuple{MPolyRingElem{T}}, Tuple{T}} where T&lt;:RingElement"><code>AbstractAlgebra.tail</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tail(p::MPolyRingElem)</code></pre><p>Return the tail of the polynomial <span>$p$</span>, i.e. the polynomial without its leading term (if any).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L284-L289">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbstractAlgebra
R,(x,y) = polynomial_ring(ZZ, [:x, :y], internal_ordering=:deglex)
p = 2*x*y + 3*y^3 + 1
leading_term(p)
leading_monomial(p)
leading_coefficient(p)
leading_term(p) == leading_coefficient(p) * leading_monomial(p)
constant_coefficient(p)
tail(p)</code></pre><h3 id="Least-common-multiple,-greatest-common-divisor"><a class="docs-heading-anchor" href="#Least-common-multiple,-greatest-common-divisor">Least common multiple, greatest common divisor</a><a id="Least-common-multiple,-greatest-common-divisor-1"></a><a class="docs-heading-anchor-permalink" href="#Least-common-multiple,-greatest-common-divisor" title="Permalink"></a></h3><p>The greatest common divisor of two polynomials a and b is returned by</p><article><details class="docstring"><summary id="Base.gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T}, AbstractAlgebra.Generic.MPoly{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#Base.gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T}, AbstractAlgebra.Generic.MPoly{T}}} where T&lt;:RingElement"><code>Base.gcd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gcd(a::MPoly{T}, a::MPoly{T}) where {T &lt;: RingElement}</code></pre><p>Return the greatest common divisor of a and b in parent(a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L3379-L3383">source</a></section></details></article><p>Note that this functionality is currently only provided for AbstractAlgebra generic polynomials. It is not automatically provided for all multivariate rings that implement the multivariate interface.</p><p>However, if such a gcd is provided, the least common multiple of two polynomials a and b is returned by</p><article><details class="docstring"><summary id="Base.lcm-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#Base.lcm-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lcm(a::AbstractAlgebra.MPolyRingElem{T}, a::AbstractAlgebra.MPolyRingElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the least common multiple of a and b in parent(a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L3490-L3494">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using AbstractAlgebra

julia&gt; R,(x,y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; a = x*y + 2*y
x*y + 2*y

julia&gt; b = x^3*y + y
x^3*y + y

julia&gt; gcd(a,b)
y

julia&gt; lcm(a,b)
x^4*y + 2*x^3*y + x*y + 2*y

julia&gt; lcm(a,b) == a * b // gcd(a,b)
true
</code></pre><h3 id="Derivations"><a class="docs-heading-anchor" href="#Derivations">Derivations</a><a id="Derivations-1"></a><a class="docs-heading-anchor-permalink" href="#Derivations" title="Permalink"></a></h3><article><details class="docstring"><summary id="AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><a class="docstring-binding" href="#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{MPolyRingElem{T}, MPolyRingElem{T}}} where T&lt;:RingElement"><code>AbstractAlgebra.derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">derivative(f::MPolyRingElem{T}, x::MPolyRingElem{T}) where T &lt;: RingElement</code></pre><p>Return the partial derivative of <code>f</code> with respect to <code>x</code>. The value <code>x</code> must be a generator of the polynomial ring of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/MPoly.jl#L1173-L1178">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = AbstractAlgebra.polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = x*y + x + y + 1
x*y + x + y + 1

julia&gt; derivative(f, x)
y + 1

julia&gt; derivative(f, y)
x + 1

julia&gt; derivative(f, 1)
y + 1

julia&gt; derivative(f, 2)
x + 1</code></pre><h3 id="Homogeneous-polynomials"><a class="docs-heading-anchor" href="#Homogeneous-polynomials">Homogeneous polynomials</a><a id="Homogeneous-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Homogeneous-polynomials" title="Permalink"></a></h3><article><details class="docstring"><summary id="AbstractAlgebra.Generic.is_homogeneous-Tuple{MPolyRingElem}"><a class="docstring-binding" href="#AbstractAlgebra.Generic.is_homogeneous-Tuple{MPolyRingElem}"><code>AbstractAlgebra.Generic.is_homogeneous</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_homogeneous(x::MPolyRingElem)</code></pre><p>Return <code>true</code> if the given polynomial is homogeneous with respect to the standard grading and <code>false</code> otherwise. Here by standard grading we mean that all variables of the polynomial ring are graded with weight 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4b29ea3e6f309d7a4b326d520f9ba3694c455154/src/generic/MPoly.jl#L626-L632">source</a></section></details></article><h2 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h2><p>Random multivariate polynomials in a given ring can be constructed by passing a range of degrees for the variables and a range on the number of terms. Additional parameters are used to generate the coefficients of the polynomial.</p><p>Note that zero coefficients may currently be generated, leading to less than the requested number of terms.</p><pre><code class="language-julia hljs">rand(R::MPolyRing, exp_range::AbstractUnitRange{Int}, term_range::AbstractUnitRange{Int}, v...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [:x, :y])
(Multivariate polynomial ring in 2 variables over integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])

julia&gt; f = rand(R, -1:2, 3:5, -10:10)
4*x^4*y^4

julia&gt; S, (s, t) = polynomial_ring(GF(7), [:x, :y])
(Multivariate polynomial ring in 2 variables over finite field F_7, AbstractAlgebra.Generic.MPoly{AbstractAlgebra.GFElem{Int64}}[x, y])

julia&gt; g = rand(S, -1:2, 3:5)
4*x^3*y^4</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ncpolynomial/">« Univariate polynomials over a noncommutative ring</a><a class="docs-footer-nextpage" href="../univpolynomial/">Universal polynomial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 03:44">Saturday 24 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
