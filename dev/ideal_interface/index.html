<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideal Interface · AbstractAlgebra.jl</title><meta name="title" content="Ideal Interface · AbstractAlgebra.jl"/><meta property="og:title" content="Ideal Interface · AbstractAlgebra.jl"/><meta property="twitter:title" content="Ideal Interface · AbstractAlgebra.jl"/><meta name="description" content="Documentation for AbstractAlgebra.jl."/><meta property="og:description" content="Documentation for AbstractAlgebra.jl."/><meta property="twitter:description" content="Documentation for AbstractAlgebra.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../total_fraction/">Total ring of fractions</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_spaces/">Matrix Spaces</a></li><li><a class="tocitem" href="../matrix_implementation/">Matrix implementation</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../assertions/">Assertion and Verbosity Macros</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li class="is-active"><a class="tocitem" href>Ideal Interface</a><ul class="internal"><li><a class="tocitem" href="#Types-and-parents"><span>Types and parents</span></a></li><li><a class="tocitem" href="#Required-functionality-for-ideals"><span>Required functionality for ideals</span></a></li><li><a class="tocitem" href="#Optional-functionality-for-ideals"><span>Optional functionality for ideals</span></a></li></ul></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li><li><a class="tocitem" href="../linear_solving/">Linear solving</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>Ideal Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideal Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ideal_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideal-Interface"><a class="docs-heading-anchor" href="#Ideal-Interface">Ideal Interface</a><a id="Ideal-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Interface" title="Permalink"></a></h1><p>AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented by anyone implementing ideals for commutative rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their ideals. There are already many helper methods in AbstractAlgebra.jl for the methods mentioned below.</p><p>In addition to the required functions, there are also optional functions which can be provided for certain types of ideals e.g., for ideals of polynomial rings. If implemented, these allow the generic code to provide additional functionality for those ideals, or in some cases, to select more efficient algorithms.</p><h2 id="Types-and-parents"><a class="docs-heading-anchor" href="#Types-and-parents">Types and parents</a><a id="Types-and-parents-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-parents" title="Permalink"></a></h2><p>Below we describe this interface for a fictitious type <code>NewIdeal</code> representing ideals over a base ring of type <code>NewRing</code>, with element type <code>NewRingElem</code>. To make use of the functionality described on this page, <code>NewIdeal</code> must be a subtype of <code>Ideal{NewRingElem}</code>. To inform the system about this relationship, it is necessary to provide the following method:</p><pre><code class="language-julia hljs">ideal_type(::Type{NewRing}) = NewIdeal</code></pre><p>julia The system automatically provides the following reverse method:</p><pre><code class="nohighlight hljs">base_ring_type(::Type{NewIdeal}) = NewRing</code></pre><p>For ideals of a Euclidean domain, it may also be possibly to opt into using the existing functionality  which is implemented in <code>src/generic/Ideal.jl</code>. In that case you would essentially defined <code>const NewIdeal = Generic.Ideal{NewRingElem}</code>. For more information about implementing new rings, see the <a href="../ring_interface/#Ring-Interface">Ring interface</a>.</p><h2 id="Required-functionality-for-ideals"><a class="docs-heading-anchor" href="#Required-functionality-for-ideals">Required functionality for ideals</a><a id="Required-functionality-for-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-ideals" title="Permalink"></a></h2><p>In the following, we list all the functions that are required to be provided for ideals in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.</p><p>To facilitate construction of new ideals, implementations must provide a method with signature</p><pre><code class="language-julia hljs">ideal(R::NewRing, xs::Vector{NewRingElem})</code></pre><p>Here <code>xs</code> is a list of generators, and <code>NewRingElem === elem_type(NewRing)</code> holds.</p><p>With this in place, the following additional ideal constructors will automatically work via generic implementations:</p><pre><code class="language-julia hljs">ideal(R::NewRing, x::RingElement...) = ideal(R, [x...])
ideal(x::RingElement, y::RingElement...) = ideal(parent(x), x, y...)
ideal(xs::Vector{NewRingElem}) = ideal(parent(xs[1]), xs)
*(x::NewRingElem, R::NewRing) = ideal(R, x)
*(R::NewRing, x::NewRingElem) = ideal(R, x)</code></pre><p>In addition sums and products of ideals can be formed:</p><pre><code class="language-julia hljs">+(I::T, J::T) where {T &lt;: NewIdeal}
*(I::T, J::T) where {T &lt;: NewIdeal}</code></pre><p>An implementation of an <code>Ideal</code> subtype must also provide the following methods:</p><pre><code class="language-julia hljs">base_ring(I::NewIdeal)
gen(I::NewIdeal, k::Int)
gens(I::NewIdeal)
ngens(I::NewIdeal)</code></pre><h2 id="Optional-functionality-for-ideals"><a class="docs-heading-anchor" href="#Optional-functionality-for-ideals">Optional functionality for ideals</a><a id="Optional-functionality-for-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-ideals" title="Permalink"></a></h2><p>Some functionality is difficult or impossible to implement for all ideals. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can&#39;t be relied on by generic functions in the AbstractAlgebra Ideal interface.</p><p>It may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn&#39;t exist.</p><p>The following method have no generic implementation and only work when explicitly implemented.</p><pre><code class="language-julia hljs">in(v::NewRingElem, I::NewIdeal)
intersect(I::T, J::T) where {T &lt;: NewIdeal}</code></pre><p>If a method for <code>in</code> as above is provided, then the following automatically works:</p><pre><code class="language-julia hljs">issubset(I::NewIdeal, J::NewIdeal)</code></pre><p>If a method for <code>in</code> as above is provided (e.g. indirectly by providing method for <code>in</code>), then the following automatically works:</p><pre><code class="language-julia hljs">==(I::T, J::T) where {T &lt;: NewIdeal}</code></pre><p>Note that implementing <code>==</code> for a Julia type means that we have to provide a matching <code>hash</code> method which preserves the invariant that <code>I == J</code> implies <code>hash(I) == hash(J)</code>. We provide such a method but by necessity it is very conservative and hence does not provide good hashing. You may wish to implement a better <code>hash</code> methods.</p><p>The following method is implemented generically via the ideal generators.</p><pre><code class="language-julia hljs">iszero(I::Ideal) = all(iszero, gens(I))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../module_interface/">« Module Interface</a><a class="docs-footer-nextpage" href="../matrix_interface/">Matrix Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 5 January 2026 03:51">Monday 5 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
