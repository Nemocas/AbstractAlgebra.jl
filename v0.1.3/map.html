<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Map interface · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li><a class="toctext" href="puiseux.html">Generic Puiseux series</a></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fields.html">Field Interface</a></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="perm.html">Permutations and Permutation groups</a></li><li><a class="toctext" href="ytabs.html">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li></ul></li><li><span class="toctext">Maps</span><ul><li class="current"><a class="toctext" href="map.html">Map interface</a><ul class="internal"><li><a class="toctext" href="#Parent-objects-1">Parent objects</a></li><li><a class="toctext" href="#Map-classes-1">Map classes</a></li><li><a class="toctext" href="#Implementing-new-map-types-1">Implementing new map types</a></li><li><a class="toctext" href="#Getters-and-setters-1">Getters and setters</a></li><li><a class="toctext" href="#Required-functionality-for-maps-1">Required functionality for maps</a></li><li><a class="toctext" href="#Optional-functionality-for-maps-1">Optional functionality for maps</a></li></ul></li><li><a class="toctext" href="functional_map.html">Functional maps</a></li><li><a class="toctext" href="map_cache.html">Cached maps</a></li><li><a class="toctext" href="map_with_inverse.html">Map with inverse</a></li></ul></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Maps</li><li><a href="map.html">Map interface</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/map.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Map interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Map-interface-1" href="#Map-interface-1">Map interface</a></h1><p>Maps in Nemo model maps on sets <span>$f : D \to C$</span> for some domain <span>$D$</span> and codomain <span>$C$</span>, which have no real limitations except that elements of the codomain and domain be represented by element objects in the system..</p><p>Maps <span>$f : D \to C$</span> in AbstractAlgebra are modeled by Julia objects that are able to be called on a single element <span>$c \in C$</span> of the domain to yield an element <span>$f(c)$</span> of the codomain. We say that the map is being applied.</p><p>Maps can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.</p><p>In the following, we will always use the word &quot;function&quot; to mean a Julia function, and reserve the word &quot;map&quot; for a map on sets, whether mathematically, or as an object in the system..</p><p>Maps in AbstractAlgebra have a domain and codomain, can be applied, composed and composed with the identity map (assuming its domain is compatible). Various special kinds of map provide more functionality.</p><h2><a class="nav-anchor" id="Parent-objects-1" href="#Parent-objects-1">Parent objects</a></h2><p>Maps in AbstractAlgebra currently don&#39;t have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.</p><h2><a class="nav-anchor" id="Map-classes-1" href="#Map-classes-1">Map classes</a></h2><p>All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from <code>SetMap</code> at the top of the hierarchy. Other classes that inherit from <code>SetMap</code> are <code>FunctionalMap</code> for maps that are constructed from a Julia function (or closure), and <code>IdentityMap</code> for the class of the identity maps within the system.</p><p>One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.</p><p>Instead, a map type <code>MyMap</code> will belong to an abstract type of the form <code>Map{D, C, T, MyMap}</code>, where <code>D</code> is the type of the object representing the domain of the map type (this can also be an abstract type, such as <code>Group</code>), <code>C</code> is the type of the object representing the codomain of the map type and <code>T</code> is the map class that <code>MyMap</code> belongs to, e.g. <code>SetMap</code> or <code>FunctionalMap</code>.</p><p>Because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.</p><p>If writing a function that accepts any map type, one makes the type of its argument belong to <code>Map</code>. For example <code>f(M::Map) = 1</code>.</p><p>If writing a function that accepts any map from a domain of type <code>D</code> to a codomain of type <code>C</code>, one makes writes for example <code>f(M::Map{D, C}) = 2</code>. Note that <code>D</code> and <code>C</code> can be abstract types, such as <code>Group</code>, but otherwise must be the types of the parent objects representing the domain and codomain.</p><p>A function that accepts any map belonging to a given map class might be written as <code>f(M::Map(FunctionalMap)) = 3</code> or <code>f(M::Map(FunctionalMap){D, C}) = 4</code> for example, where <code>D</code> and <code>C</code> are the types of the parent objects for the domain and codomain.</p><p>Finally, if a function should only work for a map of a given map type <code>MyMap</code>, say, one writes this <code>f(M::Map(MyMap))</code> or <code>f(M::Map(MyMap){D, C}</code>, where as usual <code>D</code> and <code>C</code> are the types of the domain and codomain parent objects.</p><h2><a class="nav-anchor" id="Implementing-new-map-types-1" href="#Implementing-new-map-types-1">Implementing new map types</a></h2><p>There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.</p><p>In the case of fixed domain and codomain, e.g. <code>Integers{BigInt}</code>, we would write it as follows:</p><pre><code class="language-julia">mutable struct MyMap &lt;: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}
   # some data fields
end</code></pre><p>In the case of parameterisation by the type of the domain and codomain:</p><pre><code class="language-julia">mutable struct MyMap{D, C} &lt;: Map{D, C, SetMap, MyMap}
   # some data fields
end</code></pre><p>As mentioned above, to write a function that only accepts maps of type <code>MyMap</code>, one writes the functions as follows:</p><pre><code class="language-julia">function my_fun(M::Map(MyMap))</code></pre><p>The <code>Map</code> function then computes the correct type to use, which is actually not <code>MyMap</code> if all features of the generic Map infrastructure are required. It is bad practice to write functions for <code>MyMap</code> directly instead of <code>Map(MyMap)</code>, since other users will be unable to use generic constructions over the map type <code>MyMap</code>.</p><h2><a class="nav-anchor" id="Getters-and-setters-1" href="#Getters-and-setters-1">Getters and setters</a></h2><p>When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.</p><p>Let us suppose that the <code>MyMap</code> type has a field called <code>foo</code>. Rather than access this field by writing <code>M.foo</code>, one must access it using <code>foo(M)</code> (at least until Julia 1.1).</p><p>If such a getter only needs to access the field <code>foo</code> of <code>M</code>, there is a standard way of defining such a getter and setter when defining a new map type.</p><pre><code class="language-julia">foo(M::Map(MyMap)) = get_field(M, :foo)</code></pre><p>To set a field of a map, one needs a setter, which can be implemented as follows:</p><pre><code class="language-julia">set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)</code></pre><p>In general, setters should be used rarely for map types.</p><p>Note that by providing getter and setter functions, map types need not even contain fields with the given name. For example, for a <code>MyMap</code> map type for maps between integers, one does not wish to explicitly store the domain and codomain in <code>MyMap</code>. Instead, we can define the getter functions <code>domain</code> and <code>codomain</code> to return <code>JuliaZZ</code> for any <code>MyMap</code> object. </p><pre><code class="language-julia">domain(M::Map(MyMap)) = JuliaZZ
codomain(M::Map(MyMap)) = JuliaZZ</code></pre><h2><a class="nav-anchor" id="Required-functionality-for-maps-1" href="#Required-functionality-for-maps-1">Required functionality for maps</a></h2><p>All map types must implement a standard interface, which we specify here.</p><p>We will define this interface for a custom map type <code>MyMap</code> belonging to <code>Map(SetMap)</code>, <code>SetMap</code> being the map class that all maps types belong to.</p><p>Note that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.</p><p>The required accessors for map types of class <code>SetMap</code> are as follows.</p><pre><code class="language-julia">domain(M::Map(MyMap))
codomain(M::Map(MyMap))</code></pre><p>Return the domain and codomain parent objects respectively, for the map <span>$M$</span>. it is only necessary to define these functions if the map type <code>MyMap</code> does not contain fields <code>domain</code> and <code>codomain</code> containing these parent objects.</p><p>It is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to <code>Map(MyMap)</code>.</p><pre><code class="language-julia">(M::Map(MyMap)(a))</code></pre><p>Apply the map <code>M</code> to the element <code>a</code> of the domain of <code>M</code>. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type <code>elem_type(C)</code> where <code>C</code> is the type of the codomain parent object.</p><h2><a class="nav-anchor" id="Optional-functionality-for-maps-1" href="#Optional-functionality-for-maps-1">Optional functionality for maps</a></h2><p>The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.</p><p>However, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.</p><p>We describe this optional functionality here.</p><h3><a class="nav-anchor" id="Show-method-1" href="#Show-method-1">Show method</a></h3><p>Custom map types may like to provide a custom <code>show</code> method if the default of displaying the domain and codomain of the map is not sufficient.</p><pre><code class="language-julia">show(io::IO, M::Map(MyMap))</code></pre><h3><a class="nav-anchor" id="Identity-maps-1" href="#Identity-maps-1">Identity maps</a></h3><p>There is a concrete map type <code>Generic.IdentityMap{D}</code> for the identity map on a given domain. Here <code>D</code> is the type of the object representing that domain.</p><p><code>Generic.IdentityMap</code> belongs to the supertype <code>Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}</code>.</p><p>Note that the map class is also called <code>IdentityMap</code>. It is an abstract type, whereas <code>Generic.IdentityMap</code> is a concrete type in the Generic module.</p><p>An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.</p><p>We do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.</p><p>To construct an identity map for a given domain, specified by a parent object <code>R</code>, say, we have the following function.</p><pre><code class="language-julia">identity_map(R::D) where D &lt;: Set</code></pre><p>Return an identity map on the domain <span>$R$</span>.</p><p>Of course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to <code>AbstractAlgebra.IdentityMap</code> so that composition with other map types still works.</p><h3><a class="nav-anchor" id="Composition-of-maps-1" href="#Composition-of-maps-1">Composition of maps</a></h3><p>Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.</p><p>In order to facilitate this, the Generic module provides a type <code>CompositionMap{D, C}</code>, which contains two maps <code>map1</code> and <code>map2</code>, corresponding to the two maps to be applied in a composition, in the order they should be applied.</p><p>To construct a composition map from two existing maps, we have the following function:</p><pre><code class="language-julia">compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}</code></pre><p>Compose the two maps <span>$f$</span> and <span>$g$</span>, i.e. return the map <span>$h$</span> such that <span>$h(x) = g(f(x))$</span>.</p><p>As a shortcut for this function we have the following operator:</p><pre><code class="language-julia">*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)</code></pre><p>Note the order of composition. If we have maps <span>$f : X \to Y$</span>, <span>$g : Y \to Z$</span> the correct order of the maps in this operator is <code>f*g</code>, so that <code>(f*g)(x) = g(f(x))</code>.</p><p>This is chosen so that for left <span>$R$</span>-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.</p><p>Of course, a custom map type or class of maps can implement its own composition type and compose function.</p><p>This is the case with the <code>FunctionalMap</code> class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.</p><p>By default, <code>compose</code> will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:</p><pre><code class="language-julia">check_composable(f::Map{D, U}, g::Map{U, C})</code></pre><p>Raise an exception if the codomain of <span>$f$</span> doesn&#39;t match the domain of <span>$g$</span>.</p><p>Note that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:</p><pre><code class="language-julia">map1(f::CompositeMap)
map2(f::CompositeMap)</code></pre><p>Any custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.</p><footer><hr/><a class="previous" href="matrix.html"><span class="direction">Previous</span><span class="title">Generic matrices</span></a><a class="next" href="functional_map.html"><span class="direction">Next</span><span class="title">Functional maps</span></a></footer></article></body></html>
