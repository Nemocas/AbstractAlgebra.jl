<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Maps Â· AbstractAlgebra.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractAlgebra.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction.</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction.</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href="">Maps</a><ul class="internal"><li><a class="tocitem" href="#Parent-objects"><span>Parent objects</span></a></li><li><a class="tocitem" href="#Map-classes"><span>Map classes</span></a></li><li><a class="tocitem" href="#Implementing-new-map-types"><span>Implementing new map types</span></a></li><li><a class="tocitem" href="#Getters-and-setters"><span>Getters and setters</span></a></li><li><a class="tocitem" href="#Map-functions"><span>Map functions</span></a></li></ul></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Maps</a></li><li class="is-active"><a href="">Maps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Maps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/map.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Maps"><a class="docs-heading-anchor" href="#Maps">Maps</a><a id="Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Maps" title="Permalink"></a></h1><p>Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.</p><p>In the following, we will always use the word "function" to mean a Julia function, and reserve the word "map" for a map on sets, whether mathematically, or as an object in the system.</p><h2 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h2><p>Maps in AbstractAlgebra currently don't have parents.</p><h2 id="Map-classes"><a class="docs-heading-anchor" href="#Map-classes">Map classes</a><a id="Map-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Map-classes" title="Permalink"></a></h2><p>Each map in AbstractAlgebra has a map class. Currently the supported map classes are <code>SetMap</code> which is at the root of the tree of map classes and <code>FunctionalMap</code> for maps which are built on Julia functions and <code>IdentityMap</code>.</p><p>Other map classes can be added by inheriting from one of these. A map class is in practice nothing more than a Julia abstract type.</p><p>One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.</p><p>Instead, a map type <code>MyMap</code> say will belong to an abstract type of the form <code>Map{D, C, T, MyMap}</code>, where <code>D</code> is the type of the object representing the domain of the map type (this can also be an abstract type, such as <code>Group</code>), <code>C</code> is the type of the object representing the codomain of the map type and <code>T</code> is the map class.</p><p>Firstly note that all maps in the system belong to the abstract type <code>Map</code>. Moreover, maps from a domain of type <code>D</code> to a codomain of type <code>C</code> all belong to <code>Map{D, C}</code>.</p><p>However, because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to maps by their map class or by their specific map type.</p><p>Maps with map class <code>FunctionalMap</code> all belong to <code>Map(FunctionalMap))</code>. One can also restrict the domain and codomain by writing <code>Map(FunctionalMap){D, C}</code>.</p><p>Finally, if a function should only work for a map of a the very specific map type <code>MyMap</code>, one writes <code>M::Map(MyMap))</code> or <code>M::Map(MyMap){D, C}</code> if one wishes to restrict the domain and codomain types.</p><h2 id="Implementing-new-map-types"><a class="docs-heading-anchor" href="#Implementing-new-map-types">Implementing new map types</a><a id="Implementing-new-map-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-map-types" title="Permalink"></a></h2><p>There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.</p><p>In the case of fixed domain and codomain, e.g. <code>Integers{BigInt}</code>, we would write it as follows:</p><pre><code class="language-julia">mutable struct MyMap &lt;: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}
   # some data fields
end</code></pre><p>In the case of parameterisation by the type of the domain and codomain:</p><pre><code class="language-julia">mutable struct MyMap{D, C} &lt;: Map{D, C, SetMap, MyMap}
   # some data fields
end</code></pre><h2 id="Getters-and-setters"><a class="docs-heading-anchor" href="#Getters-and-setters">Getters and setters</a><a id="Getters-and-setters-1"></a><a class="docs-heading-anchor-permalink" href="#Getters-and-setters" title="Permalink"></a></h2><p>When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.</p><p>Let us suppose that the <code>MyMap</code> type has a field called <code>foo</code>. Rather than access this field by writing <code>M.foo</code>, one must access it using <code>foo(M)</code>.</p><p>If such a getter only needs to access the field <code>foo</code> of <code>M</code>, there is a standard way of defining such a getter and setter when defining a new map type.</p><pre><code class="language-julia">foo(M::Map(MyMap)) = get_field(M, :foo)</code></pre><p>To set a field of a map, one needs a setter, which can be implemented as follows:</p><pre><code class="language-julia">set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)</code></pre><h2 id="Map-functions"><a class="docs-heading-anchor" href="#Map-functions">Map functions</a><a id="Map-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Map-functions" title="Permalink"></a></h2><pre><code class="language-julia">domain(M::Map(MyMap))
codomain(M::Map(MyMap))</code></pre><p>Return the domain and codomain parent objects respectively, for the map <span>$M$</span>.</p><p>All maps can be applied to elements in the domain.</p><pre><code class="language-julia">(M::Map(MyMap)(a))</code></pre><p>Apply the map <code>M</code> to the element <code>a</code> of the domain of <code>M</code>.</p><h3 id="Identity-maps"><a class="docs-heading-anchor" href="#Identity-maps">Identity maps</a><a id="Identity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-maps" title="Permalink"></a></h3><p>There is a concrete map type <code>Generic.IdentityMap{D}</code> for the identity map on a given domain. Here <code>D</code> is the type of the object representing that domain.</p><p><code>Generic.IdentityMap</code> belongs to the map type <code>Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}</code>.</p><p>An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.</p><p>To construct an identity map for a given domain, specified by a parent object <code>R</code>, say, we have the following function.</p><pre><code class="language-julia">identity_map(R::Set)</code></pre><h3 id="Composition-of-maps"><a class="docs-heading-anchor" href="#Composition-of-maps">Composition of maps</a><a id="Composition-of-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-maps" title="Permalink"></a></h3><p>Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.</p><p>To construct a composition map from two existing maps, we have the following function:</p><pre><code class="language-julia">compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}</code></pre><p>As a shortcut for this function we have the following operator:</p><pre><code class="language-julia">*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Observe the order of composition. If we have maps <span>$f : X \to Y$</span>, <span>$g : Y \to Z$</span> the correct order of the maps in this operator is <code>f*g</code>, so that <code>(f*g)(x) = g(f(x))</code>.</p><p>This is chosen so that for left <span>$R$</span>-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../map_introduction/">Â« Introduction</a><a class="docs-footer-nextpage" href="../functional_map/">Functional maps Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 18 December 2021 20:59">Saturday 18 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>