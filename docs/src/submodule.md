# Submodules

AbstractAlgebra allows the construction of submodules/subvector spaces of
AbstractAlgebra modules over euclidean domains. These are given as the
submodule generated by a finite list of elements in the original module.

We define two submodules to be equal if they are (transitively) submodules
of the same module $M$ and their generators generate the same set of elements.

As well as implementing the entire Module interface, AbstractAlgebra
submodules also provide the following interface.

## Constructors

```@docs
Submodule(::AbstractAlgebra.FPModule{T}, ::Vector{AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement
```

```@docs
Subspace(::AbstractAlgebra.FPModule{T}, ::Vector{AbstractAlgebra.FPModuleElem{T}}) where T <: FieldElement
```

**Examples**

```@repl
using AbstractAlgebra # hide
M = FreeModule(ZZ, 2)

m = M([ZZ(1), ZZ(2)])
n = M([ZZ(2), ZZ(-1)])

N, f = Submodule(M, [m, n])

v = N([ZZ(3), ZZ(4)])
v2 = f(v)

V = VectorSpace(QQ, 2)

m = V([QQ(1), QQ(2)])
n = V([QQ(2), QQ(-1)])

N, f = Subspace(V, [m, n])
```

## Functionality for submodules

In addition to the Module interface, AbstractAlgebra submodules implement the
following functionality.

### Basic manipulation

```@docs
supermodule(::AbstractAlgebra.Generic.Submodule{T}) where T <: RingElement
```

```@docs
issubmodule(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement
```

```@docs
iscompatible(::AbstractAlgebra.FPModule{T}, ::AbstractAlgebra.FPModule{T}) where T <: RingElement
```

**Examples**

```@repl
using AbstractAlgebra # hide
M = FreeModule(ZZ, 2)
m = M([ZZ(2), ZZ(3)])
n = M([ZZ(1), ZZ(4)])
N1 = Submodule(M, [m, n])
N2 = Submodule(M, [m])

supermodule(N1) == M
iscompatible(N1, N2)
issubmodule(M, N)
```

### Intersection

```@docs
Base.intersect(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where
T <: RingElement
```

**Examples**

```@repl
using AbstractAlgebra # hide
M = FreeModule(ZZ, 2)
m = M([ZZ(2), ZZ(3)])
n = M([ZZ(1), ZZ(4)])
N1 = Submodule(M, [m, n])
N2 = Submodule(M, [m])

I = intersect(N1, N2)
```


