```@meta
CurrentModule = AbstractAlgebra
DocTestSetup = quote
    using AbstractAlgebra
end
```

# Generic residue rings

AbstractAlgebra.jl provides modules, implemented in `src/Residue.jl` and
`src/ResidueField` for residue rings and fields, respectively, over any
Euclidean domain (in practice most of the functionality is provided for GCD
domains that provide a meaningful GCD function) belonging to the
AbstractAlgebra.jl abstract type hierarchy.

## Generic residue types

AbstractAlgebra.jl implements generic residue rings with type `Generic.Res{T}`
or in the case of residue rings that are known to be fields, `Generic.ResF{T}`,
where `T` is the type of elements of the base ring. See the file
`src/generic/GenericTypes.jl` for details.

Parent objects of generic residue ring elements have type `Generic.ResRing{T}`
and those of residue fields have type `GenericResField{T}`.

The defining modulus of the residue ring is stored in the parent object.

## Abstract types

All residue element types belong to the abstract type `ResElem{T}`
or `ResFieldElem{T}` in the case of residue fields, and the
residue ring types belong to the abstract type `ResRing{T}` or `ResField{T}`
respectively. This enables one to write generic functions that can accept any
AbstractAlgebra residue type.


Note that both the generic residue ring type `Generic.ResRing{T}` and the
abstract type it belongs to, `ResRing{T}` are both called `ResRing`, and
similarly for the residue field types. In each case, the  former is a
(parameterised) concrete type for a residue ring over a given base ring whose
elements have type `T`. The latter is an abstract type representing all
residue ring types in AbstractAlgebra.jl, whether generic or very specialised
(e.g. supplied by a C library).

## Residue ring constructors

In order to construct residues in AbstractAlgebra.jl, one must first construct the
residue ring itself. This is accomplished with one of the following constructors.

```julia
ResidueRing(R::Ring, m::RingElem; cached::Bool = true)
```
```julia
ResidueField(R::Ring, m::RingElem; cached::Bool = true)
```

Given a base ring `R` and residue $m$ contained in this ring, return the parent object
of the residue ring $R/(m)$. By default the parent object `S` will depend only on `R`
and `m` and will be cached. Setting the optional argument `cached` to `false` will
prevent the parent object `S` from being cached.

The `ResidueField` constructor does the same thing as the `ResidueRing` constructor,
but the resulting object has type belonging to `Field` rather than `Ring`, so it can
be used anywhere a field is expected in AbstractAlgebra.jl. No check is made for
maximality of the ideal generated by $m$.

Here are some examples of creating residue rings and making use of the
resulting parent objects to coerce various elements into the residue ring.

**Examples**

```jldoctest
julia> R, x = PolynomialRing(QQ, "x")
(Univariate Polynomial Ring in x over Rationals, x)

julia> S = ResidueRing(R, x^3 + 3x + 1)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> f = S()
0

julia> g = S(123)
123

julia> h = S(BigInt(1234))
1234

julia> k = S(x + 1)
x + 1

```

All of the examples here are generic residue rings, but specialised implementations
of residue rings provided by external modules will also usually provide a
`ResidueRing` constructor to allow creation of their residue rings.

## Residue constructors

One can use the parent objects of a residue ring to construct residues, as per any
ring.

```julia
(R::ResRing)() # constructs zero
(R::ResRing)(c::Integer)
(R::ResRing)(c::elem_type(R))
(R::ResRing{T})(a::T) where T <: RingElement
```

## Functions for types and parents of residue rings

```julia
base_ring(R::ResRing)
base_ring(a::ResElem)
```

Return the base ring over which the ring was constructed.

```julia
parent(a::ResElem)
```

Return the parent of the given residue.

```julia
characteristic(R::ResRing)
```

Return the characteristic of the given residue ring.

## Residue ring functions

### Basic functionality

Residue rings implement the Ring interface.

```julia
zero(R::NCRing)
one(R::NCRing)
iszero(a::NCRingElement)
isone(a::NCRingElement)
```

```julia
divexact(a::T, b::T) where T <: RingElement
inv(a::T)
```

The Residue Ring interface is also implemented.

```julia
modulus(S::ResRing)
```

```julia
data(f::ResElem)
lift(f::ResElem)
```

Return a lift of the residue to the base ring.

The following functions are also provided for residues.

```@docs
modulus(::ResElem)
```

**Examples**

```jldoctest
julia> R, x = PolynomialRing(QQ, "x")
(Univariate Polynomial Ring in x over Rationals, x)

julia> S = ResidueRing(R, x^3 + 3x + 1)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> f = S(x + 1)
x + 1

julia> h = zero(S)
0

julia> k = one(S)
1

julia> isone(k)
true

julia> iszero(f)
false

julia> m = modulus(S)
x^3 + 3*x + 1

julia> U = base_ring(S)
Univariate Polynomial Ring in x over Rationals

julia> V = base_ring(f)
Univariate Polynomial Ring in x over Rationals

julia> T = parent(f)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> f == deepcopy(f)
true

julia> R, x = PolynomialRing(QQ, "x")
(Univariate Polynomial Ring in x over Rationals, x)

julia> S = ResidueRing(R, x^3 + 3x + 1)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> r = S(x + 1)
x + 1

julia> a = modulus(S)
x^3 + 3*x + 1

julia> isunit(r)
true

```

### Inversion

```@docs
Base.inv(::ResElem)
```

**Examples**

```jldoctest
julia> R, x = PolynomialRing(QQ, "x")
(Univariate Polynomial Ring in x over Rationals, x)

julia> S = ResidueRing(R, x^3 + 3x + 1)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> f = S(x + 1)
x + 1

julia> g = inv(f)
1//3*x^2 - 1//3*x + 4//3

```

### Greatest common divisor

```@docs
gcd{T <: RingElem}(::ResElem{T}, ::ResElem{T})
```

**Examples**

```jldoctest
julia> R, x = PolynomialRing(QQ, "x")
(Univariate Polynomial Ring in x over Rationals, x)

julia> S = ResidueRing(R, x^3 + 3x + 1)
Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1

julia> f = S(x + 1)
x + 1

julia> g = S(x^2 + 2x + 1)
x^2 + 2*x + 1

julia> h = gcd(f, g)
1

```

### Square Root

```@docs
issquare{T <: Integer}(::ResFieldElem{T})
```

```@docs
Base.sqrt{T <: Integer}(::ResFieldElem{T})
```

**Examples**

```julia
julia> R = ResidueField(ZZ, 733)
Residue field of Integers modulo 733

julia> a = R(86)
86

julia> issquare(a)
true

julia> sqrt(a)
532
```

### Random generation

Random residues can be generated using `rand`. The parameters after the residue
ring are used to generate elements of the base ring.

```julia
rand(R::ResRing, v...)
```

** Examples **

```@repl
R = ResidueRing(ZZ, 7)
f = rand(R, 0:6)

S, x = PolynomialRing(QQ, "x")
U = ResidueField(S, x^3 + 3x + 1)
g = rand(S, 2:2, -10:10)
```
