<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Ring functionality Â· AbstractAlgebra.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractAlgebra.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href="">Ring functionality</a><ul class="internal"><li><a class="tocitem" href="#Abstract-types-for-rings"><span>Abstract types for rings</span></a></li><li><a class="tocitem" href="#Functions-for-types-and-parents-of-rings"><span>Functions for types and parents of rings</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Basic-functions"><span>Basic functions</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-inexact-rings-only"><span>Basic functionality for inexact rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-commutative-rings-only"><span>Basic functionality for commutative rings only</span></a></li><li><a class="tocitem" href="#Basic-functionality-for-noncommutative-rings-only"><span>Basic functionality for noncommutative rings only</span></a></li><li><a class="tocitem" href="#Unsafe-ring-operators"><span>Unsafe ring operators</span></a></li><li><a class="tocitem" href="#Random-generation"><span>Random generation</span></a></li><li><a class="tocitem" href="#Factorization"><span>Factorization</span></a></li></ul></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../laurent_mpolynomial/">Sparse distributed multivariate Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../mseries/">Multivariate series</a></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li><li><a class="tocitem" href="../free_associative_algebra/">Free algebras</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Ideals</span><ul><li><a class="tocitem" href="../ideal/">Ideal functionality</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map Interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href="">Ring functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Ring functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ring.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Ring-functionality"><a class="docs-heading-anchor" href="#Ring-functionality">Ring functionality</a><a id="Ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-functionality" title="Permalink"></a></h1><p>AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.</p><h2 id="Abstract-types-for-rings"><a class="docs-heading-anchor" href="#Abstract-types-for-rings">Abstract types for rings</a><a id="Abstract-types-for-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types-for-rings" title="Permalink"></a></h2><p>All commutative ring types in AbstractAlgebra belong to the <code>Ring</code> abstract type and commutative ring elements belong to the <code>RingElem</code> abstract type.</p><p>Noncommutative ring types belong to the <code>NCRing</code> abstract type and their elements to <code>NCRingElem</code>.</p><p>As Julia types cannot belong to our <code>RingElem</code> type hierarchy, we also provide the union type <code>RingElement</code> which includes <code>RingElem</code> in union with the Julia types <code>Integer</code>, <code>Rational</code> and <code>AbstractFloat</code>.</p><p>Similarly <code>NCRingElement</code> includes the Julia types just mentioned in union with <code>NCRingElem</code>.</p><p>Note that</p><pre><code class="language-julia">Ring &lt;: NCRing
RingElem &lt;: NCRingElem
RingElement &lt;: NCRingElement</code></pre><h2 id="Functions-for-types-and-parents-of-rings"><a class="docs-heading-anchor" href="#Functions-for-types-and-parents-of-rings">Functions for types and parents of rings</a><a id="Functions-for-types-and-parents-of-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-types-and-parents-of-rings" title="Permalink"></a></h2><pre><code class="language-julia">parent_type(::Type{T}) where T &lt;: NCRingElement
elem_type(::Type{T}) where T &lt;: NCRing</code></pre><p>Return the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.</p><pre><code class="language-julia">base_ring(R::NCRing)
base_ring(a::NCRingElement)</code></pre><p>For generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.</p><pre><code class="language-julia">parent(a::NCRingElement)</code></pre><p>Return the parent of the given ring element.</p><pre><code class="language-julia">isdomain_type(::Type{T}) where T &lt;: NCRingElement
isexact_type(::Type{T}) where T &lt;: NCRingElement</code></pre><p>Return true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)</p><p>The following function is implemented where mathematically and algorithmically possible.</p><pre><code class="language-julia">characteristic(R::NCRing)</code></pre><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>If <code>R</code> is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.</p><pre><code class="language-julia">(R::NCRing)() # constructs zero
(R::NCRing)(c::Integer)
(R::NCRing)(c::elem_type(R))
(R::NCRing{T})(a::T) where T &lt;: RingElement</code></pre><h2 id="Basic-functions"><a class="docs-heading-anchor" href="#Basic-functions">Basic functions</a><a id="Basic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functions" title="Permalink"></a></h2><p>All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.</p><p>In addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.</p><pre><code class="language-julia">zero(R::NCRing)
one(R::NCRing)
iszero(a::NCRingElement)
isone(a::NCRingElement)</code></pre><p>In addition, the following is implemented where it is mathematically/algorithmically viable to do so.</p><pre><code class="language-julia">isunit(a::NCRingElement)</code></pre><p>The following standard Julia functions are also implemented for all ring elements.</p><pre><code class="language-julia">hash(f::RingElement, h::UInt)
deepcopy_internal(a::RingElement, dict::ObjectIdDict)
show(io::IO, R::NCRing)
show(io::IO, a::NCRingElement)</code></pre><h2 id="Basic-functionality-for-inexact-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-inexact-rings-only">Basic functionality for inexact rings only</a><a id="Basic-functionality-for-inexact-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-inexact-rings-only" title="Permalink"></a></h2><p>By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.</p><pre><code class="language-julia">isequal(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>For floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.</p><pre><code class="language-julia">isapprox(a::T, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>Similarly, for a parameterised ring with type <code>MyElem{T}</code> over such an inexact ring we have the following.</p><pre><code class="language-julia">isapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T &lt;: RingElement
isapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T &lt;: RingElement</code></pre><p>These notionally perform a coercion into the parameterised ring before doing the approximate equality test.</p><h2 id="Basic-functionality-for-commutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-commutative-rings-only">Basic functionality for commutative rings only</a><a id="Basic-functionality-for-commutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-commutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia">divexact(a::T, b::T) where T &lt;: RingElement
inv(a::T)</code></pre><p>Return <code>a/b</code> or <code>1/a</code> respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia's floating point division operator.</p><h2 id="Basic-functionality-for-noncommutative-rings-only"><a class="docs-heading-anchor" href="#Basic-functionality-for-noncommutative-rings-only">Basic functionality for noncommutative rings only</a><a id="Basic-functionality-for-noncommutative-rings-only-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality-for-noncommutative-rings-only" title="Permalink"></a></h2><pre><code class="language-julia">divexact_left(a::T, b::T) where T &lt;: NCRingElement
divexact_right(a::T, b::T) where T &lt;: NCRingElement</code></pre><p>As per <code>divexact</code> above, except that division by <code>b</code> happens on the left or right, respectively, of <code>a</code>.</p><h2 id="Unsafe-ring-operators"><a class="docs-heading-anchor" href="#Unsafe-ring-operators">Unsafe ring operators</a><a id="Unsafe-ring-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-ring-operators" title="Permalink"></a></h2><p>To speed up polynomial arithmetic, various unsafe operators are provided, which mutate the output rather than create a new object.</p><pre><code class="language-julia">zero!(a::NCRingElement)
mul!(a::T, b::T, c::T) where T &lt;: NCRingElement
add!(a::T, b::T, c::T) where T &lt;: NCRingElement
addeq!(a::T, b::T) where T &lt;: NCRingElement
addmul!(a::T, b::T, c::T, t::T) where T &lt;: NCRingElement</code></pre><p>In each case the mutated object is the leftmost parameter.</p><p>The <code>addeq!(a, b)</code> operation does the same thing as <code>add!(a, a, b)</code>. The optional <code>addmul!(a, b, c, t)</code> operation does the same thing as <code>mul!(t, b, c); addeq!(a, t)</code> where <code>t</code> is a temporary which can be mutated so that an addition allocation is not needed.</p><h2 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h2><p>The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. <code>-1:10</code> for the range of allowed degrees for a univariate polynomial.</p><pre><code class="language-julia">rand(R::NCRing, v...)</code></pre><h2 id="Factorization"><a class="docs-heading-anchor" href="#Factorization">Factorization</a><a id="Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization" title="Permalink"></a></h2><p>For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.</p><pre><code class="language-julia">isirreducible(a::T) where T &lt;: RingElement
issquarefree(a::T) where T &lt;: RingElement</code></pre><p>Decide whether <code>a</code> is irreducible or squarefree, respectively.</p><pre><code class="language-julia">factor(a::T) where T &lt;: RingElement
factor_squarefree(a::T) where T &lt;: RingElement</code></pre><p>Return a factorization into irreducible or squarefree elements, respectively. The return is an object of type <code>Fac{T}</code>.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Fac" id="AbstractAlgebra.Fac"><code>AbstractAlgebra.Fac</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Fac{T &lt;: RingElement}</code></pre><p>Type for factored ring elements. The structure holds a unit of type <code>T</code> and is an iterable collection of <code>T =&gt; Int</code> pairs for the factors and exponents.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4803548c7a945f3f7bd8c63f8bb7c79fac92b11a/src/Factor.jl#L15" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.unit-Tuple{Fac}" id="AbstractAlgebra.Generic.unit-Tuple{Fac}"><code>AbstractAlgebra.Generic.unit</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unit(a::Fac{T}) -&gt; T</code></pre><p>Return the unit of the factorization.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4803548c7a945f3f7bd8c63f8bb7c79fac92b11a/src/Factor.jl#L39" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Tuple{Fac}" id="AbstractAlgebra.evaluate-Tuple{Fac}"><code>AbstractAlgebra.evaluate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::Fac{T}) -&gt; T</code></pre><p>Multiply out the factorization into a single element.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4803548c7a945f3f7bd8c63f8bb7c79fac92b11a/src/Factor.jl#L48" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Tuple{Fac, Any}" id="Base.getindex-Tuple{Fac, Any}"><code>Base.getindex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(a::Fac, b) -&gt; Int</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding exponent is returned. Otherwise an error is thrown.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4803548c7a945f3f7bd8c63f8bb7c79fac92b11a/src/Factor.jl#L78" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}" id="Base.setindex!-Tuple{Fac{Int64}, Int64, Int64}"><code>Base.setindex!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(a::Fac{T}, c::Int, b::T)</code></pre><p>If <span>$b$</span> is a factor of <span>$a$</span>, the corresponding entry is set to <span>$c$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/4803548c7a945f3f7bd8c63f8bb7c79fac92b11a/src/Factor.jl#L93" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ring_introduction/">Â« Introduction</a><a class="docs-footer-nextpage" href="../integer/">Integer ring Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 22 April 2022 18:13">Friday 22 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>