<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Partitions and Young tableaux · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li><a class="toctext" href="puiseux.html">Generic Puiseux series</a></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fields.html">Field Interface</a></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="perm.html">Permutations and Permutation groups</a></li><li class="current"><a class="toctext" href="ytabs.html">Partitions and Young tableaux</a><ul class="internal"><li><a class="toctext" href="#Partitions-1">Partitions</a></li><li><a class="toctext" href="#Young-Diagrams-and-Young-Tableaux-1">Young Diagrams and Young Tableaux</a></li><li><a class="toctext" href="#Characters-of-permutation-grups-1">Characters of permutation grups</a></li><li><a class="toctext" href="#Skew-Diagrams-1">Skew Diagrams</a></li></ul></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="map.html">Map interface</a></li><li><a class="toctext" href="functional_map.html">Functional maps</a></li><li><a class="toctext" href="map_cache.html">Cached maps</a></li><li><a class="toctext" href="map_with_inverse.html">Map with inverse</a></li></ul></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Groups</li><li><a href="ytabs.html">Partitions and Young tableaux</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/ytabs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Partitions and Young tableaux</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Partitions-and-Young-tableaux-1" href="#Partitions-and-Young-tableaux-1">Partitions and Young tableaux</a></h1><p>AbstractAlgebra.jl provides basic support for computations with Young tableaux, skew diagrams and the characters of permutation groups (implemented <code>src/generic/YoungTabs.jl</code>). All functionality of permutations is accesible in the <code>Generic</code> submodule.</p><h2><a class="nav-anchor" id="Partitions-1" href="#Partitions-1">Partitions</a></h2><p>The basic underlying object for those concepts is <code>Partition</code> of a number <span>$n$</span>, i.e. a sequence of positive integers <span>$n_1, \ldots, n_k$</span> which sum to <span>$n$</span>. Partitions in AbstractAlgebra.jl are represented internally by non-increasing <code>Vector</code>s of <code>Int</code>s. Partitions are printed using the standard notation, i.e. <span>$9 = 4 + 2 + 1 + 1 + 1$</span> is shown as <span>$4_1 2_1 1_3$</span> with the subscript indicating the count of a summand in the partition.</p><pre><code class="language-none">Generic.Partition</code></pre><h3><a class="nav-anchor" id="Array-interface-1" href="#Array-interface-1">Array interface</a></h3><p><code>Partition</code> is a concrete subtype of <code>AbstractVector{Int}</code> and implements the following standard Array interface:</p><pre><code class="language-none">size(::Generic.Partition)
getindex(::Generic.Partition, i::Integer)
setindex!(::Generic.Partition, v::Integer, i::Integer)</code></pre><p>These functions work on the level of <code>p.part</code> vector. Additionally <code>setindex!</code> will try to prevent uses which result in non-valid (i.e. non-decreasing) partition vectors.</p><p>One can easily iterate over all partitions of <span>$n$</span> using the <code>AllParts</code> type:</p><pre><code class="language-none">Generic.AllParts</code></pre><p>The number all all partitions can be computed by the hidden function <code>_numpart</code>. Much faster implementation is available in <a href="http://nemocas.github.io/Nemo.jl/latest/arb.html#Nemo.numpart-Tuple{Int64,ArbField}">Nemo.jl</a>.</p><pre><code class="language-none">Generic._numpart</code></pre><p>Since <code>Partition</code> is a subtype of <code>AbstractVector</code> generic functions which operate on vectors should work in general. However the meaning of <code>conj</code> has been changed to agree with the traditional understanding of conjugation of <code>Partitions</code>:</p><pre><code class="language-none">conj(::Generic.Partition)
conj(::Generic.Partition, v::Vector)</code></pre><h2><a class="nav-anchor" id="Young-Diagrams-and-Young-Tableaux-1" href="#Young-Diagrams-and-Young-Tableaux-1">Young Diagrams and Young Tableaux</a></h2><p>Mathematicaly speaking Young diagram is a diagram which consists of rows of square boxes such that the number of boxes in each row is no less than the number of boxes in the previous row. For example partition <span>$4_1 3_2 1$</span> represents the following diagram.</p><pre><code class="language-none">┌───┬───┬───┬───┐
│   │   │   │   │
├───┼───┼───┼───┘
│   │   │   │
├───┼───┼───┤
│   │   │   │
├───┼───┴───┘
│   │
└───┘</code></pre><p>Young Tableau is formally a bijection between the set of boxes of a Young Diagram and the set <span>$\{1, \ldots, n\}$</span>. If a bijection is increasing along rows and columns of the diagram it is referred to as <strong>standard</strong>. For example</p><pre><code class="language-none">┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┼───┤
│ 8 │ 9 │10 │
├───┼───┴───┘
│11 │
└───┘</code></pre><p>is a standard Young tableau of <span>$4_1 3_2 1$</span> where the bijection assigns consecutive natural numbers to consecutive (row-major) cells.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>In AbstractAlgebra.jl Young tableau are implemented as essentially row-major sparse matrices, i.e. <code>YoungTableau &lt;: AbstractArray{Int,2}</code> but only the defining <code>Partition</code> and the (row-major) fill-vector is stored.</p><pre><code class="language-none">Generic.YoungTableau</code></pre><p>For convenience there exists an alternative constructor of <code>YoungTableau</code>, which accepts a vector of integers and constructs <code>Partition</code> internally.</p><pre><code class="language-none">YoungTableau(p::Vector{Integer}[, fill=collect(1:sum(p))])</code></pre><h3><a class="nav-anchor" id="Array-interface-2" href="#Array-interface-2">Array interface</a></h3><p>To make <code>YoungTableaux</code> array-like we implement the following functions:</p><pre><code class="language-none">size(::Generic.YoungTableau)
getindex(::Generic.YoungTableau, n::Integer)</code></pre><p>Also the double-indexing corresponds to <code>(row, column)</code> access to an abstract array.</p><pre><code class="language-julia-repl">julia&gt; y = YoungTableau([4,3,1])
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┘
│ 5 │ 6 │ 7 │
├───┼───┴───┘
│ 8 │
└───┘

julia&gt; y[1,2]
2

julia&gt; y[2,3]
7

julia&gt; y[3,2]
0</code></pre><p>Functions defined for <code>AbstractArray</code> type based on those (e.g. <code>length</code>) should work. Again, as in the case of <code>Partition</code> the meaning of <code>conj</code> is altered to reflect the usual meaning for Young tableaux:</p><pre><code class="language-none">conj(::Generic.YoungTableau)</code></pre><h3><a class="nav-anchor" id="Pretty-printing-1" href="#Pretty-printing-1">Pretty-printing</a></h3><p>Similarly to permutations we have two methods of displaying Young Diagrams:</p><pre><code class="language-none">Generic.setyoungtabstyle</code></pre><h3><a class="nav-anchor" id="Ulitility-functions-1" href="#Ulitility-functions-1">Ulitility functions</a></h3><pre><code class="language-none">matrix_repr(::Generic.YoungTableau)
fill!(::Generic.YoungTableau, ::AbstractVector{&lt;:Integer})</code></pre><h2><a class="nav-anchor" id="Characters-of-permutation-grups-1" href="#Characters-of-permutation-grups-1">Characters of permutation grups</a></h2><p>Irreducible characters (at least over field of characteristic <span>$0$</span>) of the full group of permutations <span>$S_n$</span> correspond via <a href="https://en.wikipedia.org/wiki/Specht_module">Specht modules</a> to partitions of <span>$n$</span>.</p><pre><code class="language-none">character(::Generic.Partition)
character(lambda::Generic.Partition, p::Generic.perm)
character(lambda::Generic.Partition, mu::Generic.Partition)</code></pre><p>The values computed by characters are cached in an internal dictionary <code>Dict{Tuple{BitVector,Vector{Int}}, BigInt}</code>. Note that all of the above functions return <code>BigInts</code>. If you are sure that the computations do not overflow, variants of the last two functions using <code>Int</code> are available:</p><pre><code class="language-none">character(::Type{Int}, lambda::Partition, p::perm[, check::Bool=true])
character(::Type{Int}, lambda::Partition, mu::Partition[, check::Bool=true])</code></pre><p>The dimension <span>$\dim \lambda$</span> of the irreducible module corresponding to partition <span>$\lambda$</span> can be computed using <a href="https://en.wikipedia.org/wiki/Hook_length_formula">Hook length formula</a></p><pre><code class="language-none">Generic.rowlength
Generic.collength
hooklength
dim(::Generic.YoungTableau)</code></pre><p>The the character associated with <code>Y.part</code> can also be used to compute the dimension, but as it is expected the Murnaghan-Nakayama is much slower even though (due to caching) consecutive calls are fast:</p><pre><code class="language-julia-repl">julia&gt; λ = Partition(collect(12:-1:1))
12₁11₁10₁9₁8₁7₁6₁5₁4₁3₁2₁1₁

julia&gt; @time dim(YoungTableau(λ))
  0.224430 seconds (155.77 k allocations: 7.990 MiB)
9079590132732747656880081324531330222983622187548672000

julia&gt; @time dim(YoungTableau(λ))
  0.000038 seconds (335 allocations: 10.734 KiB)
9079590132732747656880081324531330222983622187548672000

julia&gt; G = PermutationGroup(sum(λ))
Permutation group over 78 elements

julia&gt; @time character(λ, G())
 24.154105 seconds (58.13 M allocations: 3.909 GiB, 42.84% gc time)
9079590132732747656880081324531330222983622187548672000

julia&gt; @time character(λ, G())
  0.001439 seconds (195 allocations: 24.453 KiB)
9079590132732747656880081324531330222983622187548672000</code></pre><h3><a class="nav-anchor" id="Low-level-functions-and-characters-1" href="#Low-level-functions-and-characters-1">Low-level functions and characters</a></h3><p>As mentioned above <code>character</code> functions use the Murnaghan-Nakayama rule for evaluation. The implementation follows</p><blockquote><p>Dan Bernstein, The computational complexity of rules for the character table of <span>$S_n$</span> <em>Journal of Symbolic Computation</em>, <strong>37</strong> (6), 2004, p. 727-748,</p></blockquote><p>implementing the following functions. For precise definitions and meaning please consult the paper cited.</p><pre><code class="language-none">Generic.partitionseq
isrimhook(::BitVector, ::Int, ::Int)
Generic.MN1inner</code></pre><h2><a class="nav-anchor" id="Skew-Diagrams-1" href="#Skew-Diagrams-1">Skew Diagrams</a></h2><p>Skew diagrams are formally differences of two Young diagrams. Given <span>$\lambda$</span> and <span>$\mu$</span>, two partitions of <span>$n+m$</span> and <span>$m$</span> (respectively). Suppose that each of cells of <span>$\mu$</span> is a cell of <span>$\lambda$</span> (i.e. parts of <span>$\mu$</span> are no greater than the corresponding parts of <span>$\lambda$</span>). Then the skew diagram denoted by <span>$\lambda/\mu$</span> is the set theoretic difference the of sets of boxes, i.e. is a diagram with exactly <span>$n$</span> boxes:</p><pre><code class="language-none">Generic.SkewDiagram</code></pre><p><code>SkewDiagram</code> implements array interface with the following functions:</p><pre><code class="language-none">size(xi::Generic.SkewDiagram)
in(t::Tuple{T,T}, xi::Generic.SkewDiagram) where T&lt;:Integer
getindex(xi::Generic.SkewDiagram, n::Integer)</code></pre><p>The support for skew diagrams is very rudimentary. The following functions are available:</p><pre><code class="language-none">isrimhook(::Generic.SkewDiagram)
leglength
matrix_repr(::Generic.SkewDiagram)</code></pre><footer><hr/><a class="previous" href="perm.html"><span class="direction">Previous</span><span class="title">Permutations and Permutation groups</span></a><a class="next" href="matrix_spaces.html"><span class="direction">Next</span><span class="title">Matrix Interface</span></a></footer></article></body></html>
