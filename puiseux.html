<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic Puiseux series · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multvariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li class="current"><a class="toctext" href="puiseux.html">Generic Puiseux series</a><ul class="internal"><li><a class="toctext" href="#Types-and-parent-objects-1">Types and parent objects</a></li><li><a class="toctext" href="#Puisuex-series-ring-constructors-1">Puisuex series ring constructors</a></li><li><a class="toctext" href="#Big-oh-notation-1">Big-oh notation</a></li><li><a class="toctext" href="#Puiseux-series-implementation-1">Puiseux series implementation</a></li><li><a class="toctext" href="#Basic-ring-functionality-1">Basic ring functionality</a></li><li><a class="toctext" href="#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1">Puiseux series functionality provided by AbstractAlgebra.jl</a></li></ul></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fields.html">Field Interface</a></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="perm.html">Permutation groups</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="map.html">Map interface</a></li></ul></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="puiseux.html">Generic Puiseux series</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/puiseux.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generic Puiseux series</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generic-Puiseux-series-1" href="#Generic-Puiseux-series-1">Generic Puiseux series</a></h1><p>AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring <span>$R$</span>.</p><p>Puiseux series are power series of the form <span>$a_jx^{j/m} + a_{j+1}x^{(j+1)/m} + \cdots + a_{k-1}x^{(k-1)/m} + O(x^{k/m})$</span> for some integer <span>$m &gt; 0$</span> where <span>$i \geq 0$</span>, <span>$a_i \in R$</span> and the relative precision <span>$k - j$</span> is at most equal to some specified precision <span>$n$</span>.</p><p>The generic Puiseux series module is implemented in <code>src/generic/PuiseuxSeries.jl</code>.</p><p>As well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.</p><p>All of the generic functionality is part of the <code>Generic</code> submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.</p><h2><a class="nav-anchor" id="Types-and-parent-objects-1" href="#Types-and-parent-objects-1">Types and parent objects</a></h2><p>The types of generic polynomials implemented by AbstractAlgebra.jl are <code>Generic.PuiseuxSeriesRingElem{T}</code> and <code>Generic.PuiseuxSeriesFieldElem{T}</code>.</p><p>Both series element types belong to the union type <code>Generic.PuiseuxSeriesElem</code>.</p><p>Puiseux series elements belong directly to either <code>AbstractAlgebra.RingElem</code> or <code>AbstractAlgebra.FieldElem</code> since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.</p><p>The parent types for Puiseux series, <code>Generic.PuiseuxSeriesRing{T}</code>  and <code>Generic.PuiseuxSeriesField{T}</code> respectively, belong to <code>AbstractAlgebra.Ring</code> and <code>AbstractAlgebra.Field</code> respectively.</p><p>The default precision, string representation of the variable and base ring <span>$R$</span> of a generic Puiseux series are stored in its parent object. </p><h2><a class="nav-anchor" id="Puisuex-series-ring-constructors-1" href="#Puisuex-series-ring-constructors-1">Puisuex series ring constructors</a></h2><p>In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.</p><pre><code class="language-julia">PuiseuxSeriesRing(R::AbstractAlgebra.Ring, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><pre><code class="language-julia">PuiseuxSeriesRing(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><pre><code class="language-julia">PuiseuxSeriesField(R::AbstractAlgebra.Field, prec_max::Int, s::AbstractString; cached::Bool = true)</code></pre><p>Given a base ring <code>R</code>, a maximum relative precision and a string <code>s</code> specifying how the generator (variable) should be printed, return a typle <code>S, x</code> representing the Puiseux series ring and its generator.</p><p>By default, <code>S</code> will depend only on <code>S</code>, <code>x</code> and the maximum precision and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent this.</p><p>Here are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)
S, y = PuiseuxSeriesField(QQ, 10, &quot;y&quot;)

f = R()
g = S(123)
h = R(BigInt(1234))
k = S(y + 1)</code></pre><h2><a class="nav-anchor" id="Big-oh-notation-1" href="#Big-oh-notation-1">Big-oh notation</a></h2><p>Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):</p><pre><code class="language-julia">O(x::SeriesElem)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)

f = 1 + 2x + O(x^5)
g = 2x^(1//3) + 7y^(2//3) + O(y^(7//3))</code></pre><p>What is happening here in practice is that <code>O(x^n)</code> is creating the series <code>0 + O(x^n)</code> and the rules for addition of series dictate that if this is added to a series of  greater precision, then the lower of the two precisions must be used.</p><p>Of course it may be that the precision of the series that <code>O(x^n)</code> is added to is already lower than <code>n</code>, in which case adding <code>O(x^n)</code> has no effect. This is the case if the default precision is too low, since <code>x</code> on its own has the default precision.</p><h2><a class="nav-anchor" id="Puiseux-series-implementation-1" href="#Puiseux-series-implementation-1">Puiseux series implementation</a></h2><p>Puiseux series have their maximum relative precision capped at some value <code>prec_max</code>. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.</p><p>The Puiseux series type stores such a Laurent series and a <code>scale</code> or denominator for the exponents. For example, <span>$f(x) = 1 + x^{1/3} + 2x^{2/3} + O(x^{7/3})$</span> would be stored as a Laurent series <span>$1 + x + 2x^2 + O(x^7)$</span> and a scale of <span>$3$</span>..</p><p>The maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.</p><p>In all models we say that two Puiseux series are equal if they agree up to the minimum <strong>absolute</strong> precision of the two power series.</p><p>Thus, for example, <span>$x^5 + O(x^{10}) == 0 + O(x^5)$</span>, since the minimum absolute precision is <span>$5$</span>.</p><p>Sometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the <code>isequal</code> function.</p><p>For example, if <span>$f = x^2 + O(x^7)$</span> and <span>$g = x^2 + O(x^8)$</span> and <span>$h = 0 + O(x^2)$</span> then <span>$f == g$</span>, <span>$f == h$</span> and <span>$g == h$</span>, but <code>isequal(f, g)</code>, <code>isequal(f, h)</code> and <code>isequal(g, h)</code> would all return <code>false</code>. However, if <span>$k = x^2 + O(x^7)$</span> then <code>isequal(f, k)</code> would return <code>true</code>.</p><p>There are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.</p><h2><a class="nav-anchor" id="Basic-ring-functionality-1" href="#Basic-ring-functionality-1">Basic ring functionality</a></h2><p>All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the <code>pol_length</code> and <code>polcoeff</code> functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia">S, x = PuiseuxSeriesRing(ZZ, 10, &quot;x&quot;)

f = 1 + 3x + x^3 + O(x^10)
g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))

h = zero(S)
k = one(S)
isone(k) == true
iszero(f) == false
U = base_ring(S)
v = var(S)
T = parent(x + 1)
g == deepcopy(g)
t = divexact(2g, 2)
p = precision(f)</code></pre><h2><a class="nav-anchor" id="Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1" href="#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl-1">Puiseux series functionality provided by AbstractAlgebra.jl</a></h2><p>The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.</p><p>Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.</p><h3><a class="nav-anchor" id="Basic-functionality-1" href="#Basic-functionality-1">Basic functionality</a></h3><pre><code class="language-none">coeff(a::Generic.PuiseuxSeriesElem, n::Int)</code></pre><pre><code class="language-none">coeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})</code></pre><p>Return the coefficient of the term of exponent <span>$n$</span> of the given power series. If <span>$n$</span> exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.modulus-Union{Tuple{T}, Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}} where T&lt;:AbstractAlgebra.ResElem" href="#AbstractAlgebra.Generic.modulus-Union{Tuple{T}, Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}} where T&lt;:AbstractAlgebra.ResElem"><code>AbstractAlgebra.Generic.modulus</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">modulus{T &lt;: ResElem}(a::PuiseuxSeriesElem{T})</code></pre><blockquote><p>Return the modulus of the coefficients of the given Puiseux series.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/PuiseuxSeries.jl#L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isgen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}" href="#AbstractAlgebra.Generic.isgen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}"><code>AbstractAlgebra.Generic.isgen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isgen(a::PuiseuxSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/PuiseuxSeries.jl#L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isunit-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}" href="#AbstractAlgebra.Generic.isunit-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}"><code>AbstractAlgebra.Generic.isunit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isunit(a::PuiseuxSeriesElem)</code></pre><blockquote><p>Return <code>true</code> if the given Puiseux series is arithmetically equal to a unit, i.e. is invertible, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/PuiseuxSeries.jl#L234">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, t = PuiseuxSeriesRing(QQ, 10, &quot;t&quot;)
S, x = PuiseuxSeriesRing(R, 30, &quot;x&quot;)

a = O(x^4)
b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)

k = isgen(gen(R))
m = isunit(-1 + x^(1//3) + 2x^2)
n = valuation(a)
p = valuation(b)
c = coeff(b, 2)</code></pre><h3><a class="nav-anchor" id="Division-1" href="#Division-1">Division</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}" href="#Base.inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">inv(M)</code></pre><p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == eye(2)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/903644385b91ed8d95e5e3a5716c089dd1f1b08a/base/linalg/generic.jl#L743-L767">source</a><div><pre><code class="language-none">inv{T &lt;: RingElement}(M::AbstractAlgebra.MatElem{T})</code></pre><blockquote><p>Given a non-singular <span>$n\times n$</span> matrix over a ring the tuple <span>$X, d$</span> consisting of an <span>$n\times n$</span> matrix <span>$X$</span> and a denominator <span>$d$</span> such that <span>$AX = dI_n$</span>, where <span>$I_n$</span> is the <span>$n\times n$</span> identity matrix. The denominator will be the determinant of <span>$A$</span> up to sign. If <span>$A$</span> is singular an exception is raised.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/Matrix.jl#L1990">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PuiseuxSeriesRing(QQ, 30, &quot;x&quot;)

a = 1 + x + 2x^2 + O(x^5)
b = R(-1)

c = inv(a)
d = inv(b)</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}" href="#Base.exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><p>exp(a::PuiseuxSeriesElem)</p><blockquote><p>Return the exponential of the given Puiseux series <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/PuiseuxSeries.jl#L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}" href="#Base.sqrt-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T&lt;:Union{AbstractAlgebra.RingElem, AbstractFloat, Integer, Rational}}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span>.</div><div><p>sqrt(a::PuiseuxSeriesElem)</p><blockquote><p>Return the square root of the given Puiseux series <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/da8670afbaf5cf573a02763a7b4d906e3781d816/src/generic/PuiseuxSeries.jl#L557">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, t = PolynomialRing(QQ, &quot;t&quot;)
S, x = PuiseuxSeriesRing(R, 30, &quot;x&quot;)
T, z = PuiseuxSeriesRing(QQ, 30, &quot;z&quot;)

a = 1 + z + 3z^2 + O(z^5)
b = z + 2z^2 + 5z^3 + O(z^5)

c = exp(x + O(x^40))
d = divexact(x, exp(x + O(x^40)) - 1)
f = exp(b)
h = sqrt(a)</code></pre><footer><hr/><a class="previous" href="series.html"><span class="direction">Previous</span><span class="title">Generic power series</span></a><a class="next" href="residue_rings.html"><span class="direction">Next</span><span class="title">Residue Ring Interface</span></a></footer></article></body></html>
