\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}
\newcommand{\desc}[1]{\vspace{-3mm}\begin{quote}#1\end{quote}}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{julia}
{
  keywordsprefix=\@,
  morekeywords={
    exit,whos,edit,load,is,isa,isequal,typeof,tuple,ntuple,uid,hash,finalizer,convert,promote,
    subtype,typemin,typemax,realmin,realmax,sizeof,eps,promote_type,method_exists,applicable,
    invoke,dlopen,dlsym,system,error,throw,assert,new,Inf,Nan,pi,im,begin,while,for,in,return,
    break,continue,macro,quote,let,if,elseif,else,try,catch,end,bitstype,ccall,do,using,module,
    import,export,importall,baremodule,immutable,local,global,const,Bool,Int,Int8,Int16,Int32,
    Int64,Uint,Uint8,Uint16,Uint32,Uint64,Float32,Float64,Complex64,Complex128,Any,Nothing,None,
    function,type,typealias,abstract
  },
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]" 
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{goodwillhart@googlemail.com}

\title{Nemo: A computer algebra package for Julia}
\author{William B. Hart}

\begin{document}
\lstset{
  language=julia,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Nemo is a computer algebra package for the Julia programming language (\url{http://julialang.org/}).

Nemo is based on the C libraries:

\begin{enumerate}
\item FLINT (Fast Library for Number Theory) -- \url{http://flintlib.org/}
\item ANTIC (Algebraic Number Theory in Code) -- \url{http://github.com/wbhart/antic/}
\item Pari -- \url{http://pari.math.u-bordeaux.fr/}
\item Singular -- \url{http://www.singular.uni-kl.de/}
\end{enumerate}

The scope of Nemo is computer algebra in the limited sense of the term, and number theory. 

We hope that Nemo will eventually also provide access to the Gap library -- 
\url{http://www.gap-system.org/}.

\section{The Julia programming language}

Over two hundred programming languages were examined before settling on Julia as our choice for the
Nemo project.

Some statically compiled languages such as C++, D, Rust and Nimrod could have been reasonable solutions
up to a point. Languages such as Scala, Aldor and various others also have strong points.

But Julia is the only language which met all our design criteria.

\begin{enumerate}
\item Interactive REPL
\item Jit compiled
\item Fast native C/C++ interop
\item Dependent type system
\item Familiar imperative syntax
\item Open source implementation
\item Regular releases
\item Decent sized community
\item Portable to OSX, Windows, Linux, BSD 
\end{enumerate}

Julia started life in 2009 with a first public release in 2012. It's main architects are Jeff Bezanson,
Stefan Karpinski and Viral B. Shah, though there are well over 150 contributors to date.

Julia is based on the lightning fast LLVM compiler back end and just-in-time compiler. It is capable of
producing code which runs as fast as native C code.

Julia sports hundreds of contributed libraries, a package manager and even a Jupyter based graphical
interface.

Hundreds of thousands of lines of code have already been written in Julia. The language is
already used in production environments, including big data and parallel environments. The
Julia website gets over 150,000 visits a month. There are Julia users groups worldwide and
courses taught in Julia in at least Canada and the US.

Most importantly, Julia is designed by mathematicians for mathematicians.

Some of the key features of Julia are briefly discussed below.

\subsubsection{Jit compilation}

Julia uses just-in-time (JIT) compilation, which allows it to achieve C-like performance in real time
without a separate compilation cycle. Jit compilation is achieved through use of the LLVM compiler
back end.

LLVM is the 15 year old compiler infrastructure which underlies the Clang C/C++ compiler and components
of over a dozen other programming languages.

LLVM's chief architect is Chris Lattner, an Apple employee since 2005, now working on Apple's 
Swift programming language, which uses LLVM heavily. LLVM itself is reported to be used by Apple
for its IOS tool development. 

Jit compilation is ideal for mathematical code, since we generally do not care if there is a very short
delay for incremental compilation after we hit our Enter key. We care only about how fast our very large
loops will take to execute, after jit compilation has happened.

Julia combines LLVM's Jit with dynamic type inference. This is a strategy which allows one to
combine most of the benefits of a statically typed language (such as C/C++) with the flexibility
and ease of use of dynamically typed languages (such as Python, Javascript, PHP, Perl and 
Ruby).

To the greatest extent possible, Julia tries to infer the types for each function. However, it
allows code to be written without specifying types, if one should so wish. Thus, from the user's
perspective it is dynamically typed. But in many cases, exactly the same machine code results as
would come from a C compiler and hand-written C. 

\subsubsection{Interactive console}

Julia offers an interactive console, similar to Python. It can also be used from a Jupyter derivative
known as IJulia. This can be used on the web or even natively on Windows!

Julia has a console which provides Readline like functionality and offers an online help 
system.

Most importantly, Julia offers Jit compiled code at the console! You don't have to precompile
Julia statically to get C-like performance. What you type at the console executes at lightning
speed, immediately.

The console offers exception handling and recovery, pretty printing of types and values, stack 
traces, profiling and timing, the ability to disassemble the Jit compiled code, and exposes 
Julia's type inference machinery, introspection capabilities, interactive loading of modules 
and libraries (including native code) and all of the Julia language, including sophisticated 
metaprogramming features. 

\subsubsection{Foreign function interface}

Julia allows direct access to C/C++ libraries. There is also a simple mapping from C types to Julia
types, and thus complex and costly wrappers are not needed.

Any native dynamic library (such as flint) can be directly accessed from within Julia, so long
as it is in the current library path.

There is no additional overhead in accessing native C libraries from within Julia than there
would be from a native C program using that library.

\subsubsection{Dependent and parametric types}

Few languages in the world sport a decent dependent and parametric type system. If they
do, it is usually at static compile time only.

The prime example of parametric types for a computer algebraist is when creating a type for
polynomials over a ring $R$. In Julia, we can provide a type called Poly, which depends on
another type, $R$ say, specifying the ring you are working over. e.g. $R$ might be the
integers, or another polynomial ring, or a ring of matrices, etc.

Mathematics, especially algebra, is inherently dependent, meaning that Julia's dependent type system
is ideal for computer algebra.

\subsubsection{Polymorphism}
 
Julia is polymorphic, meaning that multiple functions (and operators) can have the same name. For
example, one can write separate versions of the determinant function for matrices over a ring versus
matrices over a field.

In most dynamic languages, e.g. Python, one writes a single function det(M), say, which
may then need many lines of code to sort out what kind of object we are taking the determinant of. All
of this decision code is executed at runtime and places an additional burden on the programmer. 

The Julia dispatch mechanism, on the other hand, does all of this automatically, alleviating the need
to write such decision code.

One can still write generic, catch-all functions, which work over any ring, say. But
these do not first need to delegate to a whole bunch of special cases where specialised
algorithms can be used. 

This greatly improves clarity and readability of code, as specialised versions of generic functions are
clearly delineated by their type signatures.

In addition to this, Julia allows functions to not only be overloaded by other Julia functions of the
same name when certain types of rings are passed as parameters, but one can also overload functions
and operators with highly specialised C/C++ implementations via the Julia native code interface.

\subsubsection{Abstract types and genericity}

Julia doesn't provide classes a la C++. As such, it is not possible to inherit data types. Instead
Julia achieves genericity by inheriting behaviour.

This is achieved by providing abstract types (also known as type classes).

Each type belongs to an \emph{abstract type}, which can be thought of as a collection of types that
have some common behaviour. For example, all the different native integer types in Julia belong to a
common \code{Integer} type class. Arithmetic operations and greatest common divisor functions
make sense for all of these integer types, for example.

Making all the native integer types belong to a single abstract \code{Integer} type class means that it
is possible to write a function that accepts any native integer type as input simply by specifying that
the given parameter is an \code{Integer}. That function will then accept any values whose type belongs
to \code{Integer}.

Abstract types can also belong to one another. For example, the \code{Integer} abstract type belongs to
the \code{Real} abstract type in Julia. 

To Julia this means that any type which belongs to \code{Integer} is more specific than a type which
belongs to \code{Real} but not to \code{Integer}.

This gives Julia a very powerful means of providing genericity. One can provide two versions of a
function, one which works only with an \code{Integer} and one which works with any \code{Real}.

If a machine integer is passed to such a generic function, Julia will determine the most specific
version of the function that applies. In this case the \code{Integer} version would be called.

If some other number is passed, which is not an integer, Julia falls back to the less specific version,
namely the \code{Real} version of the function.

Of course, one can also provide an even more specific implementation which only works for one specific
type, as opposed to an entire type class. Julia will take this as being even more specific and will call
this preferentially over the less specific versions of the function, if it applies.

\subsection{Gotchas with Julia}

Like all languages, Julia has some design decisions and gotchas that new users should be aware of. We
provide an incomplete list of these below.

\subsubsection{1-indexed arrays}

All Julia arrays are indexed starting with $1$, i.e. \code{A[1]} is the first entry, not \code{A[0]}.

This is a deliberate, long standing design decision in Julia. Many mathematical papers make use of
1-based indexing for matrices and the like. 

Some other computer algebra packages, such as Pari/GP make use of the same convention as Julia. 

Experience shows that it rarely takes more than a couple of days to get used to when coming from a
language that uses the other convention.

\subsubsection{Bignums}

Julia provides a built-in multiple precision integer type (using GMP). However for performance it also
provided native integer types.

In order to maximise performance, Julia doesn't automatically switch from native integers to bignums on
overflow. This means that if one starts off with native integers, the computation will only switch to
bignums if the programmer does that explicitly.

The main place this causes an issue is when using constant integers at the REPL. If the integers are
small enough to fit in a native machine word, then that is what will be used. If they are too large
an \code{Int128} will be used if that is big enough, otherwise a multiple precision \code{BigInt}
will be used. 

This means that one must tell Julia explicitly what kind of integer one wants, if the default is not
desired. This is similar to just about any statically typed language which provides bigints. The only
ways around it would be for Julia to only provide bigints and no native types, or to require type
annotation of all variables, either of which is not desirable.

\subsubsection{Supertypes of core types}

As we explained above, Julia provides native integer types, e.g. \code{Int} which belong to a single
type class \code{Integer}.

In a computer algebra system, we'd really like \code{Integer} to then belong to some more general
abstract type class, \code{RingElem} say.

Unfortunately, it is not possible to change the abstract type that Julia's own types and abstract types
belong to.

This will be a gotcha for users of Nemo: Julia integers do not belong to Nemo's \code{RingElem} abstract
type.

One way around this is to allow types to belong to a union type, \code{Union(Integer, RingElem)}. The
other way around it is simply to implement two versions of a function, one which accepts an
\code{Integer}, the other which accepts a \emph{RingElem}.

Fortunately, one often wants to treat integers much more specially than general ring elements, so this
doesn't cause too much of a problem in practice.

\subsubsection{Division operators}

The division functions in Julia are geared towards numerical, rather than algebraic, applications.

The main division operator \code{/} in Julia returns a floating point number when dividing integers
and the \code{div} function treats even the rationals as a model of the reals, so that \code{div(a, b)}
always returns the exact value $a/b$ (in the mathematical sense), truncated to the nearest whole
number in the direction of zero.

Julia also provides \code{//} for creating fraction objects, e.g. for creating rational fractions from
integers.

For algebraic operations, Nemo introduces an additional \code{divexact} function, which assumes you are
performing an exact division of two elements of a ring. We recommend using it exclusively, unless one
knows that one wants precisely the Julia behaviour.

\subsubsection{Multiple inheritance}

The abstract type hierarchy in Julia is one of its best features. It really makes the language
flexible and powerful.

However, at present it is only possible for a given type to belong to one abstract type (and
transitively to any abstract types that it in turn belongs to).

There are cases where it would be useful if types could belong to multiple abstract types, e.g.
\code{Inexact} and \code{RingElem} for elements that belong to inexact rings as opposed to exact 
rings.

There's currently no way around this in Julia, and so the abstract type hierarchy used by Nemo is
pretty basic.

Instead of having a multitude of abstract types, we rely on the existence of functions for specific
rings to determine what can be done with them.

For example, instead of having a \code{EuclideanDomainElem} abstract class for elements of a Euclidean
domain, we rely on the existence of the \code{gcd} function for specific rings that happen to be
Euclidean domains. If the \code{gcd} function doesn't exist, Julia will throw an exception if you
try to call a function on that ring that requires a greatest common divisor to be defined. This 
(mostly) works well in practice.

\subsubsection{Performance gotchas}

There are a number of cases where Julia will provide very poor performance, which often catch new
implementors unawares.

Firstly, Julia doesn't do jit compilation at the top level. If you simply type a series of isolated
statements into the REPL they will be interpreted, not jit compiled.

If you want to get good performance, you should put your code inside a function and call it. The jit
compilation happens at the function boundary and so if your code is inside a function it will
execute quickly.

Top level variables are also very slow to access in Julia. This is because they could change type at
any time and Julia can have no way to predict this. Therefore they aren't as fast as local variables
in functions. Type inference can guarantee that local variables always have the same type meaning that
faster code can result.

Julia provides the keyword \code{const} for top level constants. The value of such constants can't
subsequently be changed, but Julia can then rely on them having the same type (and value), and they do
not suffer from the same performance issues as top level variables.

\section{Installing Nemo}

There are currently two steps to installing Nemo: install Julia-0.4 and use the Julia
package system to install Nemo.

To install Julia, please refer to the installation instructions on the Julia website
(\url{http://julialang.org/}).

On Ubuntu, if you have root access, you can simply add a ppa and use apt-get. E.g. on
my system it was as follows

\begin{verbatim}
sudo add-apt-repository ppa:staticfloat/juliareleases
sudo apt-get update
sudo apt-get install julia
\end{verbatim}

Once Julia-0.4 is installed, start up Julia (type \code{julia} at the command 
line/shell prompt).

Now you can clone, build and test Nemo as follows:

\begin{verbatim}
Pkg.clone("https://github.com/wbhart/Nemo.git")
Pkg.build()
Pkg.test("Nemo")
\end{verbatim}

The tests should only take a few seconds to a minute to run per module, depending on
the speed of your machine. 

If you encounter bugs in Nemo, please report them to \url{nemo-devel@googlegroups.com}.

\section{Using Nemo}

Julia has a module system, and we use it to provide access to Nemo.

At present there is a single module, called \code{Nemo}. To import it and use all
exported functionality simply type

\begin{lstlisting}
using Nemo
\end{lstlisting}

\section{Nemo fundamentals}

Nemo provides both generic algorithms and types, and wrappers of implementations and native types
provided by various C/C++ libraries, such as Flint, Pari, Antic, etc.

For example, there are Flint polynomial types, Pari polynomials types, etc., but also a generic
polynomial type whose coefficients can be in any Nemo ring (e.g. another polynomial ring, or a residue
ring, etc.).

Many of the generic algorithms in Nemo are specialised for working over fields. For example, different
algorithms are used when computing greatest common divisors of polynomials over more general rings 
(where it makes sense) and polynomials over fields.
 
Some Nemo objects don't belong to either rings or fields, e.g. general $m\times n$ matrices belong to
matrix spaces, which are neither rings nor fields.

\subsection{Parent objects and Nemo type classes}

We call the ring or field or space that a Nemo arithmetic object belongs to, its \emph{parent}.

Parents are implemented in Nemo as objects. For example, there is an object corresponding to the ring
of integers as implemented by Flint, namely the unique parent object of type \code{FlintIntegerRing}.

A function named \code{parent} can be used to determine the parent of any arithmetic object in Nemo. In
many cases, the arithmetic objects themselves contain pointers to their parent object.

A parent can be thought of as a kind of \emph{mathematical type}. For example, elements of $\Z/5/Z$ and
elements of $\Z/7\Z$ have the same Julia type but different parents. The Julia type only encodes the
fact that we are working in a residue ring of the integers, but the parents encode the fact that we are
working in two different rings $\Z/5\Z$ and $\Z/7\Z$. One of the parent objects will contain the modulus
$5$, the other will contain the modulus $7$.

Both Nemo arithmetic objects and parent objects have types, and these types belong to various abstract
types defined by Nemo.

At the highest level of the Nemo type hierarchy are the abstract types for the parent objects, namely
\code{Collection}, \code{Ring} and \code{Field}. Corresponding to these are the abstract types for the
corresponding arithmetic objects themselves: \code{CollectionElem}, \code{RingElem}, \code{FieldElem}.

Thus, a polynomial would have a type that belonged to \code{RingElem} and its parent would have a type
that belonged to \code{Ring}.

Actually, the abstract type hierarchy is a bit richer than this. In fact we have a number of more
refined abstract types: \code{PolyElem}, \code{SeriesElem} and \code{ResidueElem} are abstract types
that all belong to \code{RingElem}; \code{FractionElem} is an abstract type that belongs to
\code{FieldElem}; and \code{MatElem} belongs to \code{CollectionElem}.

So in fact, polynomials have types that belong to \code{PolyElem} which in turn belongs to
\code{RingElem}.

\subsection{Basic integer and rational rings}

Before one can build generic rings over other rings, one needs a starting point on which to build.

For this purpose, Nemo provides wrappers of various C libraries, such as Flint and Pari, which have
implementations of basic rings such as the integers and rationals.

Nemo provides some convenient names for the parent objects for these basic rings. Thus, \code{ZZ} is
the name of the parent object for the ring of integers and \code{QQ} is the parent object for the
rationals.

Parent objects are callable in Nemo. They can be used to create objects with that parent. For example,
\code{ZZ(2)} creates the integer $2$ and \code{QQ(2, 3)} creates the rational $2/3$.

By default, Nemo makes \code{ZZ} an alias for the unique parent object of type \code{FlintIntegerRing}
and \code{QQ} is an alias for the unique parent object of type \code{FlintRationalField}.

Once we have these basic rings we can build up more generic rings with these as base.

Flint also provides other basic rings such as padic rings and finite fields. 

\subsection{Nemo domains}

As \code{ZZ} and \code{QQ} are just variables, they can be reassigned by the user. Therefore one can
change \code{ZZ} to be the unique object of type \code{PariIntegerRing} or \code{QQ} to be the unique
object of type \code{PariRationalField}. If one then builds up a generic ring over \code{ZZ} for
example, it would then be implemented using Pari integers instead of Flint integers.

In Nemo we call the underlying system that is used to implement the basic rings the \code{domain}. One
might select a different domain to the default one for performance reasons or because of the available
functionality for that domain, or maybe because one wishes to work predominantly with one package
instead of another. 

This system of domains gives the user good control over the implementation used and allows the user to
more easily tell which external library is responsible for the underlying implementation of their code.
This allows the user to more easily credit (or blame) external implementations.

Currently, for ease of use, we do allow maximal orders of number fields to be built from Antic number
fields, even though Pari provides the underlying implementation of maximal orders and their ideals. This
reflects the fact that Antic is very new and currently doesn't perform such computations.

Below we discuss each of the parent types and object types available in Nemo and list all the functions
available for each, with examples.

\section{Generic rings}

Internally, Nemo defines an abstract type for rings, with the following line of code:

\begin{lstlisting}
abstract Ring
\end{lstlisting}

You can check (or assert) that a given type belongs to \code{Ring} with the
\code{<:} operator. For example, we can check that the type of Nemo's \code{ZZ} parent object belongs
to \code{Ring}

\begin{lstlisting}
typeof(ZZ) <: Ring
\end{lstlisting}

Nemo will return \code{true}, indicating that the type of \code{ZZ} does belong to \code{Ring}.

Note that \code{<:} can only be used to determine if a type (or abstract type) belongs to an abstract
type. Thus \code{ZZ} does not belong to \code{Ring} since \code{ZZ} is not a type but a mathematical
parent object.

An element of a ring has a type that belongs to \code{RingElem}. For example, polynomials and integers
have types that belong to \code{RingElem}.

For example the following code will return true:

\begin{lstlisting}
typeof(ZZ(1)) <: RingElem
\end{lstlisting}

\subsection{Generic polynomials ($T[x]$)}

Nemo has a parametric polynomial type (called \code{Poly}) for generic polynomials over
a ring $T$. There's not any need to deal directly with the \code{Poly} type, as we
provide a function \code{PolynomialRing} for constructing it.

The \code{Poly} type takes a parameter, namely the type of ring element that the
coefficients will have, e.g. if there was no special type for Flint polynomials over the
integers, the type of polynomials over the integers would be \code|Poly{fmpz}|.

Generic polynomials have parent \code{PolynomialRing}, which is also parameterised by the
type of the ring element of the polynomial coefficients, the same as the \code{Poly}
type is.

We have that \code{PolynomialRing} belongs to the \code{Ring} type class and \code{Poly}
belongs to the \code{PolyElem} type class which in turn belongs to the \code{RingElem}
type class.

To get the parent object for the coefficient ring we can call the \code{base_ring}
function. It accepts either a polynomial or a polynomial parent object.

We can also get a symbol representing the name of the variable (as it will print) of
a polynomial ring.

For example we have:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

base_ring(S) == R
var(S) == :y
\end{lstlisting}

\subsubsection{Constructors}

Because dealing with the Julia types directly is somewhat messy, we provide a simple
function to create the parent of a polynomial in Nemo.

\begin{lstlisting}
PolynomialRing{T <: Ring}(::T, s::String)
\end{lstlisting}

\desc{This function takes a parent object which belongs to the \code|Ring| class 
(e.g. \code|T = ZZ|), specifying the ring that the polynomial coefficients are to 
belong to, and a \code{String} giving the string representation of a variable (e.g. 
\code|"x"|). It returns a tuple \code|(R, x)| consisting of the parent of the polynomial
ring being constructed, \code|R|, and the degree $1$ polynomial \code|x| in this ring.}

This is easier to understand by giving an example

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = (x^2 + 2x + 1)*y^3 + (x - 1)*y + 4x - 1
\end{lstlisting}

Notice that we can build up polynomials from the degree one polynomials \code{x} and
\code{y} returned by the calls to \code{PolynomialRing}. 

Another thing to note is that there is no reason why the variable name \code{x} has
to be the same as the string \code{"x"}. The latter is simply how \code{x} will print
when we evaluate it. Of course, in most situations it is convenient to use the same 
letter for the variable and for the string.

Once we have constructed a polynomial ring as above, we can use it to construct
polynomials of various kinds.

This is achieved by making the parent object of the polynomial ring callable. In the
following we assume that \code{S} is a parent object of a polynomial ring, e.g.
created by the following:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

The parent object \code{S} is made callable in Nemo by overloading the Julia
\code{call} operator for polynomial ring parent objects. The type \code{T}
below will refer to the type of the polynomial coefficients.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Construct a polynomial of length $0$ in the given polynomial ring.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Construct a polynomial of length $1$ whose constant coefficient is $a$ if
$a \neq 0$, otherwise construct the zero polynomial.}

\begin{lstlisting}
S(a::Array{T, 1})
\end{lstlisting}

\desc{Construct a polynomial whose coefficients are given by the elements of the array
\code{a}, starting with the constant coefficient at index $1$. The array must be fully
initialised, otherwise an exception may result.}

\begin{lstlisting}
S(a::Poly{T})
\end{lstlisting}

\desc{Return a reference to the polynomial \code{a}.}

\begin{lstlisting}
S{R <: Ring}(a::R)
\end{lstlisting}

\desc{Try to convert the value \code{a} to the polynomial type parameterised by 
\code{T} and the symbol, if possible, and return the value, else raise an error. 
This constructor is used to coerce polynomials and coefficients from subordinate rings
up into the polynomial ring.}

\textbf{Examples.}

Here are some examples of these constructors in action. Note that we don't actually
ever need to deal with the parameterised \code{Poly} type directly.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(S, "z")

f = x^2 + y^3 + z + 1

g = S(2)

h = S(x^2 + 2x + 1)

j = T(x + 2)

k = S([x, x + 2, x^2 + 3x + 1])

l = S(k)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
degree{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the degree of the polynomial $a$. We define the degree of the zero
polynomial to be $-1$.}

\begin{lstlisting}
length{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the length of the polynomial $a$, i.e. its degree plus one.}

\begin{lstlisting}
normalise{T <: RingElem}(a::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial $a$ assuming its unnormalised
length is \code{len}. A polynomial is normalised if it is either length $0$ or its
leading coefficient is nonzero. This function is usually used internally.}

\begin{lstlisting}
coeff{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the degree $n$ term of the polnomial $a$, or zero
if it has none.}

\begin{lstlisting}
lead{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the leading coefficient of the polynomial $a$, or zero if $a$ has
length $0$.}

\begin{lstlisting}
iszero{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the additive identity of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the multiplicative identity
of the polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isgen{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the generator (variable) of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is invertible, i.e. is of length
$1$ and has invertible constant coefficient, otherwise return \code{false}.}

\begin{lstlisting}
zero{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the additive identity $0$ in the given polynomial ring.}

\begin{lstlisting}
one{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the multiplicative identity $1$ in the given polynomial ring.}

\begin{lstlisting}
gen{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the generator (variable) of the given polynomial ring.}

\begin{lstlisting}
canonical_unit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns
\code{canonical_unit} of the leading coefficient.}

\begin{lstlisting}
deepcopy{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Make a new polynomial which is arithmetically equal to $a$.}

\textbf{Examples.}

Here are some examples of the basic manipulation functions.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

a = zero(S)
b = one(S)
c = gen(S)
d = isunit(b)

f = x^2*y + 2x + 1
g = lead(f)

h = x*y^2 + (x + 1)*y + 3
j = coeff(h, 2)

if isgen(y)
   println(y, " is the generator of the ", parent(y))
end

k = isone(b)
m = iszero(a)

n = canonical_unit(-x*y + x + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators are provided for polynomials. Note that
if both operands are not in the same polynomial ring, Nemo will try to
coerce them into one of the two rings before applying the operation.

\begin{lstlisting}
+{T <: RingElem}(a::Poly{T}, b::Poly{T})
-{T <: RingElem}(a::Poly{T}, b::Poly{T})
*{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
n = f*g
p = f + g
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are faster than first coercing all
operands into the polynomial ring.

\begin{lstlisting}
*{T <: RingElem}(x::Poly{T}, y::Int)
*{T <: RingElem}(x::Poly{T}, y::fmpz)
*{T <: RingElem}(x::Int, y::Poly{T})
*{T <: RingElem}(x::fmpz, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = g - 4
k = fmpz(5) - g
l = f*7
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Poly{T})
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

\begin{lstlisting}
isequal(x::Poly{T}, y::Poly{T})
\end{lstlisting}

\desc{Returns \code{true} if \code{x == y} and if each coefficient of \code{x}
matches the corresponding coefficient of \code{y} according to \code{isequal},
when applied recursively, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3

if f == g
   println("f is equal to g")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing the arguments
into one or the other ring.

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Integer)
=={T <: RingElem}(x::Integer, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here is an example of ad hoc comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

if S(1) == 1
   println("S(1) is equal to ZZ(1)")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = -f
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a$ truncated to length $n$. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
mullow{T <: RingElem}(a::Poly{T}, b::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial \code{a*b} truncated to length $n$. If $n < 0$ we
throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncated operations.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
\end{lstlisting}

\subsubsection{Reversal}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, thought of as a polynomial of
the given length (the polynomial will be notionally truncated or padded with
zeroes before the leading term if necessary to match the specified length). 
The resulting polynomial is normalised. If \code{len} is negative we throw a
\code{DomainError()}.}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T})
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, i.e. the leading coefficient
of $x$ becomes the constant coefficient of the result, etc. The resulting
polynomial is normalised.}

\textbf{Examples.}

Here are some examples of reversal.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the left by $n$ places, i.e. $f\times x^n$ where $x$ is the
generator of the polynomial ring that $f$ belongs to. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
shift_right{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the right by $n$ places, i.e. by dividing $f$ by $x^n$ and
throwing away the remainder. If $n$ is greater than or equal to the length of
$x$ then the zero polynomial results. If $n < 0$ we throw a 
\code{DomainError()}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a^n$. If $n < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = f^5
\end{lstlisting}

\subsubsection{Modular arithmetic}

When we have polynomials over residue rings or fields, we can reduce modulo
a polynomial over the base ring. In this way we can do modular arithmetic with
polynomials.

\begin{lstlisting}
mulmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, 
                                          b::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $ab \pmod{d}$.}

\begin{lstlisting}
invmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $a^{-1} \pmod{d}$. If an impossible inverse is encountered, an
exception is thrown.}

\begin{lstlisting}
powmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, b::Int, 
                                                         d::Poly{T})
\end{lstlisting}

\desc{Return $a^b \pmod{d}$.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}. 

If \code{T} is a residue ring and the leading coefficient of $b$ is not invertible
in the \code{T}, an error will be thrown.} 

\textbf{Examples.}

Here is an example of exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(f*g, f)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::T)
divexact{T <: RingElem}(a::Poly{T}, b::Integer)
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(3*f, 3)
k = divexact(x*g, x)
\end{lstlisting}

\subsubsection{Euclidean division}

Over a residue ring we can define Euclidean division.

\begin{lstlisting}
mod{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean remainder of $f$ divided by $g$, i.e. $r$ such 
that $a = bq + r$ for some polynomial $r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
divrem{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean quotient and remainder of $f$ divided by $g$, i.e.
a tuple \code{(q, r)} such that $a = bq + r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of Euclidean division.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, "y")

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
\end{lstlisting}

\subsubsection{Pseudodivision}

Given two polynomials $a, b$, pseudodivision computes polynomials $q$ and $r$
with length$(r) <$ length$(b)$ such that
$$L^d a = bq + r,$$
where $d =$ length$(a) -$ length$(b) + 1$ and $L$ is the leading coefficient
of $b$.

We call $q$ the pseudoquotient and $r$ the pseudoremainder.

\begin{lstlisting}
pseudorem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the pseudoremainder of $a$ divided by $b$. If $b = 0$ we throw a 
\code{DivideError()}.}

\begin{lstlisting}
pseudodivrem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the pseudoquotient and pseudoremainder 
of $a$ divided by $b$. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of pseudodivision.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
\end{lstlisting}

Note that pseudodivision is not always useful. In general it computes a
multiple of the quotient, and for example in the case of polynomials over a
residue ring, this may lead to meaningless results in the presence of zero
divisors. For example

\begin{lstlisting}
R = ResidueRing(ZZ, 6)
S, x = PolynomialRing(R, "x")

f = 3*x^5 + x^4 + 3*x^2 + 2
g = 2*x^3 + 5*x^2 + 2*x + 2

pseudorem(f, g)
\end{lstlisting}

Here Nemo returns \code{3*x^2}, which happens to be \code{3*g} in this
ring.

\subsubsection{Content, primitive part, GCD and LCM}

When the base ring provides a \code{gcd} function we can provide numerous
GCD related functions for polynomials over that ring.

\begin{lstlisting}
content{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the content of the polynomial $a$, i.e. the greatest common divisor
of all its coefficients, if this exists.}

\begin{lstlisting}
primpart{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the primitive part of the polynomial $a$, i.e. the polynomial
divided by its content, if it exists.}

\begin{lstlisting}
gcd{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $a$ and $b$ if 
it exists.}

\begin{lstlisting}
lcm{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the least common multiple of the polynomials $a$ and $b$. We
define lcm$(a, b) = ab/$gcd$(a, b)$.}

We allow GCD for polynomials over residue rings, e.g. over $\Z/n\Z$, even when
the residue ring has zero divisors. However, if an impossible inverse is
encountered during the computation, due to zero divisors, we throw an error.

\begin{lstlisting}
gcdinv{T <: Union(Field, Residue), S}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(g, s)$ such that $g$ is the gcd of $a$ and $b$ and $s$
and $t$ are polynomials such that $g = as + bt$. The value $g$ will be $1$ if
$a$ is invertible modulo $b$.}

\textbf{Examples.}

Here are some examples of content, primitive part and GCD.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1

n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
r = lcm(k*m, l*m)

R, x = PolynomialRing(QQ, "x")
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, "z")

r = z^3 + 2z + 1
s = z^5 + 1
u, v = gcdinv(r, s)
\end{lstlisting}

\subsubsection{Evaluation}

\begin{lstlisting}
evaluate{T <: RingElem}(a::Poly{T}, b::T)
evaluate{T <: RingElem}(a::Poly{T}, b::Integer)
\end{lstlisting}

\desc{Return the value of the polynomial $a$ evaluated at $b$.}

\textbf{Examples.}

Here are some examples of evaluation.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = evaluate(f, 3)
h = evaluate(f, x^2 + 2x + 1)
\end{lstlisting}

\subsubsection{Composition}

\begin{lstlisting}
compose{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the composition of the polynomial $a$ with $b$, i.e. $a \circ b$.}

\textbf{Examples.}

Here are some examples of composition.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = compose(f, g)
\end{lstlisting}

\subsubsection{Derivative}

\begin{lstlisting}
derivative{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the derivative of the polynomial $a$ with respect to its main
variable.}

\textbf{Examples.}

Here are some examples of computing derivatives.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

h = x*y^2 + (x + 1)*y + 3
j = derivative(h)
\end{lstlisting}

\subsubsection{Integral}

\begin{lstlisting}
integral{T <: Union(ResidueElem, FieldElem)}(f::Poly{T})
\end{lstlisting}

\desc{Return the integral of the polynomial $f$. The constant coefficient of
the result is taken to be $0$.}

\textbf{Examples.}

Here are some examples of computing integrals.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (x^2 + 2x + 1)*y^2 + (x + 1)*y - 2x + 4

g = integral(f)   
\end{lstlisting}

\subsubsection{Resultant}

\begin{lstlisting}
resultant{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the resultant of the polynomials $a$ and $b$.}

\textbf{Examples.}

Here are some examples of computing resultants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
h = resultant(f, g)
\end{lstlisting}

\subsubsection{Discriminant}

\begin{lstlisting}
discriminant{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Compute the discriminant of the polynomial $a$.}

\textbf{Examples.}

Here are some examples of computing discriminants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = discriminant(f)
\end{lstlisting}

\subsubsection{Bezout identity}

The Bezout identity is the equivalent, for polynomials, of the extended GCD
in the case of the integers.

Given polynomials $a, b$, we can find polynomials $s, t$ such that
$$sa + bt = r,$$
where $r$ is the resultant of $a$ and $b$.

\begin{lstlisting}
bezout{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(r, s, t)$ such that $r$ is the resultant of $a$ and $b$
and with polynomials $s, t$ such that $r = as + bt$.}

\textbf{Examples.}

Here are some examples of computing the Bezout identity.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
r, s, t = gcdx(f, g)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials. It is expected
that the final argument in each of these function is the generator of the polynomial ring.

\begin{lstlisting}
chebyshev_t(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
\end{lstlisting}

\section{Flint rings}

Flint provides implementations of various explicit rings. These are used instead of generic
implementations where available.

We only describe the details that differ from the generic implementations above.

\subsection{Integers : Flint fmpz}

Multi-precision integers can be created in Nemo using \code{ZZ}. For example, to create the integer
$123$ one can write:

\begin{lstlisting}
ZZ(123)
\end{lstlisting}

By default, \code{ZZ} creates objects of the Flint \code{fmpz} type. This is achieved internally by
setting \code{ZZ = FlintIntegerRing()}, which makes \code{ZZ} the unique object of type
\code{FlintIntegerRing}.

One can also create Flint integers using the \code{fmpz} constructor directly:

\begin{lstlisting}
fmpz(123)
\end{lstlisting}

In Nemo library code we use \code{fmpz} rather than \code{ZZ} since the latter is defined only for the
convenience of the user and its definition may be changed by the user. It is also slightly more
efficient to call \code{fmpz} directly, since \code{ZZ} is a global variable.

The type of an \code{fmpz} object is \code{fmpz}. Thus the following returns \code{Nemo.fmpz}:

\begin{lstlisting}
typeof(fmpz(123))
\end{lstlisting}

An object of this type corresponds directly to the Flint \code{fmpz} C type.

The parent of an \code{fmpz} object is the unique object of type \code{FlintIntegerRing}. Thus the
following returns ``Integer Ring'':

\begin{lstlisting}
parent(fmpz(123))
\end{lstlisting}

The \code{FlintIntegerRing} type belongs to the \code{Ring} type class and the \code{fmpz} type
belongs to the \code{RingElem} type class. Thus both of the following return true:

\begin{lstlisting}
fmpz <: RingElem
FlintIntegerRing <: Ring
\end{lstlisting}

\subsubsection{Constructors}

Nemo provides various constructors for the \code{fmpz} type. Space is automatically
recovered when the created object goes out of scope.

\begin{lstlisting}
fmpz()
\end{lstlisting}

\desc{Creates an initialised \code{fmpz}. Its value will be $0$.}

\begin{lstlisting}
fmpz(n::Int)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given signed machine word value $n$.}

\begin{lstlisting}
fmpz(n::BigInt)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given Julia \code{BigInt} value $n$.}

\begin{lstlisting}
fmpz(n::Integer)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given value $n$, where $n$ has any type belonging to the Julia
\code{Integer} type class.}

\begin{lstlisting}
fmpz(n::Float16)
fmpz(n::Float32)
fmpz(n::Float64)
fmpz(n::BigFloat)
\end{lstlisting}

\desc{If $n$ is an exact integer, return the \code{fmpz} with the value $n$, otherwise raise an
\code{InexactError}.}

\begin{lstlisting}
fmpz(s::String)
\end{lstlisting}

\desc{Create an \code{fmpz} whose value is represented (in decimal) by the given string
$s$. The string should not contain any whitespace, and can optionally begin with
a $-$ sign.}

\begin{lstlisting}
fmpz(x::fmpz)
\end{lstlisting}

\desc{Returns a reference to $x$. No copy of the data is made.}

\begin{lstlisting}
deepcopy(x::fmpz)
\end{lstlisting}

\desc{Create a new \code{fmpz} whose value is arithmetically equal to that of $x$.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12.0)
c = fmpz("-1234567876545678376545678900000000000000000000000000")
d = fmpz(BigFloat(10)^100)
e = fmpz(c)
f = deepcopy(c)
\end{lstlisting}

\subsubsection{Conversions}

It is possible to convert \code{fmpz} values to a variety of other types. This is
achieved by overloading Julia's \code{convert} function.

\begin{lstlisting}
Int(x::fmpz)
UInt(x::fmpz)
BigInt(x::fmpz)
Float64(x::fmpz)
Float32(x::fmpz)
Float16(x::fmpz)
BigFloat(x::fmpz)
\end{lstlisting}

\desc{Convert the \code{fmpz} $x$ to the given type.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12)

c = Int(a)
d = UInt(b)
f = Float64(a)
g = BigFloat(a)
\end{lstlisting}


\subsubsection{Basic manipulation}

Various functions are provided to do basic manipulations of \code{fmpz}'s.

\begin{lstlisting}
one(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the multiplicative identity element in the ring of integers.}

\begin{lstlisting}
zero(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the additive identity element in the ring of integers.}

\begin{lstlisting}
isone(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the multiplicative identity $1$, otherwise
return \code{false}.}

\begin{lstlisting}
iszero(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the additive identity $0$, otherwise
return \code{false}.}

\begin{lstlisting}
isunit(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a = 1$ or $a = -1$, otherwise return \code{false}.}

\begin{lstlisting}
sign(a::fmpz)
\end{lstlisting}

\desc{Return either $-1$, $0$ or $1$ depending on whether the sign of $a$ is negative,
zero or positive, respectively. The returned value is of type \code{Int}.}

\begin{lstlisting}
fits(::Type{Int}, a::fmpz)
fits(::Type{Uint}, a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the value $a$ will fit into a variable of the given
type. Otherwise return \code{false}.}

\begin{lstlisting}
size(a::fmpz)
\end{lstlisting}

\desc{Return the number of machine words that make up the bignum $a$. The
returned value has type \code{Int}.}

\begin{lstlisting}
canonical_unit(a::fmpz)
\end{lstlisting}

\desc{This is used for canonicalising fractions. The function simply returns $-1$
if $a < 0$, otherwise it returns $1$.}

\begin{lstlisting}
num(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Simply returns the value of \code{a}.}

\begin{lstlisting}
den(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Always returns \code{fmpz(1)}.}

\textbf{Examples.}

Here are some examples of the above basic manipulations.

\begin{lstlisting}
a = one(FlintIntegerRing()) # by default one(ZZ) is the same thing 
b = zero(FlintIntegerRing()) # by default zero(ZZ) is the same thing 

if sign(a) < 0
   println("Negative")
end

if fits(Int, a)
   println("Fits into an Int")
end

s = size(a)

t = canonical_unit(fmpz(-12))

u = isunit(fmpz(-1))
v = iszero(b)
w = isone(a)
\end{lstlisting}

\subsubsection{Binary operators}

The following standard binary operators are provided for \code{fmpz}. Note that \code{$} is Julia's
xor operator.

\begin{lstlisting}
+(a::fmpz, b::fmpz)
-(a::fmpz, b::fmpz)
*(a::fmpz, b::fmpz)
%(a::fmpz, b::fmpz)
&(a::fmpz, b::fmpz)
|(a::fmpz, b::fmpz)
$(a::fmpz, b::fmpz)
\end{lstlisting}

Note that \code{%} follows the C (and Julia) convention of rounding the quotient
towards zero. If $b = 0$ is passed to \code{%}, a \code{DivideError()} is thrown.

Julia automatically provides all of the combined assignment operators \code{+=, *=, &=}
etc.

Here are some examples of binary operators.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(26)

c = a + b
d = a - b
\end{lstlisting}

\subsubsection{Integer division}

Various kinds of integer division are provided.

\begin{lstlisting}
fdiv(a::fmpz, b::fmpz)
cdiv(a::fmpz, b::fmpz)
tdiv(a::fmpz, b::fmpz)
div(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Integer division with rounding towards $-\infty$, $+\infty$ and $0$ respectively.
Note \code{div} is a synonym for \code{tdiv}. If $b = 0$ is passed to any of these
functions, a \code{DivideError()} is thrown.}

Here are some examples of integer division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = cdiv(a, b)
d = fdiv(a, b)
\end{lstlisting}

\subsubsection{Remainder}

\begin{lstlisting}
mod(a::fmpz, b::fmpz)
mod(x::fmpz, c::Int)
rem(a::fmpz, b::fmpz)
rem(x::fmpz, c::Int)
\end{lstlisting}

\desc{Integer remainder after division with rounding towards $-\infty$ and $0$
respectively. Note that \code{\%} is a synonym for \code{rem}. If $b = 0$ is passed to 
any of these functions, a \code{DivideError()} is thrown.}

Here are some examples of the remainder functions.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = mod(a, b)
d = rem(a, 3)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::fmpz, b::fmpz)
divexact(x::fmpz, c::Int)
\end{lstlisting}

\desc{Exact integer division. This is more efficient than the above division functions,
but will only return a meaningful result if the division is exact, i.e. if $b$ divides
$a$. If $b = 0$ is passed to this function, a \code{DivideError()} is thrown.}

Here is an example of exact division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(6)

c = divexact(a, b)
c = divexact(a, 2)
\end{lstlisting}

\subsubsection{GCD and LCM}

\begin{lstlisting}
gcd(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the greatest common divisor of $a$ and $b$. For convenience, 
gcd$(a, 0) = a$ and gcd$(0, b) = b$. The returned value is always nonnegative.}

\begin{lstlisting}
lcm(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the lowest common multiple of $a$ and $b$, i.e. $ab/\gcd(a, b)$ if
$a, b > 0$. For convenience, lcm$(a, 0) = 0$ and lcm$(0, b) = 0$. The returned
value is always nonnegative.}

Here are some examples of GCD and LCM.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(15)

c = gcd(a, b)
d = lcm(a, b)
\end{lstlisting}

\subsubsection{Integer logarithms}

\begin{lstlisting}
flog(a::fmpz, b::fmpz)
flog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $0$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\begin{lstlisting}
clog(a::fmpz, b::fmpz)
clog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $\infty$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\textbf{Examples.}

Here are some examples of integer logarithms.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(3)

c = clog(a, b)
d = flog(a, 2)
\end{lstlisting}

\subsubsection{Ad hoc operators}

Since the Julia types \code{Int} and \code{Uint} cannot be made members of the
\code{Ring} class, we must define some ad hoc operators, so that values of type
\code{fmpz} can be more easily combined with \code{Int} and \code{Uint} values.

\begin{lstlisting}
+(x::fmpz, c::Integer)
+(x::fmpz, c::Int)
+(x::Integer, c::fmpz)
+(x::Int, c::fmpz)
-(x::fmpz, c::Integer)
-(x::fmpz, c::Int)
-(x::Integer c::fmpz)
-(x::Int, c::fmpz)
*(x::fmpz, c::Integer)
*(x::fmpz, c::Int)
*(x::Integer, c::fmpz)
*(x::Int, c::fmpz)
%(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of the ad hoc operators.

\begin{lstlisting}
a = fmpz(-12)

b = 3 + a
c = a + 3
d = a - 3
e = 5 - a
f = a % 7
\end{lstlisting}

\subsubsection{Ad hoc division}

We also define the following, which have the same semantics as the corresponding functions above.

\begin{lstlisting}
tdiv(x::fmpz, c::Int)
fdiv(x::fmpz, c::Int)
cdiv(x::fmpz, c::Int)
div(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of ad hoc division.

\begin{lstlisting}
a = fmpz(-12)

b = tdiv(a, 5)
c = cdiv(a, 3)
\end{lstlisting}

\subsubsection{Binary shifting}

We also define the following, which have the same semantics as the corresponding functions above.

There are also shift operators, which require the shift to be of type \code{Int}.

\begin{lstlisting}
<<(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $2^c x$.}

\begin{lstlisting}
fdivpow2(x::fmpz, c::Int)
cdivpow2(x::fmpz, c::Int)
tdivpow2(x::fmpz, c::Int)
>>(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $x/2^c$ with rounding towards $-\infty$, $+\infty$ and $0$ respectively. 
Note that \code{>>} is a synonym for \code{fdivpow2}.}

Here are some examples of binary shifting.

\begin{lstlisting}
a = fmpz(-12)

b = a << 3
c = a >> 1
d = fdivpow2(a, 2)
\end{lstlisting}

\subsubsection{Powering}

There is also the caret operator, which is used for powering in Julia (and Nemo), in
line with the mathematical convention.

\begin{lstlisting}
^(x::fmpz, a::Uint)
^(x::fmpz, a::Int)
\end{lstlisting}

\desc{Return $x^a$. Requires $a \geq 0$.}

\textbf{Examples.}

Here is an example of the caret operator.

\begin{lstlisting}
a = fmpz(-12)

b = a^10
\end{lstlisting}

\subsubsection{Comparison operators and functions}

The following standard comparison operators are provided for \code{fmpz}.

\begin{lstlisting}
==(a::fmpz, b::fmpz)
>(a::fmpz, b::fmpz)
<(a::fmpz, b::fmpz)
<=(a::fmpz, b::fmpz)
>=(a::fmpz, b::fmpz)
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

Note that all these comparisons yield a result of type \code{Bool}.

There are also the following functions.

\begin{lstlisting}
isequal(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{For \code{fmpz} this is just an alias for the \code{==} operator.}

\begin{lstlisting}
cmp(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $x < y$, $1$ if $x > y$ and $0$ if $x = y$.}

\begin{lstlisting}
cmpabs(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $|x| < |y|$, $1$ if $|x| > |y|$ and $0$ if 
$|x| = |y|$, where $|x|$ is the absolute value of $x$.}

\textbf{Examples.}

Here are some examples of the comparison operators and functions.

\begin{lstlisting}
a = fmpz(-12)
b = fmpz(5)

if a < b
   println("a < b")
end

if cmpabs(a, b) == 0
   println("The absolute values of a and b are equal")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison operators}

We overload the comparison operators to more easily deal with values of type \code{Int}.

\begin{lstlisting}
==(a::fmpz, b::Int)
==(a::Int, b::fmpz)
>(a::fmpz, b::Int)
>(a::Int, b::fmpz)
<(a::fmpz, b::Int)
<(a::Int, b::fmpz)
<=(a::fmpz, b::Int)
<=(a::Int, b::fmpz)
>=(a::fmpz, b::Int)
>=(a::Int, b::fmpz)
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc comparison operators.

\begin{lstlisting}
a = fmpz(-12)

if a < 7
   println("a < 7")
end

if a == -12
   println("a == -12")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(x::fmpz)
\end{lstlisting}

\desc{Return $-x$.}

\begin{lstlisting}
~(x::fmpz)
\end{lstlisting}

\desc{Return the bignum corresponding to logical complement of the twos 
complement representation of x, namely $-x - 1$.}

Here are some examples of the unary operators.

\begin{lstlisting}
a = -fmpz(12)
b = ~fmpz(-5)
\end{lstlisting}

\subsubsection{Absolute value}

\begin{lstlisting}
abs(x::fmpz)
\end{lstlisting}

\desc{Return the absolute value of $x$, i.e. $x$ if $x >= 0$ and $-x$ otherwise.}

\textbf{Examples.}

Here is an example of the absolute value function.

\begin{lstlisting}
a = fmpz(-12)

b = abs(a)
\end{lstlisting}

\subsubsection{Division with remainder}

\begin{lstlisting}
fdivrem(a::fmpz, b::fmpz)
tdivrem(a::fmpz, b::fmpz)
divrem(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the quotient and remainder after 
division of $x$ by $y$, with rounding towards $-\infty$ and $0$ respectively. Note 
that \code{divrem} is a synonym for \code{tdivrem}. If $b = 0$ is passed to any
of these functions a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of the division with remainder functions.

\begin{lstlisting}
q, r = fdivrem(fmpz(12), fmpz(5))
q, r = tdivrem(fmpz(12), fmpz(5))
\end{lstlisting}

\subsubsection{Roots}

\begin{lstlisting}
isqrt(x::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$, rounded down to the nearest integer. If $x < 0$
a \code{DomainError()} is thrown.}

\begin{lstlisting}
isqrtrem(x::fmpz)
\end{lstlisting}

\desc{Return a tuple $(s, r)$ consisting of the square root of $x$, rounded down to the 
nearest integer and the remainder, i.e. $r = x - s^2$. If $x < 0$ a \code{DomainError()}
is thrown.}

\begin{lstlisting}
root(x::fmpz, n::Int)
\end{lstlisting}

\desc{Return the $n$-th root of $x$, rounded down to the nearest integer. If $x < 0$ and
$n$ is even, a \code{DomainError()} is thrown. If $n \leq 0$ a \code{DomainError()} is
thrown.}

\textbf{Examples.}

Here are some examples of the root taking functions.

\begin{lstlisting}
s = isqrt(fmpz(12))
s, r = isqrtrem(fmpz(12))
r = root(fmpz(1000), 3)
\end{lstlisting}

\subsubsection{Extended GCD}

\begin{lstlisting}
gcdx(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s, t)$ consisting of the greatest common divisor of $a$ and $b$
and values $s$ and $t$ such that $g = as + bt$, with $-b \leq s \leq b$ and 
$-a \leq t \leq a$.}

\begin{lstlisting}
gcdinv(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s)$ consisting of the greatest common divisor of $a$ and $b$
and a value $0 \leq s < b$ such that there exists a value $t$ such that 
$g = as + bt$. If $a < 0$ or $b < a$, a \code{DomainError()} is thrown.}

\textbf{Examples.}

Here are some examples of the extended GCD functions.

\begin{lstlisting}
g, s, t = gcdx(fmpz(12), fmpz(5))
g, s = gcdinv(fmpz(5), fmpz(12))
\end{lstlisting}

\subsubsection{Bit twiddling}

Various functions are provided to deal with bignums on a binary bit level.

\begin{lstlisting}
popcount(x::fmpz)
\end{lstlisting}

\desc{Return the number of binary ones in the binary representation of $x$. If $x < 0$ the
function will return $0$. The result that is returned is of type \code{Int}.}

\begin{lstlisting}
prevpow2(x::fmpz)
\end{lstlisting}

\desc{Return the largest power of $2$ which does not exceed $x$. If $x < 0$ the result is
set to \code{-prevpow2(-x)}.}

\begin{lstlisting}
nextpow2(x::fmpz)
\end{lstlisting}

\desc{Return the smallest power of $2$ which is not less than $x$. If $x < 0$ the result is
set to \code{-nextpow2(-x)}.}

\begin{lstlisting}
trailing_zeros(x::fmpz)
\end{lstlisting}

\desc{Return the number of trailing zeros in the binary representation of the absolute
value of $x$.}

\begin{lstlisting}
clrbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $0$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
setbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $1$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
combit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Complement bit $n$ in the binary representation of the absolute value of $x$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\textbf{Examples.}

Here are some examples of the bit twiddling functions.

\begin{lstlisting}
a = fmpz(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)
\end{lstlisting}

\subsubsection{Alternative bases}

\begin{lstlisting}
base(n::fmpz, b::Int)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in the given base $b$. Valid
bases are $2 \leq b \leq 62$. If an invalid base is applied an error is raised.}

\begin{lstlisting}
bin(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in binary, i.e. base $2$.}

\begin{lstlisting}
oct(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in octal, i.e. base $8$.}

\begin{lstlisting}
dec(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in decimal, i.e. base $10$.}

\begin{lstlisting}
hex(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in hexadecimal, i.e. base $16$.}

\begin{lstlisting}
ndigits(n::fmpz, b::Integer = 10)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of digits required to represent the
absolute value of $n$ as a string in base $b$. The default is $b = 10$. Note that $0$
always requires one digit as a string.}

\begin{lstlisting}
nbits(n::fmpz)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of bits required to represent the
absolute value of $n$ in binary. We take the convention that $0$ requires $0$ binary 
bits.}

\textbf{Examples.}

Here are some examples of the functions for alternative bases.

\begin{lstlisting}
a = fmpz(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)
\end{lstlisting}

\subsubsection{String I/O}

\begin{lstlisting}
string(x::fmpz)
\end{lstlisting}

\desc{Return a unicode string representation of the value of $x$ in decimal, including the sign
if $x < 0$.}

\textbf{Examples.}

Here is an example of string I/O.

\begin{lstlisting}
a = fmpz(12)

string(a)
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the Euclidean remainder of $a$ by $b$. If $m = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
powmod(x::fmpz, p::Int, m::fmpz)
powmod(x::fmpz, p::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^p \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown.}

\begin{lstlisting}
invmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^{-1} \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown. If
an impossible inverse is encountered, an exception is thrown.}

\begin{lstlisting}
gcdinv(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Returns the pair \code{g, xinv} where $g$ is the greatest common divisor of
$x$ and $m$ and \code{xinv} is $x^{-1} \pmod{m}$. If $m \leq 0$ a 
\code{DomainError()} is thrown.}

\begin{lstlisting}
sqrtmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$ modulo $m$. If $m \leq 0$ a \code{DomainError()}
is thrown. If $x$ is not a square modulo $m$, an exception is thrown. Requires $m$ to
be prime. This condition is not checked and an infinite loop may result if $m$ is
not prime.}

\begin{lstlisting}
crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, sign = false)
crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, sign = false)
\end{lstlisting}

\desc{Return a value $r$ such that $r \equiv r1 \pmod {m1}$ and $r \equiv r2 \pmod{m2}$.
If \code{sign = true} the value will be in the range \code{-m1*m2/2 < r <= m1*m2/2}. If
\code{sign = false} the value will be in the range \code{0 <= r < m1*m2}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = powmod(fmpz(12), fmpz(110), fmpz(13))
a = powmod(fmpz(12), 110, fmpz(13))
b = invmod(fmpz(12), fmpz(13))
c = sqrtmod(fmpz(12), fmpz(13))
d = crt(fmpz(5), fmpz(13), fmpz(7), fmpz(37), true)
\end{lstlisting}

\subsubsection{Number theoretic/combinatorial functions}

\begin{lstlisting}
divisible(x::fmpz, y::fmpz)
divisible(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return \code{true} if $x$ is divisible by $y$, otherwise return \code{false}. If
$y = 0$ a \code{DivideError()} is raised.}

\begin{lstlisting}
issquare(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is a perfect square, otherwise return \code{false}.}

\begin{lstlisting}
isprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is prime, otherwise return \code{false}.}

\begin{lstlisting}
isprobabprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is very probably prime, otherwise return \code{false}.}

\begin{lstlisting}
remove(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Returns a pair $(n, z)$ where $n$ is an \code{Int} and $z$ a \code{fmpz} such that
$x = y^nz$ and $z$ is not divisible by $y$. If $y = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)
\end{lstlisting}

\desc{If $n$ has a factor which lies in the residue class $r \pmod{m}$ for $0 < r < m < n$,
this function returns such a factor. Otherwise it returns $0$. This is only efficient if 
$m$ is at least the cube root of $n$. We require gcd$(r, m) = 1$ and this condition is not
checked.}

\begin{lstlisting}
fac(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the factorial of $n$, i.e. $n(n - 1)(n - 2)\ldots 1$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
risingfac(x::fmpz, n::Int)
risingfac(x::Int, n::Int)
\end{lstlisting}

\desc{Return the rising factorial of $x$, i.e. $x(x + 1)(x + 2)\ldots (x + n - 1)$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
primorial(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the primorial of $n$, i.e. the product of all primes
less than or equal to $n$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
fib(n::Int)
\end{lstlisting}

\desc{Return the $n$-th element of the Fibonacci sequence, starting with 
\code{fib(1) = 1}, \code{fib(2) = 1} and following the recursion 
\code{fib(n) = fib(n - 1) + fib(n - 2)} for $n \geq 3$.
We return fib$(0) = 0$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
binom(n::Int, k::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the binomial coefficient $\frac{n!}{(n - k)!k!}$. If
$n, k < 0$ or $k > n$ we return $0$.}

\begin{lstlisting}
moebiusmu(x::fmpz)
\end{lstlisting}

\desc{Returns the M\"{o}bius mu function of $x$ as an \code{Int}. The value returned is
either $-1$, $0$ or $1$. If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
jacobi(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the value of the Jacobi symbol $\ljk{x}{y}$. If $y \leq x$ or $x < 0$ we
throw a \code{DomainError()}.}

\begin{lstlisting}
sigma(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return the value of the sigma function, i.e. $\sum_{0 < d \;| x} d^y$. If $y < 0$
we throw a \code{DomainError()}.}

\begin{lstlisting}
eulerphi(x::fmpz)
\end{lstlisting}

\desc{Return the value of the Euler phi function, i.e. the number of $0 < d \leq x$ such
that gcd$(d, x) = 1$. If $x < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of number theoretic and combinatorial functions.

\begin{lstlisting}
if isprime(fmpz(13))
   println("13 is prime")
end

n = fac(100)
s = sigma(fmpz(128), 10)
a = eulerphi(fmpz(12480))
\end{lstlisting}

\subsection{Flint integer polynomials ($\Z[x]$): fmpz_poly}

The Flint integer polynomial type is \code{fmpz_poly}. Polynomials of this type are created
using the \code{PolynomialRing} constructor.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpzPolyRing}.

We describe functions for \code{fmpz_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided, as these are faster than first coercing
to a common ring and then applying the operator.

\begin{lstlisting}
+(x::fmpz_poly, y::Int)
+(x::fmpz_poly, y::fmpz)
+(x::Int, y::fmpz_poly)
+(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::fmpz_poly, y::Int)
-(x::fmpz_poly, y::fmpz)
-(x::Int, y::fmpz_poly)
-(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1
g = x^2 - 7x + 4

h = f + 7
k = g - 7
l = fmpz(3) + f
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

\begin{lstlisting}
==(x::fmpz_poly, y::fmpz)
==(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return \code{true} if $x == y$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

f != fmpz(6)
fmpz(7) == R(7)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fmpz_poly, y::Int)
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

g = divexact(f*3, 3)
\end{lstlisting}

\subsubsection{Content, primitive part and GCD}

\begin{lstlisting}
content(f::fmpz_poly)
\end{lstlisting}

\desc{Return the content of the polynomial $f$, i.e. the greatest common divisor of its
coefficients.}

\begin{lstlisting}
primpart(f::fmpz_poly)
\end{lstlisting}

\desc{Return the primitive part of the polynomial $f$, i.e. the polynomial divided by
its content.}

\begin{lstlisting}
gcd(f::fmpz_poly, g::fmpz_poly)
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $f$ and $g$.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = x + 1

k = content(3*f)
l = primpart(3*f)
m = gcd(f*h, g*h)
\end{lstlisting}

\subsubsection{Signature}

\begin{lstlisting}
signature(f::fmpz_poly)
\end{lstlisting}

\desc{Computes the signature of the polynomial $f$, i.e. a tuple $(r, s)$ where $r$ is
the number of real roots and $s$ is half the number of complex roots.}

\textbf{Examples.}

Here is an example of signature.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 3x + 1

(r, s) = signature(f)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials over \code{fmpz}. It is expected
that the final argument in each of these function is the generator of the polynomial ring.

\begin{lstlisting}
chebyshev_t(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\begin{lstlisting}
cyclotomic(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $n$th cyclotomic polynomial, defined as
$$\Phi_n(x) = \prod_{\omega} (x-\omega),$$ where $\omega$ runs over all the 
$n$th primitive roots of unity.}

\begin{lstlisting}
swinnerton_dyer(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Swinnerton-Dyer polynomial $S_n$, defined as the integer 
polynomial $$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3}
\pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$$ where $p_n$ denotes the $n$-th prime 
number and all combinations of signs are taken. This polynomial has degree $2^n$
and is irreducible over the integers (it is the minimal polynomial of 
$\sqrt{2} + \ldots + \sqrt{p_n}$)}

\begin{lstlisting}
cos_minpoly{S}(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the minimal polynomial of $2 \cos(2 \pi / n)$. For suitable choice of 
$n$, this gives the minimal polynomial of $2 \cos(a \pi)$ or $2 \sin(a \pi)$ for any
rational $a$.}

\begin{lstlisting}
theta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Jacobi theta function raised to 
the power $r$, i.e. $\vartheta(q)^r$ where 
$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$.}

\begin{lstlisting}
eta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Dedekind eta function (without 
the leading factor $q^{1/24}$) raised to the power $r$, i.e. $(q^{-1/24} \eta(q))^r 
= \prod_{k=1}^{\infty} (1 - q^k)^r$.

In particular, $r = -1$ gives the generating function of the partition function $p(k)$, 
and $r = 24$ gives, after multiplication by $q$, the modular discriminant $\Delta(q)$ 
which generates the Ramanujan tau function $\tau(k)$.}

\textbf{Examples.}

Here are some examples of computing special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = chebyshev_t(20, x)
g = chebyshev_u(15, x)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
\end{lstlisting}

\subsection{Residue rings}

Nemo allows the construction of residue rings. 

There are two examples to keep in mind:

\begin{enumerate}
\item $\Z/n\Z$ for some positive integer $n$

\item $\Q[x]/(f)$ where $f$ is a polynomial in $\Q[x]$.
\end{enumerate}

Currently we only allow construction of residue rings of the form $R/(r)$ where
$R$ is a ring and $(r)$ is a principal ideal generated by an element $r \in R$. 

In (1) above the principal ideal is $(n)$ and in (2) the principal
ideal is $(f)$.

We don't require the ideal $(r)$ to be maximal or prime (corresponding in the
commutative case to residue rings that are fields and integral domains 
respectively). 

Instead, we allow $r$ to be any nonzero element of $R$, but raise an exception
every time a computation in $R/(r)$ requires computing an impossible inverse.

The type for a residue ring in Nemo is \code{Residue}. But again there is no
need to deal directly with the type at all, as we provide a function
\code{ResidueRing} for constructing it.

As usual, we give a description of the ugly internals which can be skipped if
desired.

The type takes two parameters, the first a ring \code{T} on which it is
parameterised and the second a symbol \code{S}. This symbol will always be
a unique symbol automatically generated by Nemo, which the user can't see. It
is used to identify the variable which holds the modulus of the type.

For example, suppose we construct $\Z/n\Z$ where $n$ is a bignum integer. Then
the type would be something like \code|Residue{ZZ, :##residue#418}| where the
hidden variable \code{##residue#418} contains the bignum integer $n$.

Here is the actual Julia type definition

\begin{lstlisting}
type Residue{T <: RingElem} <: Ring
   data::T
end
\end{lstlisting}

Note that the modulus is not stored as a data field inside the type, but is
a type parameter, \code{S}. This allows for an extremely efficient 
representation of values of \code{Residue} type.

For example, a polynomial whose coefficients are in $\Z/n\Z$ can be 
represented as an array of values of type \code{Residue}, each of which holds
only a single integer for the residue, not an integer for the residue and
another for the modulus. This results in a factor of two space saving when
creating arrays of values of type \code{Residue}, for a fixed modulus $n$.

\subsubsection{Constructors}

To make it easy to deal with the \code{Residue} type in Nemo, we provide a
function for constructing the type of a residue ring

\begin{lstlisting}
ResidueRing{T <: Ring}(::Type{T}, r::T)
ResidueRing{T <: Ring}(::Type{T}, r::Int)
\end{lstlisting}

\desc{This function takes a type \code{T} which belongs to the \code{Ring}
class (e.g. \code{T = ZZ}) and an element \code{r} of the ring \code{T} (or
an integer that can be coerced into \code{T}). It returns the type 
corresponding to the residue ring $T/(r)$.}

\begin{lstlisting}
Residue{T <: RingElem}(a::T)
Residue{T <: RingElem}(a::Int)  
Residue{T <: RingElem}(a::ZZ)  
\end{lstlisting}

\desc{Create a residue congruent to $a$. The value $a$ is first reduced
modulo the modulus of the residue ring.}

\begin{lstlisting}
Residue{T <: RingElem}(a::Residue{T, S})  
\end{lstlisting}

\desc{Return a reference to the residue $a$. No copy of the data is made.}

\begin{lstlisting}
Residue{T <: RingElem}()
\end{lstlisting}

\desc{Create a new residue, which is congruent to $0$.}

\textbf{Examples.}

Here are some examples of constructing residue rings and elements in them.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = R(123)
g = R(f)
h = R(ZZ(12))
k = R()

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

m = T(x^4)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
modulus{T <: RingElem}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the modulus of the given residue ring.}

\begin{lstlisting}
zero{T <: RingElem}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the additive identity of the given residue ring.}

\begin{lstlisting}
one{T <: RingElem}(::Type{Residue{T, S}})
\end{lstlisting}

\desc{Return the multiplicative identity of the given residue ring.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the additive identity in the
residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the multiplicative identity in
the residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is invertible in the residue ring,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns $a$. No
check is performed to check that $a$ is actually invertible.}

\textbf{Examples.}

Here are some examples of basic manipulation of residue rings.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = modulus(R)
g = zero(R)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = one(T)

k = isunit(h)

m = canonical_unit(R(11))
n = canonical_unit(T(x + 1))

p = isone(h)
q = iszero(g)
\end{lstlisting}

\subsubsection{Unary operations}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = -R(12345)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = -T(x^5 + 1)
\end{lstlisting}

\subsubsection{Binary operations and functions}

The following binary operators and functions are defined for residue rings.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a$ divided by $b$. If an impossible inverse is encounted
an exception is thrown.}

\begin{lstlisting}
gcd{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return the greatest common divisor of $a$ and $b$. 

Recall that $a$ and $b$ are represented by values $a'$ and $b'$ in $T$, 
say. We define the greatest common divisor of $a$ and $b$ to be the 
residue class of gcd$($gcd$(a', b'), m)$ when that is defined, where 
$m$ is the modulus of the residue ring.

This definition does not depend on the choice of representatives of
$a$ and $b$.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

h = f + g
j = f - g
k = f*g
l = gcd(f, g)

Q = ResidueRing(ZZ, 7)

a = Q(3)
b = Q(4)

m = divexact(a*b, a)

S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

q = n + p
r = n - p
s = n*p
t = divexact(n*p, p)
u = gcd(n, p)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

In a residue ring $R$ over a ring $T$, with modulus $m$, it is convenient
to think of $n \in \Z$ as corresponding to $1$ added to itself $n$ times
in $T$ then reduced modulo $m$.

This allows us to efficiently define the following ad hoc operators, which
effectively make the integers $n \in \Z$ a convenient notation for certain
elements of the residue ring $R$.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T, S}, b::Int)
+{T <: RingElem}(a::Int, b::Residue{T, S})
+{T <: RingElem}(a::Residue{T, S}, b::ZZ)
+{T <: RingElem}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a + b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T, S}, b::Int)
-{T <: RingElem}(a::Int, b::Residue{T, S})
-{T <: RingElem}(a::Residue{T, S}, b::ZZ)
-{T <: RingElem}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $a - b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T, S}, b::Int)
*{T <: RingElem}(a::Residue{T, S}, b::ZZ)
\end{lstlisting}

\desc{Return $ab$, i.e. the element $a$ added to itself $b$ times.}

\begin{lstlisting}
*{T <: RingElem}(a::Int, b::Residue{T, S})
*{T <: RingElem}(a::ZZ, b::Residue{T, S})
\end{lstlisting}

\desc{Return $ab$, i.e. the element $b$ added to itself $a$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a + 3
c = 3 - a
d = 5a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = f + 4
h = 4 - f
k = f*5
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T, S}(x::Residue{T, S}, y::Residue{T, S})
\end{lstlisting}

\desc{Return \code{true} if $x = y$ arithmetically in the given residue ring, 
otherwise return false.}

Julia automatically defines a \code{!=} operator.

\begin{lstlisting}
isequal(x::Residue{T, S}, y::Residue{T, S})
\end{lstlisting}

\desc{Returns \code{true} if the residues (as elements of \code{T}) compare
equal recursively according to \code{isequal}, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)
b = a
c = R(2)

b == a
c != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = 8f
h = f + g

f == g
h != g
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Thinking of integers as corresponding to elements of a residue ring, we
can define the following ad hoc comparison operators.

\begin{lstlisting}
=={T, S}(x::Residue{T, S}, y::Int)
=={T, S}(x::Residue{T, S}, y::ZZ)
\end{lstlisting}

\desc{Given $x \in R$ where $R$ is the given residue ring, return \code{true} 
if $x = y.1$ in $R$, otherwise return \code{false}.}

\begin{lstlisting}
=={T, S}(x::ZZ, y::Residue{T, S})
=={T, S}(x::Int, y::Residue{T, S})
\end{lstlisting}

\desc{Given $y \in R$ where $R$ is the given residue ring, return \code{true} 
if $x.1 = y$ in $R$, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} operators.

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

a == 3
4 != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

f != 5
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Residue{T, S}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a^5

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = f^100
\end{lstlisting}

\subsubsection{Exact division}

So long as we don't encounter an impossible inverse, we can
divide elements in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T, S}, b::Residue{T, S})
\end{lstlisting}

\desc{Return the quotient of $a$ by $b$ in the given residue
ring, i.e. return an element $c$ such that $ac = b$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)
b = R(3)

c = divexact(a, b)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = T(x^4 + x + 2)

h = divexact(f, g)
\end{lstlisting}

\subsubsection{Inversion}

So long as we don't encounter an impossible inverse, we can
invert an element in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
inv{T <: RingElem}(a::Residue{T, S})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the given residue
ring, i.e. return an element $b$ such that $ab = 1$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of computing inverses.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)

b = inv(a)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = inv(f)
\end{lstlisting}

\subsection{Power series rings}

In Nemo we provide a parametric type \code{PowerSeries} for univariate power
series over a ring. There's no need to deal directly with the type, as we
provide a function \code{PowerSeriesRing} for constructing it.

We will describe how the \code{PowerSeries} type works, but the uninterested
user can skip to the section on constructors.

As for the \code{Poly} type, the \code{PowerSeries} type takes two parameters:
a type \code{T} in the \code{Ring} class and a parameter \code{S} for a symbol
representing the variable of the power series ring. For example, the type of
a power series ring $\Z[[x]]$ would be denoted \code|PowerSeries{ZZ, :x}|.

Here is the definition of the \code{PowerSeries} type in Nemo.

\begin{lstlisting}
type PowerSeries{T <: RingElem} <: Ring
   arr::Ptr{Void}
   length::Int
   alloc::Int
   inv::Int
   prec :: Precision
   coeffs :: Array{T, 1}
end
\end{lstlisting}

This is identical to the definition for the \code{Poly} type, except for the
\code{prec} field.

The precision of each power series is retained with the element, rather than
the ring itself. This means that operations can be applied to power series
with different precisions.

The precision can be either a non-negative integer or infinite precision. To
denote the latter, we use the Julia \code{nothing} value.

\begin{lstlisting}
typealias Precision Union(Nothing, Int)
\end{lstlisting}

Thus when a power series has a precision which is of type \code{Int} it
represents a finite precision power series. If it has a precision which is
set to \code{nothing} then it is infinite precision (exact), obviously
with all zero coefficients from some point onwards!

We define precision such that the power series $1 + x + O(x^3)$ has
precision $3$ and $1 + x$ has precision \code{nothing}.

We overload arithmetic and comparison between operands of type \code{Int}
and \code{Nothing} so that one can add and subtract precisions (where this
is defined) and compare precisions. An infinite precision power series
always has greater precision than a finite precision power series. We also
allow taking \code{max} and \code{min} of two values of type \code{Precision}.

\subsubsection{Constructors}

We define the following function for constructing the type of a power series
ring.

\begin{lstlisting}
PowerSeriesRing{T <: Ring}(::Type{T}, s::String)
\end{lstlisting}

\desc{Returns a tuple \code{(R, x)} consisting of the type \code{R} 
corresponding to the power series ring over the ring \code{T} and the generator
\code{x} of that power series ring. The generator \code{x} will be printed as
per the supplied string \code{s}. This need not be the same as the variable
name used to store the generator \code{x}, but it is usually convenient to make
it so.}

We also provide various constructors for creating elements of a power series
ring.

\begin{lstlisting}
PowerSeries{T <: RingElem}()
\end{lstlisting}

\desc{Create the infinite precision power series $0$ in the given power series
ring.}

\begin{lstlisting}
PowerSeries{T <: RingElem}(a::Integer)
PowerSeries{T <: RingElem}(a::T)
\end{lstlisting}

\desc{Create the infinite precision power series $a$ in the given power series
ring.}

\begin{lstlisting}
PowerSeries{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return a reference to the power series \code{a}. No copy of the data is
made by this function.}

\begin{lstlisting}
PowerSeries{T, S}(::Type{PowerSeries{T, S}}, 
                          a :: Array{T, 1}, n :: Precision)
\end{lstlisting}

\desc{Create a power series in the given power series ring with precision
\code{n} and with coefficients given by the array \code{a}. The constant 
coefficient of the power series will be the first element in the array. Note
that the precision \code{n} can be any nonnegative integer, or the special
value \code{nothing}, which corresponds to an infinite precision power series.
The array may have trailing zeroes, but these are ignored (i.e. normalisation
of the underlying polynomial data occurs automatically).}

\begin{lstlisting}
O{T, S}(a :: PowerSeries{T, S})
\end{lstlisting}

\desc{This function should only be passed a power series of the form \code{x^n}
for some nonnegative \code{n}. It then returns $0 + O(x^n)$, which is useful
for adding to infinite precision power series to turn them into finite 
precision ones. 

If the power series $0$ is passed to this function we throw a 
\code{DivideError()}. We also throw an exception if a power series with finite
precision is passed to this function.

Note that whilst we do not disallow it, we do not give any special meaning to
expressions like $O(x - 1)$. If a general infinite precision power series is
passed to this function, only the highest degree of the nonzero terms is
observed.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = x^3 + 2x + 1
b = x^2 + 3x + O(x^4)

c = R(a)
d = PowerSeries(R, [ZZ(1), ZZ(2), ZZ(3)], 5)
f = PowerSeries(R, [ZZ(1), ZZ(2), ZZ(3)], nothing)

g = R(1)
h = R(ZZ(2))
k = R()
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
degree{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the degree of the polynomial underlying the power series $a$.
We define the degree of the zero polynomial to be $-1$.}

\begin{lstlisting}
length{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the length of the polynomial underlying the power series $a$, i.e.
its degree plus one.}

\begin{lstlisting}
normalise{T <: RingElem}(a::PowerSeries{T, S}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial representing the power
series \code{a}, assuming that its unnormalised length is \code{len}. The
polynomial representing \code{a} is normalised if it has either length $0$
or its leading coefficient is nonzero. This function is mainly used internally
because all user functions in Nemo normalise the internal polynomial
representation of power series.}

\begin{lstlisting}
coeff{T <: RingElem}(a::PowerSeries{T, S}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the power series \code{a} with degree 
\code{n}. If $n < 0$ or greater than or equal to the power series precision
we return $0$.}

\begin{lstlisting}
zero{T <: RingElem}(::Type{PowerSeries{T, S}})
\end{lstlisting}

\desc{Return the additive identity of the power series ring, i.e. $0$ as an
infinite precision power series.}

\begin{lstlisting}
one{T <: RingElem}(::Type{PowerSeries{T, S}})
\end{lstlisting}

\desc{Return the multiplicative identity of the power series ring, i.e. $1$ as an
infinite precision power series.}

\begin{lstlisting}
gen{T <: RingElem}(::Type{PowerSeries{T, S}})
\end{lstlisting}

\desc{Return the degree one, monic monomial generator of the power series
ring.}

\begin{lstlisting}
iszero{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if $a$ is the additive identity of the power series
ring. Otherwise, return \code{false}. Note that this is not the same as
checking \code{a == 0}. The latter does not check that the precision of
\code{a} is \code{nothing}.}

\begin{lstlisting}
isone{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if $a$ is the multiplicative identity of the power
series ring. Otherwise, return \code{false}. Note that this is not the same
as checking \code{a == 1}. The latter does not check that the precision of
\code{a} is \code{nothing}.}

\begin{lstlisting}
isgen{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if $a$ is the degree one, monic monomial generator of
the power series ring. Otherwise, return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if $a$ is an invertible element of the power series
ring, i.e. if the lead term is degree zero with invertible coefficient.
Otherwise, return \code{false}.}

\begin{lstlisting}
valuation{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return the valuation of the power series \code{a} with respect to the
generator of the power series ring. If the power series is zero to finite
precision $n$, the valuation is defined to be $n$.}

\textbf{Examples.}

Here are some examples of basic manipulations of power series.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)

c = gen(R)
d = zero(R)
f = one(R)

g = iszero(d)
h = isone(f)
k = isgen(c)
m = isunit(-1 + x + 2x^2)
n = valuation(a)
p = valuation(b)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = 1 + 2x + x^2 + O(x^3)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{T <: RingElem}(a::PowerSeries{T, S}, b::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $a + b$. If the two power series have differing precisions, the
result will be a power series with the lower precision.}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T, S}, b::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $a - b$. If the two power series have differing precisions, the
result will be a power series with the lower precision.}

\begin{lstlisting}
*{T <: RingElem}(a::PowerSeries{T, S}, b::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $ab$. The return precision is equal to the least out of the
product of the precision of \code{a} by the valuation of \code{b} and
the product of the valuation of \code{a} by the precision of \code{b}.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = a + b
g = a - c
h = b*c
j = a*c
m = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*{T <: RingElem}(a::Int, b::PowerSeries{T, S})
*{T <: RingElem}(a::ZZ, b::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Poly{T}, b::Int)
*{T <: RingElem}(a::Poly{T}, b::ZZ)
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = 2a
g = ZZ(3)*b
h = c*2
j = d*ZZ(3)
\end{lstlisting}

\subsubsection{Comparison}

Note that we take the convention that $1 + x + O(x^4) == 1 + x + O(x^8)$. 

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T, S}, y::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if the two power series are the same up to the lesser
of the precisions of the two series, otherwise return \code{false}.}

Julia automatically defines a corresponding \code{!=} operator.

\begin{lstlisting}
isequal(x::PowerSeries{T, S}, y::PowerSeries{T, S})
\end{lstlisting}

\desc{Returns \code{true} if the $x == y$, the precisions of $x$ and $y$ are
the same and if each coefficient of $x$ recursively compares equal to the
corresponding coefficient of $y$ according to \code{isequal}, otherwise return
\code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^3)
c = 1 + x + 3x^2 + O(x^5)
d = 3x^3 - x^4

a == 2x + x^3
b == d
c != d
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Note that we take the convention that $0 == 0 + O(x^4)$.

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T, S}, y::Int)
=={T <: RingElem}(x::PowerSeries{T, S}, y::ZZ)
\end{lstlisting}

\desc{Return \code{true} if the power series \code{x} is equal to \code{y} up
to the precision it has. Note that this is always true if \code{x} has
precision $0$.}

\begin{lstlisting}
=={T <: RingElem}(x::Int, y::PowerSeries{T, S})
=={T <: RingElem}(x::ZZ, y::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{true} if the power series \code{y} is equal to \code{x} up
to the precision it has. Note that this is always true if \code{y} has
precision $0$.}

Julia automatically defines a corresponding \code{!=} operator corresponding to
the above.

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^0)
c = 1 + O(x^5)
d = R(3)

d == 3
c == ZZ(1)
ZZ(0) != a
2 == b
ZZ(1) == c
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::PowerSeries{T, S}, b::Int)
\end{lstlisting}

\desc{Return $a^b$. The result will have precision equal to $b - 1$ times the
valuation of $a$ plus the precision of $a$. This is the same as if $a$ were
multiplied by itself $b$ times.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = a^12
g = b^12
h = c^12
k = d^12
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(a::PowerSeries{T, S}, n::Int)
\end{lstlisting}

\desc{Return \code{a*x^n}, where \code{x} is the generator of the power series
ring and \code{n} is a nonnegative integer. If \code{n} is negative we raise
a \code{DomainError()}. As \code{x^n} is considered exact, the precision of
the result will be the precision of \code{a} increased by \code{n}.}

\begin{lstlisting}
shift_right{T <: RingElem}(a::PowerSeries{T, S}, n::Int)
\end{lstlisting}

\desc{Return \code{a/x^n}, discarding the remainder, where \code{x} is the
generator of the power series ring and \code{n} is a nonnegative integer. If 
\code{n} is negative we raise a \code{DomainError()}. As \code{x^n} is
considered exact, the precision of the result will be the precision of \code{a}
decreased by \code{n}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = shift_left(a, 2)
g = shift_left(b, 2)
h = shift_right(c, 1)
k = shift_right(d, 3)
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(x::PowerSeries{T, S}, prec::Precision)
\end{lstlisting}

\desc{Return the power series \code{x} truncated to the given precision. If
\code{x} already has precision less than or equal to \code{prec} this results
in no change. The precision \code{prec} can be \code{nothing}, representing
an infinite precision. But this has no effect. If \code{prec} is negative we
throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncation.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = truncate(a, 3)
g = truncate(b, 2)
h = truncate(c, nothing)
k = truncate(d, 5)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(x::PowerSeries{T, S}, y::PowerSeries{T, S})
\end{lstlisting}

\desc{Return \code{x/y}. This requires \code{x} to have valuation at least that
of \code{y}. It also requires the first nonzero coefficient of \code{y} to be
a unit in the ring \code{T}. If \code{y} is zero, a \code{DivideError()} is
thrown. 

The precision of the result is equal to the minimum of $p_x - v_y$
and $p_y - 2v_y + v_x$ where $p_x$, $p_y$ are the precisions of \code{x} and
\code{y} respectively and $v_x$, $v_y$ are the corresponding valuations.

If the precision of \code{y} is infinite and the result would be a power
series of infinite length, an exception is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x + x^3 + O(x^6)

f = divexact(a, d)
g = divexact(d, a)
h = divexact(b, c)
k = divexact(d, c)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Return $1/a$. A \code{DivideError()} is thrown if \code{a} is zero. An
exception is thrown if \code{a} isn't invertible or if \code{a} has infinite
precision and has anything other than a nonzero constant term.

The precision of the result is equal to the precision of \code{a}.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, "x")

a = 1 + x + 2x^2 + O(x^5)
b = R(-1)

c = inv(a)
d = inv(b)
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp{T <: RingElem}(a::PowerSeries{T, S})
\end{lstlisting}

\desc{Compute the power series exponential of the given power series \code{a}
to the same precision as \code{a}. If \code{a} has infinite precision an
exception is thrown.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
using Nemo.Fields

R, x = PowerSeriesRing(QQ, "x")

a = exp(x + O(x^40))
b = divexact(x, exp(x + O(x^40)) - 1)
\end{lstlisting}

\section{The Fields module}

Nemo provides various constructions of fields. To make use of this 
functionality simply import the \code{Fields} module

\begin{lstlisting}
using Nemo.Fields
\end{lstlisting}

The first thing the \code{Fields} module does is define the abstract
type \code{Field} like so

\begin{lstlisting}
abstract Field <: Ring
\end{lstlisting}

This means fields can be used anywhere that a more general ring can be used
in Nemo.

Nemo fields provide the \code{/} operator, and genuine fields are closed under
the action of this operator, except for division by zero.

\subsection{Fraction fields}

We allow the construction of a fraction field over any ring in Nemo. Not all
such constructions make sense. Typically it only makes sense to construct the
fraction field of an integral domain. However, so long as zero divisors are
avoided there is nothing stopping one constructing the fraction field of a
more general Euclidean ring in Nemo.

Specifically, a ring must provide a \code{gcd} function before we can take its
fraction field. This is required for canonicalisation.

The type of an element of a fraction field in Nemo is \code{Fraction}. However
the user need never deal directly with the type, as we provide convenient
functions for constructing objects of this type.

The reader not interested in the internal details of the \code{Fraction} type
can skip ahead to the section on constructors.

The definition of the \code{Fraction} type in Julia is as follows.

\begin{lstlisting}
type Fraction{T <: Ring} <: Field
   n :: Int
   d :: Int
   num :: T
   den :: T
end
\end{lstlisting}

It is parameterised over a ring type \code{T} and contains a numerator 
\code{num} and denominator \code{den}, both of type \code{T}.

For the special case of fractions over the integers, i.e. elements of the
field of rational numbers, we want to make use of the corresponding flint
type which consists just of two \code{fmpz} values. In that case we cannot
use \code{T} as the type (since that would be \code{ZZ}, but must use
\code{Int}. For this purpose we include a numerator and denominator of the
correct type, called \code{n} and \code{d} respectively.

The inner constructor for the \code{Fraction} type does not try to canonicalise
the fraction, but all other constructors should produce a canonicalised
fraction, where possible.

In order to canonicalise we divide both numerator and denominator by their
greatest common divisor. We also divide by \code{canonical_unit(den)} where
\code{den} is the denominator. This allows us to easily check equality of
fractions.

The \code{canonical_unit} function must have the properties

\begin{lstlisting}
canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)
\end{lstlisting}

for all values $a$ and $b$ in the ring \code{T} and $u$ any invertible element
in \code{T}. Moreover, \code{canonical_unit} must always return an invertible
element in the ring \code{T}.

We overload the \code{/} operator in Nemo for rings whose fraction field can
be taken (e.g. \code{ZZ} and \code|Poly{T}|), so that elements of the
fraction field of a ring can be constructed directly, without first
constructing the type.

For example if we have

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

s = (x + 1)/(x^2 + 1)
\end{lstlisting}

then the value $s$ belongs to the fraction field of $R$ automatically, even
though this field has not been constructed yet.

The \code{/} operator doubles as a division operator when passed operands
in a fraction field.

In Nemo, we consider the fraction field of a field to be itself.

\subsubsection{Constructors}

We provide a convenient function for constructing a fraction field of a ring in
Nemo.

\begin{lstlisting}
FractionField{T <: Ring}(::Type{T})
\end{lstlisting}

\desc{Given a type \code{T} in the \code{Ring} class, this function returns a
type corresponding to its fraction field.}

There are also numerous constructors for generating elements in the fraction
field.

\begin{lstlisting}
Fraction{T <: Ring}(a :: T, b :: T)
\end{lstlisting}

\desc{This is the unadorned inner constructor. It does not try to canonicalise
or check for division by zero. It is mainly used internally to actually 
construct the value with $a$ as numerator and $b$ as denominator.}

\begin{lstlisting}
Fraction{T <: Ring}()
\end{lstlisting}

\desc{Return the value $0/1$ in the fraction field of the ring $T$.}

\begin{lstlisting}
Fraction{T <: Ring}(a::Integer)
\end{lstlisting}

\desc{Return the value $a/1$ in the fraction field of the ring $T$, i.e.
$1/1$ added to itself $a$ times.}

\begin{lstlisting}
Fraction{T <: Ring}(a::T)
\end{lstlisting}

\desc{Return the value $a/1$ in the fraction field of the ring $T$.}

\begin{lstlisting}
Fraction{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return a reference to the value $a$. No copy of the data is made.}

We also provide a simpler way of constructing elements of a fraction field
without needing to first construct the type of the fraction field. We use
the division operator.

\begin{lstlisting}
/(x::ZZ, y::ZZ)
\end{lstlisting}

\desc{Return the value $x/y$ in the fraction field of \code{ZZ}. The fraction
is canonicalised, i.e. reduced to lowest terms with positive denominator. If
$y = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
/{T <: RingElem}(x::Poly{T}, y::Poly{T})
\end{lstlisting}

\desc{Return the value $x/y$ in the fraction field of the given polynomial
ring. The fraction is canonicalised, i.e. reduced to lowest terms with the
numerator and denominator normalised by dividing both by the
\code{canonical_unit} of the leading coefficient of the denominator. For
example, for polynomials over the integers, the denominator will have
positive leading coefficient. For polynomials over a field, the denominator
will be a monic polynomial. If $y = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of constructors for fraction fields.

\begin{lstlisting}
R = FractionField(ZZ)

a = R(ZZ(3), ZZ(2))

S, x = PolynomialRing(ZZ, "x")
T = FractionField(S)

b = T(3)
c = T(ZZ(7))
d = T(x + 2)
f = T(d)
g = T()

k = ZZ(5)/ZZ(7)
m = (x + 3)/(x^2 + 2)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
num{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return the numerator of the fraction $a$.}

\begin{lstlisting}
den{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return the denominator of the fraction $a$.}

\begin{lstlisting}
zero{T <: Ring}(::Type{Fraction{T}})
\end{lstlisting}

\desc{Return the additive identity of the fraction field of the ring $T$.}

\begin{lstlisting}
one{T <: Ring}(::Type{Fraction{T}})
\end{lstlisting}

\desc{Return the multiplicative identity of the fraction field of the ring 
$T$.}

\begin{lstlisting}
iszero{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is the additive identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is multiplicative identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is invertible, i.e. is not zero,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T}(a::Fraction{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. This function simply returns $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations for fraction fields.

\begin{lstlisting}
R = FractionField(ZZ)
S, x = PolynomialRing(ZZ, "x")

a = num(ZZ(4)/ZZ(6))
b = den((x + 1)/(-x^2 + 1))

c = zero(R)
d = one(S)
f = canonical_unit((x + 1)/(-x^2 + 1))
g = isunit((x + 1)/(-x^2 + 1))

h = iszero(c)
d = isone(d)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(ZZ(4)/ZZ(6))
b = -((x + 1)/(-x^2 + 1))
\end{lstlisting}

\subsubsection{Comparison operators}

\begin{lstlisting}
=={T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y$, else
return \code{false}.}

\begin{lstlisting}
isequal{T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerators of \code{x} and \code{y} compare
equal recursively according to \code{isequal} and similarly for the
denominators, else return \code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(ZZ(4)/ZZ(6))
b = -((x + 1)/(-x^2 + 1))

a == -ZZ(2)/ZZ(3)
b == 1/(x - 1)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing both
operands into the fraction field.

\begin{lstlisting}
=={T}(x::Fraction{T}, y::T)
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y/1$, else
return \code{false}.}

\begin{lstlisting}
=={T}(x::T, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $y$ equals the fraction $x/1$, else
return \code{false}.}

\begin{lstlisting}
=={T <: Ring}(x::Fraction{T}, y::Int)
=={T <: Ring}(x::Fraction{T}, y::ZZ)
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $x$ is equal to $y$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\begin{lstlisting}
=={T <: Ring}(x::Int, y::Fraction{T})
=={T <: Ring}(x::ZZ, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $y$ is equal to $x$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = 1/(x - 1)

1/a == x - 1
ZZ(4)/ZZ(2) == 2
ZZ(3) == ZZ(6)/ZZ(2)
1 == one(S)
\end{lstlisting}

\subsubsection{Binary operators and functions}

The following binary operators are available for elements of fraction fields.
All of the functions canonicalise their outputs.

\begin{lstlisting}
+{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a - b$.}

\desc{Return $a + b$.}

\begin{lstlisting}
*{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a*b$.}

\begin{lstlisting}
/{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/b$, in the field of fractions of $T$.}

\begin{lstlisting}
divexact{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{An alias for $a/b$.}

\begin{lstlisting}
gcd{T <: Ring}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $c/d$ where $c$ is the GCD of the numerators of $a$ and $b$ and
$d$ is the GCD of their denominators.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -ZZ(2)/ZZ(3) + ZZ(3)/ZZ(7)
b = (x + 1)/(-x^2 + 1) - x/(2x + 1)
c = (ZZ(5)/ZZ(3))*(ZZ(7)/ZZ(2))
d = a/c
f = gcd(b, (x + 1)/(x - 1))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following binary operators are more efficient than simply coercing both
arguments into the fraction field. All functions canonicalise their outputs.

\begin{lstlisting}
+{T <: Ring}(a::Fraction{T}, b::Int)
+{T <: Ring}(a::Fraction{T}, b::ZZ)
+{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a + b/1$.}

\begin{lstlisting}
+{T <: Ring}(a::Int, b::Fraction{T})
+{T <: Ring}(a::ZZ, b::Fraction{T})
+{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 + b$.}

\begin{lstlisting}
-{T <: Ring}(a::Fraction{T}, b::Int)
-{T <: Ring}(a::Fraction{T}, b::ZZ)
-{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a - b/1$.}

\begin{lstlisting}
-{T <: Ring}(a::Int, b::Fraction{T})
-{T <: Ring}(a::ZZ, b::Fraction{T})
-{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 - b$.}

\begin{lstlisting}
*{T <: Ring}(a::Fraction{T}, b::Int)
*{T <: Ring}(a::Fraction{T}, b::ZZ)
*{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a * b/1$.}

\begin{lstlisting}
*{T <: Ring}(a::Int, b::Fraction{T})
*{T <: Ring}(a::ZZ, b::Fraction{T})
*{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 * b$.}

\begin{lstlisting}
/{T <: Ring}(a::Fraction{T}, b::Int)
/{T <: Ring}(a::Fraction{T}, b::ZZ)
/{T <: Ring}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a / (b/1)$.}

\begin{lstlisting}
/{T <: Ring}(a::Int, b::Fraction{T})
/{T <: Ring}(a::ZZ, b::Fraction{T})
/{T <: Ring}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $(a/1) / b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -ZZ(2)/ZZ(3)
b = (x + 1)/(-x^2 + 1)

c = a + 2
d = ZZ(3) - a

e = b*(x + 1)
f = a/5
g = (x + 1)/b
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: Ring}(a::Fraction{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -ZZ(2)/ZZ(3)
b = (x + 1)/(-x^2 + 1)

c = a^12
d = b^-12
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: Ring}(a::Fraction{T})
\end{lstlisting}

\desc{Return $1/a$.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -ZZ(2)/ZZ(3)
b = (x + 1)/(-x^2 + 1)

c = inv(a)
d = inv(b)
\end{lstlisting}

\subsection{The rationals}

The field of rationals in Nemo is \code|Fraction{ZZ}|. For convenience this is
type aliased with \code{QQ}. Thus for example, one may write

\begin{lstlisting}
a = QQ(2)

R, x = PolynomialRing(QQ, "x")

f = ZZ(3)/ZZ(2)*x + ZZ(1)/ZZ(2)
\end{lstlisting}

The \code{QQ} type supports all of the functionality of the previous section. In
this section we describe additional functionality that is provided for \code{QQ}
but not for general fraction fields.

\subsubsection{Basic manipulation}

\begin{lstlisting}
height(a::Fraction{ZZ})
\end{lstlisting}

\desc{Return the height of the fraction $a$, namely the largest of the absolute
values of the numerator and denominator. The type of the return value is a 
\code{ZZ}.}

\begin{lstlisting}
height_bits(a::Fraction{ZZ})
\end{lstlisting}

\desc{Return the number of bits of the height of the fraction $a$. The type of
the return value is an \code{Int}.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
a = -ZZ(2)/ZZ(3)
b = ZZ(123)/ZZ(234)

c = height(a)
d = height_bits(b)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
cmp(a::Fraction{ZZ}, b::Fraction{ZZ}) 
\end{lstlisting}

\desc{Return \code{-1} if $a < b$, \code{0} if $a = b$ and $1$ if $a > b$.}

\begin{lstlisting}
<(a::Fraction{ZZ}, b::Fraction{ZZ}) 
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
automatically provides corresponding functions \code{>}, \code{<=} and
\code{>=}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
a = -ZZ(2)/ZZ(3)
b = ZZ(1)/ZZ(2)

a < b
b >= a
c = cmp(a, b)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience.

\begin{lstlisting}
<(a::Fraction{ZZ}, b::ZZ)
<(a::Fraction{ZZ}, b::Int)
<(a::ZZ, b::Fraction{ZZ})
<(a::Int, b::Fraction{ZZ})
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
automatically provides corresponding functions \code{>}, \code{<=} and
\code{>=}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
a = -ZZ(2)/ZZ(3)
b = ZZ(1)/ZZ(2)

a < 1
a <= 0
b >= ZZ(0)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
>>(a::Fraction{ZZ}, b::Int)
\end{lstlisting}

\desc{Return $a/2^b$.}

\begin{lstlisting}
<<(a::Fraction{ZZ}, b::Int)
\end{lstlisting}

\desc{Return $a\times 2^b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
a = -ZZ(2)/ZZ(3)
b = ZZ(1)/ZZ(2)

c = a << 3
d = b >> 5
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(a::Fraction{ZZ}, m::Int)
mod(a::Fraction{ZZ}, m::ZZ)
\end{lstlisting}

\desc{If $a = p/q$ this function returns $pq^{-1} \pmod{m}$. This is only
defined if $q$ is invertible modulo $m$. The result is returned as a \code{ZZ}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = -ZZ(2)/ZZ(3)
b = ZZ(1)/ZZ(2)

c = mod(a, 7)
d = mod(b, ZZ(5))
\end{lstlisting}

\subsubsection{Rational reconstruction}

\begin{lstlisting}
reconstruct(a::ZZ, m::ZZ)
reconstruct(a::ZZ, m::Int)
reconstruct(a::Int, m::ZZ)
reconstruct(a::Int, m::Int)
\end{lstlisting}

\desc{Attempt to find a rational number $n/d$ such that 
$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$ and 
$0 < d \leq \lfloor\sqrt{m/2}\rfloor$ such that gcd$(n, d) = 1$ and
$a \equiv nd^{-1} \pmod{m}$. If no solution exists, an exception is thrown.}

\textbf{Examples.}

Here are some examples of rational reconstruction.

\begin{lstlisting}
a = reconstruct(7, 13)
b = reconstruct(ZZ(15), 31)
c = reconstruct(ZZ(123), ZZ(237))
\end{lstlisting}

\subsubsection{Rational enumeration}

\begin{lstlisting}
next_minimal(x::Fraction{ZZ})
\end{lstlisting}

\desc{Given $x$, returns the next rational number in the sequence obtained by
enumerating all positive denominators $q$, and for each $q$ enumerating
the numerators $1 \le p < q$ in order and generating both $p/q$ and $q/p$,
but skipping all gcd$(p,q) \neq 1$. Starting with zero, this generates
every nonnegative rational number once and only once, with the first
few entries being:

$$0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, 1/5, 5, 2/5, \ldots.$$

This enumeration produces the rational numbers in order of minimal height. 
It has the disadvantage of being somewhat slower to compute than the
Calkin-Wilf enumeration.

If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
next_signed_minimal(x::Fraction{ZZ})
\end{lstlisting}

\desc{Given a signed rational number $x$ assumed to be in canonical form, 
returns the next element in the minimal-height sequence generated by 
\code{fmpq_next_minimal} but with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
in order of minimal height.}

\begin{lstlisting}
next_calkin_wilf(x::Fraction{ZZ})
\end{lstlisting}

\desc{Given $x$ return the next number in the breadth-first traversal of the
Calkin-Wilf tree. Starting with zero, this generates every nonnegative
rational number once and only once, with the first few entries being:

$$0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \ldots.$$

Despite the appearance of the initial entries, the Calkin-Wilf enumeration 
does not produce the rational numbers in order of height: some small fractions
will appear late in the sequence. This order has the advantage of being faster 
to produce than the minimal-height order.}

\begin{lstlisting}
next_signed_calkin_wilf(x::Fraction{ZZ})
\end{lstlisting}

\desc{Given a signed rational number $x$ returns the next element in the
Calkin-Wilf sequence with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
but not in order of minimal height.}

\textbf{Examples.}

Here are some examples of rational enumeration.

\begin{lstlisting}
next_minimal(ZZ(2)/ZZ(3))
next_signed_minimal(-ZZ(21)/ZZ(31))
next_calkin_wilf(ZZ(321)/ZZ(113))
next_signed_calkin_wilf(-ZZ(51)/ZZ(17))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
harmonic(n::Int)
\end{lstlisting}

\desc{Computes the harmonic number $H_n = 1 + 1/2 + 1/3 + \cdots + 1/n$.
Table lookup is used for $H_n$ whose numerator and denominator 
fit in a single limb. For larger $n$, a divide and conquer strategy is used.}

\begin{lstlisting}
dedekind_sum(h::ZZ, k::ZZ)
dedekind_sum(h::ZZ, k::Int)
dedekind_sum(h::Int, k::ZZ)
dedekind_sum(h::Int, k::Int)
\end{lstlisting}

\desc{Computes the Dedekind sum $s(h,k)$ for arbitrary $h$ and $k$.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
a = harmonic(12)

b = dedekind_sum(12, 13)
c = dedekind_sum(-120, ZZ(1305))
\end{lstlisting}

\subsection{Finite fields}

We allow the construction of finite fields of any characteristic and degree in
Nemo. When a Conway polynomial is known, the field is generated using the 
Conway polynomial. Otherwise a random irreducible polynomial is used. 

(At this stage we make no attempt to compatibly embed finite fields generated 
using randomly chosen irreducible polynomials, such as with the 
Bosma-Cannon-Steel construction. But this may change in a later version of 
Nemo.) 

The finite field type in Nemo is \code{FinFieldElem}. The uninterested user can skip
description of the internals of this type, as we provide functions for 
constructing the type.

As with the \code{ZZ} type, the \code{FinFieldElem} type in Nemo simply represents a
flint type. In fact, the contents are the same as an \code{fmpz_poly}, since
fundamentally an element of a finite field is a polynomial expression.

The following is essentially what the Julia definition of the Nemo
\code{FinFieldElem} type looks like. It mirrors the contents of the
flint \code{fmpz_poly_struct}, which is how finite field elements are stored
in flint.

\begin{lstlisting}
type FinFieldElem{S} <: Field
   coeffs :: Ptr{Void}
   alloc :: Int
   length :: Int
\end{lstlisting}

Actually, in practice, we define an immutable type called 
\code{fmpz_poly_struct} in Julia which contains precisely the fields above. The
body of the \code{FinFieldElem} type then contains just an
\code{fmpz_poly_struct}. But this is not an essential detail.

The \code{FinFieldElem} type is parameterised by a symbol \code{S} which holds
on to a flint context object with information such as the polynomial used to
generate the field, the characteristic and much more besides.

There are no user serviceable parts inside, so we omit details of this 
\code{fq_ctx} type which stores this context object. Needless to say, it
contains no more and no less than a flint \code{fq_ctx_t}.

The \code{FinFieldElem} type belongs to the \code{Field} typeclass, and
therefore elements of a finite field can be passed to any function which
operates on field or ring elements.

\subsubsection{Constructors}

We provide the following functions for constructing finite fields in Nemo.

\begin{lstlisting}
FiniteField(p::ZZ, deg::Int, var::String)
FiniteField(p::Int, deg::Int, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the type \code{R} of a finite
field of characteristic \code{p} of degree \code{deg} and a generator \code{x}.
Elements of the finite field \code{R} can be constructed as polynomials of
degree less than \code{deg} in \code{x}. The generator \code{x} of the field 
will be printed as the provided string \code{var}.

If a Conway polynomial is known for the given characteristic and degree, it
will be used to construct the field. Otherwise a random irreducible polynomial
will be used. We make no attempt to compatibly embed finite fields in the
latter case.

The characteristic \code{p} must be prime, but we do not check this condition.
Undefined behaviour, including the possibility of an infinite loop, may result
otherwise. The degree \code{deg} must be nonnegative. If \code{deg} is 
negative we throw a \code{DomainError()}.}

We provide various convenient functions for constructing elements of a finite
field.

\begin{lstlisting}
FinFieldElem{S}(a::Int)
FinFieldElem{S}(a::ZZ)
\end{lstlisting}

\desc{Return the element \code{a} of the finite field, considered as an element
of $\F_p$.}

\begin{lstlisting}
FinFieldElem{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return a reference to the element \code{a} of the finite field. No copy
of the data is made by this function.}

\textbf{Examples.}

Here are some examples of constructing finite fields and elements in them.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
S, y = FiniteField(ZZ(17), 3, "y")

f = 3x^4 + 2x^3 + 4x^2 + x + 1
g = 2y^2 + 11y + 16

h = R(4)
k = S(11)
m = R(h)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{Return the additive identity in the finite field, i.e. $0$.}

\begin{lstlisting}
one{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{Return the multiplicative identity in the finite field, i.e. $1$.}

\begin{lstlisting}
gen{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{Return a generator of the finite field, namely one whose
representation is the monomial of degree $1$ modulo the defining
polynomial of the field. The generator may not be a multiplicative
generator.}

\begin{lstlisting}
iszero{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the additive identity in the
finite field, i.e. if it is $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the multiplicative identity in
the finite field, i.e. if it is $1$, otherwise return \code{false}.}

\begin{lstlisting}
isunit{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is invertible in the finite field,
i.e. if it is not zero, otherwise return \code{false}.}

\begin{lstlisting}
characteristic{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{Return the prime characteristic $p$ of the finite field as a bignum
\code{ZZ}.}

\begin{lstlisting}
order{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{Return the number of elements in the finite field, i.e. $q = p^d$
where \code{p} is the characteristic and $d$ is the degree.}

\begin{lstlisting}
degree{S}(::Type{FinFieldElem{S}})
\end{lstlisting}

\desc{If the finite field is $\F_q$ where $q = p^d$, where $p$ is the
prime characteristic of the field, this function returns the degree
$d$.}

\textbf{Examples.}

Here are some examples of basic manipulations of finite fields.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = zero(R)
b = one(R)
c = gen(R)
d = characteristic(R)
f = order(R)
g = degree(R)
h = iszero(a)
k = isone(b)
m = isunit(x + 1)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = -a
\end{lstlisting}

\subsubsection{Binary operators and functions}

We provide the following binary operators and functions for elements of
finite fields.

\begin{lstlisting}
+{S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
gcd{S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{Return gcd$(a, b)$. For a finite field this is always $1$ unless both
$a$ and $b$ are $0$, in which case the gcd is $0$.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = a + b
d = a - b
f = a*b
g = gcd(a, b)
h = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

We provide the following ad hoc binary operators, which are faster than first
coercing all their arguments into the finite field.

\begin{lstlisting}
*{S}(x::Int, y::FinFieldElem{S})
*{S}(x::ZZ, y::FinFieldElem{S})
\end{lstlisting}

\desc{Return $xy$, i.e. $y$ added to itself $x$ times.}

\begin{lstlisting}
*{S}(x::FinFieldElem{S}, y::Int)
*{S}(x::FinFieldElem{S}, y::ZZ)
\end{lstlisting}

\desc{Return $xy$, i.e. $x$ added to itself $y$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = 3a
c = a*ZZ(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{S}(a::FinFieldElem{S}, n::Int)
^{S}(a::FinFieldElem{S}, n::ZZ)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here are some examples of powering of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = a^3
c = a^ZZ(-5)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{Return \code{true} if the finite field elements $a$ and $b$ are 
arithmetically equal, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} functionality.

\begin{lstlisting}
isequal{S}(a::FinFieldElem{S}, b::FinFieldElem{S})
\end{lstlisting}

\desc{For finite fields the \code{isequal} function is simply an alias for
the \code{==} operator.}

\textbf{Examples.}

Here are some examples of comparison of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

b != a
R(3) == R(3)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{S}(x::FinFieldElem{S}, y::FinFieldElem{S})
/{S}(x::FinFieldElem{S}, y::FinFieldElem{S})
\end{lstlisting}

\desc{Return $x/y$, which is an exact division in a finite field when defined,
since every nonzero element is invertible. We throw a \code{DivideError()} if
$y = 0$. Both forms of exact division are the same, one being a synonym for 
the other.}

\textbf{Examples.}

Here are some examples of exact division of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

c = divexact(a, b)
d = b/a
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the finite field, i.e. 
$a^{-1}$ such that $aa^{-1} = 1$ in the finite field.}

\textbf{Examples.}

Here are some examples of inversion of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = inv(a)
b == a^-1
\end{lstlisting}

\subsubsection{Special functions}

Various special functions with finite field specific behaviour are
defined.

\begin{lstlisting}
trace{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return the trace of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
norm{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return the norm of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
frobenius{S}(a::FinFieldElem{S}, n = 1)
\end{lstlisting}

\desc{Return the iterated Frobenius $\sigma_p^n(a)$ where $\sigma_p$ is the 
Frobenius map sending the element $a$ to $a^p$ in the finite field of 
characteristic $p$. By default the Frobenius map is applied $n = 1$ times if
$n$ is not specified.}

\begin{lstlisting}
pth_root{S}(a::FinFieldElem{S})
\end{lstlisting}

\desc{Return the $p$-th root of $a$ in the finite field of characteristic
$p$. This is the inverse operation to the Frobenius map $\sigma_p$.}

\textbf{Examples.}

Here are some examples of special finite field functionality.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = trace(a)
c = norm(a)
d = frobenius(a)
f = frobenius(a, 3)
g = pth_root(a)
\end{lstlisting}

\subsection{The p-adics}

We define a parametric type \code{Padic} to contain elements of the $p$-adic
numbers in Nemo. As usual, the user need not know the details of the type, as
we define a function \code{PadicField} for constructing it.

We describe here the internals of the \code{Padic} type, but the reader may
skip ahead to the section on constructors if so desired.

The \code{Padic} type takes a single parameter \code{S}, which is a symbol.
This symbol is the name of a variable which contains, amongst other things,
the prime $p$ for the $p$-adic type.

The first part of the \code{Padic} type in Nemo mirrors the internals of the
flint \code{padic_t} type. Here is its definition.

\begin{lstlisting}
type Padic{S} <: Field
   u :: Int 
   v :: Int
   N :: Int
   exact :: Bool
end
\end{lstlisting}

The \code{u}, \code{v} and \code{N} fields correspond to the $p$-adic unit
(actually of type \code{fmpz} in flint), the valuation and precision
respectively. 

There is one additional field, called \code{exact}. We use this to specify
when a $p$-adic number is exact (i.e. when it exactly represents a rational
number with denominator a power of $p$). We require this because of the way
flint handles $p$-adic precision.

The flint $p$-adic interface ignores the precision of inputs to its $p$-adic
functions and only pays attention to the desired precision as set in the
output(s). We modify this behaviour in Nemo by computing on-the-fly the best
possible output precision given the input precisions. We then use this for the
required output precision when calling flint.

However, the flint $p$-adic type has no way to specify an infinite precision
output, e.g. when the input precisions are in fact known exactly. The
additional \code{exact} field in the Nemo type allows us to handle such cases
specially.

Flint does provide some functions which ignore the specified output precision,
interpreting the result as exact. We use these in combination with the Nemo
\code{exact} field to provide operations on infinite precision $p$-adics.

There is also a flint \code{padic_ctx_t} type which is mirrored in a Julia
\code{padic_ctx} type. As the details are not important we omit the definition
here. It is this \code{padic_ctx} that is attached to the symbol \code{S} on
which the Nemo \code{Padic} type is parameterised.

\subsubsection{Constructors}

We provide the following simple function for creating the type of the $p$-adic
numbers.

\begin{lstlisting}
PadicField(p::Int)
PadicField(p::ZZ)
\end{lstlisting}

\desc{This function returns a type corresponding to the $p$-adic numbers for
the given prime $p$. We test that $p$ is actually prime before constructing
the type. If not, an exception is thrown.}

No default precision is used for the $p$-adic type in Nemo. Elements can be
constructed with any desired precision and the results of computations are
computed to the best possible output precision given the precision of the
inputs. 

This includes the possibility of infinite precision in the case of exact
rational values with a power of the prime $p$ as denominator. Nemo will throw
an exception if an output value has infinite precision in theory but which
cannot be represented exactly due to requiring infinite space (e.g. negative
integers or fractions with something other than a power of $p$ as denominator).

To construct values of $p$-adic type we use the \code{O} operator. It requires
the $p$-adic type as a parameter for reasons of type soundness and so that
expressions such as $O(7^0)$ can be entered unambiguously (as \code{O(R, 7^0)},
say).

\begin{lstlisting}
O{S}(::Type{Padic{S}}, m::Int)
O{S}(::Type{Padic{S}}, m::ZZ)
O{S}(::Type{Padic{S}}, m::QQ)
\end{lstlisting}

\desc{Construct the value $0 + O(p^n)$ given $m = p^n$. An exception results
if $m$ is not found to be a power of \code{p = prime(Padic{S})}.}

The \code{O(p^n)} construction can be used to construct $p$-adic values of
precision $n$ by adding it to integer values representing the $p$-adic value
modulo $p^n$. See the examples below for details.

\begin{lstlisting}
Padic{S}()
\end{lstlisting}

\desc{Construct the $p$-adic value $0$ with precision $0$, i.e. $0 + O(p^0)$.}

\begin{lstlisting}
Padic{S}(a::Int)
Padic{S}(a::ZZ)
Padic{S}(a::QQ)
\end{lstlisting}

\desc{Construct the exact (infinite precision) $p$-adic value representing the
integer or rational $a$. An exception will result if $a < 0$ or if the 
denominator of $a$ is not a power of $p$.}

\textbf{Examples.}

Here are some examples of constructing $p$-adics.

\begin{lstlisting}
R = PadicField(7)
S = PadicField(ZZ(65537))

a = R()
b = R(1)
c = R(ZZ(123))
d = R(ZZ(1)/7^2)

f = 1 + 2*7 + 4*7^2 + O(R, 7^3)
g = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)
h = ZZ(1)/7^2 + ZZ(2)/7 + 3 + 4*7 + O(R, 7^2)
\end{lstlisting}

Beware that the expression \code{1 + 2*p + 3*p^2 + O(R, p^n)} is actually computed as
a normal Julia expression. Therefore if \code{Int} values are used instead of
\code{ZZ}'s, overflow may result in evaluating the value.

Also note that one cannot use \code{7^-2} in a $p$-adic expression, since the 
exponentiation operator must always return an integer, for reasons of type soundness.

\subsubsection{Basic manipulation}

\begin{lstlisting}
prime{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the prime $p$ on which the $p$-adic type is based. The returned
value is of type \code{ZZ}.}

\begin{lstlisting}
precision{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the precision of the given $p$-adic value, e.g. the precision of
$1 + 7 + 2*7^2 + O(7^3)$ is $3$. The precision is meaningless for an
exact value.}

\begin{lstlisting}
valuation{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic valuation of the given $p$-adic value.}

\begin{lstlisting}
isexact{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is exact, i.e. infinite
precision, otherwise return \code{false}.}

\begin{lstlisting}
zero{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the additive identity, i.e. exact $0$ in the field of $p$-adic
numbers.}

\begin{lstlisting}
one{S}(::Type{Padic{S}})
\end{lstlisting}

\desc{Return the multiplicative identity, i.e. exact $1$ in the field of
$p$-adic numbers.}

\begin{lstlisting}
iszero{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is the additive identity,
i.e. exact $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone{S}(a::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is the multiplicative
identity, i.e. exact $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of basic manipulations of $p$-adics.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = R(2)

d = one(R)
f = zero(R)
g = isone(d)
h = iszero(f)
k = isexact(c)
n = precision(a)
p = prime(R)
v = valuation(b)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{S}(x::Padic{S})
\end{lstlisting}

\desc{Return $-x$. Note that if $x$ is for example a positive integer
represented exactly, then $-x$ may not be representable exactly as a $p$-adic.
In this case an exception is raised.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = R(0)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $x + y$. The output precision will be the least of the input
precisions.}

\begin{lstlisting}
-{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $x - y$. The output precision will be the least of the input
precisions. Note that if $x$ and $y$ are exact and $x - y$ cannot be
represented exactly, an exception will be raised.}

\begin{lstlisting}
*{S}(x::Padic{S}, y::Padic{S})
\end{lstlisting}

\desc{Return $xy$. The output precision will be the least of valuation$(x) +$
precision$(y)$ and precision$(x) +$ valuation$(y)$.}

\textbf{Examples.}

Here are some examples of binary operators for $p$-adics.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + b
g = a - b
h = a*b
j = b*c
k = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
+{S}(x::Padic{S}, y::Int)
+{S}(x::Padic{S}, y::ZZ)
+{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $x + y$ where $y$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
+{S}(x::Int, y::Padic{S})
+{S}(x::ZZ, y::Padic{S})
+{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $x + y$ where $x$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
-{S}(x::Padic{S}, y::Int)
-{S}(x::Padic{S}, y::ZZ)
-{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $x - y$ where $y$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
-{S}(x::Int, y::Padic{S})
-{S}(x::ZZ, y::Padic{S})
-{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $x - y$ where $x$ is interpreted as an exact $p$-adic value. If
the result is unrepresentable, an exception results.}

\begin{lstlisting}
*{S}(x::Padic{S}, y::Int)
*{S}(x::Padic{S}, y::ZZ)
*{S}(x::Padic{S}, y::QQ)
\end{lstlisting}

\desc{Return $xy$. If $y$ is negative or the result is not representable, an
exception results.}

\begin{lstlisting}
*{S}(x::Int, y::Padic{S})
*{S}(x::ZZ, y::Padic{S})
*{S}(x::QQ, y::Padic{S})
\end{lstlisting}

\desc{Return $xy$. If $x$ is negative or the result is not representable, an 
exception results.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + 2
g = 3 - b
h = a*ZZ(5)
j = ZZ(3)*c
k = 2*d
l = 2 + d
m = d - ZZ(2)
n = a + ZZ(1)/7^2
p = (ZZ(12)/11)*b
q = c*(ZZ(1)/7)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Compare the given $p$-adic values at the least of the two precisions and
return \code{true} if they are equal to that precision, otherwise return
\code{false}. With this definition \code{0 == 0 + O(7^3)} returns
\code{true}. If one wishes to compare with exact $0$, one should use
\code{iszero}.}

Julia automatically supplies a corresponding \code{!=} operator.

\begin{lstlisting}
isequal{S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if \code{a == b} and if they are either both exact or
if the precisions are the same, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

a == 1 + 2*7 + O(R, 7^2)
b == c
c == R(0)
d == R(2)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience. They
allow comparison with exact values (up to the precision of the $p$-adic value
supplied).

\begin{lstlisting}
=={S}(a::Padic{S}, b::Int)
=={S}(a::Padic{S}, b::ZZ)
=={S}(a::Padic{S}, b::QQ)
\end{lstlisting}

\desc{Return \code{true} if the exact value $b$ is equal to the $p$-adic 
value $a$ up to the precision of $a$, otherwise return \code{false}.}

\begin{lstlisting}
=={S}(a::Int, b::Padic{S})
=={S}(a::ZZ, b::Padic{S})
=={S}(a::QQ, b::Padic{S})
\end{lstlisting}

\desc{Return \code{true} if the exact value $a$ is equal to the $p$-adic 
value $b$ up to the precision of $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R = PadicField(7)

a = 1 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

a == 1
b == ZZ(0)
c == 2
ZZ(2) == c
a == ZZ(344)/1
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{S}(a::Padic{S}, n::Int)
\end{lstlisting}

\desc{Return $a^n$. The output precision will be the same as if $a$ had been
multiplied by itself $n$ times, i.e. precision$(a) + (n - 1)\times$
valuation$(a)$. If the input is exact and $n \geq 0$ the output will be
exact. If $n < 0$ and $a$ is exact, it may be that the output is not
representable. In such cases an exception is raised.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

d = a^5
f = b^3
g = c^7
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{S}(a::Padic{S}, b::Padic{S})
/{S}(a::Padic{S}, b::Padic{S})
\end{lstlisting}

\desc{Return $a/b$. The output precision will be the minimum of 
precision$(a) -$ valuation$(b)$ and precision$(b) - 2\times$valuation$(b) +$
valuation$(a)$. If the result is not representable, an exception is
thrown. If \code{b == 0} a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact{S}(a::Padic{S}, b::Int)
divexact{S}(a::Padic{S}, b::ZZ)
divexact{S}(a::Padic{S}, b::QQ)
/{S}(a::Padic{S}, b::Int)
/{S}(a::Padic{S}, b::ZZ)
/{S}(a::Padic{S}, b::QQ)
\end{lstlisting}

\desc{Return $a/b$. The output precision will be precision$(a) -$ 
valuation$(b)$. If the result is not representable, an exception is
thrown. If \code{b == 0} a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact{S}(a::Int, b::Padic{S})
divexact{S}(a::ZZ, b::Padic{S})
divexact{S}(a::QQ, b::Padic{S})
/{S}(a::Int, b::Padic{S})
/{S}(a::ZZ, b::Padic{S})
/{S}(a::QQ, b::Padic{S})
\end{lstlisting}

\desc{Return $a/b$. The output precision will be 
precision$(b) - 2\times$valuation$(b) +$ valuation$(a)$. If the result is not
representable, an exception is thrown. If \code{b == 0} a \code{DivideError()}
is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = divexact(a, b)
g = divexact(c, d)
h = divexact(d, R(7^3))
j = divexact(R(34), R(17))

k = a/2
l = b/ZZ(7)
m = c/(ZZ(12)/7^2)
n = 2/d
p = R(3)/3
q = (ZZ(5)/7)/R(5)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$, i.e. $1/a$. If \code{a == 0}
a \code{DivideError()} is thrown. If the result is not representable, an
exception is thrown.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = inv(a)
g = inv(b)
h = inv(c)
k = inv(d)
l = inv(R(1))
\end{lstlisting}

\subsubsection{Square root}

\begin{lstlisting}
sqrt{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic square root of $a$. We define this only when the
valuation of $a$ is even. The precision of the output will be precision$(a) -$
valuation$(a)/2$. If the square root does not exist or is unrepresentable, an
exception is thrown.}

\textbf{Examples.}

Here are some examples of taking a $p$-adic square root.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)

d = sqrt(a)
f = sqrt(b)
f = sqrt(c)
g = sqrt(R(121))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic exponential of $a$. We define this only when the
valuation of $a$ is positive (unless \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the result is not
representable an exception is thrown.}

\begin{lstlisting}
log{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the $p$-adic logarithm of $a$. We define this only when the
valuation of $a$ is zero (but not for \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the result is not
representable an exception is thrown.}

\begin{lstlisting}
teichmuller{S}(a::Padic{S})
\end{lstlisting}

\desc{Return the Teichmuller lift of the $p$-adic value $a$. We require the
valuation of $a$ to be nonnegative. The precision of the output will be the
same as the precision of the input. For convenience, if $a$ is congruent to
zero modulo $p$ we return zero. If the result is not representable an
exception is thrown.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
R = PadicField(7)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 5*7 + 3*7^2 + O(R, 7^3)
c = 3*7 + 2*7^2 + O(R, 7^5)

c = exp(c)
d = log(a)
c = exp(R(0))
d = log(R(1))
f = teichmuller(b) 
\end{lstlisting}

\end{document}
