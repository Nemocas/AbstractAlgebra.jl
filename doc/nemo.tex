\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}
\newcommand{\desc}[1]{\vspace{-3mm}\begin{quote}#1\end{quote}}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{julia}
{
  keywordsprefix=\@,
  morekeywords={
    exit,whos,edit,load,is,isa,isequal,typeof,tuple,ntuple,uid,hash,finalizer,convert,promote,
    subtype,typemin,typemax,realmin,realmax,sizeof,eps,promote_type,method_exists,applicable,
    invoke,dlopen,dlsym,system,error,throw,assert,new,Inf,Nan,pi,im,begin,while,for,in,return,
    break,continue,macro,quote,let,if,elseif,else,try,catch,end,bitstype,ccall,do,using,module,
    import,export,importall,baremodule,immutable,local,global,const,Bool,Int,Int8,Int16,Int32,
    Int64,Uint,Uint8,Uint16,Uint32,Uint64,Float32,Float64,Complex64,Complex128,Any,Nothing,None,
    function,type,typealias,abstract
  },
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]" 
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{goodwillhart@googlemail.com}

\title{Nemo: A computer algebra package for Julia}
\author{William B. Hart}

\begin{document}
\lstset{
  language=julia,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Nemo is a computer algebra package for the Julia programming language (\url{http://julialang.org/}).

Nemo is based on the C libraries:

\begin{enumerate}
\item FLINT (Fast Library for Number Theory) -- \url{http://flintlib.org/}
\item ANTIC (Algebraic Number Theory in Code) -- \url{http://github.com/wbhart/antic/}
\item Arb -- \url{http://fredrikj.net/arb/}
\item Pari -- \url{http://pari.math.u-bordeaux.fr/}
\item Singular -- \url{http://www.singular.uni-kl.de/}
\end{enumerate}

The scope of Nemo is computer algebra in the limited sense of the term, and number theory. 

We hope that Nemo will eventually also provide access to the Gap library -- 
\url{http://www.gap-system.org/}.

\section{The Julia programming language}

Over two hundred programming languages were examined before settling on Julia as our choice for the
Nemo project.

Some statically compiled languages such as C++, D, Rust and Nimrod could have been reasonable solutions
up to a point. Languages such as Scala, Aldor and various others also have strong points.

But Julia is the only language which met all our design criteria.

\begin{enumerate}
\item Interactive REPL
\item Jit compiled
\item Fast native C/C++ interop
\item Dependent type system
\item Familiar imperative syntax
\item Open source implementation
\item Regular releases
\item Decent sized community
\item Portable to OSX, Windows, Linux, BSD 
\end{enumerate}

Julia started life in 2009 with a first public release in 2012. It's main architects are Jeff Bezanson,
Stefan Karpinski and Viral B. Shah, though there are well over 150 contributors to date.

Julia is based on the lightning fast LLVM compiler back end and just-in-time compiler. It is capable of
producing code which runs as fast as native C code.

Julia sports hundreds of contributed libraries, a package manager and even a Jupyter based graphical
interface.

Hundreds of thousands of lines of code have already been written in Julia. The language is
already used in production environments, including big data and parallel environments. The
Julia website gets over 150,000 visits a month. There are Julia users groups worldwide and
courses taught in Julia in at least Canada and the US.

Most importantly, Julia is designed by mathematicians for mathematicians.

Some of the key features of Julia are briefly discussed below.

\subsubsection{Jit compilation}

Julia uses just-in-time (JIT) compilation, which allows it to achieve C-like performance in real time
without a separate compilation cycle. Jit compilation is achieved through use of the LLVM compiler
back end.

LLVM is the 15 year old compiler infrastructure which underlies the Clang C/C++ compiler and components
of over a dozen other programming languages.

LLVM's chief architect is Chris Lattner, an Apple employee since 2005, now working on Apple's 
Swift programming language, which uses LLVM heavily. LLVM itself is reported to be used by Apple
for its IOS tool development. 

Jit compilation is ideal for mathematical code, since we generally do not care if there is a very short
delay for incremental compilation after we hit our Enter key. We care only about how fast our very large
loops will take to execute, after jit compilation has happened.

Julia combines LLVM's Jit with dynamic type inference. This is a strategy which allows one to
combine most of the benefits of a statically typed language (such as C/C++) with the flexibility
and ease of use of dynamically typed languages (such as Python, Javascript, PHP, Perl and 
Ruby).

To the greatest extent possible, Julia tries to infer the types for each function. However, it
allows code to be written without specifying types, if one should so wish. Thus, from the user's
perspective it is dynamically typed. But in many cases, exactly the same machine code results as
would come from a C compiler and hand-written C. 

\subsubsection{Interactive console}

Julia offers an interactive console, similar to Python. It can also be used from a Jupyter derivative
known as IJulia. This can be used on the web or even natively on Windows!

Julia has a console which provides Readline like functionality and offers an online help 
system.

Most importantly, Julia offers Jit compiled code at the console! You don't have to precompile
Julia statically to get C-like performance. What you type at the console executes at lightning
speed, immediately.

The console offers exception handling and recovery, pretty printing of types and values, stack 
traces, profiling and timing, the ability to disassemble the Jit compiled code, and exposes 
Julia's type inference machinery, introspection capabilities, interactive loading of modules 
and libraries (including native code) and all of the Julia language, including sophisticated 
metaprogramming features. 

\subsubsection{Foreign function interface}

Julia allows direct access to C/C++ libraries. There is also a simple mapping from C types to Julia
types, and thus complex and costly wrappers are not needed.

Any native dynamic library (such as flint) can be directly accessed from within Julia, so long
as it is in the current library path.

There is no additional overhead in accessing native C libraries from within Julia than there
would be from a native C program using that library.

\subsubsection{Dependent and parametric types}

Few languages in the world sport a decent dependent and parametric type system. If they
do, it is usually at static compile time only.

The prime example of parametric types for a computer algebraist is when creating a type for
polynomials over a ring $R$. In Julia, we can provide a type called Poly, which depends on
another type, $R$ say, specifying the ring you are working over. e.g. $R$ might be the
integers, or another polynomial ring, or a ring of matrices, etc.

Mathematics, especially algebra, is inherently dependent, meaning that Julia's dependent type system
is ideal for computer algebra.

\subsubsection{Polymorphism}
 
Julia is polymorphic, meaning that multiple functions (and operators) can have the same name. For
example, one can write separate versions of the determinant function for matrices over a ring versus
matrices over a field.

In most dynamic languages, e.g. Python, one writes a single function det(M), say, which
may then need many lines of code to sort out what kind of object we are taking the determinant of. All
of this decision code is executed at runtime and places an additional burden on the programmer. 

The Julia dispatch mechanism, on the other hand, does all of this automatically, alleviating the need
to write such decision code.

One can still write generic, catch-all functions, which work over any ring, say. But
these do not first need to delegate to a whole bunch of special cases where specialised
algorithms can be used. 

This greatly improves clarity and readability of code, as specialised versions of generic functions are
clearly delineated by their type signatures.

In addition to this, Julia allows functions to not only be overloaded by other Julia functions of the
same name when certain types of rings are passed as parameters, but one can also overload functions
and operators with highly specialised C/C++ implementations via the Julia native code interface.

\subsubsection{Abstract types and genericity}

Julia doesn't provide classes a la C++. As such, it is not possible to inherit data types. Instead
Julia achieves genericity by inheriting behaviour.

This is achieved by providing abstract types (also known as type classes).

Each type belongs to an \emph{abstract type}, which can be thought of as a collection of types that
have some common behaviour. For example, all the different native integer types in Julia belong to a
common \code{Integer} type class. Arithmetic operations and greatest common divisor functions
make sense for all of these integer types, for example.

Making all the native integer types belong to a single abstract \code{Integer} type class means that it
is possible to write a function that accepts any native integer type as input simply by specifying that
the given parameter is an \code{Integer}. That function will then accept any values whose type belongs
to \code{Integer}.

Abstract types can also belong to one another. For example, the \code{Integer} abstract type belongs to
the \code{Real} abstract type in Julia. 

To Julia this means that any type which belongs to \code{Integer} is more specific than a type which
belongs to \code{Real} but not to \code{Integer}.

This gives Julia a very powerful means of providing genericity. One can provide two versions of a
function, one which works only with an \code{Integer} and one which works with any \code{Real}.

If a machine integer is passed to such a generic function, Julia will determine the most specific
version of the function that applies. In this case the \code{Integer} version would be called.

If some other number is passed, which is not an integer, Julia falls back to the less specific version,
namely the \code{Real} version of the function.

Of course, one can also provide an even more specific implementation which only works for one specific
type, as opposed to an entire type class. Julia will take this as being even more specific and will call
this preferentially over the less specific versions of the function, if it applies.

\subsection{Gotchas with Julia}

Like all languages, Julia has some design decisions and gotchas that new users should be aware of. We
provide an incomplete list of these below.

\subsubsection{1-indexed arrays}

All Julia arrays are indexed starting with $1$, i.e. \code{A[1]} is the first entry, not \code{A[0]}.

This is a deliberate, long standing design decision in Julia. Many mathematical papers make use of
1-based indexing for matrices and the like. 

Some other computer algebra packages, such as Pari/GP make use of the same convention as Julia. 

Experience shows that it rarely takes more than a couple of days to get used to when coming from a
language that uses the other convention.

\subsubsection{Bignums}

Julia provides a built-in multiple precision integer type (using GMP). However for performance it also
provided native integer types.

In order to maximise performance, Julia doesn't automatically switch from native integers to bignums on
overflow. This means that if one starts off with native integers, the computation will only switch to
bignums if the programmer does that explicitly.

The main place this causes an issue is when using constant integers at the REPL. If the integers are
small enough to fit in a native machine word, then that is what will be used. If they are too large
an \code{Int128} will be used if that is big enough, otherwise a multiple precision \code{BigInt}
will be used. 

This means that one must tell Julia explicitly what kind of integer one wants, if the default is not
desired. This is similar to just about any statically typed language which provides bigints. The only
ways around it would be for Julia to only provide bigints and no native types, or to require type
annotation of all variables, either of which is not desirable.

\subsubsection{Supertypes of core types}

As we explained above, Julia provides native integer types, e.g. \code{Int} which belong to a single
type class \code{Integer}.

In a computer algebra system, we'd really like \code{Integer} to then belong to some more general
abstract type class, \code{RingElem} say.

Unfortunately, it is not possible to change the abstract type that Julia's own types and abstract types
belong to.

This will be a gotcha for users of Nemo: Julia integers do not belong to Nemo's \code{RingElem} abstract
type.

One way around this is to allow types to belong to a union type, \code{Union(Integer, RingElem)}. The
other way around it is simply to implement two versions of a function, one which accepts an
\code{Integer}, the other which accepts a \emph{RingElem}.

Fortunately, one often wants to treat integers much more specially than general ring elements, so this
doesn't cause too much of a problem in practice.

\subsubsection{Division operators}

The division functions in Julia are geared towards numerical, rather than algebraic, applications.

The main division operator \code{/} in Julia returns a floating point number when dividing integers
and the \code{div} function treats even the rationals as a model of the reals, so that \code{div(a, b)}
always returns the exact value $a/b$ (in the mathematical sense), truncated to the nearest whole
number in the direction of zero.

Julia also provides \code{//} for creating fraction objects, e.g. for creating rational fractions from
integers.

For algebraic operations, Nemo introduces an additional \code{divexact} function, which assumes you are
performing an exact division of two elements of a ring. We recommend using it exclusively, unless one
knows that one wants precisely the Julia behaviour.

\subsubsection{Multiple inheritance}

The abstract type hierarchy in Julia is one of its best features. It really makes the language
flexible and powerful.

However, at present it is only possible for a given type to belong to one abstract type (and
transitively to any abstract types that it in turn belongs to).

There are cases where it would be useful if types could belong to multiple abstract types, e.g.
\code{Inexact} and \code{RingElem} for elements that belong to inexact rings as opposed to exact 
rings.

There's currently no way around this in Julia, and so the abstract type hierarchy used by Nemo is
pretty basic.

Instead of having a multitude of abstract types, we rely on the existence of functions for specific
rings to determine what can be done with them.

For example, instead of having a \code{EuclideanDomainElem} abstract class for elements of a Euclidean
domain, we rely on the existence of the \code{gcd} function for specific rings that happen to be
Euclidean domains. If the \code{gcd} function doesn't exist, Julia will throw an exception if you
try to call a function on that ring that requires a greatest common divisor to be defined. This 
(mostly) works well in practice.

\subsubsection{Performance gotchas}

There are a number of cases where Julia will provide very poor performance, which often catch new
implementors unawares.

Firstly, Julia doesn't do jit compilation at the top level. If you simply type a series of isolated
statements into the REPL they will be interpreted, not jit compiled.

If you want to get good performance, you should put your code inside a function and call it. The jit
compilation happens at the function boundary and so if your code is inside a function it will
execute quickly.

Top level variables are also very slow to access in Julia. This is because they could change type at
any time and Julia can have no way to predict this. Therefore they aren't as fast as local variables
in functions. Type inference can guarantee that local variables always have the same type meaning that
faster code can result.

Julia provides the keyword \code{const} for top level constants. The value of such constants can't
subsequently be changed, but Julia can then rely on them having the same type (and value), and they do
not suffer from the same performance issues as top level variables.

\section{Installing Nemo}

There are currently two steps to installing Nemo: install Julia-0.4 and use the Julia
package system to install Nemo.

To install Julia, please refer to the installation instructions on the Julia website
(\url{http://julialang.org/}).

On Ubuntu, if you have root access, you can simply add a ppa and use apt-get. E.g. on
my system it was as follows

\begin{verbatim}
sudo add-apt-repository ppa:staticfloat/juliareleases
sudo apt-get update
sudo apt-get install julia
\end{verbatim}

Once Julia-0.4 is installed, start up Julia (type \code{julia} at the command 
line/shell prompt).

Now you can clone, build and test Nemo as follows:

\begin{verbatim}
Pkg.clone("https://github.com/wbhart/Nemo.git")
Pkg.build()
Pkg.test("Nemo")
\end{verbatim}

The tests should only take a few seconds to a minute to run per module, depending on
the speed of your machine. 

If you encounter bugs in Nemo, please report them to \url{nemo-devel@googlegroups.com}.

\section{Using Nemo}

Julia has a module system, and we use it to provide access to Nemo.

At present there is a single module, called \code{Nemo}. To import it and use all
exported functionality simply type

\begin{lstlisting}
using Nemo
\end{lstlisting}

\section{Nemo fundamentals}

Nemo provides both generic algorithms and types, and wrappers of implementations and native types
provided by various C/C++ libraries, such as Flint, Pari, Antic, etc.

For example, there are Flint polynomial types, Pari polynomials types, etc., but also a generic
polynomial type whose coefficients can be in any Nemo ring (e.g. another polynomial ring, or a residue
ring, etc.).

Many of the generic algorithms in Nemo are specialised for working over fields. For example, different
algorithms are used when computing greatest common divisors of polynomials over more general rings 
(where it makes sense) and polynomials over fields.
 
Some Nemo objects don't belong to either rings or fields, e.g. general $m\times n$ matrices belong to
matrix spaces, which are neither rings nor fields.

\subsection{Parent objects and Nemo type classes}

We call the ring or field or space that a Nemo arithmetic object belongs to, its \emph{parent}.

Parents are implemented in Nemo as objects. For example, there is an object corresponding to the ring
of integers as implemented by Flint, namely the unique parent object of type \code{FlintIntegerRing}.

A function named \code{parent} can be used to determine the parent of any arithmetic object in Nemo. In
many cases, the arithmetic objects themselves contain pointers to their parent object.

A parent can be thought of as a kind of \emph{mathematical type}. For example, elements of $\Z/5/Z$ and
elements of $\Z/7\Z$ have the same Julia type but different parents. The Julia type only encodes the
fact that we are working in a residue ring of the integers, but the parents encode the fact that we are
working in two different rings $\Z/5\Z$ and $\Z/7\Z$. One of the parent objects will contain the modulus
$5$, the other will contain the modulus $7$.

Both Nemo arithmetic objects and parent objects have types, and these types belong to various abstract
types defined by Nemo.

At the highest level of the Nemo type hierarchy are the abstract types for the parent objects, namely
\code{Collection}, \code{Ring} and \code{Field}. Corresponding to these are the abstract types for the
corresponding arithmetic objects themselves: \code{CollectionElem}, \code{RingElem}, \code{FieldElem}.

Thus, a polynomial would have a type that belonged to \code{RingElem} and its parent would have a type
that belonged to \code{Ring}.

Actually, the abstract type hierarchy is a bit richer than this. In fact we have a number of more
refined abstract types: \code{PolyElem}, \code{SeriesElem} and \code{ResidueElem} are abstract types
that all belong to \code{RingElem}; \code{FractionElem} is an abstract type that belongs to
\code{FieldElem}; and \code{MatElem} belongs to \code{CollectionElem}.

So in fact, polynomials have types that belong to \code{PolyElem} which in turn belongs to
\code{RingElem}.

\subsection{Basic integer and rational rings}

Before one can build generic rings over other rings, one needs a starting point on which to build.

For this purpose, Nemo provides wrappers of various C libraries, such as Flint and Pari, which have
implementations of basic rings such as the integers and rationals.

Nemo provides some convenient names for the parent objects for these basic rings. Thus, \code{ZZ} is
the name of the parent object for the ring of integers and \code{QQ} is the parent object for the
rationals.

Parent objects are callable in Nemo. They can be used to create objects with that parent. For example,
\code{ZZ(2)} creates the integer $2$ and \code{QQ(2, 3)} creates the rational $2/3$.

By default, Nemo makes \code{ZZ} an alias for the unique parent object of type \code{FlintIntegerRing}
and \code{QQ} is an alias for the unique parent object of type \code{FlintRationalField}.

Once we have these basic rings we can build up more generic rings with these as base.

Flint also provides other basic rings such as padic rings and finite fields. 

\subsection{Nemo domains}

As \code{ZZ} and \code{QQ} are just variables, they can be reassigned by the user. Therefore one can
change \code{ZZ} to be the unique object of type \code{PariIntegerRing} or \code{QQ} to be the unique
object of type \code{PariRationalField}. If one then builds up a generic ring over \code{ZZ} for
example, it would then be implemented using Pari integers instead of Flint integers.

In Nemo we call the underlying system that is used to implement the basic rings the \code{domain}. One
might select a different domain to the default one for performance reasons or because of the available
functionality for that domain, or maybe because one wishes to work predominantly with one package
instead of another. 

This system of domains gives the user good control over the implementation used and allows the user to
more easily tell which external library is responsible for the underlying implementation of their code.
This allows the user to more easily credit (or blame) external implementations.

Currently, for ease of use, we do allow maximal orders of number fields to be built from Antic number
fields, even though Pari provides the underlying implementation of maximal orders and their ideals. This
reflects the fact that Antic is very new and currently doesn't perform such computations.

Below we discuss each of the parent types and object types available in Nemo and list all the functions
available for each, with examples.

\section{Generic rings}

Internally, Nemo defines an abstract type for rings, with the following line of code:

\begin{lstlisting}
abstract Ring
\end{lstlisting}

You can check (or assert) that a given type belongs to \code{Ring} with the
\code{<:} operator. For example, we can check that the type of Nemo's \code{ZZ} parent object belongs
to \code{Ring}

\begin{lstlisting}
typeof(ZZ) <: Ring
\end{lstlisting}

Nemo will return \code{true}, indicating that the type of \code{ZZ} does belong to \code{Ring}.

Note that \code{<:} can only be used to determine if a type (or abstract type) belongs to an abstract
type. Thus \code{ZZ} does not belong to \code{Ring} since \code{ZZ} is not a type but a mathematical
parent object.

An element of a ring has a type that belongs to \code{RingElem}. For example, polynomials and integers
have types that belong to \code{RingElem}.

For example the following code will return true:

\begin{lstlisting}
typeof(ZZ(1)) <: RingElem
\end{lstlisting}

\subsection{Generic polynomial rings ($R[x]$) : \code|Poly\{T\}|}

Nemo has a parametric polynomial type (called \code{Poly}) for generic polynomials over
a ring $T$. There's not any need to deal directly with the \code{Poly} type, as we
provide a function \code{PolynomialRing} for constructing it.

The \code{Poly} type takes a parameter, namely the type of ring element that the
coefficients will have, e.g. if there was no special type for Flint polynomials over the
integers, the type of polynomials over the integers would be \code|Poly{fmpz}|.

Generic polynomials have parent \code{PolynomialRing}, which is also parameterised by the
type of the ring element of the polynomial coefficients, the same as the \code{Poly}
type is.

We have that \code{PolynomialRing} belongs to the \code{Ring} type class and \code{Poly}
belongs to the \code{PolyElem} type class which in turn belongs to the \code{RingElem}
type class.

To get the parent object for the coefficient ring we can call the \code{base_ring}
function. It accepts either a polynomial or a polynomial parent object.

We can also get a symbol representing the name of the variable (as it will print) of
a polynomial ring.

For example we have:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

base_ring(S) == R
var(S) == :y
\end{lstlisting}

\subsubsection{Constructors}

Because dealing with the Julia types directly is somewhat messy, we provide a simple
function to create the parent of a polynomial in Nemo.

\begin{lstlisting}
PolynomialRing{T <: Ring}(::T, s::String)
\end{lstlisting}

\desc{This function takes a parent object which belongs to the \code|Ring| class 
(e.g. \code|T = ZZ|), specifying the ring that the polynomial coefficients are to 
belong to, and a \code{String} giving the string representation of a variable (e.g. 
\code|"x"|). It returns a tuple \code|(R, x)| consisting of the parent of the polynomial
ring being constructed, \code|R|, and the degree $1$ polynomial \code|x| in this ring.}

This is easier to understand by giving an example

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = (x^2 + 2x + 1)*y^3 + (x - 1)*y + 4x - 1
\end{lstlisting}

Notice that we can build up polynomials from the degree one polynomials \code{x} and
\code{y} returned by the calls to \code{PolynomialRing}. 

Another thing to note is that there is no reason why the variable name \code{x} has
to be the same as the string \code{"x"}. The latter is simply how \code{x} will print
when we evaluate it. Of course, in most situations it is convenient to use the same 
letter for the variable and for the string.

Once we have constructed a polynomial ring as above, we can use it to construct
polynomials of various kinds.

This is achieved by making the parent object of the polynomial ring callable. In the
following we assume that \code{S} is a parent object of a polynomial ring, e.g.
created by the following:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

The parent object \code{S} is made callable in Nemo by overloading the Julia
\code{call} operator for polynomial ring parent objects. The type \code{T}
below will refer to the type of the polynomial coefficients.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Construct a polynomial of length $0$ in the given polynomial ring.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Construct a polynomial of length $1$ whose constant coefficient is $a$ if
$a \neq 0$, otherwise construct the zero polynomial.}

\begin{lstlisting}
S(a::Array{T, 1})
\end{lstlisting}

\desc{Construct a polynomial whose coefficients are given by the elements of the array
\code{a}, starting with the constant coefficient at index $1$. The array must be fully
initialised, otherwise an exception may result.}

\begin{lstlisting}
S(a::Poly{T})
\end{lstlisting}

\desc{Return a reference to the polynomial \code{a}.}

\begin{lstlisting}
S{R <: Ring}(a::R)
\end{lstlisting}

\desc{Try to convert the value \code{a} to the polynomial type parameterised by 
\code{T} and the symbol, if possible, and return the value, else raise an error. 
This constructor is used to coerce polynomials and coefficients from subordinate rings
up into the polynomial ring.}

\textbf{Examples.}

Here are some examples of these constructors in action. Note that we don't actually
ever need to deal with the parameterised \code{Poly} type directly.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(S, "z")

f = x^2 + y^3 + z + 1

g = S(2)

h = S(x^2 + 2x + 1)

j = T(x + 2)

k = S([x, x + 2, x^2 + 3x + 1])

l = S(k)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
degree{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the degree of the polynomial $a$. We define the degree of the zero
polynomial to be $-1$.}

\begin{lstlisting}
length{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the length of the polynomial $a$, i.e. its degree plus one.}

\begin{lstlisting}
normalise{T <: RingElem}(a::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial $a$ assuming its unnormalised
length is \code{len}. A polynomial is normalised if it is either length $0$ or its
leading coefficient is nonzero. This function is usually used internally.}

\begin{lstlisting}
coeff{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the degree $n$ term of the polnomial $a$, or zero
if it has none.}

\begin{lstlisting}
lead{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the leading coefficient of the polynomial $a$, or zero if $a$ has
length $0$.}

\begin{lstlisting}
iszero{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the additive identity of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the multiplicative identity
of the polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isgen{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is the generator (variable) of the
polynomial ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Return \code{true} if the polynomial $a$ is invertible, i.e. is of length
$1$ and has invertible constant coefficient, otherwise return \code{false}.}

\begin{lstlisting}
zero{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the additive identity $0$ in the given polynomial ring.}

\begin{lstlisting}
one{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the multiplicative identity $1$ in the given polynomial ring.}

\begin{lstlisting}
gen{T <: Ring}(::Type{Poly{T}})
\end{lstlisting}

\desc{Return the generator (variable) of the given polynomial ring.}

\begin{lstlisting}
canonical_unit{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns
\code{canonical_unit} of the leading coefficient.}

\begin{lstlisting}
deepcopy{T <: Ring}(a::Poly{T})
\end{lstlisting}

\desc{Make a new polynomial which is arithmetically equal to $a$.}

\textbf{Examples.}

Here are some examples of the basic manipulation functions.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

a = zero(S)
b = one(S)
c = gen(S)
d = isunit(b)

f = x^2*y + 2x + 1
g = lead(f)

h = x*y^2 + (x + 1)*y + 3
j = coeff(h, 2)

if isgen(y)
   println(y, " is the generator of the ", parent(y))
end

k = isone(b)
m = iszero(a)

n = canonical_unit(-x*y + x + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators are provided for polynomials. Note that
if both operands are not in the same polynomial ring, Nemo will try to
coerce them into one of the two rings before applying the operation.

\begin{lstlisting}
+{T <: RingElem}(a::Poly{T}, b::Poly{T})
-{T <: RingElem}(a::Poly{T}, b::Poly{T})
*{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
n = f*g
p = f + g
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are faster than first coercing all
operands into the polynomial ring.

\begin{lstlisting}
*{T <: RingElem}(x::Poly{T}, y::Int)
*{T <: RingElem}(x::Poly{T}, y::fmpz)
*{T <: RingElem}(x::Int, y::Poly{T})
*{T <: RingElem}(x::fmpz, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = g - 4
k = fmpz(5) - g
l = f*7
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Poly{T})
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

\begin{lstlisting}
isequal(x::Poly{T}, y::Poly{T})
\end{lstlisting}

\desc{Returns \code{true} if \code{x == y} and if each coefficient of \code{x}
matches the corresponding coefficient of \code{y} according to \code{isequal},
when applied recursively, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3

if f == g
   println("f is equal to g")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing the arguments
into one or the other ring.

\begin{lstlisting}
=={T <: RingElem}(x::Poly{T}, y::Integer)
=={T <: RingElem}(x::Integer, y::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here is an example of ad hoc comparison.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

if S(1) == 1
   println("S(1) is equal to ZZ(1)")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = -f
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a$ truncated to length $n$. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
mullow{T <: RingElem}(a::Poly{T}, b::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial \code{a*b} truncated to length $n$. If $n < 0$ we
throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncated operations.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
\end{lstlisting}

\subsubsection{Reversal}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T}, len::Int)
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, thought of as a polynomial of
the given length (the polynomial will be notionally truncated or padded with
zeroes before the leading term if necessary to match the specified length). 
The resulting polynomial is normalised. If \code{len} is negative we throw a
\code{DomainError()}.}

\begin{lstlisting}
reverse{T <: RingElem}(x::Poly{T})
\end{lstlisting}

\desc{Return the reverse of the polynomial $x$, i.e. the leading coefficient
of $x$ becomes the constant coefficient of the result, etc. The resulting
polynomial is normalised.}

\textbf{Examples.}

Here are some examples of reversal.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the left by $n$ places, i.e. $f\times x^n$ where $x$ is the
generator of the polynomial ring that $f$ belongs to. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
shift_right{T <: RingElem}(x::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial that results from shifting the coefficients of the
polynomial $x$ to the right by $n$ places, i.e. by dividing $f$ by $x^n$ and
throwing away the remainder. If $n$ is greater than or equal to the length of
$x$ then the zero polynomial results. If $n < 0$ we throw a 
\code{DomainError()}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Poly{T}, n::Int)
\end{lstlisting}

\desc{Return the polynomial $a^n$. If $n < 0$ we throw a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = f^5
\end{lstlisting}

\subsubsection{Modular arithmetic}

When we have polynomials over residue rings or fields, we can reduce modulo
a polynomial over the base ring. In this way we can do modular arithmetic with
polynomials.

\begin{lstlisting}
mulmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, 
                                          b::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $ab \pmod{d}$.}

\begin{lstlisting}
invmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, d::Poly{T})
\end{lstlisting}

\desc{Return $a^{-1} \pmod{d}$. If an impossible inverse is encountered, an
exception is thrown.}

\begin{lstlisting}
powmod{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, b::Int, 
                                                         d::Poly{T})
\end{lstlisting}

\desc{Return $a^b \pmod{d}$.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}. 

If \code{T} is a residue ring and the leading coefficient of $b$ is not invertible
in the \code{T}, an error will be thrown.} 

\textbf{Examples.}

Here is an example of exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(f*g, f)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Poly{T}, b::T)
divexact{T <: RingElem}(a::Poly{T}, b::Integer)
\end{lstlisting}

\desc{Return $a$ divided by $b$. The result is only meaningful if the division is
exact. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = divexact(3*f, 3)
k = divexact(x*g, x)
\end{lstlisting}

\subsubsection{Euclidean division}

Over a residue ring we can define Euclidean division.

\begin{lstlisting}
mod{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean remainder of $f$ divided by $g$, i.e. $r$ such 
that $a = bq + r$ for some polynomial $r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\begin{lstlisting}
divrem{T <: Union(ResidueElem, FieldElem)}(f::Poly{T}, g::Poly{T})
\end{lstlisting}

\desc{Return the Euclidean quotient and remainder of $f$ divided by $g$, i.e.
a tuple \code{(q, r)} such that $a = bq + r$ with deg$(r) <$ deg$(b)$. If 
$g = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of Euclidean division.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, "y")

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
\end{lstlisting}

\subsubsection{Pseudodivision}

Given two polynomials $a, b$, pseudodivision computes polynomials $q$ and $r$
with length$(r) <$ length$(b)$ such that
$$L^d a = bq + r,$$
where $d =$ length$(a) -$ length$(b) + 1$ and $L$ is the leading coefficient
of $b$.

We call $q$ the pseudoquotient and $r$ the pseudoremainder.

\begin{lstlisting}
pseudorem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the pseudoremainder of $a$ divided by $b$. If $b = 0$ we throw a 
\code{DivideError()}.}

\begin{lstlisting}
pseudodivrem{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the pseudoquotient and pseudoremainder 
of $a$ divided by $b$. If $b = 0$ we throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of pseudodivision.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
\end{lstlisting}

Note that pseudodivision is not always useful. In general it computes a
multiple of the quotient, and for example in the case of polynomials over a
residue ring, this may lead to meaningless results in the presence of zero
divisors. For example

\begin{lstlisting}
R = ResidueRing(ZZ, 6)
S, x = PolynomialRing(R, "x")

f = 3*x^5 + x^4 + 3*x^2 + 2
g = 2*x^3 + 5*x^2 + 2*x + 2

pseudorem(f, g)
\end{lstlisting}

Here Nemo returns \code{3*x^2}, which happens to be \code{3*g} in this
ring.

\subsubsection{Content, primitive part, GCD and LCM}

When the base ring provides a \code{gcd} function we can provide numerous
GCD related functions for polynomials over that ring.

\begin{lstlisting}
content{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the content of the polynomial $a$, i.e. the greatest common divisor
of all its coefficients, if this exists.}

\begin{lstlisting}
primpart{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the primitive part of the polynomial $a$, i.e. the polynomial
divided by its content, if it exists.}

\begin{lstlisting}
gcd{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $a$ and $b$ if 
it exists.}

\begin{lstlisting}
lcm{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the least common multiple of the polynomials $a$ and $b$. We
define lcm$(a, b) = ab/$gcd$(a, b)$.}

We allow GCD for polynomials over residue rings, e.g. over $\Z/n\Z$, even when
the residue ring has zero divisors. However, if an impossible inverse is
encountered during the computation, due to zero divisors, we throw an error.

\begin{lstlisting}
gcdinv{T <: Union(ResidueElem, FieldElem)}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(g, s)$ such that $g$ is the gcd of $a$ and $b$ and $s$
and $t$ are polynomials such that $g = as + bt$. The value $g$ will be $1$ if
$a$ is invertible modulo $b$.}

\textbf{Examples.}

Here are some examples of content, primitive part and GCD.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1

n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
r = lcm(k*m, l*m)

R, x = PolynomialRing(QQ, "x")
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, "z")

r = z^3 + 2z + 1
s = z^5 + 1
u, v = gcdinv(r, s)
\end{lstlisting}

\subsubsection{Evaluation}

\begin{lstlisting}
evaluate{T <: RingElem}(a::Poly{T}, b::T)
evaluate{T <: RingElem}(a::Poly{T}, b::Integer)
evaluate{T <: RingElem}(a::Poly{T}, b::fmpz)
\end{lstlisting}

\desc{Return the value of the polynomial $a$ evaluated at $b$.}

\textbf{Examples.}

Here are some examples of evaluation.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = evaluate(f, 3)
h = evaluate(f, x^2 + 2x + 1)
\end{lstlisting}

\subsubsection{Composition}

\begin{lstlisting}
compose{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the composition of the polynomial $a$ with $b$, i.e. $a \circ b$.}

\textbf{Examples.}

Here are some examples of composition.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
h = compose(f, g)
\end{lstlisting}

\subsubsection{Derivative}

\begin{lstlisting}
derivative{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Return the derivative of the polynomial $a$ with respect to its main
variable.}

\textbf{Examples.}

Here are some examples of computing derivatives.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

h = x*y^2 + (x + 1)*y + 3
j = derivative(h)
\end{lstlisting}

\subsubsection{Integral}

\begin{lstlisting}
integral{T <: Union(ResidueElem, FieldElem)}(f::Poly{T})
\end{lstlisting}

\desc{Return the integral of the polynomial $f$. The constant coefficient of
the result is taken to be $0$.}

\textbf{Examples.}

Here are some examples of computing integrals.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, "y")

f = (x^2 + 2x + 1)*y^2 + (x + 1)*y - 2x + 4

g = integral(f)   
\end{lstlisting}

\subsubsection{Resultant}

\begin{lstlisting}
resultant{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return the resultant of the polynomials $a$ and $b$.}

\textbf{Examples.}

Here are some examples of computing resultants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
h = resultant(f, g)
\end{lstlisting}

\subsubsection{Discriminant}

\begin{lstlisting}
discriminant{T <: RingElem}(a::Poly{T})
\end{lstlisting}

\desc{Compute the discriminant of the polynomial $a$.}

\textbf{Examples.}

Here are some examples of computing discriminants.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = x*y^2 + (x + 1)*y + 3
g = discriminant(f)
\end{lstlisting}

\subsubsection{Bezout identity}

The Bezout identity is the equivalent, for polynomials, of the extended GCD
in the case of the integers.

Given polynomials $a, b$, we can find polynomials $s, t$ such that
$$sa + bt = r,$$
where $r$ is the resultant of $a$ and $b$.

\begin{lstlisting}
bezout{T <: RingElem}(a::Poly{T}, b::Poly{T})
\end{lstlisting}

\desc{Return a tuple $(r, s, t)$ such that $r$ is the resultant of $a$ and $b$
and with polynomials $s, t$ such that $r = as + bt$.}

\textbf{Examples.}

Here are some examples of computing the Bezout identity.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)
r, s, t = gcdx(f, g)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials. It is expected
that the final argument in each of these function is the generator of the polynomial ring.

\begin{lstlisting}
chebyshev_t{T <: RingElem}(n::Int, x::Poly{T})
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u{T <: RingElem}(n::Int, x::Poly{T})
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\textbf{Examples.}

Here are some examples of special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
\end{lstlisting}

\subsection{Generic residue rings ($R/(f)$) : \code|Residue\{T\}|}

Nemo allows the construction of residue rings. 

There are two examples to keep in mind:

\begin{enumerate}
\item $\Z/n\Z$ for some positive integer $n$

\item $\Q[x]/(f)$ where $f$ is a polynomial in $\Q[x]$.
\end{enumerate}

Currently we only allow construction of residue rings of the form $R/(r)$ where
$R$ is a ring and $(r)$ is a principal ideal generated by an element $r \in R$. 

In the first example above the principal ideal is $(n)$ and in the second the principal
ideal is $(f)$.

We don't require the ideal $(r)$ to be maximal or prime (corresponding in the
commutative case to residue rings that are fields and integral domains 
respectively). 

Instead, we allow $r$ to be any nonzero element of $R$, but raise an exception
every time a computation in $R/(r)$ requires computing an impossible inverse.

The parent object for a residue ring in Nemo has type \code{ResidueRing} belonging
to the type class \code{Ring} and residues have type \code{Residue} belonging to
the type class \code{ResidueElem} which in turn belongs to \code{RingElem}. 

There is no need to deal directly with these types, as we provide a function
\code{ResidueRing} for constructing residue ring parent objects and various
constructors for creating residue objects.

Both the \code{ResidueRing} and \code{Residue} types are parameterised by the
type of objects in the base ring over which the residue ring is constructed.

Each \code{Residue} object contains a pointer to its parent object, which in
turn contains the modulus for the residue.

\subsubsection{Constructors}

To make it easy to deal with the \code{ResidueRing} type in Nemo, we provide a
function for constructing the parent object of a residue ring

\begin{lstlisting}
ResidueRing{T <: RingElem}(S::Ring, el::T)
ResidueRing{T <: RingElem}(S::Ring, el::Integer)
\end{lstlisting}

\desc{This function takes a base ring \code{S} and an element \code{el} of that
ring. The function returns a parent object for the residue ring \code{S/(el)}.}

In the constructors below we assume \code{R} has been created using the 
\code{ResidueRing} constructor, e.g:

\begin{lstlisting}
R = ResidueRing(ZZ, 17)
\end{lstlisting}

We now discuss the various constructors available to create \code{Residue}
objects that belong to the given ring. In each case, \code{T} is the type of
elements of the base ring of the residue ring.

\begin{lstlisting}
R(a::T)
R(a::Integer)  
\end{lstlisting}

\desc{Create a residue congruent to $a$. The value $a$ is first reduced
modulo the modulus of the residue ring.}

\begin{lstlisting}
R(a::Residue{T})  
\end{lstlisting}

\desc{Return a reference to the residue $a$. No copy of the data is made.}

\begin{lstlisting}
Residue()
\end{lstlisting}

\desc{Create a new residue, which is congruent to $0$.}

\begin{lstlisting}
Residue(a::RingElem)
\end{lstlisting}

\desc{Try to coerce $a$ into the base ring of the residue ring and then
create a new residue congruent to it.}

\textbf{Examples.}

Here are some examples of constructing residue rings and elements in them.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = R(123)
g = R(f)
h = R(fmpz(12))
k = R()

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

m = T(x^4)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
modulus{T <: RingElem}(R::ResidueRing{T})
modulus{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the modulus of the given residue ring or of the parent of the given
residue element respectively.}

\begin{lstlisting}
data{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the value stored in the given residue element as an element of the
base ring.}

\begin{lstlisting}
zero{T <: RingElem}(R::ResidueRing{T})
\end{lstlisting}

\desc{Return the additive identity of the given residue ring.}

\begin{lstlisting}
one{T <: RingElem}(::ResidueRing{T})
\end{lstlisting}

\desc{Return the multiplicative identity of the given residue ring.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the additive identity in the
residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is the multiplicative identity in
the residue ring, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if the residue $a$ is invertible in the residue ring,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. The function simply returns $a$. No
check is performed to check that $a$ is actually invertible.}

\begin{lstlisting}
deepcopy{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Create a new residue element which is arithmetically equal to the given
residue element.}

\textbf{Examples.}

Here are some examples of basic manipulation of residue rings.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = modulus(R)
g = zero(R)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = one(T)

k = isunit(h)

m = canonical_unit(R(11))
n = canonical_unit(T(x + 1))

p = isone(h)
q = iszero(g)
\end{lstlisting}

\subsubsection{Unary operations}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 16453889)

f = -R(12345)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

h = -T(x^5 + 1)
\end{lstlisting}

\subsubsection{Binary operators}

The following binary operators for residue rings are provided.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

h = f + g
j = f - g
k = f*g

Q = ResidueRing(ZZ, 7)
S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

q = n + p
r = n - p
s = n*p
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return $a$ divided by $b$. If an impossible inverse is encounted
an exception is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
Q = ResidueRing(ZZ, 7)

a = Q(3)
b = Q(4)

m = divexact(a*b, a)

S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

t = divexact(n*p, p)
\end{lstlisting}

\begin{lstlisting}
gcd{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\subsubsection{GCD}

\desc{Return the greatest common divisor of $a$ and $b$. 

Recall that $a$ and $b$ are represented by values $a'$ and $b'$ in the base
ring. We define the greatest common divisor of $a$ and $b$ to be the residue
class of gcd$($gcd$(a', b'), m)$ when that is defined, where $m$ is the
modulus of the residue ring.

This definition does not depend on the choice of representatives of
$a$ and $b$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R = ResidueRing(ZZ, 12)

f = R(4)
g = R(6)

l = gcd(f, g)

Q = ResidueRing(ZZ, 7)
S, x = PolynomialRing(Q, "x")
T = ResidueRing(S, x^3 + 3x + 1)

n = T(x^5 + 1)
p = T(x^2 + 2x + 1)

u = gcd(n, p)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

In a residue ring $R$ over a ring $T$, with modulus $m$, it is convenient
to think of $n \in \Z$ as corresponding to $1$ added to itself $n$ times
in $T$ then reduced modulo $m$.

This allows us to efficiently define the following ad hoc operators, which
effectively make the integers $n \in \Z$ a convenient notation for certain
elements of the residue ring $R$.

\begin{lstlisting}
+{T <: RingElem}(a::Residue{T}, b::Integer)
+{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $a + b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
-{T <: RingElem}(a::Residue{T}, b::Integer)
-{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $a - b$ with the integer operand thought of as an element of 
the given residue ring.}

\begin{lstlisting}
*{T <: RingElem}(a::Residue{T}, b::Integer)
\end{lstlisting}

\desc{Return $ab$, i.e. the element $a$ added to itself $b$ times.}

\begin{lstlisting}
*{T <: RingElem}(a::Integer, b::Residue{T})
\end{lstlisting}

\desc{Return $ab$, i.e. the element $b$ added to itself $a$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a + 3
c = 3 - a
d = 5a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = f + 4
h = 4 - f
k = f*5
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
=={T, S}(x::Residue{T}, y::Residue{T})
\end{lstlisting}

\desc{Return \code{true} if $x = y$ arithmetically in the given residue ring, 
otherwise return false.}

Julia automatically defines a \code{!=} operator.

\begin{lstlisting}
isequal(x::Residue{T}, y::Residue{T})
\end{lstlisting}

\desc{Returns \code{true} if the residues (as elements of the base ring) compare
equal recursively according to \code{isequal}, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)
b = a
c = R(2)

b == a
c != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = 8f
h = f + g

f == g
h != g
isequal(f, g)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Thinking of integers as corresponding to elements of a residue ring, we
can define the following ad hoc comparison operators.

\begin{lstlisting}
=={T, S}(x::Residue{T}, y::Integer)
\end{lstlisting}

\desc{Given $x \in R$ for some residue ring $R$, return \code{true} 
if $x = y.1$ in $R$, otherwise return \code{false}.}

\begin{lstlisting}
=={T, S}(x::Integer, y::Residue{T})
\end{lstlisting}

\desc{Given $y \in R$ for some residue ring $R$, return \code{true} 
if $x.1 = y$ in $R$, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} operators.

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

a == 3
4 != a

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

f != 5
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Residue{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)

a = R(3)

b = a^5

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = f^100
\end{lstlisting}

\subsubsection{Inversion}

So long as we don't encounter an impossible inverse, we can
invert an element in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
inv{T <: RingElem}(a::Residue{T})
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the given residue
ring, i.e. return an element $b$ such that $ab = 1$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of computing inverses.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)

b = inv(a)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)

g = inv(f)
\end{lstlisting}

\subsubsection{Exact division}

So long as we don't encounter an impossible inverse, we can
divide elements in a residue ring $R = T/(m)$, if $T$ is a
Euclidean ring, i.e. if we have a \code{gcd} function in $T$.

\begin{lstlisting}
divexact{T <: RingElem}(a::Residue{T}, b::Residue{T})
\end{lstlisting}

\desc{Return the quotient of $a$ by $b$ in the given residue
ring, i.e. return an element $c$ such that $ac = b$ in the residue ring,
if such exists. If an impossible inverse is encountered during the
computation, we throw an exception.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = ResidueRing(ZZ, 49)

a = R(5)
b = R(3)

c = divexact(a, b)

S, x = PolynomialRing(R, "x")
T = ResidueRing(S, x^3 + 3x + 1)

f = T(x^5 + 1)
g = T(x^4 + x + 2)

h = divexact(f, g)
\end{lstlisting}

\subsection{Generic power series rings ($R[[x]]$): \code|PowerSeries\{T\}|}

In Nemo we provide univariate power series rings. The type of a parent object for
a power series ring is a \code{PowerSeriesRing} which belongs to the \code{Ring}
type class. Power series elements are of type \code{PowerSeries} which belongs to
the \code{SeriesElem} type class, which in turn belongs to \code{RingElem}.

There's no need to deal directly with these types, as we provide a function
\code{PowerSeriesRing} for constructing the ring parent objects and various
constructors to create power series element objects.

As for the \code{Poly} type, the \code{PowerSeries} and \code{PowerSeriesRing}
types take as parameters the type \code{T} of the elements in the base ring
over which the power series ring is constructed.

For example, if there wasn't a special Flint type for power series, the type of
a power series ring $\Z[[x]]$ over the Flint integers would be denoted
\code|PowerSeriesRing{fmpz}| and elements of the ring would have type
\code|PowerSeries{fmpz}|.

Power series differ from polynomials in Nemo primarily in that they have a
precision attached to them. Each power series object has its own precision,
stored in a field \code{prec} and each power series parent object has a
maximum precision, stored in \code{prec_max}.

The precision is always a non-negative integer.

By default, power series in Nemo use a \emph{capped relative} precision model.
This means that the precision of a power series in a given ring is capped at
the precision given by \code{prec_max}. Moreover, the precision of each 
individual power series is relative, meaning that if the leading term of
a nonzero power series element is $c_ax^a$ and the precision is $b$ then the
power series is of the form $c_ax^a + c_{a+1}x^{a+1} + \ldots + O(x^{a + b})$.

The zero power series is simply taken to be $0 + O(x^b)$.

(Another commonly seen model of power series is the \emph{capped absolute}
model. In that case a precision $b$ would indicate that all power series are
of the form $c_0x^0 + c_1x + \ldots + O(x^b)$, where $c_0$ need not be
nonzero. Currently Nemo doesn't provide an implementation of the capped
absolute model.)

The capped relative model has the advantage that power series are stable
multiplicatively. In other words, for nonzero power series $f$ and $g$ we
have that \code{divexact(f*g), g) == f}.

However, capped relative power series are not additively stable, i.e. we
do not always have $(f + g) - g = f$.

In the capped relative model we say that two power series are equal if they
agree up to the \emph{absolute} precision of the two power series. Thus, for
example, $x^5 + O(x^10) == 0 + O(x^5)$, since the minimum absolute precision
is $5$.

During computations, it is possible for power series to ``lose'' precision
due to cancellation. For example if $f = x^3 + x^5 + O(x^8)$ and
$g = x^3 + x^6 + O(x^8)$ then $f - g = x^5 - x^6 + O(x^8)$ which now has
relative precision $3$ instead of relative precision $5$.

Amongst other things, this means that equality is not transitive. For example
$x^6 + O(x^11) == 0 + O(x^5)$ and $x^7 + O(x^12) == 0 + O(x^5)$ but
$x^6 + O(x^11) \neq x^7 + O(x^12)$.

Sometimes it is necessary to compare power series not just for arithmetic
equality, as above, but to see if they have precisely the same precision and
terms. For this purpose we introduce the \code{isequal} function.

For example, if $f = x^2 + O(x^7)$ and $g = x^2 + O(x^8)$ and $h = 0 + O(x^2)$
then $f == g$, $f == h$ and $g == h$, but \code{isequal(f, g)},
\code{isequal(f, h)} and \code{isequal(g, h)} would all return \code{false}.
However, if $k = x^2 + O(x^7)$ then \code{isequal(f, k)} would return
\code{true}.

There are further difficulties if we construct polynomial over power series.
For example, consider the polynomial in $y$ over the power series ring in $x$
over the rationals. Normalisation of such polynomials is problematic. For
instance, what is the leading coefficient of $(0 + O(x^10))y + (1 + O(x^10))$?

If one takes it to be $(0 + O(x^10))$ then some functions may not terminate
due to the fact that algorithms may require the degree of polynomials to
decrease with each iteration. Instead, the degree may remain constant and
simply accumulate leading terms which are arithmetically zero but not
identically zero.

On the other hand, when constructing power series over other power series, if
we simply throw away terms which are arithmetically equal to zero, our
computations may have different output depending on the order in which
power series are added!

One should be aware of these difficulties when working with power series.
Power series, as represented on a computer, simply don't satisfy the axioms
of a ring. They must be used with care in order to approximate operations in
a mathematical power series ring.

Simply increasing the precision will not necessarily give a ``more correct''
answer and some computations may not even terminate due to the presence of
arithmetic zeroes!

Note that power series in Nemo are currently \emph{stored} in absolute 
rather than relative format. Thus $x^10 + O(x^30)$ has a length $11$
polynomial underlying it, rather than a length $1$ polynomial. This may
change in a later version of Nemo.

\subsubsection{Constructors}

We define the following function for constructing the parent object of a
power series ring.

\begin{lstlisting}
PowerSeriesRing(R::Ring, p::Int, s::String)
\end{lstlisting}

\desc{Returns a tuple \code{(S, x + O(x^p))} consisting of the parent \code{S} 
corresponding to the power series ring over the ring \code{R} and the generator
\code{x + O(x^p)} of that power series ring, where $p$ is the maximum precision
of elements of the power series ring.

The generator \code{x + O(x^p)} will be printed as per the supplied string
\code{s}, which specifies the variable for the power series. This need not be the
same as the variable name used to store the generator \code{x}, but it is usually
convenient to make it to be so.}

We also provide various constructors for creating elements of a power series
ring. Below we assume that $S$ is a power series ring parent object, created
for example by the following code:

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

We will also let $p$ stand for the maximum precision, e.g. $p = 30$ in the case of
$S$ as we just defined it, and $x$ to be the variable of the power series. We let
$T$ stand for the type of the coefficients of the power series.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Create the power series $0 + O(x^p)$.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Create the power series $a + O(x^p)$.}

\begin{lstlisting}
S(a::PowerSeries{T})
\end{lstlisting}

\desc{Return a reference to the power series \code{a}. No copy of the data is
made by this function.}

\begin{lstlisting}
S(a::Array{T, 1}, n::Int p::Int)
\end{lstlisting}

\desc{Create a power series with precision \code{p} and with coefficients given
by the array \code{a}. The constant coefficient of the power series will be the
first element in the array. The length \code{n} must be a nonnegative integer
and may not exceed the number of elements in the array, though it may be less
(this is useful so that one does not have to create a new array if the array
has trailing zeros). All but the first \code{n} terms of the array are ignored.}

\begin{lstlisting}
S(a::RingElem)
\end{lstlisting}

\desc{Try to coerce $a$ into the base ring of the power series ring and then
construct the power series $a + O(x^p)$.}

\begin{lstlisting}
O(a::PowerSeries{T})
\end{lstlisting}

\desc{The power series $a$ should be of the form \code{x^n} for some nonnegative
\code{n}. The function then returns $0 + O(x^n)$ with the same parent as the
supplied power series.

If the power series $0$ is passed to this function we throw a \code{DomainError()}. 

Note that whilst we do not disallow it, we do not give any special meaning to
expressions like $O(x - 1)$. Only the highest degree of the nonzero terms is
observed.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x^3 + 2x + 1
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)

c = S(a)
d = S([t + 1, t, R(1)], 3, 5)

g = S(1)
h = S(fmpz(2))
k = S()
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
length{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the length of the polynomial underlying the power series $a$, i.e.
its degree plus one. Recall that power series in Nemo are stored in absolute
format, not relative format, so the length of the underlying polynomial may be
much bigger than the precision due to leading zeros.}

\begin{lstlisting}
normalise{T <: RingElem}(a::PowerSeries{T}, len::Int)
\end{lstlisting}

\desc{Return the normalised length of the polynomial representing the power
series \code{a}, assuming that its unnormalised length is \code{len}. The
polynomial representing \code{a} is normalised if it has either length $0$
or its leading coefficient is nonzero. This function is mainly used internally
because all user functions in Nemo normalise the internal polynomial
representation of power series.}

\begin{lstlisting}
coeff{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return the coefficient of the power series \code{a} with degree 
\code{n}. If $n < 0$ we throw a \code{DomainError()} and if $n$ is greater
than or equal to the power series precision we return $0$.}

\begin{lstlisting}
zero{T <: RingElem}(R::PowerSeriesRing{T})
\end{lstlisting}

\desc{Return $0 + O(x^p)$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
one{T <: RingElem}(::Type{PowerSeries{T}})
\end{lstlisting}

\desc{Return $1 + O(x^p)$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
gen{T <: RingElem}(::Type{PowerSeries{T}})
\end{lstlisting}

\desc{Return $x + O(x^{p+1})$ where $p$ is the maximum precision for the
given power series ring and where $x$ is its variable.}

\begin{lstlisting}
iszero{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $0$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isone{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $1$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isgen{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to $x$ in the
power series ring up to the precision of $a$.}

\begin{lstlisting}
isunit{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is an invertible element of the power series
ring, i.e. if the lead term is degree zero with invertible coefficient.
Otherwise, return \code{false}.}

\begin{lstlisting}
valuation{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the valuation of the power series \code{a} with respect to the
generator of the power series ring. If the power series is zero to finite
precision $n$, the valuation is defined to be $n$.}

\begin{lstlisting}
precision{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the (absolute) precision of the power series \code{a}.}

\begin{lstlisting}
max_precision{T <: RingElem}(R::PowerSeriesRing{T})
\end{lstlisting}

\desc{Return the maximum precision for the given power series ring. Recall
that this is a relative precision.}

\begin{lstlisting}
deepcopy{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Create a new power series object which is precisely equal to the
supplied power series, i.e. with the same coefficients and precision.}

\textbf{Examples.}

Here are some examples of basic manipulations of power series.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = O(x^4)
b = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)

c = gen(R)
d = zero(R)
f = one(R)

g = iszero(d)
h = isone(f)
k = isgen(c)
m = isunit(-1 + x + 2x^2)
n = valuation(a)
p = valuation(b)
q = deepcopy(a)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = 1 + 2x + x^2 + O(x^3)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $a + b$. If the two power series have differing absolute
precisions, the result will be a power series with the lower precision.}

\begin{lstlisting}
-{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $a - b$. If the two power series have differing absolute
precisions, the result will be a power series with the lower precision.}

\begin{lstlisting}
*{T <: RingElem}(a::PowerSeries{T}, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $ab$. The return precision is equal to the least out of the
sum of the precision of \code{a} and the valuation of \code{b} and
the sum of the valuation of \code{a} and the precision of \code{b}.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = a + b
g = a - c
h = b*c
j = a*c
m = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*{T <: RingElem}(a::Int, b::PowerSeries{T})
*{T <: RingElem}(a::fmpz, b::PowerSeries{T})
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$b$.}

\begin{lstlisting}
*{T <: RingElem}(a::PowerSeries{T}, b::Int)
*{T <: RingElem}(a::PowerSeries{T}, b::fmpz)
\end{lstlisting}

\desc{Return $ab$. The resulting power series will have the same precision as
$a$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 3x^2 + O(x^5)
d = x^2 + 3x^3 - x^4

f = 2a
g = fmpz(3)*b
h = c*2
j = d*fmpz(3)
\end{lstlisting}

\subsubsection{Comparison}

Note that we take the convention that $1 + x + O(x^4) == 1 + x + O(x^8)$. 

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if the two power series are the same up to the lesser
of the precisions of the two series, otherwise return \code{false}.}

Julia automatically defines a corresponding \code{!=} operator.

\begin{lstlisting}
isequal(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Returns \code{true} if the $x == y$, the precisions of $x$ and $y$ are
the same and if each coefficient of $x$ recursively compares equal to the
corresponding coefficient of $y$ according to \code{isequal}, otherwise return
\code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^3)
c = 1 + x + 3x^2 + O(x^5)
d = 3x^3 - x^4

a == 2x + x^3
b == d
c != d
isequal(b, d) == false
\end{lstlisting}

\subsubsection{Ad hoc comparison}

Note that we take the convention that $0 == 0 + O(x^4)$.

\begin{lstlisting}
=={T <: RingElem}(x::PowerSeries{T}, y::Int)
=={T <: RingElem}(x::PowerSeries{T}, y::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the power series \code{x} is equal to \code{y} up
to the precision it has. Note that this is always true if \code{x} has
precision $0$.}

\begin{lstlisting}
=={T <: RingElem}(x::Int, y::PowerSeries{T})
=={T <: RingElem}(x::fmpz, y::PowerSeries{T})
\end{lstlisting}

\desc{Return \code{true} if the power series \code{y} is equal to \code{x} up
to the precision it has. Note that this is always true if \code{y} has
precision $0$.}

Julia automatically defines a corresponding \code{!=} operator corresponding to
the above.

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^0)
c = 1 + O(x^5)
d = S(3)

d == 3
c == fmpz(1)
fmpz(0) != a
2 == b
fmpz(1) == c
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::PowerSeries{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$. The result will have precision equal to $b - 1$ times the
valuation of $a$ plus the precision of $a$. This is the same as if $a$ were
multiplied by itself $b$ times.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = a^12
g = b^12
h = c^12
k = d^12
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
shift_left{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return \code{a*x^n}, where \code{x} is the generator of the power series
ring and \code{n} is a nonnegative integer. If \code{n} is negative we raise
a \code{DomainError()}.}

\begin{lstlisting}
shift_right{T <: RingElem}(a::PowerSeries{T}, n::Int)
\end{lstlisting}

\desc{Return \code{a/x^n}, discarding the remainder, where \code{x} is the
generator of the power series ring and \code{n} is a nonnegative integer. If 
\code{n} is negative we raise a \code{DomainError()}.}

\textbf{Examples.}

Here are some examples of shifting.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = shift_left(a, 2)
g = shift_left(b, 2)
h = shift_right(c, 1)
k = shift_right(d, 3)
\end{lstlisting}

\subsubsection{Truncation}

\begin{lstlisting}
truncate{T <: RingElem}(a::PowerSeries{T}, prec::Int)
\end{lstlisting}

\desc{Return the power series \code{a} truncated to the given (absolute)
precision. If \code{a} already has precision less than or equal to \code{prec}
this results in no change. If \code{prec} is negative we throw a
\code{DomainError()}.}

\textbf{Examples.}

Here are some examples of truncation.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 2x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = 2x + x^3 + O(x^4)

f = truncate(a, 3)
g = truncate(b, 2)
h = truncate(c, 7)
k = truncate(d, 5)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact{T <: RingElem}(x::PowerSeries{T}, y::PowerSeries{T})
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$. This requires \code{x} to have
valuation at least that of \code{y}. It also requires the first nonzero
coefficient of \code{y} to be a unit in the ring \code{T}. If \code{y}
is zero, a \code{DivideError()} is thrown. 

The precision of the result is equal to the minimum of $p_x - v_y$
and $p_y - 2v_y + v_x$ where $p_x$, $p_y$ are the precisions of \code{x} and
\code{y} respectively and $v_x$, $v_y$ are the corresponding valuations.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x + x^3 + O(x^6)

f = divexact(a, d)
g = divexact(d, a)
h = divexact(b, c)
k = divexact(d, c)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(x::PowerSeries{T}, y::Int)
divexact{T <: RingElem}(x::PowerSeries{T}, y::fmpz)
divexact{T <: RingElem}(x::PowerSeries{T}, y::T)
divexact{T <: RingElem}(x::PowerSeries{T}, y::Integer)
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$. If \code{y} is zero, a
\code{DivideError()} is thrown. 

The precision of the result is equal to that of $x$.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = x + x^3
b = O(x^4)
c = 1 + x + 2x^2 + O(x^5)
d = x + x^3 + O(x^6)

f = divexact(a, 7)
g = divexact(b, fmpz(11))
h = divexact(c, fmpz(2))
k = divexact(d, 9)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Return the power series inverse of $a$. A \code{DivideError()} is thrown 
if \code{a} is zero. An exception is thrown if \code{a} isn't invertible.

The precision of the result is equal to the precision of \code{a}.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = 1 + x + 2x^2 + O(x^5)
b = S(-1)

c = inv(a)
d = inv(b)
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp{T <: RingElem}(a::PowerSeries{T})
\end{lstlisting}

\desc{Compute the power series exponential of the given power series \code{a}
to the same precision as \code{a}. The valuation of \code{a} must be nonzero.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S, x = PowerSeriesRing(R, 30, "x")

a = exp(x + O(x^40))
b = divexact(x, exp(x + O(x^40)) - 1)
\end{lstlisting}

\subsection{Generic matrices (Mat$(R)$): \code|Mat\{T\}|}

In Nemo we provide generic matric spaces for $m\times n$ matrices over a ring $R$.
Note that $m\times n$ matrices do not form a ring.

The type of a parent object for a matrix space is a \code{MatrixSpace}. Currently
this belongs to the \code{Ring} type class to accomodate the special case when
working with $n\times n$ matrices. However this will change in a later version
of Nemo when matrix algebras are provided.

Matrix elements are of type \code{Mat} which belongs to the \code{MatElem} type
class, which in turn belongs to \code{RingElem}. Again, this is temporary to
accomodate the special case where matrices happen to be square, forming an actual
mathematical ring.

There's no need to deal directly with these types, as we provide a function
\code{MatrixSpace} for constructing the matrix space parent objects and various
constructors to create matrix objects.

As for other generic types, the \code{Mat} and \code{MatrixSpace}
types take as parameters the type \code{T} of the elements in the base ring
over which the matrix space is constructed.

For example, if there wasn't a special Flint type for matrices, the type of
a matrix space $Mat_{m, n}(\Z)$ over the Flint integers would be denoted
\code|MatrixSpace{fmpz}| and elements of the matrix space would have type
\code|Mat{fmpz}|.

\subsubsection{Constructors}

We define the following function for constructing the parent object of a
matrix space.

\begin{lstlisting}
MatrixSpace(R::Ring, r::Int, c::Int)
\end{lstlisting}

\desc{Returns a parent object \code{S} corresponding to the space of $r\times c$
matrices over the ring \code{R}}.

We also provide various constructors for creating elements of a matrix space. Below
we assume that $S$ is a matrix space parent object, created for example by the
following code:

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)
\end{lstlisting}

In the following we will also let $r$ stand for the number of rows and $c$ for the
number of columns, e.g. $r = 3$ and $c = 3$ in the case of $S$ as we just defined it.
We let $T$ stand for the type of the entries of the matrices.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Create the $r\times c$ matrix with all entries zero.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Create the $r\times c$ diagonal matrix, with diagonal entries equal to
$a$ (viewed as an element of the base ring).}

\begin{lstlisting}
S(a::Mat{T})
\end{lstlisting}

\desc{Return a reference to the matrix \code{a}. No copy of the data is
made by this function.}

\begin{lstlisting}
S(a::Array{T, 2})
\end{lstlisting}

\desc{Create an $r\times c$ given by the entries of the $r\times c$ Julia array
$a$.}

\begin{lstlisting}
S(a::RingElem)
\end{lstlisting}

\desc{Try to coerce $a$ into the base ring of the matrix space and then construct
the diagonal $r\times c$ matrix with diagonal entries equal to $a$.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S()
B = S(12)
C = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
D = S(c)
F = S(R(11))
\end{lstlisting}

\subsubsection{Basic manipulation}

To access entries of a matrix we overload Julia's \code{getindex} and \code{setindex}
methods. For example, if $A$ is a \code|Mat{T}|as defined in the example above
we have the following matrix notation.

\begin{lstlisting}
A[i::Int, j::Int]
\end{lstlisting}

\desc{When assigned to, this allows the entry at row $i$ and column $j$ to be assigned
to. When used in an expression, this allows the entry at row $i$ and column $j$ of
the matrix to be used in an expression. Note that Julia arrays and Nemo matrices are
$1$-indexed, i.e. the top left entry is $A[1, 1]$.}

\begin{lstlisting}
rows{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return the number of rows of the given matrix.}

\begin{lstlisting}
cols{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return the number of rows of the given matrix.}

\begin{lstlisting}
zero{T <: RingElem}(R::MatrixSpace{T})
\end{lstlisting}

\desc{Return the $0$ matrix in the matrix space, i.e. the matrix with all entries
equal to $0$ in the base ring.}

\begin{lstlisting}
one{T <: RingElem}(::Type{MatrixSpace{T}})
\end{lstlisting}

\desc{Return $1$ diagonal matrix in the matrix space, i.e. the matrix with all
diagonal entries equal to $1$ in the base ring.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to the $0$ matrix.}

\begin{lstlisting}
isone{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return \code{true} if $a$ is arithmetically equal to the $1$ diagonal
matrix.}

\begin{lstlisting}
deepcopy{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Create a new matrix object which is equal to the supplied matrix, i.e.
with the same entries.}

\textbf{Examples.}

Here are some examples of basic manipulation of matrices.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])

C = zero(S)
D = one(S)

f = iszero(C)
g = isone(D)
h = A[1, 2]
B[1, 1] = R(3)
r = rows(B)
c = cols(B)
k = deepcopy(A)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return $-a$, i.e. the matrix with all entries negated.}

\textbf{Examples.}

Here is an example of unary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

B = -A
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+{T <: RingElem}(a::Mat{T}, b::Mat{T})
\end{lstlisting}

\desc{Return $a + b$. The matrices must have the same dimensions otherwise
an exception is thrown.}

\begin{lstlisting}
-{T <: RingElem}(a::Mat{T}, b::Mat{T})
\end{lstlisting}

\desc{Return $a - b$. The matrices must have the same dimensions otherwise
an exception is thrown.}

\begin{lstlisting}
-{T <: RingElem}(a::Mat{T}, b::Mat{T})
\end{lstlisting}

\desc{Return $a - b$. The matrices must have the same dimensions otherwise
an exception is thrown.}

\begin{lstlisting}
*{T <: RingElem}(a::Mat{T}, b::Mat{T})
\end{lstlisting}

\desc{Return $a - b$. The number of columns of $a$ must equal the number of
rows of $b$, otherwise an exception is thrown.}

\textbf{Examples.}

Here is an example of unary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])

C = A + B
D = A - B
F = A*B
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
+{T <: RingElem}(a::Mat{T}, b::Integer)
+{T <: RingElem}(a::Mat{T}, b::fmpz)
+{T <: RingElem}(a::Mat{T}, b::T)
\end{lstlisting}

\desc{Return the sum of $a$ and the diagonal matrix with $b$ for the diagonal
entries.}

\begin{lstlisting}
+{T <: RingElem}(a::Integer, b::Mat{T})
+{T <: RingElem}(a::fmpz, b::Mat{T})
+{T <: RingElem}(a::T, b::Mat{T})
\end{lstlisting}

\desc{Return the sum of the diagonal matrix with $a$ for the diagonal
entries and the matrix $b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Mat{T}, b::Integer)
-{T <: RingElem}(a::Mat{T}, b::fmpz)
-{T <: RingElem}(a::Mat{T}, b::T)
\end{lstlisting}

\desc{Return the difference of $a$ and the diagonal matrix with $b$ for the diagonal
entries.}

\begin{lstlisting}
-{T <: RingElem}(a::Integer, b::Mat{T})
-{T <: RingElem}(a::fmpz, b::Mat{T})
-{T <: RingElem}(a::T, b::Mat{T})
\end{lstlisting}

\desc{Return the difference of the diagonal matrix with $a$ for the diagonal
entries and the matrix $b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Mat{T}, b::Integer)
*{T <: RingElem}(a::Mat{T}, b::fmpz)
*{T <: RingElem}(a::Mat{T}, b::T)
\end{lstlisting}

\desc{Return the matrix whose entries are those of $a$ multiplied by $b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Integer, b::Mat{T})
*{T <: RingElem}(a::fmpz, b::Mat{T})
*{T <: RingElem}(a::T, b::Mat{T})
\end{lstlisting}

\desc{Return the matrix whose entries are $a$ multiplied by the entries of
$b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

B = A + 12
C = fmpz(11) + A
D = A - (t + 1)
F = A*3
G = fmpz(7)*A
H = (t - 1)*A
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Mat{T}, n::Int)
\end{lstlisting}

\desc{Return the matrix $a$ raised to the power of $n$, i.e. multiplied by
itself $n$ times. For generic matrices over a ring, binary exponentiation is
used. If the exponent is $0$ the $1$ diagonal matrix is returned. Currently
negative powers are not supported and a \code{DomainError()} is raised in
this case. Note that the matrix must be square for this operation to be
performed, otherwise an exception is raised.}

\textbf{Examples.}

Here is an example of powering.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

B = A^12
\end{lstlisting}

\subsubsection{Comparisons}

\begin{lstlisting}
=={T <: RingElem}(a::Mat{T}, b::Mat{T})
\end{lstlisting}

\desc{Return \code{true} if the two matrices are equal, i.e. if corresponding
entries are equal, otherwise return \code{false}. The matrices must have the
same dimensions, otherwise an exception is raised.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])
B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])

A != B
A == deepcopy(A)
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

\begin{lstlisting}
=={T <: RingElem}(a::Mat{T}, b::Integer)
=={T <: RingElem}(a::Mat{T}, b::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the matrix $a$ is equal to the diagonal matrix
of the same dimensions with $b$ for the diagonal entries, otherwise
return \code{false}.}

\begin{lstlisting}
=={T <: RingElem}(a::Integer, b::Mat{T})
=={T <: RingElem}(a::fmpz, b::Mat{T})
\end{lstlisting}

\desc{Return \code{true} if the diagonal matrix of the same dimensions as $b$,
with $a$ for the diagonal entries is equal to the matrix $b$, otherwise
return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

A != 12
fmpz(11) != A
S(11) == 11
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Mat{T}, b::Integer)
divexact{T <: RingElem}(a::Mat{T}, b::fmpz)
divexact{T <: RingElem}(a::Mat{T}, b::T)
\end{lstlisting}

\desc{Return $a/b$, i.e. the matrix whose entries are those of $a$ divided
by $b$. It is assumed that each such division is exact.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

B = divexact(A, -1)
C = divexact(12*A, fmpz(3))
D = divexact((t^2 - 1)*A, t + 1)
\end{lstlisting}

\subsubsection{Gram matrix}

\begin{lstlisting}
gram{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return the Gram matrix of $a$, i.e. if $a$ is an $r\times c$ matrix
return the $r\times r$ matrix whose entries $i, j$ are the dot products
of the $i$-th and $j$-th rows, respectively.}

\textbf{Examples.}

Here is an example of computing the Gram matrix.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

B = gram(A)
\end{lstlisting}

\subsubsection{Trace}

\begin{lstlisting}
trace{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return the trace of the matrix $a$, i.e. the sum of the diagonal
elementst. We require the matrix to be square.}

\textbf{Examples.}

Here is an example of computing the trace of a matrix.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

b = trace(A)
\end{lstlisting}

\subsubsection{Content}

\begin{lstlisting}
content{T <: RingElem}(a::Mat{T})
\end{lstlisting}

\desc{Return the content of the matrix $a$, i.e. the greatest common
divisor of all its entries, assuming it exists.}

\textbf{Examples.}

Here is an example of computing the content of a matrix.

\begin{lstlisting}
R, t = PolynomialRing(QQ, "t")
S = MatrixSpace(R, 3, 3)

A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])

b = content(A)
\end{lstlisting}

\section{Generic fields}

Nemo provides various constructions of fields. 

Nemo defines the abstract type \code{Field} like so:

\begin{lstlisting}
abstract Field <: Ring
\end{lstlisting}

This means fields can be used anywhere that a more general ring can be used
in Nemo.

Division in a field can be performed with \code{divexact}. Of course all
divisions in a field are exact, except division by zero which will raise
a \code{DivideError()}.

The \code{//} operator doubles as a division operator when passed operands
in a field. It is an alias for \code{divexact}.

\subsection{Fraction fields Frac$(R)$: \code|Fraction\{T\}|}

We allow the construction of a fraction field over any ring in Nemo. Not all
such constructions make sense. Typically it only makes sense to construct the
fraction field of an integral domain. However, so long as zero divisors are
avoided there is nothing stopping one constructing the fraction field of a
more general Euclidean ring in Nemo.

Specifically, a ring must provide a \code{gcd} function before we can take its
fraction field. This is required for canonicalisation.

The type of an element of a fraction field in Nemo is \code{Fraction} which
belongs to the type class \code{FractionElem} which in turn belongs to
\code{FieldElem}. The type of a fraction field parent object is
\code{FractionField} which belongs to \code{Field}.

The user need never deal directly with these types, as we provide convenient
functions for constructing objects of those types.

The types of \code{FractionField} parent objects and \code{Fraction} elements
are parameterised by the type \code{T} of elements of the base ring of the
fraction field.

The generic \code{Fraction} objects contain a numerator and denominator, both
of type \code{T}, and a pointer to the parent fraction field object.

The fraction field parent objects can be used to construct fractions in the
given fraction field.

The fractions in Nemo are canonicalised, which means that we divide both
numerator and denominator by their greatest common divisor. We also divide
by \code{canonical_unit(d)} where \code{d} is the denominator when needed,
e.g. when printing fractions or taking their numerator or denominator, etc.
We also use this to easily check equality of fractions.

The \code{canonical_unit} function must have the properties

\begin{lstlisting}
canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)
\end{lstlisting}

for all nonzero values $a$ and $b$ in the base ring and $u$ any invertible element
in the base ring. Moreover, \code{canonical_unit} must always return an invertible
element in the base ring for nonzero elements of the ring.

We overload the \code{//} operator in Nemo for rings whose fraction field can
be taken (e.g. \code{fmpz} and \code|Poly{T}|), so that elements of the
fraction field of a ring can be constructed directly, without first
constructing the type.

For example if we have

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

s = (x + 1)//(x^2 + 1)
\end{lstlisting}

then the value $s$ belongs to the fraction field of $R$ automatically, even
though this field has not been constructed yet.

In Nemo, we consider the fraction field of a field to be itself.

\subsubsection{Constructors}

We provide a convenient function for constructing a fraction field of a ring in
Nemo.

\begin{lstlisting}
FractionField(R::Ring)
\end{lstlisting}

\desc{Construct the fraction field of the given ring.}

There are also numerous constructors for generating elements in the fraction
field. In the constructor below, we assume $S$ is the fraction field of a ring,
e.g. as constructed by the following:

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
S = FractionField(R)
\end{lstlisting}

We assume $T$ represents the type of elements of the base ring.

\begin{lstlisting}
S(a::T)
\end{lstlisting}

\desc{Construct the canonicalised fraction \code{a//1} in the fraction field.}

\begin{lstlisting}
S(a::Integer)
S(a::T)
\end{lstlisting}

\desc{Return the value $a//1$ in the fraction field.}

\begin{lstlisting}
S(a::Integer, b::Integer)
S(a::T, b::T)
S(a::T, b::Integer)
S(a::Integer, b::T)
\end{lstlisting}

\desc{Construct the canonicalised fraction \code{a//b} in the fraction field. If
$b = 0$ we throw a \code{DivideError()} and an exception is raised in general
if $b$ is not invertible.}

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the value $0/1$ in the fraction field.}

\begin{lstlisting}
S(a::Fraction{T})
\end{lstlisting}

\desc{Return a reference to the value $a$. No copy of the data is made.}

\begin{lstlisting}
S(b::RingElem)
\end{lstlisting}

\desc{Coerce $b$ into the base ring of the fraction field and construct the
fraction $b//1$.}

We also provide a simpler way of constructing elements of a fraction field
without needing to first construct the type of the fraction field. 

\begin{lstlisting}
//(x::T, y::T)
//(x::T, y::Integer)
//(x::Integer, y::T)
\end{lstlisting}

\desc{Return the canonicalised value $x//y$ in the fraction field. In the cases
where one argument is an integer, it is first coerced into the base ring. If
$y = 0$ we throw a \code{DivideError()} and an exception is raised in general
if $y$ is not invertible.}

\textbf{Examples.}

Here are some examples of constructors for fraction fields.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")
T = FractionField(S)

b = T(3)
c = T(fmpz(7))
d = T(x + 2)
f = T(d)
g = T()
h = T(x + 1, x + 2)

k = (x + 3)//(x^2 + 2)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
num{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return the numerator of the fraction $a$.}

\begin{lstlisting}
den{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return the denominator of the fraction $a$.}

\begin{lstlisting}
zero{T <: RingElem}(R::FractionField{T})
\end{lstlisting}

\desc{Return the additive identity of the fraction field of the ring $T$.}

\begin{lstlisting}
one{T <: RingElem}(R::Type{FractionField{T})
\end{lstlisting}

\desc{Return the multiplicative identity of the fraction field of the ring 
$T$.}

\begin{lstlisting}
iszero{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is the additive identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isone{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is multiplicative identity in the
fraction field, otherwise return \code{false}.}

\begin{lstlisting}
isunit{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $a$ is invertible, i.e. is not zero,
otherwise return \code{false}.}

\begin{lstlisting}
canonical_unit{T}(a::Fraction{T})
\end{lstlisting}

\desc{Used for canonicalising fractions. This function simply returns $a$.}

\begin{lstlisting}
deepcopy{T}(a::Fraction{T})
\end{lstlisting}

\desc{Creates a new fraction object arithmetically equal to $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations for fraction fields.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = den((x + 1)//(-x^2 + 1))

c = zero(S)
d = one(S)
f = canonical_unit((x + 1)//(-x^2 + 1))
g = isunit((x + 1)//(-x^2 + 1))

h = iszero(c)
d = isone(d)
f = deepcopy(d)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here is an example of a unary operator.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -((x + 1)//(-x^2 + 1))
\end{lstlisting}

\subsubsection{Binary operators and functions}

The following binary operators are available for elements of fraction fields.
All of the functions canonicalise their outputs.

\begin{lstlisting}
+{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $a*b$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)
b = (x + 1)//(-x^2 + 1) - x//(2x + 1)
c = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following binary operators are more efficient than simply coercing both
arguments into the fraction field. All functions canonicalise their outputs.

\begin{lstlisting}
+{T <: RingElem}(a::Fraction{T}, b::Integer)
+{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a + b/1$.}

\begin{lstlisting}
+{T <: RingElem}(a::Integer, b::Fraction{T})
+{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 + b$.}

\begin{lstlisting}
-{T <: RingElem}(a::Fraction{T}, b::Integer)
-{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a - b/1$.}

\begin{lstlisting}
-{T <: RingElem}(a::Integer, b::Fraction{T})
-{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 - b$.}

\begin{lstlisting}
*{T <: RingElem}(a::Fraction{T}, b::Integer)
*{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a * b/1$.}

\begin{lstlisting}
*{T <: RingElem}(a::Integer, b::Fraction{T})
*{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $a/1 * b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

c = a + 2
d = 3 - a
e = b*(x + 1)
\end{lstlisting}

\subsubsection{Comparison operators}

\begin{lstlisting}
=={T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y$, else
return \code{false}.}

\begin{lstlisting}
isequal{T}(x::Fraction{T}, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerators of \code{x} times the denominator
of \code{y} compares equal recursively according to \code{isequal} with the
denominator of \code{x} times the numerator of \code{y}, else return
\code{false}.}

\textbf{Examples.}

Here are some examples of comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -(ZZ(4)/ZZ(6))
b = -((x + 1)/(-x^2 + 1))

a == -ZZ(2)/ZZ(3)
b == 1/(x - 1)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following comparison operators are faster than first coercing both
operands into the fraction field.

\begin{lstlisting}
=={T}(x::Fraction{T}, y::T)
\end{lstlisting}

\desc{Return \code{true} if the fraction $x$ equals the fraction $y/1$, else
return \code{false}.}

\begin{lstlisting}
=={T}(x::T, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the fraction $y$ equals the fraction $x/1$, else
return \code{false}.}

\begin{lstlisting}
=={T <: RingElem}(x::Fraction{T}, y::Integer)
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $x$ is equal to $y$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\begin{lstlisting}
=={T <: RingElem}(x::Integer, y::Fraction{T})
\end{lstlisting}

\desc{Return \code{true} if the numerator of the fraction $y$ is equal to $x$
in the ring $T$ and the denominator is $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = 1//(x - 1)

1//a == x - 1
1 == one(S)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^{T <: RingElem}(a::Fraction{T}, b::Int)
\end{lstlisting}

\desc{Return $a^b$. The exponent may be negative.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

c = a^(-12)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv{T <: RingElem}(a::Fraction{T})
\end{lstlisting}

\desc{Return $1/a$.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1)

b = inv(a)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
//{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return the $a*inv(b)$.}

\begin{lstlisting}
divexact{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{An alias for \code{a//b}.}

\textbf{Examples.}

Here are an example of exact division.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x + 1)//(-x^2 + 1) 
b = -x//(2x + 1)

c = a//c
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact{T <: RingElem}(a::Fraction{T}, b::Integer)
divexact{T <: RingElem}(a::Fraction{T}, b::T)
\end{lstlisting}

\desc{Return $a / (b/1)$.}

\begin{lstlisting}
divexact{T <: RingElem}(a::Integer, b::Fraction{T})
divexact{T <: RingElem}(a::T, b::Fraction{T})
\end{lstlisting}

\desc{Return $(a/1) / b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = (x^2)//(2x + 1)
b = (x + 1)//(-x^2 + 1)

f = a//5
g = (x + 1)//b
h = 3//b
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd{T <: RingElem}(a::Fraction{T}, b::Fraction{T})
\end{lstlisting}

\desc{Return $c/d$ where $c$ is the GCD of the numerators of $a$ and $b$ and
$d$ is the GCD of their denominators.}

\textbf{Examples.}

Here are some examples of binary operators and functions.

\begin{lstlisting}
S, x = PolynomialRing(ZZ, "x")

a = -x//(2x + 1)

f = gcd(a, (x + 1)/(x - 1))
\end{lstlisting}

\section{Flint rings}

Flint provides implementations of various explicit rings. These are used instead of generic
implementations where available.

We only describe the details that differ from the generic implementations above.

\subsection{General Flint functions}

\begin{lstlisting}
flint_cleanup()
\end{lstlisting}

\desc{Free any internal caches used by Flint, Arb and Antic.
Examples of cached data include \code{mpz} integers used internally
to speed up allocation of bignums,
prime numbers, and high-precision values of mathematical constants.
Normally, these caches should not take up too much memory, but there may
be extreme circumstances where the user needs to free them manually.
This function is safe to call at any time.}

\begin{lstlisting}
flint_set_num_threads(n::Int)
\end{lstlisting}

\desc{Set the number of threads that Flint may use internally (the default
value is 1). Most functions are currently unaffected by this setting.}

\textbf{Examples.}

Here are some examples of the above functions.

\begin{lstlisting}
flint_cleanup()

flint_set_num_threads(2)

flint_set_num_threads(1)
\end{lstlisting}

\subsection{Flint integers ($\Z$): \code{fmpz}}

Multi-precision integers can be created in Nemo using \code{ZZ}. For example, to create the integer
$123$ one can write:

\begin{lstlisting}
ZZ(123)
\end{lstlisting}

By default, \code{ZZ} creates objects of the Flint \code{fmpz} type. This is achieved internally by
setting \code{ZZ = FlintIntegerRing()}, which makes \code{ZZ} the unique object of type
\code{FlintIntegerRing}.

One can also create Flint integers using the \code{fmpz} constructor directly:

\begin{lstlisting}
fmpz(123)
\end{lstlisting}

In Nemo library code we use \code{fmpz} rather than \code{ZZ} since the latter is defined only for the
convenience of the user and its definition may be changed by the user. It is also slightly more
efficient to call \code{fmpz} directly, since \code{ZZ} is a global variable.

The type of an \code{fmpz} object is \code{fmpz}. Thus the following returns \code{Nemo.fmpz}:

\begin{lstlisting}
typeof(fmpz(123))
\end{lstlisting}

An object of this type corresponds directly to the Flint \code{fmpz} C type.

The parent of an \code{fmpz} object is the unique object of type \code{FlintIntegerRing}. Thus the
following returns ``Integer Ring'':

\begin{lstlisting}
parent(fmpz(123))
\end{lstlisting}

The \code{FlintIntegerRing} type belongs to the \code{Ring} type class and the \code{fmpz} type
belongs to the \code{RingElem} type class. Thus both of the following return true:

\begin{lstlisting}
fmpz <: RingElem
FlintIntegerRing <: Ring
\end{lstlisting}

\subsubsection{Constructors}

Nemo provides various constructors for the \code{fmpz} type. Space is automatically
recovered when the created object goes out of scope.

\begin{lstlisting}
fmpz()
\end{lstlisting}

\desc{Creates an initialised \code{fmpz}. Its value will be $0$.}

\begin{lstlisting}
fmpz(n::Int)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given signed machine word value $n$.}

\begin{lstlisting}
fmpz(n::BigInt)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given Julia \code{BigInt} value $n$.}

\begin{lstlisting}
fmpz(n::Integer)
\end{lstlisting}

\desc{Create an \code{fmpz} with the given value $n$, where $n$ has any type belonging to the Julia
\code{Integer} type class.}

\begin{lstlisting}
fmpz(n::Float16)
fmpz(n::Float32)
fmpz(n::Float64)
fmpz(n::BigFloat)
\end{lstlisting}

\desc{If $n$ is an exact integer, return the \code{fmpz} with the value $n$, otherwise raise an
\code{InexactError}.}

\begin{lstlisting}
fmpz(s::String)
\end{lstlisting}

\desc{Create an \code{fmpz} whose value is represented (in decimal) by the given string
$s$. The string should not contain any whitespace, and can optionally begin with
a $-$ sign.}

\begin{lstlisting}
fmpz(x::fmpz)
\end{lstlisting}

\desc{Returns a reference to $x$. No copy of the data is made.}

\begin{lstlisting}
deepcopy(x::fmpz)
\end{lstlisting}

\desc{Create a new \code{fmpz} whose value is arithmetically equal to that of $x$.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12.0)
c = fmpz("-1234567876545678376545678900000000000000000000000000")
d = fmpz(BigFloat(10)^100)
e = fmpz(c)
f = deepcopy(c)
\end{lstlisting}

\subsubsection{Conversions}

It is possible to convert \code{fmpz} values to a variety of other types. This is
achieved by overloading Julia's \code{convert} function.

\begin{lstlisting}
Int(x::fmpz)
UInt(x::fmpz)
BigInt(x::fmpz)
Float64(x::fmpz)
Float32(x::fmpz)
Float16(x::fmpz)
BigFloat(x::fmpz)
\end{lstlisting}

\desc{Convert the \code{fmpz} $x$ to the given type.}

\textbf{Examples.}

Here are some examples of the above constructors.

\begin{lstlisting}
a = fmpz(-123)
b = fmpz(12)

c = Int(a)
d = UInt(b)
f = Float64(a)
g = BigFloat(a)
\end{lstlisting}

\subsubsection{Basic manipulation}

Various functions are provided to do basic manipulations of \code{fmpz}'s.

\begin{lstlisting}
one(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the multiplicative identity element in the ring of integers.}

\begin{lstlisting}
zero(::FlintIntegerRing)
\end{lstlisting}

\desc{Create the additive identity element in the ring of integers.}

\begin{lstlisting}
isone(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the multiplicative identity $1$, otherwise
return \code{false}.}

\begin{lstlisting}
iszero(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a$ is the additive identity $0$, otherwise
return \code{false}.}

\begin{lstlisting}
isunit(a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $a = 1$ or $a = -1$, otherwise return \code{false}.}

\begin{lstlisting}
sign(a::fmpz)
\end{lstlisting}

\desc{Return either $-1$, $0$ or $1$ depending on whether the sign of $a$ is negative,
zero or positive, respectively. The returned value is of type \code{Int}.}

\begin{lstlisting}
fits(::Type{Int}, a::fmpz)
fits(::Type{Uint}, a::fmpz)
\end{lstlisting}

\desc{Return \code{true} if the value $a$ will fit into a variable of the given
type. Otherwise return \code{false}.}

\begin{lstlisting}
size(a::fmpz)
\end{lstlisting}

\desc{Return the number of machine words that make up the bignum $a$. The
returned value has type \code{Int}.}

\begin{lstlisting}
canonical_unit(a::fmpz)
\end{lstlisting}

\desc{This is used for canonicalising fractions. The function simply returns $-1$
if $a < 0$, otherwise it returns $1$.}

\begin{lstlisting}
num(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Simply returns the value of \code{a}.}

\begin{lstlisting}
den(a::fmpz)
\end{lstlisting}

\desc{For convenience when working with rationals. Always returns \code{fmpz(1)}.}

\textbf{Examples.}

Here are some examples of the above basic manipulations.

\begin{lstlisting}
a = one(FlintIntegerRing()) # by default one(ZZ) is the same thing 
b = zero(FlintIntegerRing()) # by default zero(ZZ) is the same thing 

if sign(a) < 0
   println("Negative")
end

if fits(Int, a)
   println("Fits into an Int")
end

s = size(a)

t = canonical_unit(fmpz(-12))

u = isunit(fmpz(-1))
v = iszero(b)
w = isone(a)
\end{lstlisting}

\subsubsection{Binary operators}

The following standard binary operators are provided for \code{fmpz}. Note that \code{$} is Julia's
xor operator.

\begin{lstlisting}
+(a::fmpz, b::fmpz)
-(a::fmpz, b::fmpz)
*(a::fmpz, b::fmpz)
%(a::fmpz, b::fmpz)
&(a::fmpz, b::fmpz)
|(a::fmpz, b::fmpz)
$(a::fmpz, b::fmpz)
\end{lstlisting}

Note that \code{%} follows the C (and Julia) convention of rounding the quotient
towards zero. If $b = 0$ is passed to \code{%}, a \code{DivideError()} is thrown.

Julia automatically provides all of the combined assignment operators \code{+=, *=, &=}
etc.

Here are some examples of binary operators.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(26)

c = a + b
d = a - b
\end{lstlisting}

\subsubsection{Integer division}

Various kinds of integer division are provided.

\begin{lstlisting}
fdiv(a::fmpz, b::fmpz)
cdiv(a::fmpz, b::fmpz)
tdiv(a::fmpz, b::fmpz)
div(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Integer division with rounding towards $-\infty$, $+\infty$ and $0$ respectively.
Note \code{div} is a synonym for \code{tdiv}. If $b = 0$ is passed to any of these
functions, a \code{DivideError()} is thrown.}

Here are some examples of integer division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = cdiv(a, b)
d = fdiv(a, b)
\end{lstlisting}

\subsubsection{Remainder}

\begin{lstlisting}
mod(a::fmpz, b::fmpz)
mod(x::fmpz, c::Int)
rem(a::fmpz, b::fmpz)
rem(x::fmpz, c::Int)
\end{lstlisting}

\desc{Integer remainder after division with rounding towards $-\infty$ and $0$
respectively. Note that \code{\%} is a synonym for \code{rem}. If $b = 0$ is passed to 
any of these functions, a \code{DivideError()} is thrown.}

Here are some examples of the remainder functions.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(5)

c = mod(a, b)
d = rem(a, 3)
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::fmpz, b::fmpz)
divexact(x::fmpz, c::Int)
\end{lstlisting}

\desc{Exact integer division. This is more efficient than the above division functions,
but will only return a meaningful result if the division is exact, i.e. if $b$ divides
$a$. If $b = 0$ is passed to this function, a \code{DivideError()} is thrown.}

Here is an example of exact division.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(6)

c = divexact(a, b)
c = divexact(a, 2)
\end{lstlisting}

\subsubsection{GCD and LCM}

\begin{lstlisting}
gcd(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the greatest common divisor of $a$ and $b$. For convenience, 
gcd$(a, 0) = a$ and gcd$(0, b) = b$. The returned value is always nonnegative.}

\begin{lstlisting}
lcm(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Returns the lowest common multiple of $a$ and $b$, i.e. $ab/\gcd(a, b)$ if
$a, b > 0$. For convenience, lcm$(a, 0) = 0$ and lcm$(0, b) = 0$. The returned
value is always nonnegative.}

Here are some examples of GCD and LCM.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(15)

c = gcd(a, b)
d = lcm(a, b)
\end{lstlisting}

\subsubsection{Integer logarithms}

\begin{lstlisting}
flog(a::fmpz, b::fmpz)
flog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $0$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\begin{lstlisting}
clog(a::fmpz, b::fmpz)
clog(a::fmpz, b::Int)
\end{lstlisting}

\desc{Returns $\log_b(a)$ rounded towards $\infty$. Both $a$ and $b$ are required
to be positive, otherwise a \code{DomainError()} exception is thrown.}

\textbf{Examples.}

Here are some examples of integer logarithms.

\begin{lstlisting}
a = fmpz(12)
b = fmpz(3)

c = clog(a, b)
d = flog(a, 2)
\end{lstlisting}

\subsubsection{Ad hoc operators}

Since the Julia types \code{Int} and \code{Uint} cannot be made members of the
\code{Ring} class, we must define some ad hoc operators, so that values of type
\code{fmpz} can be more easily combined with \code{Int} and \code{Uint} values.

\begin{lstlisting}
+(x::fmpz, c::Integer)
+(x::fmpz, c::Int)
+(x::Integer, c::fmpz)
+(x::Int, c::fmpz)
-(x::fmpz, c::Integer)
-(x::fmpz, c::Int)
-(x::Integer c::fmpz)
-(x::Int, c::fmpz)
*(x::fmpz, c::Integer)
*(x::fmpz, c::Int)
*(x::Integer, c::fmpz)
*(x::Int, c::fmpz)
%(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of the ad hoc operators.

\begin{lstlisting}
a = fmpz(-12)

b = 3 + a
c = a + 3
d = a - 3
e = 5 - a
f = a % 7
\end{lstlisting}

\subsubsection{Ad hoc division}

We also define the following, which have the same semantics as the corresponding functions above.

\begin{lstlisting}
tdiv(x::fmpz, c::Int)
fdiv(x::fmpz, c::Int)
cdiv(x::fmpz, c::Int)
div(x::fmpz, c::Int)
\end{lstlisting}

Here are some examples of ad hoc division.

\begin{lstlisting}
a = fmpz(-12)

b = tdiv(a, 5)
c = cdiv(a, 3)
\end{lstlisting}

\subsubsection{Binary shifting}

We also define the following, which have the same semantics as the corresponding functions above.

There are also shift operators, which require the shift to be of type \code{Int}.

\begin{lstlisting}
<<(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $2^c x$.}

\begin{lstlisting}
fdivpow2(x::fmpz, c::Int)
cdivpow2(x::fmpz, c::Int)
tdivpow2(x::fmpz, c::Int)
>>(x::fmpz, c::Int)
\end{lstlisting}

\desc{Return $x/2^c$ with rounding towards $-\infty$, $+\infty$ and $0$ respectively. 
Note that \code{>>} is a synonym for \code{fdivpow2}.}

Here are some examples of binary shifting.

\begin{lstlisting}
a = fmpz(-12)

b = a << 3
c = a >> 1
d = fdivpow2(a, 2)
\end{lstlisting}

\subsubsection{Powering}

There is also the caret operator, which is used for powering in Julia (and Nemo), in
line with the mathematical convention.

\begin{lstlisting}
^(x::fmpz, a::Uint)
^(x::fmpz, a::Int)
\end{lstlisting}

\desc{Return $x^a$. Requires $a \geq 0$.}

\textbf{Examples.}

Here is an example of the caret operator.

\begin{lstlisting}
a = fmpz(-12)

b = a^10
\end{lstlisting}

\subsubsection{Comparison operators and functions}

The following standard comparison operators are provided for \code{fmpz}.

\begin{lstlisting}
==(a::fmpz, b::fmpz)
>(a::fmpz, b::fmpz)
<(a::fmpz, b::fmpz)
<=(a::fmpz, b::fmpz)
>=(a::fmpz, b::fmpz)
\end{lstlisting}

Julia automatically provides a \code{!=} operator.

Note that all these comparisons yield a result of type \code{Bool}.

There are also the following functions.

\begin{lstlisting}
isequal(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{For \code{fmpz} this is just an alias for the \code{==} operator.}

\begin{lstlisting}
cmp(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $x < y$, $1$ if $x > y$ and $0$ if $x = y$.}

\begin{lstlisting}
cmpabs(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return $-1$ if $|x| < |y|$, $1$ if $|x| > |y|$ and $0$ if 
$|x| = |y|$, where $|x|$ is the absolute value of $x$.}

\textbf{Examples.}

Here are some examples of the comparison operators and functions.

\begin{lstlisting}
a = fmpz(-12)
b = fmpz(5)

if a < b
   println("a < b")
end

if cmpabs(a, b) == 0
   println("The absolute values of a and b are equal")
end
\end{lstlisting}

\subsubsection{Ad hoc comparison operators}

We overload the comparison operators to more easily deal with values of type \code{Int}.

\begin{lstlisting}
==(a::fmpz, b::Int)
==(a::Int, b::fmpz)
>(a::fmpz, b::Int)
>(a::Int, b::fmpz)
<(a::fmpz, b::Int)
<(a::Int, b::fmpz)
<=(a::fmpz, b::Int)
<=(a::Int, b::fmpz)
>=(a::fmpz, b::Int)
>=(a::Int, b::fmpz)
\end{lstlisting}

\textbf{Examples.}

Here are some examples of the ad hoc comparison operators.

\begin{lstlisting}
a = fmpz(-12)

if a < 7
   println("a < 7")
end

if a == -12
   println("a == -12")
end
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(x::fmpz)
\end{lstlisting}

\desc{Return $-x$.}

\begin{lstlisting}
~(x::fmpz)
\end{lstlisting}

\desc{Return the bignum corresponding to logical complement of the twos 
complement representation of x, namely $-x - 1$.}

Here are some examples of the unary operators.

\begin{lstlisting}
a = -fmpz(12)
b = ~fmpz(-5)
\end{lstlisting}

\subsubsection{Absolute value}

\begin{lstlisting}
abs(x::fmpz)
\end{lstlisting}

\desc{Return the absolute value of $x$, i.e. $x$ if $x >= 0$ and $-x$ otherwise.}

\textbf{Examples.}

Here is an example of the absolute value function.

\begin{lstlisting}
a = fmpz(-12)

b = abs(a)
\end{lstlisting}

\subsubsection{Division with remainder}

\begin{lstlisting}
fdivrem(a::fmpz, b::fmpz)
tdivrem(a::fmpz, b::fmpz)
divrem(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(q, r)$ consisting of the quotient and remainder after 
division of $x$ by $y$, with rounding towards $-\infty$ and $0$ respectively. Note 
that \code{divrem} is a synonym for \code{tdivrem}. If $b = 0$ is passed to any
of these functions a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of the division with remainder functions.

\begin{lstlisting}
q, r = fdivrem(fmpz(12), fmpz(5))
q, r = tdivrem(fmpz(12), fmpz(5))
\end{lstlisting}

\subsubsection{Roots}

\begin{lstlisting}
isqrt(x::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$, rounded down to the nearest integer. If $x < 0$
a \code{DomainError()} is thrown.}

\begin{lstlisting}
isqrtrem(x::fmpz)
\end{lstlisting}

\desc{Return a tuple $(s, r)$ consisting of the square root of $x$, rounded down to the 
nearest integer and the remainder, i.e. $r = x - s^2$. If $x < 0$ a \code{DomainError()}
is thrown.}

\begin{lstlisting}
root(x::fmpz, n::Int)
\end{lstlisting}

\desc{Return the $n$-th root of $x$, rounded down to the nearest integer. If $x < 0$ and
$n$ is even, a \code{DomainError()} is thrown. If $n \leq 0$ a \code{DomainError()} is
thrown.}

\textbf{Examples.}

Here are some examples of the root taking functions.

\begin{lstlisting}
s = isqrt(fmpz(12))
s, r = isqrtrem(fmpz(12))
r = root(fmpz(1000), 3)
\end{lstlisting}

\subsubsection{Extended GCD}

\begin{lstlisting}
gcdx(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s, t)$ consisting of the greatest common divisor of $a$ and $b$
and values $s$ and $t$ such that $g = as + bt$, with $-b \leq s \leq b$ and 
$-a \leq t \leq a$.}

\begin{lstlisting}
gcdinv(a::fmpz, b::fmpz)
\end{lstlisting}

\desc{Return a tuple $(g, s)$ consisting of the greatest common divisor of $a$ and $b$
and a value $0 \leq s < b$ such that there exists a value $t$ such that 
$g = as + bt$. If $a < 0$ or $b < a$, a \code{DomainError()} is thrown.}

\textbf{Examples.}

Here are some examples of the extended GCD functions.

\begin{lstlisting}
g, s, t = gcdx(fmpz(12), fmpz(5))
g, s = gcdinv(fmpz(5), fmpz(12))
\end{lstlisting}

\subsubsection{Bit twiddling}

Various functions are provided to deal with bignums on a binary bit level.

\begin{lstlisting}
popcount(x::fmpz)
\end{lstlisting}

\desc{Return the number of binary ones in the binary representation of $x$. If $x < 0$ the
function will return $0$. The result that is returned is of type \code{Int}.}

\begin{lstlisting}
prevpow2(x::fmpz)
\end{lstlisting}

\desc{Return the largest power of $2$ which does not exceed $x$. If $x < 0$ the result is
set to \code{-prevpow2(-x)}.}

\begin{lstlisting}
nextpow2(x::fmpz)
\end{lstlisting}

\desc{Return the smallest power of $2$ which is not less than $x$. If $x < 0$ the result is
set to \code{-nextpow2(-x)}.}

\begin{lstlisting}
trailing_zeros(x::fmpz)
\end{lstlisting}

\desc{Return the number of trailing zeros in the binary representation of the absolute
value of $x$.}

\begin{lstlisting}
clrbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $0$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
setbit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Set bit $n$ in the binary representation of the absolute value of $x$ to $1$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\begin{lstlisting}
combit!(x::fmpz, n::Int)
\end{lstlisting}

\desc{Complement bit $n$ in the binary representation of the absolute value of $x$. Bits
are numbered starting with $n = 0$ for the least significant bit. N.B. this function does
not return the result, but alters the value of $x$. This is an unsafe operation which will
change the value of all variables which contain a reference to $x$.}

\textbf{Examples.}

Here are some examples of the bit twiddling functions.

\begin{lstlisting}
a = fmpz(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)
\end{lstlisting}

\subsubsection{Alternative bases}

\begin{lstlisting}
base(n::fmpz, b::Int)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in the given base $b$. Valid
bases are $2 \leq b \leq 62$. If an invalid base is applied an error is raised.}

\begin{lstlisting}
bin(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in binary, i.e. base $2$.}

\begin{lstlisting}
oct(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in octal, i.e. base $8$.}

\begin{lstlisting}
dec(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in decimal, i.e. base $10$.}

\begin{lstlisting}
hex(n::fmpz)
\end{lstlisting}

\desc{Return a unicode string giving the representation of $n$ in hexadecimal, i.e. base $16$.}

\begin{lstlisting}
ndigits(n::fmpz, b::Integer = 10)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of digits required to represent the
absolute value of $n$ as a string in base $b$. The default is $b = 10$. Note that $0$
always requires one digit as a string.}

\begin{lstlisting}
nbits(n::fmpz)
\end{lstlisting}

\desc{Return an \code{Int} representing the number of bits required to represent the
absolute value of $n$ in binary. We take the convention that $0$ requires $0$ binary 
bits.}

\textbf{Examples.}

Here are some examples of the functions for alternative bases.

\begin{lstlisting}
a = fmpz(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)
\end{lstlisting}

\subsubsection{String I/O}

\begin{lstlisting}
string(x::fmpz)
\end{lstlisting}

\desc{Return a unicode string representation of the value of $x$ in decimal, including the sign
if $x < 0$.}

\textbf{Examples.}

Here is an example of string I/O.

\begin{lstlisting}
a = fmpz(12)

string(a)
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the Euclidean remainder of $a$ by $b$. If $m = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
powmod(x::fmpz, p::Int, m::fmpz)
powmod(x::fmpz, p::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^p \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown.}

\begin{lstlisting}
invmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return $x^{-1} \pmod{m}$. If $m \leq 0$ a \code{DomainError()} is thrown. If
an impossible inverse is encountered, an exception is thrown.}

\begin{lstlisting}
gcdinv(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Returns the pair \code{g, xinv} where $g$ is the greatest common divisor of
$x$ and $m$ and \code{xinv} is $x^{-1} \pmod{m}$. If $m \leq 0$ a 
\code{DomainError()} is thrown.}

\begin{lstlisting}
sqrtmod(x::fmpz, m::fmpz)
\end{lstlisting}

\desc{Return the square root of $x$ modulo $m$. If $m \leq 0$ a \code{DomainError()}
is thrown. If $x$ is not a square modulo $m$, an exception is thrown. Requires $m$ to
be prime. This condition is not checked and an infinite loop may result if $m$ is
not prime.}

\begin{lstlisting}
crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, sign = false)
crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, sign = false)
\end{lstlisting}

\desc{Return a value $r$ such that $r \equiv r1 \pmod {m1}$ and $r \equiv r2 \pmod{m2}$.
If \code{sign = true} the value will be in the range \code{-m1*m2/2 < r <= m1*m2/2}. If
\code{sign = false} the value will be in the range \code{0 <= r < m1*m2}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = powmod(fmpz(12), fmpz(110), fmpz(13))
a = powmod(fmpz(12), 110, fmpz(13))
b = invmod(fmpz(12), fmpz(13))
c = sqrtmod(fmpz(12), fmpz(13))
d = crt(fmpz(5), fmpz(13), fmpz(7), fmpz(37), true)
\end{lstlisting}

\subsubsection{Number theoretic/combinatorial functions}

\begin{lstlisting}
divisible(x::fmpz, y::fmpz)
divisible(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return \code{true} if $x$ is divisible by $y$, otherwise return \code{false}. If
$y = 0$ a \code{DivideError()} is raised.}

\begin{lstlisting}
issquare(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is a perfect square, otherwise return \code{false}.}

\begin{lstlisting}
isprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is prime, otherwise return \code{false}.}

\begin{lstlisting}
isprobabprime(x::fmpz)
\end{lstlisting}

\desc{Return \code{true} if $x$ is very probably prime, otherwise return \code{false}.}

\begin{lstlisting}
remove(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Returns a pair $(n, z)$ where $n$ is an \code{Int} and $z$ a \code{fmpz} such that
$x = y^nz$ and $z$ is not divisible by $y$. If $y = 0$ a \code{DivideError()} is thrown.}

\begin{lstlisting}
divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)
\end{lstlisting}

\desc{If $n$ has a factor which lies in the residue class $r \pmod{m}$ for $0 < r < m < n$,
this function returns such a factor. Otherwise it returns $0$. This is only efficient if 
$m$ is at least the cube root of $n$. We require gcd$(r, m) = 1$ and this condition is not
checked.}

\begin{lstlisting}
fac(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the factorial of $n$, i.e. $n(n - 1)(n - 2)\ldots 1$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
risingfac(x::fmpz, n::Int)
risingfac(x::Int, n::Int)
\end{lstlisting}

\desc{Return the rising factorial of $x$, i.e. $x(x + 1)(x + 2)\ldots (x + n - 1)$.
If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
primorial(n::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the primorial of $n$, i.e. the product of all primes
less than or equal to $n$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
fib(n::Int)
\end{lstlisting}

\desc{Return the $n$-th element of the Fibonacci sequence, starting with 
\code{fib(1) = 1}, \code{fib(2) = 1} and following the recursion 
\code{fib(n) = fib(n - 1) + fib(n - 2)} for $n \geq 3$.
We return fib$(0) = 0$. If $n < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
binom(n::Int, k::Int)
\end{lstlisting}

\desc{Return as a \code{fmpz} the binomial coefficient $\frac{n!}{(n - k)!k!}$. If
$n, k < 0$ or $k > n$ we return $0$.}

\begin{lstlisting}
moebiusmu(x::fmpz)
\end{lstlisting}

\desc{Returns the M\"{o}bius mu function of $x$ as an \code{Int}. The value returned is
either $-1$, $0$ or $1$. If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
jacobi(x::fmpz, y::fmpz)
\end{lstlisting}

\desc{Return the value of the Jacobi symbol $\ljk{x}{y}$. If $y \leq x$ or $x < 0$ we
throw a \code{DomainError()}.}

\begin{lstlisting}
sigma(x::fmpz, y::Int)
\end{lstlisting}

\desc{Return the value of the sigma function, i.e. $\sum_{0 < d \;| x} d^y$. If $y < 0$
we throw a \code{DomainError()}.}

\begin{lstlisting}
eulerphi(x::fmpz)
\end{lstlisting}

\desc{Return the value of the Euler phi function, i.e. the number of $0 < d \leq x$ such
that gcd$(d, x) = 1$. If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
bell(x::Int)
\end{lstlisting}

\desc{Return the Bell number $B_n$.}

\begin{lstlisting}
numpart(x::fmpz)
numpart(x::Int)
\end{lstlisting}

\desc{Return the number of partitions of $x$, i.e. $p(x)$. Since $p(x)$
has $O(\sqrt{x})$ digits, this function can only be computed up to
about $x = 10^{19}$. For large $x$, the result is computed faster if one
sets \code{flint_set_num_threads(2)}.}

\textbf{Examples.}

Here are some examples of number theoretic and combinatorial functions.

\begin{lstlisting}
if isprime(fmpz(13))
   println("13 is prime")
end

n = fac(100)
s = sigma(fmpz(128), 10)
a = eulerphi(fmpz(12480))

p = numpart(1000)
\end{lstlisting}

\subsection{Flint polynomials over $\Z$: \code{fmpz_poly}}

The Flint integer polynomial type is \code{fmpz_poly}. Polynomials of this type are created
using the \code{PolynomialRing} constructor.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpzPolyRing}.

We describe functions for \code{fmpz_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided, as these are faster than first coercing
to a common ring and then applying the operator.

\begin{lstlisting}
+(x::fmpz_poly, y::Int)
+(x::fmpz_poly, y::fmpz)
+(x::Int, y::fmpz_poly)
+(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::fmpz_poly, y::Int)
-(x::fmpz_poly, y::fmpz)
-(x::Int, y::fmpz_poly)
-(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1
g = x^2 - 7x + 4

h = f + 7
k = g - 7
l = fmpz(3) + f
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

\begin{lstlisting}
==(x::fmpz_poly, y::fmpz)
==(x::fmpz, y::fmpz_poly)
\end{lstlisting}

\desc{Return \code{true} if $x == y$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

f != fmpz(6)
fmpz(7) == R(7)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fmpz_poly, y::Int)
\end{lstlisting}

\desc{Return the quotient of $x$ by $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 2x + 1

g = divexact(f*3, 3)
\end{lstlisting}

\subsubsection{Content, primitive part and GCD}

\begin{lstlisting}
content(f::fmpz_poly)
\end{lstlisting}

\desc{Return the content of the polynomial $f$, i.e. the greatest common divisor of its
coefficients.}

\begin{lstlisting}
primpart(f::fmpz_poly)
\end{lstlisting}

\desc{Return the primitive part of the polynomial $f$, i.e. the polynomial divided by
its content.}

\begin{lstlisting}
gcd(f::fmpz_poly, g::fmpz_poly)
\end{lstlisting}

\desc{Return the greatest common divisor of the polynomials $f$ and $g$.}

\textbf{Examples.}

Here is an example of ad hoc division.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^2 + 2x + 1
g = x^3 + 3x + 1
h = x + 1

k = content(3*f)
l = primpart(3*f)
m = gcd(f*h, g*h)
\end{lstlisting}

\subsubsection{Signature}

\begin{lstlisting}
signature(f::fmpz_poly)
\end{lstlisting}

\desc{Computes the signature of the polynomial $f$, i.e. a tuple $(r, s)$ where $r$ is
the number of real roots and $s$ is half the number of complex roots.}

\textbf{Examples.}

Here is an example of signature.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = x^3 + 3x + 1

(r, s) = signature(f)
\end{lstlisting}

\subsubsection{Special polynomials}

The following functions compute univariate special polynomials over \code{fmpz}. It is expected
that the final argument in each of these function is an element of the polynomial ring.

\begin{lstlisting}
chebyshev_t(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $T_n(x)$, defined by 
$T_n(x) = \cos(n \cos^{-1}(x))$.}

\begin{lstlisting}
chebyshev_u(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Chebyshev polynomial of the first kind $U_n(x)$, defined by 
$(n+1) U_n(x) = T'_{n+1}(x)$.}

\begin{lstlisting}
cyclotomic(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $n$th cyclotomic polynomial, defined as
$$\Phi_n(x) = \prod_{\omega} (x-\omega),$$ where $\omega$ runs over all the 
$n$th primitive roots of unity.}

\begin{lstlisting}
swinnerton_dyer(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the Swinnerton-Dyer polynomial $S_n$, defined as the integer 
polynomial $$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3}
\pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$$ where $p_n$ denotes the $n$-th prime 
number and all combinations of signs are taken. This polynomial has degree $2^n$
and is irreducible over the integers (it is the minimal polynomial of 
$\sqrt{2} + \ldots + \sqrt{p_n}$)}

\begin{lstlisting}
cos_minpoly{S}(n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the minimal polynomial of $2 \cos(2 \pi / n)$. For suitable choice of 
$n$, this gives the minimal polynomial of $2 \cos(a \pi)$ or $2 \sin(a \pi)$ for any
rational $a$.}

\begin{lstlisting}
theta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Jacobi theta function raised to 
the power $r$, i.e. $\vartheta(q)^r$ where 
$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$.}

\begin{lstlisting}
eta_qexp{S}(r::Int, n::Int, x::fmpz_poly)
\end{lstlisting}

\desc{Return the $q$-expansion to length $n$ of the Dedekind eta function (without 
the leading factor $q^{1/24}$) raised to the power $r$, i.e. $(q^{-1/24} \eta(q))^r 
= \prod_{k=1}^{\infty} (1 - q^k)^r$.

In particular, $r = -1$ gives the generating function of the partition function $p(k)$, 
and $r = 24$ gives, after multiplication by $q$, the modular discriminant $\Delta(q)$ 
which generates the Ramanujan tau function $\tau(k)$.}

\textbf{Examples.}

Here are some examples of computing special polynomials.

\begin{lstlisting}
R, x = PolynomialRing(ZZ, "x")

f = chebyshev_t(20, x)
g = chebyshev_u(15, x)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1+x+x^2)
\end{lstlisting}

\subsection{Flint polynomials over $\Z/n\Z$ (multiprecision $n$): \code{fmpz_mod_poly}}

The Flint type for polynomials over $\Z/n\Z$ for multiprecision $n$ is \code{fmpz_mod_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor. They are
automatically created if the modulus $n$ doesn't fit into a \code{UInt}.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678901)
S, x = PolynomialRing(R, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpzModPolyRing}.

We describe functions for \code{fmpz_mod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the constructors below $S$ is assumed to be an \code{FmpzModPolyRing} as constructed above.

\begin{lstlisting}
S(arr::Array{fmpz, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array, reduced modulo the
modulus of the base ring of $S$.}

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer reduced
modulo the modulus of the base ring of $S$ (or the zero polynomial if $a$ is zero when
reduced modulo the modulus).}

\begin{lstlisting}
S(p::fmpz_poly)
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those of the given polynomial, but
reduced modulo the modulus of the base ring of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678901)
S, x = PolynomialRing(R, "x")

a = S()
b = S(x + 1)
c = S([R(1), R(0), R(2)])
d = S(c)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fmpz_mod_poly, y::Residue{fmpz})
*(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $xy$.}

\begin{lstlisting}
+(x::fmpz_mod_poly, y::Residue{fmpz})
+(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::fmpz_mod_poly, y::Residue{fmpz})
-(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   a = R(12) + g
   b = f - R(12)
   c = f*R(12)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

\begin{lstlisting}
==(x::fmpz_mod_poly, y::Residue{fmpz})
==(x::Residue{fmpz}, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if $x$ and $y$ are equal, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   S(7) == R(7)
   R(7) != x + 1
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fmpz_mod_poly, y::Residue{fmpz})
\end{lstlisting}

\desc{Divide the polynomial $x$ by the residue $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   
   a = divexact(R(7)*f, R(7)) 
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Return $x^e \pmod{y}$.}

\textbf{Examples.}

Here is an example of modular arithmetic.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1
   
   a = powmod(f, fmpz(7), g) 
\end{lstlisting}

\subsubsection{Lifting}

\begin{lstlisting}
lift(x::FmpzPolyRing, y::fmpz_mod_poly)
\end{lstlisting}

\desc{Lift the polynomial $y$ over $\Z/n\Z$ to a polynomial over $\Z$ in the given ring.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   T, y = PolynomialRing(ZZ, "y")

   f = x^2 + 2x + 1

   a = lift(T, f) 
\end{lstlisting}

\subsubsection{Irreducibility testing}

\begin{lstlisting}
isirreducible(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is irreducible, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   isirreducible(f) == false
\end{lstlisting}

\subsubsection{Squarefree testing}

\begin{lstlisting}
issquarefree(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is squarefree, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   issquarefree(f) == false
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_squarefree(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the squarefree factorisation of the given polynomial. The
entries in the array are tuples $(p, e)$ consisting of squarefree polynomials $p$ and their
exponent $e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\begin{lstlisting}
factor_shape(x::fmpz_mod_poly)
\end{lstlisting}

\desc{Return an array containing the shape of the factorisation of the given polynomial.
The entries in the array are tuples $(d, e)$ consisting of the degrees $d$ of the
irreducible polynomials and their exponents $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1

   R = factor(f*g)
   S = factor_squarefree(f*g)
   T = factor_distinct_deg((x + 1)*g*(x^5+x+1))
   U = factor_shape(f*g)
\end{lstlisting}

\subsection{Flint polynomials over $\Z/n\Z$ (small $n$): \code{nmod_poly}}

The Flint type for polynomials over $\Z/n\Z$ for small $n$ is \code{nmod_poly}. Polynomials
of this type are created using the \code{PolynomialRing} constructor. They are automatically
created if the modulus $n$ fits into a \code{UInt}.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{NmodPolyRing}.

We describe functions for \code{nmod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the constructors below $S$ is assumed to be an \code{NmodPolyRing} as constructed above.

\begin{lstlisting}
S(arr::Array{UInt, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array.}

\begin{lstlisting}
S(arr::Array{fmpz, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those in the array, reduced modulo the
modulus of the base ring of $S$.}

\begin{lstlisting}
S(a::UInt)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer (or the
zero polynomial if $a$ is zero).}

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ whose coefficient is the given integer reduced
modulo the modulus of the base ring of $S$ (or the zero polynomial if $a$ is zero when
reduced modulo the modulus).}

\begin{lstlisting}
S(p::fmpz_poly)
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are those of the given polynomial, but
reduced modulo the modulus of the base ring of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, "x")

a = S()
b = S(x + 1)
c = S([R(1), R(0), R(2)])
d = S(c)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::nmod_poly, y::Residue{fmpz})
*(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $xy$.}

\begin{lstlisting}
+(x::nmod_poly, y::Residue{fmpz})
+(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $x + y$.}

\begin{lstlisting}
-(x::nmod_poly, y::Residue{fmpz})
-(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return the polynomial $x - y$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   a = R(12) + g
   b = f - R(12)
   c = f*R(12)
\end{lstlisting}

\subsubsection{Ad hoc comparison}

\begin{lstlisting}
==(x::nmod_poly, y::Residue{fmpz})
==(x::Residue{fmpz}, y::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if $x$ and $y$ are equal, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
   R = ResidueRing(ZZ, 13)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 2

   S(7) == R(7)
   R(7) != x + 1
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::nmod_poly, y::Residue{fmpz})
\end{lstlisting}

\desc{Divide the polynomial $x$ by the residue $y$, assuming the division is exact.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   
   a = divexact(R(7)*f, R(7)) 
\end{lstlisting}

\subsubsection{Interpolation}

\begin{lstlisting}
divexact(R::NmodPolyRing, xval::Array{Residue{fmpz}, 1}, yval::Array{Residue{fmpz}, 1})
\end{lstlisting}

\desc{Returns the unique polynomial in the given ring $R$ of degree at most equal to the
length of the two supplied arrays, which interpolates the values in the array \code{yval}
at the values in the array \code{xval}.}

\textbf{Examples.}

Here is an example of interpolation.

\begin{lstlisting}
  R = ResidueRing(ZZ, 23)
  S, x = PolynomialRing(R, "x")

  xval = [ R(0), R(1), R(2), R(3) ]

  yval = [ R(0), R(1), R(4), R(9) ] 

  f = interpolate(S, xval, yval)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R = ResidueRing(ZZ, 23)
  S, x = PolynomialRing(R, "x")

  f = x^6 + x^4 + 2 *x^2 

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Lifting}

\begin{lstlisting}
lift(x::FmpzPolyRing, y::nmod_poly)
\end{lstlisting}

\desc{Lift the polynomial $y$ over $\Z/n\Z$ to a polynomial over $\Z$ in the given ring.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   T, y = PolynomialRing(ZZ, "y")

   f = x^2 + 2x + 1

   a = lift(T, f) 
\end{lstlisting}

\subsubsection{Irreducibility testing}

\begin{lstlisting}
isirreducible(x::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is irreducible, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   isirreducible(f) == false
\end{lstlisting}

\subsubsection{Squarefree testing}

\begin{lstlisting}
issquarefree(x::nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if the polynomial $x$ is squarefree, otherwise return \code{false}.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1

   issquarefree(f) == false
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_squarefree(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the squarefree factorisation of the given polynomial. The
entries in the array are tuples $(p, e)$ consisting of squarefree polynomials $p$ and their
exponent $e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\begin{lstlisting}
factor_shape(x::nmod_poly)
\end{lstlisting}

\desc{Return an array containing the shape of the factorisation of the given polynomial.
The entries in the array are tuples $(d, e)$ consisting of the degrees $d$ of the
irreducible polynomials and their exponents $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R = ResidueRing(ZZ, 23)
   S, x = PolynomialRing(R, "x")

   f = x^2 + 2x + 1
   g = x^3 + 3x + 1

   R = factor(f*g)
   S = factor_squarefree(f*g)
   T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))
   U = factor_shape(f*g)
\end{lstlisting}

\subsection{Flint polynomials over $\Q$: \code{fmpq_poly}}

The Flint type for polynomials over $\Q$ is \code{fmpq_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor with
\code{FlintRationalField()} as an argument (the same as \code{QQ}, by default).  

\begin{lstlisting}
S, x = PolynomialRing(QQ, "x")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FmpqPolyRing}.

We describe functions for \code{fmpq_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FmpqPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::Int)
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into $\Q$ and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = S(12)
   b = S(fmpz(12))
   
   R, y = PolynomialRing(ZZ, "y")

   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Basic manipulation}

Internally, Flint stores \code{fmpq_poly}'s as an array of integers and a single
common denominator.

\begin{lstlisting}
den(a::fmpq_poly)
\end{lstlisting}

\desc{Return the common denominator of the coefficients of the polynomial $a$.}

\textbf{Examples.}

Here is an example of basic manipulation.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = den(-fmpz(12)//7*x + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fmpq_poly, b::fmpq)
*(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fmpq_poly, b::Int)
+(a::Int, b::fmpq_poly)
+(a::fmpq_poly, b::fmpz)
+(a::fmpz, b::fmpq_poly)
+(a::fmpq_poly, b::fmpq)
+(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fmpq_poly, b::Int)
-(a::Int, b::fmpq_poly)
-(a::fmpq_poly, b::fmpz)
-(a::fmpz, b::fmpq_poly)
-(a::fmpq_poly, b::fmpq)
-(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = fmpq(2, 3)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fmpq_poly, b::fmpq)
==(a::fmpq, b::fmpq_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   a != fmpq(2, 3)
   fmpq(2, 3) == S(fmpq(2, 3))
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(a::fmpq_poly, b::Int)
divexact(a::fmpq_poly, b::fmpz)
\end{lstlisting}

\desc{Return the quotient of $a$ by $b$. A \code{DivideError()} is raised if $b = 0$.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
   S, x = PolynomialRing(QQ, "x")

   a = 7y^2 + 3y + 2

   b = divexact(a, 7)
   c = divexact(a, fmpz(11))
\end{lstlisting}

\subsubsection{Signature}

\begin{lstlisting}
signature(f::fmpq_poly)
\end{lstlisting}

\desc{Computes the signature of the polynomial $f$, i.e. a tuple $(r, s)$ where $r$ is
the number of real roots and $s$ is half the number of complex roots.}

\textbf{Examples.}

Here is an example of signature.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")

f = (x^3 + 3x + QQ(2)//QQ(3))

(r, s) = signature(f)
\end{lstlisting}

\subsection{Flint polynomials over $\F_{p^k}$ (multiprecision $p$): \code{fq_poly}}

The Flint type for polynomials over $\F_{p^k}$ for multiprecision $p$ is \code{fq_poly}.
Polynomials of this type are created using the \code{PolynomialRing} constructor with
an \code{FqFiniteField} parent object as parameter. For example

\begin{lstlisting}
R, x = FiniteField(fmpz(23), 5, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FqPolyRing}.

We describe functions for \code{fq_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FqPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::Array{fmpz, 1})
S{T <: Integer}(a::Array{T, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are the integers in the given
array (thought of as elements of the finite field).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into the finite field and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = S(fmpz(12))
   b = S([1, 2, 3])
   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fq_poly, b::fq)
*(a::fq, b::fq_poly)
*(a::fq_poly, b::Integer)
*(a::Integer, b::fq_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fq_poly, b::Int)
+(a::Int, b::fq_poly)
+(a::fq_poly, b::Integer)
+(a::Integer, b::fq_poly)
+(a::fq_poly, b::fmpz)
+(a::fmpz, b::fq_poly)
+(a::fq_poly, b::fq)
+(a::fq, b::fq_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_poly, b::Int)
-(a::Int, b::fq_poly)
-(a::fq_poly, b::Integer)
-(a::Integer, b::fq_poly)
-(a::fq_poly, b::fmpz)
-(a::fmpz, b::fq_poly)
-(a::fq_poly, b::fq)
-(a::fq, b::fq_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = (x + 1)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fq_poly, b::fq)
==(a::fq, b::fq_poly)
==(a::fq_poly, b::fmpz)
==(a::fmpz, b::fq_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   a != x + 1
   x + 1 == S(x + 1)
   a != fmpz(11)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::fq_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::fq_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R, x = FiniteField(fmpz(23), 5, "x")
  S, y = PolynomialRing(R, "y")

  a = 7y^2 + 3y + 2

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fq_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fq_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R, x = FiniteField(fmpz(23), 5, "x")
   S, y = PolynomialRing(R, "y")

   f = 7y^2 + 3y + 2
   g = 11y^3 - 2y^2 + 5

   A = factor(f*g)
   B = factor_distinct_deg((y + 1)*g*(y^5+y^3+y+1))
\end{lstlisting}

\subsection{Flint polynomials over $\F_{p^k}$ (small $p$): \code{fq_nmod_poly}}

The Flint type for polynomials over $\F_{p^k}$ for $p$ that fits in an \code{Int} is
\code{fq_poly}. Polynomials of this type are created using the \code{PolynomialRing}
constructor with an \code{FqNmodFiniteField} parent object as parameter. For example

\begin{lstlisting}
R, x = FiniteField(23, 5, "x")
S, y = PolynomialRing(R, "y")
\end{lstlisting}

Polynomials in this ring have parent of type \code{FqNmodPolyRing}.

We describe functions for \code{fq_nmod_poly} only where they differ from the functions
available for generic polynomials.

\subsubsection{Constructors}

In the following constructors we assume that $S$ is an \code{FqNmodPolyRing} parent 
object, as created by the above construction for example.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the polynomial of degree $0$ with $a$ as its only coefficient (or
the zero polynomial if $a = 0$).}

\begin{lstlisting}
S(a::Array{fmpz, 1})
S{T <: Integer}(a::Array{T, 1})
\end{lstlisting}

\desc{Construct the polynomial whose coefficients are the integers in the given
array (thought of as elements of the finite field).}

\begin{lstlisting}
S(a::fmpz_poly)
\end{lstlisting}

\desc{Coerce the given polynomial into the ring $S$, i.e. coerce its coefficients
into the finite field and change the variable to that of $S$.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = S(fmpz(12))
   b = S([1, 2, 3])
   c = S(3y^3 + 2y + 1)
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

The following ad hoc binary operators are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
*(a::fq_nmod_poly, b::fq_nmod)
*(a::fq_nmod, b::fq_poly_nmod)
*(a::fq_nmod_poly, b::Integer)
*(a::Integer, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $ab$.}

\begin{lstlisting}
+(a::fq_nmod_poly, b::Int)
+(a::Int, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::Integer)
+(a::Integer, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::fmpz)
+(a::fmpz, b::fq_nmod_poly)
+(a::fq_nmod_poly, b::fq_nmod)
+(a::fq_nmod, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_nmod_poly, b::Int)
-(a::Int, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::Integer)
-(a::Integer, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::fmpz)
-(a::fmpz, b::fq_nmod_poly)
-(a::fq_nmod_poly, b::fq_nmod)
-(a::fq_nmod, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return $a - b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   b = a + 7
   c = fmpz(7) - a
   d = (x + 1)*a
\end{lstlisting}

\subsubsection{Ad hoc comparisons}

The following ad hoc binary comparisons are provided over and above the basic ones
for performance reasons.

\begin{lstlisting}
==(a::fq_nmod_poly, b::fq_nmod)
==(a::fq_nmod, b::fq_nmod_poly)
==(a::fq_nmod_poly, b::fmpz)
==(a::fmpz, b::fq_nmod_poly)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparisons.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   a = 7y^2 + 3y + 2

   a != x + 1
   x + 1 == S(x + 1)
   a != fmpz(11)
\end{lstlisting}

\subsubsection{Inflation and deflation}

\begin{lstlisting}
inflate(f::fq_nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x)$, returns $f(x^n)$.}

\begin{lstlisting}
deflate(f::fq_nmod_poly, n::Int)
\end{lstlisting}

\desc{Given a polynomial $f(x^n)$, returns $f(x)$.}

\textbf{Examples.}

Here is an example of inflation and deflation.

\begin{lstlisting}
  R, x = FiniteField(23, 5, "x")
  S, y = PolynomialRing(R, "y")

  a = 7y^2 + 3y + 2

  g = inflate(f, 2)
  h = deflate(g, 2)
\end{lstlisting}

\subsubsection{Factorisation}

\begin{lstlisting}
factor(x::fq_nmod_poly)
\end{lstlisting}

\desc{Return an array containing the factorisation of the given polynomial. The entries in
the array are tuples $(p, e)$ consisting of irreducible polynomials $p$ and their exponent
$e$ in the factorisation.}

\begin{lstlisting}
factor_distinct_deg(x::fq_nmod_poly)
\end{lstlisting}

\desc{Return an array containing the distinct degree factorisation of the given polynomial.
The entries in the array are tuples $(p, e)$ consisting of polynomials $p$ which are the
products of all the irreducible polynomials of the given degree $e$ in the factorisation.}

\textbf{Examples.}

Here are some examples of factoring.

\begin{lstlisting}
   R, x = FiniteField(23, 5, "x")
   S, y = PolynomialRing(R, "y")

   f = 7y^2 + 3y + 2
   g = 11y^3 - 2y^2 + 5

   A = factor(f*g)
   B = factor_distinct_deg((y + 1)*g*(y^5+y^3+y+1))
\end{lstlisting}

\subsection{Flint power series over $\Z$: \code{fmpz_series}}

Flint doesn't have a module for power series over $\Z$, but the \code{fmpz_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpz_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpz_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, x = PowerSeriesRing(ZZ, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpzSeriesRing}.

Currently the \code{fmpz_series} module provides nothing additional on top of
the functionality that is described for generic power series.

\subsection{Flint power series over $\Z/n\Z$ (multiprecision $n$): \code{fmpz_mod_series}}

Flint doesn't have a module for power series over $\Z/n\Z$, but the \code{fmpz_mod_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpz_mod_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpz_mod_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R = ResidueRing(ZZ, 123456789012345678949)
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpzModSeriesRing}.

We list only the functionality that the \code{fmpz_mod_series} module provides on top of
the functionality that is described for generic power series.

\subsubsection{Constructors}

In the following we assume that $S$ is a power series ring parent object as created
by the construction above, for example.

\begin{lstlisting}
S(a::Array{Residue{fmpz}, 1}, n::Int, p::Int)
\end{lstlisting}

\desc{Create the power series in the ring $S$ whose coefficients are the entries in
the array $a$, reduced modulo the modulus of the residue ring. The length of the
array is specified by $n$, though $n$ can be less than this (remaining entries in the
array are ignored) and $p$ gives the precision of the power series created.}

\textbf{Examples.}

Here are some examples of power series constructors.

\begin{lstlisting}
   R = ResidueRing(ZZ, 123456789012345678949)
   S, x = PowerSeriesRing(R, 30, "x")

   f = S([R(0), R(3), R(1)], 3, 5)
\end{lstlisting}

\subsection{Flint power series over $\Q$: \code{fmpq_series}}

Flint doesn't have a module for power series over $\Q$, but the \code{fmpq_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fmpq_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fmpq_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor.
It takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, x = PowerSeriesRing(QQ, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FmpqSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fmpq_series, y::fmpq)
*(x::fmpq, y::fmpq_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = PowerSeriesRing(QQ, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*fmpq(2, 3)

   c = fmpq(2, 3)*a
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp(x::fmpq_series)
\end{lstlisting}

\desc{Compute the exponential of the given power series. The constant term must be $0$.}

\begin{lstlisting}
log(x::fmpq_series)
\end{lstlisting}

\desc{Compute the logarithm of the given power series. The constant term must be $1$.}

\begin{lstlisting}
sin(x::fmpq_series)
cos(x::fmpq_series)
tan(x::fmpq_series)
asin(x::fmpq_series)
atan(x::fmpq_series)
\end{lstlisting}

\desc{Compute the respective trigonometric series by substituting the given power series.
The constant term must be $0$.}

\begin{lstlisting}
sinh(x::fmpq_series)
cosh(x::fmpq_series)
tanh(x::fmpq_series)
asinh(x::fmpq_series)
atanh(x::fmpq_series)
\end{lstlisting}

\desc{Compute the respective hyperbolic trigonometric series by substituting the given power
series. The constant term must be $0$.}

\begin{lstlisting}
sqrt(x::fmpq_series)
\end{lstlisting}

\desc{Compute the square root of the given power series. The constant term must be $1$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, x = PowerSeriesRing(QQ, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   b = x + 2x^2 + 5x^3 + O(x^5)

   c = exp(b)
   d = log(a)
   f = sqrt(a)
   g = sin(b)
   h = atanh(b)   
\end{lstlisting}

\subsection{Flint power series over $\F_{p^k}$ (multiprecision $p$): \code{fq_series}}

Flint doesn't have a module for power series over $\F_{p^k}$, but the \code{fq_poly}
module contains code for power series operations. In Nemo, for the purposes of
simplicity, we deal with Flint as though it has a module called \code{fq_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fq_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor when
it is passed an \code{FqFiniteField} parent object as argument. The function also takes a
maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, t = FiniteField(fmpz(23), 5, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FqSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Constructors}

In the constructor below we assume $S$ is an \code{FqSeriesRing} parent object, as
constructed above for example. We assume the maximum precision of the power series
for this object to be $k$.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the power series $a + O(x^k)$.}

\textbf{Examples.}

Here is an example of a constructor.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = S(fmpz(12))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fq_series, y::fq)
*(x::fq, y::fq_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*(t^2 + 1)

   c = 2t*a
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fq_series, y::fq)
\end{lstlisting}

\desc{Return $x/y$. If $y = 0$ this raises a \code{DivideError()}.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R, t = FiniteField(fmpz(23), 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = divexact(a, t^2 + 1)
\end{lstlisting}

\subsection{Flint power series over $\F_{p^k}$ (small $p$): \code{fq_nmod_series}}

Flint doesn't have a module for power series over $\F_{p^k}$ for small $p$, but the
\code{fq_nmod_poly} module contains code for power series operations. In Nemo, for the
purposes of simplicity, we deal with Flint as though it has a module called
\code{fq_nmod_series}.

The power series type in Nemo for polynomials treated as power series is
\code{fq_nmod_series}. 

Power series of this type are created using the \code{PowerSeriesRing} constructor when
it is passed an \code{FqNmodFiniteField} parent object as argument. The function also
takes a maximum (relative) precision and a variable name as a string.

\begin{lstlisting}
R, t = FiniteField(23, 5, "t")
S, x = PowerSeriesRing(R, 30, "x")
\end{lstlisting}

Power series in this ring have parent of type \code{FqNmodSeriesRing}.

We describe only the functions which are different to those described for generic
power series.

\subsubsection{Constructors}

In the constructor below we assume $S$ is an \code{FqNmodSeriesRing} parent object, as
constructed above for example. We assume the maximum precision of the power series
for this object to be $k$.

\begin{lstlisting}
S(a::fmpz)
\end{lstlisting}

\desc{Construct the power series $a + O(x^k)$.}

\textbf{Examples.}

Here is an example of a constructor.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = S(fmpz(12))
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(x::fq_nmod_series, y::fq_nmod)
*(x::fq_nmod, y::fq_nmod_series)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = a*(t^2 + 1)

   c = 2t*a
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(x::fq_nmod_series, y::fq_nmod)
\end{lstlisting}

\desc{Return $x/y$. If $y = 0$ this raises a \code{DivideError()}.}

\textbf{Examples.}

Here is an example of ad hoc exact division.

\begin{lstlisting}
   R, t = FiniteField(23, 5, "t")
   S, x = PowerSeriesRing(R, 30, "x")

   a = 1 + x + 3x^2 + O(x^5)
   
   b = divexact(a, t^2 + 1)
\end{lstlisting}

\subsection{Flint matrices over $\Z/n\Z$ (small $n$): \code{nmod_mat}}

The Flint type for matrices over $\Z/n\Z$ for small $n$ is \code{nmod_mat}. Matrices
of this type are created using the \code{MatrixSpace} constructor in Nemo. They are
automatically created if the modulus $n$ fits into a \code{UInt}.

\begin{lstlisting}
R = ResidueRing(ZZ, 7)
S = MatrixSpace(R, 3, 3)
\end{lstlisting}

Matrices in this matrix space have parent of type \code{NmodMatSpace}.

We describe functions for \code{nmod_mat} only where they differ from the functions
available for generic matrices.

\subsubsection{Constructors}

In the constructors below $S$ is assumed to be an \code{NmodMatSpace} as constructed above.
We assume that $r$ is the number of rows and $c$ the number of columns for matrices in this
space, e.g. $r = 3$ and $c = 3$ in the example above.

\begin{lstlisting}
S(a::Array{BigInt, 2})
\end{lstlisting}

\desc{Construct the $r\times c$ matrix with entries given by the Julia array $a$, viewed
as elements of the base ring.}

\begin{lstlisting}
S(arr::Array{Int, 1})
S(arr::Array{BigInt, 1})
S(arr::Array{fmpz, 1})
S(arr::Array{Residue{fmpz}, 1})
\end{lstlisting}

\desc{Given a one dimensional Julia array of length $rc$, construct the matrix with $r$
rows and $c$ columns with the array entries as matrix entries. The entries are specified
one row after the other.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([BigInt(4) 5 6; 7 3 2; 1 4 5])
   b = S([4, 5, 6, 7, 3, 2, 1, 4, 5])
   c = S([R(4), R(5), R(6), R(7), R(3), R(2), R(1), R(4), R(5)])
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
*(a::nmod_mat, b::UInt)
\end{lstlisting}

\desc{Return $ab$, i.e. the matrix whose entries are those of $a$ multiplied by $b$.}

\begin{lstlisting}
*(a::UInt, b::nmod_mat)
\end{lstlisting}

\desc{Return $ab$, i.e. the matrix whose entries are $a$ multiplied by the entries
of $b$.}

\textbf{Examples.}

Here is an example of ad hoc binary operators.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = UInt(5)*a
\end{lstlisting}

\subsubsection{Row echelon form}

\begin{lstlisting}
rref(a::nmod_mat)
\end{lstlisting}

\desc{Return the row echelon form of $a$.}

\begin{lstlisting}
rref!(a::nmod_mat)
\end{lstlisting}

\desc{Compute the row echelon form of $a$ in-place. It is the users responsibility
to ensure this matrix is not aliased elsewhere.}

\textbf{Examples.}

Here is an example of row echelon form.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = rref(a)
\end{lstlisting}

\subsubsection{Determinant}

\begin{lstlisting}
determinant(a::nmod_mat)
\end{lstlisting}

\desc{Return the determinant of $a$ as an \code|Residue{fmpz}|.}

\textbf{Examples.}

Here is an example of determinant.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = determinant(a)
\end{lstlisting}

\subsubsection{Rank}

\begin{lstlisting}
rank(a::nmod_mat)
\end{lstlisting}

\desc{Return the rank of $a$.}

\textbf{Examples.}

Here is an example of computing the rank.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = rank(a)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::nmod_mat)
\end{lstlisting}

\desc{Return the matrix inverse of $a$. Note the matrix must be must be square and
invertible, otherwise an exception is thrown.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)

   a = S([BigInt(4) 5 6; 7 3 2; 1 4 5])

   b = inv(a)
\end{lstlisting}

\subsubsection{Linear solving}

\begin{lstlisting}
solve(a::nmod_mat, b::nmod_mat)
\end{lstlisting}

\desc{Return the column vector $x$ such that $ax = b$ where $x$ and $b$ are column
vectors with the same number of rows as the $a$. Note that $a$ must be a square
matrix. If these conditions are not met, an exception is raised.}

\textbf{Examples.}

Here is an example of linear solving.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)
   T = MatrixSpace(R, 3, 1)

   a = S([4 5 6; 7 3 2; 1 4 5])
   b = T([5, 3, 2])

   x = solve(a, b)
\end{lstlisting}

\subsubsection{LU decomposition}

\begin{lstlisting}
lufact(a::nmod_mat)
\end{lstlisting}

\desc{Compute a tuple of matrices $(l, u, p)$ such that $pa = lu$ where $l$ is a
lower triangular matrix, $u$ is upper triangular and $p$ is a permutation matrix.}

\textbf{Examples.}

Here is an example of LU decomposition.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)
   T = MatrixSpace(R, 3, 1)

   a = S([4 5 6; 7 3 2; 1 4 5])
  
   l, u, p = lufact(a)
\end{lstlisting}

\subsubsection{Matrix concatenation}

\begin{lstlisting}
hcat(a::nmod_mat, b::nmod_mat)
\end{lstlisting}

\desc{Return the matrix that is the horizontal concatenation of $a$ and $b$.
Both $a$ and $b$ must have the same number of rows, else an exception is raised.}

\begin{lstlisting}
vcat(a::nmod_mat, b::nmod_mat)
\end{lstlisting}

\desc{Return the matrix that is the vertical concatenation of $a$ and $b$.
Both $a$ and $b$ must have the same number of columns, else an exception is raised.}

\textbf{Examples.}

Here are some examples of concatenation.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)
   T = MatrixSpace(R, 3, 1)

   a = S([4 5 6; 7 3 2; 1 4 5])
   b = S([9 5 3; 2 7 1; 0 6 9])
  
   c = hcat(a, b)
   d = vcat(a, b)
\end{lstlisting}

\subsubsection{Conversions}

\begin{lstlisting}
Array(a::nmod_mat)
\end{lstlisting}

\desc{Return a two dimensional Julia array with entries that are of type
\code|Residue{fmpz}| containing the entries of the matrix $a$.} 

\textbf{Examples.}

Here is an example of conversion.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)
   T = MatrixSpace(R, 3, 1)

   a = S([4 5 6; 7 3 2; 1 4 5])
  
   A = Array(a)
\end{lstlisting}

\subsubsection{Lifting}

\begin{lstlisting}
lift(a::nmod_mat)
\end{lstlisting}

\desc{Return a lift of the matrix $a$ to a matrix over $\Z$, i.e. where the
entries of the returned matrix are those of $a$ lifted to $\Z$.}

\textbf{Examples.}

Here is an example of lifting.

\begin{lstlisting}
   R = ResidueRing(ZZ, 7)
   S = MatrixSpace(R, 3, 3)
   T = MatrixSpace(R, 3, 1)

   a = S([4 5 6; 7 3 2; 1 4 5])
  
   b = lift(a)
\end{lstlisting}

\subsection{Flint matrices over $\Z$: \code{fmpz_mat}}

The Flint type for matrices over $\Z$ is \code{fmpz_mat}. Matrices
of this type are created using the \code{MatrixSpace} constructor in Nemo. 

\begin{lstlisting}
S = MatrixSpace(ZZ, 3, 3)
\end{lstlisting}

Matrices in this matrix space have parent of type \code{FmpzMatSpace}.

We describe functions for \code{fmpz_mat} only where they differ from the functions
available for generic matrices.

\subsubsection{Row echelon form}

\begin{lstlisting}
rref(a::fmpz_mat)
\end{lstlisting}

\desc{Return a tuple $(R, d)$ where $R/d$ is the row echelon form of $a$ over $\Q$.
Here $R$ is a matrix over $\Z$ and $d$ is an \code{fmpz} denominator.}

\textbf{Examples.}

Here is an example of row echelon form.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 4 1 1])
   
   rref(A)
\end{lstlisting}

\subsubsection{Determinant}

\begin{lstlisting}
determinant(a::fmpz_mat)
\end{lstlisting}

\desc{Return the determinant of $a$.}

\textbf{Examples.}

Here is an example of determinant.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = determinant(a)
\end{lstlisting}

\subsubsection{Rank}

\begin{lstlisting}
rank(a::fmpz_mat)
\end{lstlisting}

\desc{Return the rank of $a$.}

\textbf{Examples.}

Here is an example of computing the rank.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   a = S([4 5 6; 7 3 2; 1 4 5])

   b = rank(a)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::fmpz_mat)
\end{lstlisting}

\desc{Return the matrix inverse of $a$. Note the matrix must be must be square and
invertible, otherwise an exception is thrown.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])
  
   B = inv(A)
\end{lstlisting}

\subsubsection{Pseudo inversion}

\begin{lstlisting}
pseudo_inv(a::fmpz_mat)
\end{lstlisting}

\desc{Return a tuple $(R, d)$ where $R/d$ is the inverse of $a$ over $\Q$.
Here $R$ is a matrix over $\Z$ and $d$ is an \code{fmpz} denominator.
Note that the matrix must be square and and non-singular, otherwise an exception is thrown.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([1 0 1; 2 3 1; 5 6 7])
  
   B, d = pseudo_inv(A)
\end{lstlisting}

\subsubsection{Linear solving}

\begin{lstlisting}
solve(a::fmpz_mat, b::fmpz_mat)
\end{lstlisting}

\desc{Return a tuple $(x, d)$ consisting of the column vector $x$ such that $ax/d = b$
where $x$ and $b$ are column vectors with the same number of rows as the $a$ and $d$ is
a denominator. Note that $a$ must be a square matrix. If these conditions are not met,
an exception is raised.}

\begin{lstlisting}
solve_dixon(a::fmpz_mat, b::fmpz_mat)
\end{lstlisting}

\desc{Return a tuple $(x, m)$ consisting of the column vector $x$ such that
$ax = b \pmod{m}$ where $x$ and $b$ are column vectors with the same number of rows as
the $a$. Note that $a$ must be a square matrix. If these conditions are not met, an
exception is raised.}

\textbf{Examples.}

Here is an example of linear solving.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)
   T = MatrixSpace(ZZ, 3, 1)

   A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])   
   B = T([fmpz(4), 5, 7])

   X, d = solve(A, B)
   X, m = solve_dixon(A, B)
\end{lstlisting}

\subsubsection{Matrix concatenation}

\begin{lstlisting}
hcat(a::fmpz_mat, b::fmpz_mat)
\end{lstlisting}

\desc{Return the matrix that is the horizontal concatenation of $a$ and $b$.
Both $a$ and $b$ must have the same number of rows, else an exception is raised.}

\begin{lstlisting}
vcat(a::fmpz_mat, b::fmpz_mat)
\end{lstlisting}

\desc{Return the matrix that is the vertical concatenation of $a$ and $b$.
Both $a$ and $b$ must have the same number of columns, else an exception is raised.}

\textbf{Examples.}

Here are some examples of concatenation.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)
   T = MatrixSpace(ZZ, 3, 6)
   U = MatrixSpace(ZZ, 6, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 6 3])
   B = S([fmpz(1) 4 7; 9 6 7; 4 3 3])

   C = hcat(A, B)
   D = vcat(A, B)
\end{lstlisting}

\subsubsection{Transpose}

\begin{lstlisting}
transpose(a::fmpz_mat)
\end{lstlisting}

\desc{Return the transpose of the matrix $a$.}

\textbf{Examples.}

Here is an example of transposing a matrix.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 6 3])
 
   B = transpose(A)
\end{lstlisting}

\subsubsection{scaling}

\begin{lstlisting}
<<(a::fmpz_mat, n::Int)
\end{lstlisting}

\desc{Return the matrix whose entries are those of $a$ multiplied by $2^n$.}

\begin{lstlisting}
>>(a::fmpz_mat, n::Int)
\end{lstlisting}

\desc{Return the matrix whose entries are those of $a$ divided by $2^n$, where
any remainders are discarded. Rounding is towards zero.}

\textbf{Examples.}

Here are some examples of scaling.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 6 3])
 
   B = A<<5
   C = B>>2
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::fmpz_mat, b::fmpz_mat)
\end{lstlisting}

\desc{Return $a$ times the inverse of $b$. The matrix $b$ must be square and
invertible, otherwise an exception is raised.}

\textbf{Examples.}

Here is an example of exact division.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])
   B = S([2 3 4; 7 9 1; 5 4 5])
 
   divexact(B, A)
\end{lstlisting}

\subsubsection{Modular reduction}

\begin{lstlisting}
reduce_mod(a::fmpz_mat, m::Int)
reduce_mod(a::fmpz_mat, m::fmpz)
\end{lstlisting}

\desc{Return the matrix whose entries are those of $a$ reduced modulo $m$.}

\textbf{Examples.}

Here is an example of modular reduction.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 9 2 2])
   
   reduce_mod(A, 5)
   reduce_mod(A, 2)
\end{lstlisting}

\subsubsection{Hadamard matrix}

\begin{lstlisting}
hadamard(S::FmpzMatSpace)
\end{lstlisting}

\desc{Return the Hadamard matrix for the given matrix space. The number of rows must
equal the number of columns. It is not always possible to create a Hadamard matrix.
If the algorithm fails, an exception is raised.}

\begin{lstlisting}
is_hadamard(a::fmpz_mat)
\end{lstlisting}

\desc{Return true if the matrix $a$ is a Hadamard matrix. The matrix must be square
or an exception is raised.}

\textbf{Examples.}

Here is an example of computing the Hadamard matrix.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = hadamard(S)
   is_hadamard(A) == true
\end{lstlisting}

\subsubsection{Nullspace}

\begin{lstlisting}
nullspace(a::fmpz_mat)
\end{lstlisting}

\desc{Return a tuple $(N, n)$ consisting of the nullity $n$ and a matrix $N$ with
$c$ rows and $c$ columns, where $c$ is the number of columns of $a$, such that 
the first $n$ columns of $N$ are a basis for the nullspace of $a$.}

\textbf{Examples.}

Here is an example of computing the nullspace.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 4 1 1])
   
   N, r = nullspace(A)
\end{lstlisting}

\subsubsection{Hermite normal form}

\begin{lstlisting}
hnf(a::fmpz_mat)
\end{lstlisting}

\desc{Compute the Hermite normal form of $a$.}

\begin{lstlisting}
hnf_with_transform(a::fmpz_mat)
\end{lstlisting}

\desc{Compute a tuple $(H, T)$ where $H$ is the Hermite normal form of $a$
and $T$ is a transformation matrix so that $H = TA$.}

\begin{lstlisting}
hnf_modular(a::fmpz_mat, m::fmpz)
\end{lstlisting}

\desc{Compute the Hermite normal form of $a$ given that $m$ is a multiple of
the determinant of the nonzero rows of $a$.}

\begin{lstlisting}
is_hnf(a::fmpz_mat)
\end{lstlisting}

\desc{Return \code{true} if the matrix $a$ is in Hermite normal form, otherwise
return false.}

\textbf{Examples.}

Here are some examples of computing the Hermite normal form.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
   B = hnf(A)
   H, T = hnf_with_transform(A)
   M = hnf_modular(A, fmpz(27))
   is_hnf(M) == true
\end{lstlisting}

\subsubsection{LLL reduction}

\begin{lstlisting}
lll(a::fmpz_mat)
\end{lstlisting}

\desc{Compute the LLL reduction of $a$.}

\begin{lstlisting}
lll_with_transform(a::fmpz_mat)
\end{lstlisting}

\desc{Compute a tuple $(L, T)$ where $L$ is the LLL reduction of $a$
and $T$ is a transformation matrix so that $L = TA$.}

\begin{lstlisting}
lll_gram(g::fmpz_mat)
\end{lstlisting}

\desc{Given the Gram matrix $g$ of a matrix $a$, compute the Gram matrix of
the LLL reduction of $a$.}

\begin{lstlisting}
lll_gram_with_transform(a::fmpz_mat)
\end{lstlisting}

\desc{Given the Gram matrix $g$ of a matrix $a$, compute a tuple $(L, T)$ where
$G$ is the gram matrix $L$ of the LLL reduction of $a$ and $T$ is a transformation
matrix so that $L = TA$.}

\begin{lstlisting}
lll_with_removal(a::fmpz_mat, b::fmpz)
\end{lstlisting}

\desc{Compute the LLL reduction of $a$ and throw away rows whose norm exceeds
the given bound $b$. Return a tuple $(r, L)$ where the first $r$ rows of $L$
are the rows remaining after removal.}

\begin{lstlisting}
lll_with_removal_transform(a::fmpz_mat, b::fmpz)
\end{lstlisting}

\desc{Compute a tuple $(r, L, T)$ where the first $r$ rows of $L$ are those
remaining from the LLL reduction after removal of vectors with norm exceeding
the bound $b$ and $T$ is a transformation matrix so that $L = TA$.}

\textbf{Examples.}

Here are some examples of computing the LLL reduction.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
   L = lll(A)
   L, T = lll_with_transform(A)

   G == lll_gram(gram(A))
   G, T = lll_gram_with_transform(gram(A))

   r, L = lll_with_removal(A, fmpz(100))
   r, L, T = lll_with_removal_transform(A, fmpz(100))
\end{lstlisting}

\subsubsection{Smith normal form}

\begin{lstlisting}
snf(a::fmpz_mat)
\end{lstlisting}

\desc{Compute the Smith normal form of $a$.}

\begin{lstlisting}
is_snf(a::fmpz_mat)
\end{lstlisting}

\desc{Return \code{true} if $a$ is in Smith normal form, otherwise return
\code{false}.}

\begin{lstlisting}
snf_diagonal(a::fmpz_mat)
\end{lstlisting}

\desc{Given a diagonal matrix $a$ compute the Smith normal form of $a$.}

\textbf{Examples.}

Here are some examples of computing the Smith normal form.

\begin{lstlisting}
   S = MatrixSpace(ZZ, 3, 3)

   A = S([fmpz(2) 3 5; 1 4 7; 19 3 7])
   
   B = snf(A)
   is_snf(B) == true

   B = S([fmpz(2) 0 0; 0 4 0; 0 0 7])

   C = snf_diagonal(B)
\end{lstlisting}

\section{Flint fields}

Flint provides implementations of various explicit fields. We describe their
Nemo wrappers here.

\subsection{Flint rationals ($\Q$): \code|fmpq|}

Flint provides the module \code{fmpq} for rational numbers. The type of Flint rationals
in Nemo is also given the name \code{fmpq}.

The parent object for Flint rationals is of type \code{FlintRationalField}, which
belongs to the \code{Field} type class. Rational number objects have type \code{fmpq}
which belongs to the \code{FractionElem} type class, which in turn belongs to 
\code{FieldElem}.

The parent object for the rationals can be constructed using the \code{FractionField}
function. For example:

\begin{lstlisting}
R = FractionField(ZZ)
\end{lstlisting}

By default, Nemo makes \code{QQ = FractionField(ZZ)}, though the user can change this
assignment.

The \code{fmpq} type supports all of the functionality of the generic fraction field
section. In this section we describe additional functionality that is provided for
Flint rationals but not for general fraction fields.

\subsubsection{Constructors}

In the constructors below we assume $R$ is a Flint rational field parent object.

\begin{lstlisting}
R(a::Rational{BigInt})
\end{lstlisting}

\desc{Construct an \code{fmpq} from a Julia big rational $a$.}

One can also construct Flint rationals directly using the \code{fmpq} constructors.

\textbf{Examples.}

Here is an example of some constructors.

\begin{lstlisting}
R = FractionField(ZZ)

a = R(BigInt(1)//2)
b = fmpq(BigInt(1)//2)
\end{lstlisting}

\subsubsection{Conversions}

We provide the means to convert Flint \code{fmpz} and \code{fmpq} values to Julia
rationals.

\begin{lstlisting}
Rational(a::fmpq)
Rational(a::fmpz)
\end{lstlisting}

\desc{Return $a$ as a Julia big rational.}

\textbf{Examples.}

Here is an example of some conversions.

\begin{lstlisting}
a = Rational(fmpz(12))
b = Rational(fmpq(3, 7))
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
abs(a::fmpq)
\end{lstlisting}

\desc{Return the absolute value of the rational number $a$.}

\begin{lstlisting}
height(a::fmpq)
\end{lstlisting}

\desc{Return the height of the fraction $a$, namely the largest of the absolute
values of the numerator and denominator. The type of the return value is a 
\code{ZZ}.}

\begin{lstlisting}
height_bits(a::fmpq)
\end{lstlisting}

\desc{Return the number of bits of the height of the fraction $a$. The type of
the return value is an \code{Int}.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(123)//234

c = abs(a)
d = height(a)
e = height_bits(b)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
isless(a::fmpq, b::fmpq) 
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
supplies operators $<$, $>$, $\leq$ and $\geq$ from this automatically.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

a < b
b >= a
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience.

\begin{lstlisting}
==(a::fmpq, b::Int)
==(a::Int, b::fmpq)
\end{lstlisting}

\desc{Return \code{true} if $a$ is equal to $b$, otherwise return \code{false}. Julia
automatically provides \code{!=} from this.}

\begin{lstlisting}
isless(a::fmpq, b::fmpz)
isless(a::fmpq, b::Integer)
isless(a::fmpz, b::fmpq)
isless(a::Integer, b::fmpq)
\end{lstlisting}

\desc{Return \code{true} if $a < b$, otherwise return \code{false}. Julia
automatically provides corresponding functions \code{>}, \code{<=} and
\code{>=}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

a < 1
a <= 0
b >= fmpz(0)
\end{lstlisting}

\subsubsection{Shifting}

\begin{lstlisting}
<<(a::fmpq, b::Int)
\end{lstlisting}

\desc{Return $a\times 2^b$.}

\begin{lstlisting}
>>(a::fmpq, b::Int)
\end{lstlisting}

\desc{Return $a/2^b$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpq(1, 2)

c = a << 3
d = b >> 5
\end{lstlisting}

\subsubsection{Modular arithmetic}

\begin{lstlisting}
mod(a::fmpq, m::Integer)
mod(a::fmpq, m::fmpz)
\end{lstlisting}

\desc{If $a = p/q$ this function returns $pq^{-1} \pmod{m}$. This is only
defined if $q$ is invertible modulo $m$. The result is returned as an \code{fmpz}.}

\textbf{Examples.}

Here are some examples of modular arithmetic.

\begin{lstlisting}
a = -fmpz(2)//3
b = fmpz(1)//2

c = mod(a, 7)
d = mod(b, fmpz(5))
\end{lstlisting}

\subsubsection{GCD}

Nemo defines the greatest common divisor of two rationals as the greatest rational $r$
such that both the rationals are integer multiples of $r$.

\begin{lstlisting}
gcd(a::fmpq, b::fmpq)
\end{lstlisting}

\desc{Return the greatest common divisor of $a$ and $b$.}

\subsubsection{Rational reconstruction}

\begin{lstlisting}
reconstruct(a::fmpz, m::fmpz)
reconstruct(a::fmpz, m::Integer)
reconstruct(a::Integer, m::fmpz)
reconstruct(a::Integer, m::Integer)
\end{lstlisting}

\desc{Attempt to find a rational number $n/d$ such that 
$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$ and 
$0 < d \leq \lfloor\sqrt{m/2}\rfloor$ such that gcd$(n, d) = 1$ and
$a \equiv nd^{-1} \pmod{m}$. If no solution exists, an exception is thrown.}

\textbf{Examples.}

Here are some examples of rational reconstruction.

\begin{lstlisting}
a = reconstruct(7, 13)
b = reconstruct(fmpz(15), 31)
c = reconstruct(fmpz(123), fmpz(237))
\end{lstlisting}

\subsubsection{Rational enumeration}

\begin{lstlisting}
next_minimal(x::fmpq)
\end{lstlisting}

\desc{Given $x$, returns the next rational number in the sequence obtained by
enumerating all positive denominators $q$, and for each $q$ enumerating
the numerators $1 \le p < q$ in order and generating both $p/q$ and $q/p$,
but skipping all gcd$(p,q) \neq 1$. Starting with zero, this generates
every nonnegative rational number once and only once, with the first
few entries being:

$$0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, 1/5, 5, 2/5, \ldots.$$

This enumeration produces the rational numbers in order of minimal height. 
It has the disadvantage of being somewhat slower to compute than the
Calkin-Wilf enumeration.

If $x < 0$ we throw a \code{DomainError()}.}

\begin{lstlisting}
next_signed_minimal(x::fmpq)
\end{lstlisting}

\desc{Given a signed rational number $x$ assumed to be in canonical form, 
returns the next element in the minimal-height sequence generated by 
\code{fmpq_next_minimal} but with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
in order of minimal height.}

\begin{lstlisting}
next_calkin_wilf(x::fmpq)
\end{lstlisting}

\desc{Given $x$ return the next number in the breadth-first traversal of the
Calkin-Wilf tree. Starting with zero, this generates every nonnegative
rational number once and only once, with the first few entries being:

$$0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \ldots.$$

Despite the appearance of the initial entries, the Calkin-Wilf enumeration 
does not produce the rational numbers in order of height: some small fractions
will appear late in the sequence. This order has the advantage of being faster 
to produce than the minimal-height order.}

\begin{lstlisting}
next_signed_calkin_wilf(x::fmpq)
\end{lstlisting}

\desc{Given a signed rational number $x$ returns the next element in the
Calkin-Wilf sequence with negative numbers interleaved:

$$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots.$$

Starting with zero, this generates every rational number once and only once,
but not in order of minimal height.}

\textbf{Examples.}

Here are some examples of rational enumeration.

\begin{lstlisting}
next_minimal(fmpz(2)//3)
next_signed_minimal(-fmpz(21)//31)
next_calkin_wilf(fmpz(321)//113)
next_signed_calkin_wilf(-fmpz(51)//(17))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
harmonic(n::Int)
\end{lstlisting}

\desc{Computes the harmonic number $H_n = 1 + 1/2 + 1/3 + \cdots + 1/n$.
Table lookup is used for $H_n$ whose numerator and denominator 
fit in a single limb. For larger $n$, a divide and conquer strategy is used.}

\begin{lstlisting}
bernoulli(n::Int)
\end{lstlisting}

\desc{Computes the Bernoulli number $B_n$ for nonnegative $n$.}

\begin{lstlisting}
bernoulli_cache(n::Int)
\end{lstlisting}

\desc{Precomputes and caches all the Bernoulli numbers up to $B_n$.
This is much faster than repeatedly calling \code{bernoulli(k)}.
Once cached, subsequent calls to \code{bernoulli(k)} for any $k \le n$
will read from the cache, making them virtually free.}

\begin{lstlisting}
dedekind_sum(h::fmpz, k::fmpz)
dedekind_sum(h::fmpz, k::Integer)
dedekind_sum(h::Integer, k::fmpz)
dedekind_sum(h::Integer, k::Integer)
\end{lstlisting}

\desc{Computes the Dedekind sum $s(h,k)$ for arbitrary $h$ and $k$.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
a = harmonic(12)

b = dedekind_sum(12, 13)
c = dedekind_sum(-120, fmpz(1305))

d = bernoulli(12)

bernoulli_cache(100)
e = bernoulli(100)
\end{lstlisting}

\subsection{Flint finite fields $\F_{p^k}$ (multiprecision $p$): \code|fq|}

We allow the construction of finite fields of any characteristic and degree in
Nemo.

(At this stage we make no attempt to compatibly embed finite fields generated 
using randomly chosen irreducible polynomials, such as with the 
Bosma-Cannon-Steel construction. But this may change in a later version of 
Flint/Nemo.)

The Flint type for finite fields $\F_{p^k}$ for multiprecision $p$ is
\code{fq}.

The type of elements of Flint \code{fq} fields in Nemo is \code{fq}.
This type belongs to the \code{FiniteFieldElem} type class, which in turn belongs
to the \code{FieldElem} class. The type of the parent object for such fields is
\code{FqFiniteField} which belongs to the \code{Field} type class.

The parent object for such a field is created using the \code{FiniteField}
function, e.g.

\begin{lstlisting}
FiniteField(p::fmpz, deg::Int, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
a finite field of characteristic \code{p} of degree \code{deg}, and a
generator \code{x}.

When a Conway polynomial is known, the field is generated using the
Conway polynomial. Otherwise a random sparse, irreducible polynomial is used.

The generator \code{x} of the field will be printed as the provided string
\code{var}. The characteristic \code{p} must be prime, but we do not check this
condition. The degree \code{deg} must be nonnegative. If \code{deg} is negative
we throw a \code{DomainError()}.}

For example, the following code generates a parent object for the finite field
of characteristic $7$ and degree $5$ (defined by a Conway polynomial).

\begin{lstlisting}
S, x = FiniteField(fmpz(7), 5, "x")
\end{lstlisting}

The parent object for such a field can also be created by specifying
an irreducible polynomial of type \code{fmpz_mod_poly}, e.g.

\begin{lstlisting}
FiniteField(f::fmpz_mod_poly, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
the finite field $\F_p[t]/(f)$, and a generator \code{x}.

The generator \code{x} of the field will be printed as the provided string
\code{var}. The polynomial \code{f} must be irreducible, but we do not check this
condition.}

\begin{lstlisting}
R, t = PolynomialRing(ResidueRing(ZZ, 12431351431561), "t")
S, x = FiniteField(t^2 + 7, "x")
\end{lstlisting}

\subsubsection{Constructors}

Elements of the finite field \code{R} can be constructed as polynomials of
degree less than \code{deg} in \code{x}. As usual we overload the parent object
for the finite field to construct elements of the field.

In the constructors below, we take $S$ to be a parent object of a finite field
as given by the construction above, for example.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the element $0$ of the finite field.}

\begin{lstlisting}
S(a::Int)
S(a::Integer)
S(a::fmpz)
\end{lstlisting}

\desc{Return the element \code{a} of the finite field, where $a$ is considered 
an element of $\F_p$.}

\begin{lstlisting}
S(a::fq)
\end{lstlisting}

\desc{Return a reference to the element \code{a} of the finite field. No copy
of the data is made by this function.}

\textbf{Examples.}

Here are some examples of constructing finite fields and elements in them.

\begin{lstlisting}
S, y = FiniteField(fmpz(17), 3, "y")

f = 2y^2 + 11y + 16

g = S(4)
h = S()
k = S(g)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero(R::FqFiniteField)
\end{lstlisting}

\desc{Return the additive identity in the finite field, i.e. $0$.}

\begin{lstlisting}
one(R::FqFiniteField)
\end{lstlisting}

\desc{Return the multiplicative identity in the finite field, i.e. $1$.}

\begin{lstlisting}
gen(R::FqFiniteField)
\end{lstlisting}

\desc{Return a generator of the finite field, namely one whose
representation is the monomial of degree $1$ modulo the defining
polynomial of the field. The generator is guaranteed to be a multiplicative 
generator only if the field is generated by a Conway polynomial.}

\begin{lstlisting}
iszero(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the additive identity in the
finite field, i.e. if it is $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the multiplicative identity in
the finite field, i.e. if it is $1$, otherwise return \code{false}.}

\begin{lstlisting}
isgen(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the generator of the finite field,
otherwise return \code{false}.}

\begin{lstlisting}
isunit(a::fq)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is invertible in the finite field,
i.e. if it is not zero, otherwise return \code{false}.}

\begin{lstlisting}
characteristic(R::FqFiniteField)
\end{lstlisting}

\desc{Return the prime characteristic $p$ of the finite field as a bignum
\code{ZZ}.}

\begin{lstlisting}
order(R::FqFiniteField)
\end{lstlisting}

\desc{Return the number of elements in the finite field, i.e. $q = p^d$
where \code{p} is the characteristic and $d$ is the degree.}

\begin{lstlisting}
degree(R::FqFiniteField)
\end{lstlisting}

\desc{If the finite field is $\F_q$ where $q = p^d$, where $p$ is the
prime characteristic of the field, this function returns the degree
$d$.}

\begin{lstlisting}
coeff(a::fq, n::Int)
\end{lstlisting}

\desc{Return the coefficient of degree $n$ in the polynomial representation
of the element $a$ of the finite field. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
deepcopy(a::fq)
\end{lstlisting}

\desc{Return a new finite field element which is arithmetically equal to
the given element.}

\begin{lstlisting}
canonical_unit(a::fq)
\end{lstlisting}

\desc{Used for canonicalising fractions. Simply returns $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations of finite fields.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = zero(R)
b = one(R)
c = gen(R)
d = characteristic(R)
f = order(R)
g = degree(R)
h = iszero(a)
k = isone(b)
m = isunit(x + 1)
n = deepcopy(c)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(a::fq)
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = -a
\end{lstlisting}

\subsubsection{Binary operators}

We provide the following binary operators for elements of
finite fields.

\begin{lstlisting}
+(a::fq, b::fq)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq, b::fq)
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*(a::fq, b::fq)
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = a + b
d = a - b
f = a*b
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

We provide the following ad hoc binary operators, which are faster than first
coercing all their arguments into the finite field.

\begin{lstlisting}
*(x::Int, y::fq)
*(x::Integer, y::fq)
*(x::fmpz, y::fq)
\end{lstlisting}

\desc{Return $xy$, i.e. $y$ added to itself $x$ times.}

\begin{lstlisting}
*(x::fq, y::Int)
*(x::fq, y::Integer)
*(x::fq, y::fmpz)
\end{lstlisting}

\desc{Return $xy$, i.e. $x$ added to itself $y$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = 3a
c = a*fmpz(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::fq, n::Int)
^(a::fq, n::fmpz)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here are some examples of powering of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = a^3
c = a^fmpz(-5)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::fq, b::fq)
\end{lstlisting}

\desc{Return \code{true} if the finite field elements $a$ and $b$ are 
arithmetically equal, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} functionality.

\textbf{Examples.}

Here are some examples of comparison of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

b != a
R(3) == R(3)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::fq)
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the finite field, i.e. 
$a^{-1}$ such that $aa^{-1} = 1$ in the finite field.}

\textbf{Examples.}

Here are some examples of inversion of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = inv(a)
b == a^-1
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(x::fq, y::fq)
//(x::fq, y::fq)
\end{lstlisting}

\desc{Return $x/y$, which is an exact division in a finite field when defined,
since every nonzero element is invertible. We throw a \code{DivideError()} if
$y = 0$. Both forms of exact division are the same, one being a synonym for 
the other.}

\textbf{Examples.}

Here are some examples of exact division of finite field elements.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

c = divexact(a, b)
d = b//a
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd(a::fq, b::fq)
\end{lstlisting}

\desc{Return gcd$(a, b)$. For a finite field this is always $1$ unless both
$a$ and $b$ are $0$, in which case the gcd is $0$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = gcd(a, b)
d = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Special functions}

Various special functions with finite field specific behaviour are
defined.

\begin{lstlisting}
trace(a::fq)
\end{lstlisting}

\desc{Return the trace of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
norm(a::fq)
\end{lstlisting}

\desc{Return the norm of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
frobenius(a::fq, n = 1)
\end{lstlisting}

\desc{Return the iterated Frobenius $\sigma_p^n(a)$ where $\sigma_p$ is the 
Frobenius map sending the element $a$ to $a^p$ in the finite field of 
characteristic $p$. By default the Frobenius map is applied $n = 1$ times if
$n$ is not specified.}

\begin{lstlisting}
pth_root(a::fq)
\end{lstlisting}

\desc{Return the $p$-th root of $a$ in the finite field of characteristic
$p$. This is the inverse operation to the Frobenius map $\sigma_p$.}

\textbf{Examples.}

Here are some examples of special finite field functionality.

\begin{lstlisting}
R, x = FiniteField(fmpz(7), 5, "x")

a = x^4 + 3x^2 + 6x + 1

b = trace(a)
c = norm(a)
d = frobenius(a)
f = frobenius(a, 3)
g = pth_root(a)
\end{lstlisting}

\subsection{Flint finite fields $\F_{p^k}$ (small $p$): \code|fq_nmod|}

The Flint type for finite fields $\F_{p^k}$ for $p$ that fits in a single machine
word is \code{fq_nmod}.

The type of elements of Flint \code{fq_nmod} fields in Nemo is \code{fq_nmod}.
This type belongs to the \code{FiniteFieldElem} type class, which in turn belongs
to the \code{FieldElem} class. The type of the parent object for such fields is
\code{FqNmodFiniteField} which belongs to the \code{Field} type class.

The parent object for such a field can be created using the \code{FiniteField}
function by specifying $p$ and $k$, e.g.

\begin{lstlisting}
FiniteField(p::Int, deg::Int, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
a finite field of characteristic \code{p} of degree \code{deg}, and a
generator \code{x}.

When a Conway polynomial is known, such a field is generated using the
Conway polynomial. Otherwise a random sparse, irreducible polynomial is used.

The generator \code{x} of the field will be printed as the provided string
\code{var}. The characteristic \code{p} must be prime, but we do not check this
condition. The degree \code{deg} must be nonnegative. If \code{deg} is negative
we throw a \code{DomainError()}.}

For example, the following code generates a parent object for the finite field
of characteristic $7$ and degree $5$ (defined by a Conway polynomial).

\begin{lstlisting}
S, x = FiniteField(7, 5, "x")
\end{lstlisting}

The parent object for such a field can also be created by specifying
an irreducible polynomial of type \code{nmod_poly}, e.g.

\begin{lstlisting}
FiniteField(f::nmod_poly, var::String)
\end{lstlisting}

\desc{Return a tuple \code{(R, x)} consisting of the parent object \code{R} of
the finite field $\F_p[t]/(f)$, and a generator \code{x}.

The generator \code{x} of the field will be printed as the provided string
\code{var}. The polynomial \code{f} must be irreducible, but we do not check this
condition.}

\begin{lstlisting}
R, t = PolynomialRing(ResidueRing(ZZ, 3), "t")
S, x = FiniteField(t^2 + 1, "x")
\end{lstlisting}

\subsubsection{Constructors}

Elements of the finite field \code{R} can be constructed as polynomials of
degree less than \code{deg} in \code{x}. As usual we overload the parent object
for the finite field to construct elements of the field.

In the constructors below, we take $S$ to be a parent object of a finite field
as given by the construction above, for example.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Return the element $0$ of the finite field.}

\begin{lstlisting}
S(a::Int)
S(a::Integer)
S(a::fmpz)
\end{lstlisting}

\desc{Return the element \code{a} of the finite field, where $a$ is considered 
an element of $\F_p$.}

\begin{lstlisting}
S(a::fq_nmod)
\end{lstlisting}

\desc{Return a reference to the element \code{a} of the finite field. No copy
of the data is made by this function.}

\textbf{Examples.}

Here are some examples of constructing finite fields and elements in them.

\begin{lstlisting}
S, y = FiniteField(17, 3, "y")

f = 2y^2 + 11y + 16

g = S(4)
h = S()
k = S(g)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the additive identity in the finite field, i.e. $0$.}

\begin{lstlisting}
one(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the multiplicative identity in the finite field, i.e. $1$.}

\begin{lstlisting}
gen(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return a generator of the finite field, namely one whose
representation is the monomial of degree $1$ modulo the defining
polynomial of the field. The generator is guaranteed to be a multiplicative 
generator only if the field is generated by a Conway polynomial.}

\begin{lstlisting}
iszero(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the additive identity in the
finite field, i.e. if it is $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the multiplicative identity in
the finite field, i.e. if it is $1$, otherwise return \code{false}.}

\begin{lstlisting}
isgen(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is the generator of the finite field,
otherwise return \code{false}.}

\begin{lstlisting}
isunit(a::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the element $a$ is invertible in the finite field,
i.e. if it is not zero, otherwise return \code{false}.}

\begin{lstlisting}
characteristic(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the prime characteristic $p$ of the finite field as a bignum
\code{ZZ}.}

\begin{lstlisting}
order(R::FqNmodFiniteField)
\end{lstlisting}

\desc{Return the number of elements in the finite field, i.e. $q = p^d$
where \code{p} is the characteristic and $d$ is the degree.}

\begin{lstlisting}
degree(R::FqNmodFiniteField)
\end{lstlisting}

\desc{If the finite field is $\F_q$ where $q = p^d$, where $p$ is the
prime characteristic of the field, this function returns the degree
$d$.}

\begin{lstlisting}
coeff(a::fq_nmod, n::Int)
\end{lstlisting}

\desc{Return the coefficient of degree $n$ in the polynomial representation
of the element $a$ of the finite field. If $n < 0$ we throw a
\code{DomainError()}.}

\begin{lstlisting}
deepcopy(a::fq_nmod)
\end{lstlisting}

\desc{Return a new finite field element which is arithmetically equal to
the given element.}

\begin{lstlisting}
canonical_unit(a::fq_nmod)
\end{lstlisting}

\desc{Used for canonicalising fractions. Simply returns $a$.}

\textbf{Examples.}

Here are some examples of basic manipulations of finite fields.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = zero(R)
b = one(R)
c = gen(R)
d = characteristic(R)
f = order(R)
g = degree(R)
h = iszero(a)
k = isone(b)
m = isunit(x + 1)
n = deepcopy(c)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(a::fq_nmod)
\end{lstlisting}

\desc{Return $-a$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = -a
\end{lstlisting}

\subsubsection{Binary operators}

We provide the following binary operators for elements of
finite fields.

\begin{lstlisting}
+(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $a + b$.}

\begin{lstlisting}
-(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $a - b$.}

\begin{lstlisting}
*(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return $ab$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = a + b
d = a - b
f = a*b
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

We provide the following ad hoc binary operators, which are faster than first
coercing all their arguments into the finite field.

\begin{lstlisting}
*(x::Int, y::fq_nmod)
*(x::Integer, y::fq_nmod)
*(x::fmpz, y::fq_nmod)
\end{lstlisting}

\desc{Return $xy$, i.e. $y$ added to itself $x$ times.}

\begin{lstlisting}
*(x::fq_nmod, y::Int)
*(x::fq_nmod, y::Integer)
*(x::fq_nmod, y::fmpz)
\end{lstlisting}

\desc{Return $xy$, i.e. $x$ added to itself $y$ times.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = 3a
c = a*fmpz(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::fq_nmod, n::Int)
^(a::fq_nmod, n::fmpz)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here are some examples of powering of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = a^3
c = a^fmpz(-5)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return \code{true} if the finite field elements $a$ and $b$ are 
arithmetically equal, otherwise return \code{false}.}

Julia automatically provides corresponding \code{!=} functionality.

\textbf{Examples.}

Here are some examples of comparison of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

b != a
R(3) == R(3)
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::fq_nmod)
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$ in the finite field, i.e. 
$a^{-1}$ such that $aa^{-1} = 1$ in the finite field.}

\textbf{Examples.}

Here are some examples of inversion of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = inv(a)
b == a^-1
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(x::fq_nmod, y::fq_nmod)
//(x::fq_nmod, y::fq_nmod)
\end{lstlisting}

\desc{Return $x/y$, which is an exact division in a finite field when defined,
since every nonzero element is invertible. We throw a \code{DivideError()} if
$y = 0$. Both forms of exact division are the same, one being a synonym for 
the other.}

\textbf{Examples.}

Here are some examples of exact division of finite field elements.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + 2

c = divexact(a, b)
d = b//a
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd(a::fq_nmod, b::fq_nmod)
\end{lstlisting}

\desc{Return gcd$(a, b)$. For a finite field this is always $1$ unless both
$a$ and $b$ are $0$, in which case the gcd is $0$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1
b = 3x^4 + 2x^2 + x + 1

c = gcd(a, b)
d = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Special functions}

Various special functions with finite field specific behaviour are
defined.

\begin{lstlisting}
trace(a::fq_nmod)
\end{lstlisting}

\desc{Return the trace of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
norm(a::fq_nmod)
\end{lstlisting}

\desc{Return the norm of $a$. This is an element of $\F_p$, but the value
returned is this value embedded in the original finite field.}

\begin{lstlisting}
frobenius(a::fq_nmod, n = 1)
\end{lstlisting}

\desc{Return the iterated Frobenius $\sigma_p^n(a)$ where $\sigma_p$ is the 
Frobenius map sending the element $a$ to $a^p$ in the finite field of 
characteristic $p$. By default the Frobenius map is applied $n = 1$ times if
$n$ is not specified.}

\begin{lstlisting}
pth_root(a::fq_nmod)
\end{lstlisting}

\desc{Return the $p$-th root of $a$ in the finite field of characteristic
$p$. This is the inverse operation to the Frobenius map $\sigma_p$.}

\textbf{Examples.}

Here are some examples of special finite field functionality.

\begin{lstlisting}
R, x = FiniteField(7, 5, "x")
a = x^4 + 3x^2 + 6x + 1

b = trace(a)
c = norm(a)
d = frobenius(a)
f = frobenius(a, 3)
g = pth_root(a)
\end{lstlisting}

\subsection{Flint $p$-adics $\Q_p$: \code{padic}}

The Flint type for $p$-adic numbers is \code{padic}. In Nemo elements of a
$p$-adic field are of type \code{padic}. These belong to a \code{PadicFieldElem}
type class, which in turn belongs to \code{FieldElem}. The parent objects for 
the $p$-adic fields are of type \code{FlintPadicField} which belongs to the
\code{Field} type class.

As usual, the user need not deal directly with the types, as we define a function
\code{FlintPadicField} for constructing parent objects for $p$-adic fields.

By default, the global variable \code{PadicField} is defined to be
\code{FlintPadicField} so that \code{PadicField} also constructs parent objects
for $p$-adic fields.

The $p$-adics implement a capped relative precision model. This has consistent
behaviour for multiplicative operations on $p$-adics, but not for additive
operations, where cancellation can occur.

\subsubsection{Constructors}

We provide the following simple function for creating the type of the $p$-adic
numbers.

\begin{lstlisting}
PadicField(p::Int, prec::Int)
PadicField(p::ZZ, prec::Int)
\end{lstlisting}

\desc{This function returns a type corresponding to the $p$-adic numbers for
the given prime $p$. We test that $p$ is actually prime before constructing
the type. If not, an exception is thrown. The second argument is a default
(absolute) precision for elements in this field.}

To construct values of $p$-adic type we use the \code{O} operator. It requires
the $p$-adic type as a parameter for reasons of type soundness and so that
expressions such as $O(7^0)$ can be entered unambiguously (as \code{O(R, 7^0)},
say).

\begin{lstlisting}
O(R::FlintPadicField, m::Int)
O(R::FlintPadicField m::fmpz)
O(R::FlintPadicField, m::fmpq)
\end{lstlisting}

\desc{Construct the value $0 + O(p^n)$ given $m = p^n$. An exception results
if $m$ is not found to be a power of \code{p = prime(R)}.}

The \code{O(p^n)} construction can be used to construct $p$-adic values of
precision $n$ by adding it to integer values representing the $p$-adic value
modulo $p^n$. See the examples below for details.

In the constructors below, we assume $S$ is a $p$-adic field parent object,
constructed using the \code{PadicField} function, for example:

\begin{lstlisting}
S = PadicField(17, 30)
\end{lstlisting}

We also assume below that $p$ is the prime passed to the \code{PadicField}
constructor, e.g. $p = 17$ in the above and that $k$ is the default precision,
e.g. $k = 30$ in the above.

\begin{lstlisting}
S()
\end{lstlisting}

\desc{Construct the $p$-adic value $0$ with default precision, i.e. $0 + O(p^k)$.}

\begin{lstlisting}
S(a::Int)
S(a::fmpz)
S(a::fmpq)
\end{lstlisting}

\desc{Construct the $p$-adic value representing the integer or rational $a$ to
precision $k$.}

\textbf{Examples.}

Here are some examples of constructing $p$-adics.

\begin{lstlisting}
R = PadicField(7, 30)
S = PadicField(fmpz(65537), 30)

a = R()
b = R(1)
c = R(fmpz(123))
d = R(fmpz(1)//7^2)

f = 1 + 2*7 + 4*7^2 + O(R, 7^3)
g = 13 + 357*fmpz(65537) + O(S, fmpz(65537)^12)
h = fmpz(1)//7^2 + fmpz(2)//7 + 3 + 4*7 + O(R, 7^2)
\end{lstlisting}

Beware that the expression \code{1 + 2*p + 3*p^2 + O(R, p^n)} is actually computed as
a normal Julia expression. Therefore if \code{Int} values are used instead of
\code{fmpz}'s, overflow may result in evaluating the value.

Also note that one cannot use \code{7^-2} in a $p$-adic expression, since the 
exponentiation operator must always return an integer, for reasons of type soundness.

\subsubsection{Basic manipulation}

\begin{lstlisting}
prime(R::PadicField)
\end{lstlisting}

\desc{Return the prime $p$ on which the $p$-adic type is based. The returned
value is of type \code{fmpz}.}

\begin{lstlisting}
precision(a::padic)
\end{lstlisting}

\desc{Return the precision of the given $p$-adic value, e.g. the precision of
$1 + 7 + 2*7^2 + O(7^3)$ is $3$.}

\begin{lstlisting}
valuation(a::padic)
\end{lstlisting}

\desc{Return the $p$-adic valuation of the given $p$-adic value.}

\begin{lstlisting}
zero(R::PadicField)
\end{lstlisting}

\desc{Return the additive identity, i.e. $0$ in the field of $p$-adic
numbers to the default precision.}

\begin{lstlisting}
one(R::PadicField)
\end{lstlisting}

\desc{Return the multiplicative identity, i.e. $1$ in the field of
$p$-adic numbers to the default precision.}

\begin{lstlisting}
iszero(a::padic)
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is equal to the additive identity,
i.e. $0$, otherwise return \code{false}.}

\begin{lstlisting}
isone(a::padic)
\end{lstlisting}

\desc{Return \code{true} if the given $p$-adic value is equal to the multiplicative
identity, i.e. $1$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of basic manipulations of $p$-adics.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = R(2)

d = one(R)
f = zero(R)
g = isone(d)
h = iszero(f)
k = precision(a)
m = prime(R)
n = valuation(b)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(x::padic)
\end{lstlisting}

\desc{Return $-x$.}

\textbf{Examples.}

Here are some examples of unary operators.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = R(0)

c = -a
d = -b
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+(x::padic, y::padic)
\end{lstlisting}

\desc{Return $x + y$. The output precision will be the least of the input
precisions.}

\begin{lstlisting}
-(x::padic, y::padic)
\end{lstlisting}

\desc{Return $x - y$. The output precision will be the least of the input
precisions.}

\begin{lstlisting}
*(x::padic, y::padic)
\end{lstlisting}

\desc{Return $xy$. The output precision will be the least of valuation$(x) +$
precision$(y)$ and precision$(x) +$ valuation$(y)$.}

\textbf{Examples.}

Here are some examples of binary operators for $p$-adics.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + b
g = a - b
h = a*b
j = b*c
k = a*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
+(x::padic, y::Int)
+(x::padic, y::fmpz)
+(x::padic, y::fmpq)
\end{lstlisting}

\desc{Return $x + y$ where $y$ is interpreted as a $p$-adic value to the default
precision.}

\begin{lstlisting}
+(x::Int, y::padic)
+(x::fmpz, y::padic)
+(x::fmpq, y::padic)
\end{lstlisting}

\desc{Return $x + y$ where $x$ is interpreted as a $p$-adic value to the default
precision.}

\begin{lstlisting}
-(x::padic, y::Int)
-(x::padic, y::fmpz)
-(x::padic, y::fmpq)
\end{lstlisting}

\desc{Return $x - y$ where $y$ is interpreted as a $p$-adic value to the default
precision.}

\begin{lstlisting}
-(x::Int, y::padic)
-(x::fmpz, y::padic)
-(x::fmpq, y::padic)
\end{lstlisting}

\desc{Return $x - y$ where $x$ is interpreted as a $p$-adic value to the default
precision.}

\begin{lstlisting}
*(x::padic, y::Int)
*(x::padic, y::fmpz)
*(x::padic, y::fmpq)
\end{lstlisting}

\desc{Return $xy$.}

\begin{lstlisting}
*(x::Int, y::padic)
*(x::fmpz, y::padic)
*(x::fmpq, y::padic)
\end{lstlisting}

\desc{Return $xy$.}

\textbf{Examples.}

Here are some examples of ad hoc binary operators.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 7^2 + 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

f = a + 2
g = 3 - b
h = a*fmpz(5)
j = fmpz(3)*c
k = 2*d
l = 2 + d
m = d - fmpz(2)
n = a + fmpz(1)//7^2
p = (fmpz(12)//11)*b
q = c*(fmpz(1)//7)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::padic, b::padic)
\end{lstlisting}

\desc{Compare the given $p$-adic values at the least of the two precisions and
return \code{true} if they are equal to that precision, otherwise return
\code{false}.}

Julia automatically supplies a corresponding \code{!=} operator.

\begin{lstlisting}
isequal(a::padic, b::padic)
\end{lstlisting}

\desc{Return \code{true} if \code{a == b} and their precisions are the same,
otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 2*7 + 4*7^2 + O(R, 7^3)
b = 3*7^3 + O(R, 7^5)
c = O(R, 7^3)
d = R(2)

a == 1 + 2*7 + O(R, 7^2)
b == c
c == R(0)
d == R(2)
isequal(b, c) == false
\end{lstlisting}

\subsubsection{Ad hoc comparison}

The following ad hoc comparison operators are provided for convenience. 

\begin{lstlisting}
==(a::padic, b::Int)
==(a::padic, b::fmpz)
==(a::padic, b::fmpq)
\end{lstlisting}

\desc{Return \code{true} if the value $b$ is equal to the $p$-adic 
value $a$ up to the precision of $a$, otherwise return \code{false}.}

\begin{lstlisting}
==(a::Int, b::padic)
==(a::fmpz, b::padic)
==(a::fmpq, b::padic)
\end{lstlisting}

\desc{Return \code{true} if the value $a$ is equal to the $p$-adic 
value $b$ up to the precision of $b$, otherwise return \code{false}.}

\textbf{Examples.}

Here are some examples of ad hoc comparison.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

a == 1
b == fmpz(0)
c == 2
fmpz(2) == c
a == fmpz(344)//1
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::padic, n::Int)
\end{lstlisting}

\desc{Return $a^n$. The output precision will be the same as if $a$ had been
multiplied by itself $n$ times, i.e. precision$(a) + (n - 1)\times$
valuation$(a)$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = O(R, 7^5)
c = R(2)

d = a^5
f = b^3
g = c^7
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(a::padic)
\end{lstlisting}

\desc{Return the multiplicative inverse of $a$, i.e. $1/a$. If \code{a == 0}
a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of inversion.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = inv(a)
g = inv(b)
h = inv(c)
k = inv(d)
l = inv(R(1))
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::padic, b::padic)
//(a::padic, b::padic)
\end{lstlisting}

\desc{Return $a/b$. The output precision will be the minimum of 
precision$(a) -$ valuation$(b)$ and precision$(b) - 2\times$valuation$(b) +$
valuation$(a)$. If \code{b == 0} a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = divexact(a, b)
g = divexact(c, d)
h = divexact(d, R(7^3))
j = divexact(R(34), R(17))
\end{lstlisting}


\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(a::padic, b::Int)
divexact(a::padic, b::fmpz)
divexact(a::padic, b::fmpq)
//(a::padic, b::Int)
//(a::padic, b::fmpz)
//(a::padic, b::fmpq)
\end{lstlisting}

\desc{Return $a/b$. The output precision will be precision$(a) -$ 
valuation$(b)$. If \code{b == 0} a \code{DivideError()} is thrown.}

\begin{lstlisting}
divexact(a::Int, b::padic)
divexact(a::fmpz, b::padic)
divexact(a::fmpq, b::padic)
//(a::Int, b::padic)
//(a::fmpz, b::padic)
//(a::fmpq, b::padic)
\end{lstlisting}

\desc{Return $a/b$. The output precision will be 
precision$(b) - 2\times$valuation$(b) +$ valuation$(a)$. If \code{b == 0}
a \code{DivideError()} is thrown.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)
d = 7 + 2*7^2 + O(R, 7^5)

f = a//2
g = b//fmpz(7)
h = c//(fmpz(12)//7^2)
k = 2//d
l = R(3)//3
m = (fmpz(5)//7)//R(5)
\end{lstlisting}

\subsubsection{GCD}

\begin{lstlisting}
gcd(a::padic, b::padic)
\end{lstlisting}

\desc{Returns $1$ unless both $a$ and $b$ are $0$, in which case it returns $0$.}

\textbf{Examples.}

Here are some examples of GCD.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)

d = gcd(a, b)
f = gcd(R(0), R(0))
\end{lstlisting}

\subsubsection{Square root}

\begin{lstlisting}
sqrt(a::padic)
\end{lstlisting}

\desc{Return the $p$-adic square root of $a$. We define this only when the
valuation of $a$ is even. The precision of the output will be precision$(a) -$
valuation$(a)/2$. If the square root does not exist, an exception is thrown.}

\textbf{Examples.}

Here are some examples of taking a $p$-adic square root.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 3*7 + O(R, 7^5)
c = 7^2 + 2*7^3 + O(R, 7^4)

d = sqrt(a)
f = sqrt(b)
f = sqrt(c)
g = sqrt(R(121))
\end{lstlisting}

\subsubsection{Special functions}

\begin{lstlisting}
exp(a::padic)
\end{lstlisting}

\desc{Return the $p$-adic exponential of $a$. We define this only when the
valuation of $a$ is positive (unless \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the input is not
valid an exception is thrown.}

\begin{lstlisting}
log(a::padic)
\end{lstlisting}

\desc{Return the $p$-adic logarithm of $a$. We define this only when the
valuation of $a$ is zero (but not for \code{a == 0}). The precision of the
output will be the same as the precision of the input. If the input is not
valid an exception is thrown.}

\begin{lstlisting}
teichmuller(a::padic)
\end{lstlisting}

\desc{Return the Teichmuller lift of the $p$-adic value $a$. We require the
valuation of $a$ to be nonnegative. The precision of the output will be the
same as the precision of the input. For convenience, if $a$ is congruent to
zero modulo $p$ we return zero. If the input is not valid an exception is
thrown.}

\textbf{Examples.}

Here are some examples of special functions.

\begin{lstlisting}
R = PadicField(7, 30)

a = 1 + 7 + 2*7^2 + O(R, 7^3)
b = 2 + 5*7 + 3*7^2 + O(R, 7^3)
c = 3*7 + 2*7^2 + O(R, 7^5)

c = exp(c)
d = log(a)
c = exp(R(0))
d = log(R(1))
f = teichmuller(b) 
\end{lstlisting}

\section{Antic fields}

Antic is a library for number fields, built on top of Flint. For now it provides us
with number field arithmetic.

\subsection{Antic number fields $\Q[x]/(f)$: \code|nf_elem|}

Number fields in Antic are represented by an irreducible polynomial $f$ over $\Q$,
with special code to deal with the case where $f$ happens to be defined over $\Z$
and monic.

Antic has a type \code{nf_elem} for elements of a number field.

In Nemo the parent object of a number field has type \code{AnticNumberField} which
belongs to the \code{Field} type class. Elements of a number field are of type
\code{nf_elem} which belongs to the \code{NumberFieldElem} type class, which belongs
to code{FieldElem}.

The user need not deal with the types directly since we provide a function
\code{AnticNumberField} to create parent objects for number fields and we also
provide various constructors to create elements of a number field.

By default, the global variable \code{NumberField} is set equal to
\code{AnticNumberField} which means that the following code can be used to
create number field objects in Nemo.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
\end{lstlisting}

Here, $x^3 + 3x + 1$ is the irreducible polynomial over $\Q$ giving the minimum
polynomial of the generator $a$ of the number field $K$ (though it need not be
a monic polynomial).

\subsubsection{Constructors}

Various constructors are provided to create elements of a number field in Nemo.
In the constructors below we assume that $K$ is the parent object of a number field,
for example created by the construction above.

\begin{lstlisting}
K()
\end{lstlisting}

\desc{Create the element $0$ of the number field.}

\begin{lstlisting}
K(a::Int)
K(a::fmpz)
K(a::fmpq)
\end{lstlisting}

\desc{Create the element of the number field represented by the degree $0$
polynomial with constant coefficient $a$.}

\begin{lstlisting}
K(g::fmpq_poly)
\end{lstlisting}

\desc{Create the element of the number field represented by the polynomial
$g$. The polynomial is first reduced modulo the defining polynomial $f$ of
the number field, thus they must both belong to the same polynomial ring.}

\begin{lstlisting}
K(d::nf_elem)
\end{lstlisting}

\desc{Return a reference to the number field element $d$. No copy is made
of the data.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

k = K()
l = K(123)
m = K(fmpz(12))
n = K(x^2 + 2x - 7)
p = K(n)
\end{lstlisting}

\subsubsection{Conversions}

If $R$ is the parent object of the polynomial ring to which the defining
polynomial $f$ of the number field belongs, we can coerce the polynomial
representation $g$ of a number field element $d$ into the polynomial ring
defined by $R$. This allows us to retrieve the polynomial representation
of number field elements as a polynomial.

\begin{lstlisting}
R(d::nf_elem)
\end{lstlisting}

\desc{Return the polynomial representation of the number field element $d$
in the polynomial ring $R$ which was used to define the number field.}

\textbf{Examples.}

Here is an example of a conversion.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

k = K(x^2 + 2x - 7)
l = R(k)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
zero(R::AnticNumberField)
\end{lstlisting}

\desc{Return the element $0$ of the number field with parent object $R$.}

\begin{lstlisting}
one(R::AnticNumberField)
\end{lstlisting}

\desc{Return the element $1$ of the number field with parent object $R$.}

\begin{lstlisting}
gen(R::AnticNumberField)
\end{lstlisting}

\desc{Return the generator of the number field with parent object $R$.}

\begin{lstlisting}
degree(R::AnticNumberField)
\end{lstlisting}

\desc{Return the degree of the number field.}

\begin{lstlisting}
signature(R::AnticNumberField)
\end{lstlisting}

\desc{Returns the signature of the number field, i.e. a tuple $(r, s)$ where $r$ is
the number of complex embeddings of $R$ and $s$ is half the number of complex embeddings of $R$.}

\begin{lstlisting}
iszero(d::nf_elem)
\end{lstlisting}

\desc{Return \code{true} if the given element $d$ is equal to $0$, else return
\code{false}.}

\begin{lstlisting}
isone(d::nf_elem)
\end{lstlisting}

\desc{Return \code{true} if the given element $d$ is equal to $1$, else return
\code{false}.}

\begin{lstlisting}
isgen(d::nf_elem)
\end{lstlisting}

\desc{Return \code{true} if the given element $d$ is the generator of the
number field it belongs to, else return \code{false}.}

\begin{lstlisting}
coeff(d::nf_elem, n::int)
\end{lstlisting}

\desc{Return the coefficient of degree $n$ of the polynomial representation
of the number field element $d$. If $n < 0$ we throw a \code{DomainError()}.
If $n$ is bigger than the degree of the element $d$ we return $0$.}

\begin{lstlisting}
deepcopy(d::nf_elem)
\end{lstlisting}

\desc{Return a new number field element arithmetically equal to $d$.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

d = a^2 + 2a - 7

k = zero(K)
l = one(K)
m = gen(K)
n = deepcopy(d)
p = coeff(d, 1)
isgen(m) == true
isone(l) == true
q = degree(K)
(r, s) = signature(K)
\end{lstlisting}

\subsubsection{Unary operators}

\begin{lstlisting}
-(d::nf_elem)
\end{lstlisting}

\desc{Return $-d$.}

\textbf{Examples.}

Here is an example of unary operators.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

d = a^2 + 2a - 7

f = -d
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+(c::nf_elem, d::nf_elem)
\end{lstlisting}

\desc{Return $c + d$.}

\begin{lstlisting}
-(c::nf_elem, d::nf_elem)
\end{lstlisting}

\desc{Return $c - d$.}

\begin{lstlisting}
*(c::nf_elem, d::nf_elem)
\end{lstlisting}

\desc{Return $cd$.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = a^2 + 2a - 7
d = 3a^2 - a + 1

f = c + d
g = c - d
h = c*d
\end{lstlisting}

\subsubsection{Ad hoc binary operators}

\begin{lstlisting}
+(c::nf_elem, d::Int)
+(c::nf_elem, d::fmpz)
+(c::nf_elem, d::fmpq)
\end{lstlisting}

\desc{Return $c + d$ where $d$ is coerced into the number field.}

\begin{lstlisting}
+(c::Int, d::nf_elem)
+(c::fmpz, d::nf_elem)
+(c::fmpq, d::nf_elem)
\end{lstlisting}

\desc{Return $c + d$ where $c$ is coerced into the number field.}

\begin{lstlisting}
-(c::nf_elem, d::Int)
-(c::nf_elem, d::fmpz)
-(c::nf_elem, d::fmpq)
\end{lstlisting}

\desc{Return $c - d$ where $d$ is coerced into the number field.}

\begin{lstlisting}
-(c::Int, d::nf_elem)
-(c::fmpz, d::nf_elem)
-(c::fmpq, d::nf_elem)
\end{lstlisting}

\desc{Return $c - d$ where $c$ is coerced into the number field.}

\begin{lstlisting}
*(c::nf_elem, d::Int)
*(c::nf_elem, d::fmpz)
*(c::nf_elem, d::fmpq)
\end{lstlisting}

\desc{Return $cd$ where $d$ is coerced into the number field.}

\begin{lstlisting}
*(c::Int, d::nf_elem)
*(c::fmpz, d::nf_elem)
*(c::fmpq, d::nf_elem)
\end{lstlisting}

\desc{Return $cd$ where $c$ is coerced into the number field.}

\textbf{Examples.}

Here is an example of ad hoc binary operators.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

d = a^2 + 2a - 7

f = d + 21
g = fmpz(3) + d
h = d - fmpq(2, 3)
k = fmpq(2, 7)*d
l = d*fmpz(5)
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(d::nf_elem, n::Int)
\end{lstlisting}

\desc{Return $d^n$.}

\textbf{Examples.}

Here are some examples of powering.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

d = a^2 + 2a - 7

f = d^5
g = d^(-2)
h = d^0
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(c::nf_elem, d::nf_elem)
\end{lstlisting}

\desc{Return \code{true} if $c$ is equal to $d$ in the number field.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = 3a^2 - a + 1
d = a^2 + 2a - 7

c != d
c == 3a^2 - a + 1
\end{lstlisting}

\subsubsection{Inversion}

\begin{lstlisting}
inv(c::nf_elem)
\end{lstlisting}

\desc{Return the multiplicative inverse of $c$ in the number field. If $c = 0$
we throw a \code{DivideError()}.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = 3a^2 - a + 1

c*inv(c) == 1
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(c::nf_elem, d::nf_elem)
\end{lstlisting}

\desc{Return $c$ times the inverse of $d$ in the number field. If $d = 0$ we
throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of exact division.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = 3a^2 - a + 1
d = a^2 + 2a - 7

divexact(c, d) == c*inv(d)
\end{lstlisting}

\subsubsection{Ad hoc exact division}

\begin{lstlisting}
divexact(c::nf_elem, d::Int)
divexact(c::nf_elem, d::fmpz)
divexact(c::nf_elem, d::fmpq)
\end{lstlisting}

\desc{Return $c$ divided by $d$ in the number field. If $d = 0$ we
throw a \code{DivideError()}.}

\textbf{Examples.}

Here are some examples of ad hoc exact division.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = 3a^2 - a + 1

divexact(7c, 7) == c
divexact(fmpq(2, 3)*c, fmpq(2, 3)) == c
\end{lstlisting}

\subsubsection{Norm and trace}

\begin{lstlisting}
norm(c::nf_elem)
\end{lstlisting}

\desc{Return the norm of the given number field element $c$ as an \code{fmpq}.}

\begin{lstlisting}
trace(c::nf_elem)
\end{lstlisting}

\desc{Return the trace of the given number field element $c$ as an \code{fmpq}.}

\textbf{Examples.}

Here are some examples of norm and trace.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")

c = 3a^2 - a + 1

norm(c)
trace(c)
\end{lstlisting}

\section{Arb rings}

Arb is a library for real and complex numbers implemented using
a ball (mid-rad) representation which tracks error bounds rigorously.

\subsection{Arb real numbers ($\R$): \code|arb|}

Arb provides the module \code{arb} for real numbers represented
in mid-rad interval form $[m \pm r] = [m-r, m+r]$. The type of Arb real
numbers in Nemo is also given the name \code{arb}.

The parent object for Arb reals is of type \code{ArbField}, which
belongs to the \code{Field} type class.

The \code{ArbField} parent is initialised with the precision in bits (\code{prec})
used for operations on interval midpoints. The precision used for
interval radii is a fixed implementation-defined constant (30 bits).

The following creates a parent object \code{RR} representing
the field of real numbers with 64-bit precision, and elements
\code{x}, \code{y} representing the rational numbers 1/4 and 1/10:

\begin{lstlisting}
RR = ArbField(64)
x = RR("0.25")
y = RR("0.1")
\end{lstlisting}

Since interval midpoints are binary floating-point numbers with
finite precision, one has
\code{isexact(x) == true} and \code{isexact(y) == false} in this example.

In the following, we will assume that \code{RR} is an \code{ArbField}
instance as above.

\subsubsection{Constructors}

\begin{lstlisting}
RR(x::Float64)
RR(x::Int)
RR(x::UInt)
RR(x::fmpz)
RR(x::fmpq)
RR(x::arb)
\end{lstlisting}

\desc{Constructs an \code{arb} element from the given value.}

\begin{lstlisting}
ball(m::arb, r::arb)
\end{lstlisting}

\desc{Constructs an \code{arb} enclosing the range $[m-|r|, m+|r|]$ given
the pair $(m, r)$.}

\begin{lstlisting}
RR(x::String)
\end{lstlisting}

\desc{Constructs an \code{arb} element from a string representation.
Valid strings include integer and floating-point literals. Midpoint-radius
pairs of such literals may also be given in the form \code{"m +/- r"}
or \code{"[m +/- r]"}}

\textbf{Examples.}

\begin{lstlisting}
x = RR(3)
y = RR(QQ(2,3))

z = ball(RR(3), RR("0.0001"))

s = RR("3 +/- 0.0001")
t = RR("-1.24e+12345")

u = RR("nan +/- inf")
\end{lstlisting}

\subsubsection{Conversions}

\begin{lstlisting}
Float64(x::arb)
\end{lstlisting}

\desc{Return the midpoint of $x$ rounded down to a machine double.}

\textbf{Examples.}

\begin{lstlisting}
x = RR(QQ(2,3))

Float64(x)
\end{lstlisting}

\subsubsection{Parts of numbers}

\begin{lstlisting}
midpoint(x::arb)

radius(x::arb)
\end{lstlisting}

\desc{Return the midpoint and the radius of the interval $x$, respectively.
The output is a point-valued \text{arb} instance, having radius zero.}

\textbf{Examples.}

\begin{lstlisting}
x = RR(QQ(2,3))

midpoint(x)

radius(x)
\end{lstlisting}

\subsubsection{Comparisons and predicates}

Boolean-valued functions defined on intervals must be used carefully.

In general, we extend predicates defined on point values (such as
the usual comparisons $=, \ne, \le, \ldots$ defined on pairs of real numbers)
to intervals as follows: we return
\texttt{true} if the predicate holds for all choices of points
in the input intervals, and therefore certainly is true.
We return \texttt{false} otherwise, i.e.\ both if the predicate
either certainly is false or if truth cannot be determined.

For example, we certainly have $[0 \pm 0.1] \ne 1$, but both the
comparisons $[0 \pm 0.1] \ne 0$ and $[0 \pm 0.1] = 0$
return \texttt{false}.

\begin{lstlisting}
iszero(x::arb)
isnonzero(x::arb)
isone(x::arb)
isfinite(x::arb)
isexact(x::arb)
isint(x::arb)
ispositive(x::arb)
isnonnegative(x::arb)
isnegative(x::arb)
isnonpositive(x::arb)
\end{lstlisting}

\desc{Return whether $x$ certainly is, respectively, equal to zero,
not equal to zero, equal to 1, finite (having finite midpoint and radius),
exact (having zero radius), an exact integer, positive, nonnegative,
negative, or nonpositive.}

\begin{lstlisting}
overlaps(x::arb, y::arb)
\end{lstlisting}

\desc{Return whether $x$ and $y$ have any point in common.}

\begin{lstlisting}
contains(x::arb, y::fmpq)
contains(x::arb, y::fmpz)
contains(x::arb, y::Int)
contains(x::arb, y::BigFloat)
contains(x::arb, y::arb)
\end{lstlisting}

\desc{Return whether the interval $x$ contains the point $y$,
or entirely contains $y$ when this is an interval.}

\begin{lstlisting}
contains_zero(x::arb)
contains_positive(x::arb)
contains_negative(x::arb)
contains_nonpositive(x::arb)
contains_nonnegative(x::arb)
\end{lstlisting}

\desc{Return whether the interval $x$ respectively contains the
point $x$, any positive point, any negative point, any nonnegative point,
or any nonnegative point.}

\begin{lstlisting}
==(x::arb, y::arb)
!=(x::arb, y::arb)
>(x::arb, y::arb)
>=(x::arb, y::arb)
<(x::arb, y::arb)
<=(x::arb, y::arb)
\end{lstlisting}

\desc{Compare two intervals.}

\begin{lstlisting}
==(x::arb, y::Union{Int,Float64,fmpz,fmpq})
!=(x::arb, y::Union{Int,Float64,fmpz,fmpq})
<=(x::arb, y::Union{Int,Float64,fmpz,fmpq})
>=(x::arb, y::Union{Int,Float64,fmpz,fmpq})
<(x::arb, y::Union{Int,Float64,fmpz,fmpq})
>(x::arb, y::Union{Int,Float64,fmpz,fmpq})

==(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
!=(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
<=(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
>=(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
<(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
>(x::Union{Int,Float64,fmpz,fmpq}, y::arb)
\end{lstlisting}

\desc{Compare an interval with a quantity of another type.}

\begin{lstlisting}
strongequal(x::arb, y::arb)
\end{lstlisting}

\desc{Returns whether $x$ and $y$ are identical as intervals, that is,
have identical components midpoints and radii. Note that this is
not the same as testing mathematical equality of real numbers,
as implemented by the \code{==} operator.}

\textbf{Examples.}

\begin{lstlisting}
x = RR("1 +/- 0.001")
y = RR("3")
z = RR("4")

!isexact(x)

isint(y)

x <= z

x == 3

\end{lstlisting}

\subsubsection{Arithmetic operations}

\begin{lstlisting}
-(x::arb)
abs(x::arb)
inv(x::arb)

+(x::arb, y::arb)
-(x::arb, y::arb)
*(x::arb, y::arb)
//(x::arb, y::arb)

+(x::arb, y::UInt)
-(x::arb, y::UInt)
*(x::arb, y::UInt)
//(x::arb, y::UInt)

+(x::UInt, y::arb)
-(x::UInt, y::arb)
*(x::UInt, y::arb)
//(x::UInt, y::arb)

+(x::arb, y::Int)
-(x::arb, y::Int)
*(x::arb, y::Int)
//(x::arb, y::Int)

+(x::Int, y::arb)
-(x::Int, y::arb)
*(x::Int, y::arb)
//(x::Int, y::arb)

+(x::arb, y::fmpz)
-(x::arb, y::fmpz)
*(x::arb, y::fmpz)
//(x::arb, y::fmpz)

+(x::fmpz, y::arb)
-(x::fmpz, y::arb)
*(x::fmpz, y::arb)
//(x::fmpz, y::arb)

^(x::arb, y::arb)
^(x::arb, y::fmpz)
^(x::arb, y::Int)
^(x::arb, y::UInt)
^(x::arb, y::fmpq)
\end{lstlisting}

\desc{Perform the respective arithmetic involving real numbers.}

\textbf{Examples.}

\begin{lstlisting}
x = RR(3)
y = RR(QQ(2,3))

x + y

inv(y) - x

3 * x + ZZ(100) // y

(x^2 + y^2) ^ QQ(1,2)
\end{lstlisting}

\subsubsection{Miscellaneous operations}

\begin{lstlisting}
ldexp(x::arb, y::Int)

ldexp(x::arb, y::fmpz)
\end{lstlisting}

\desc{Return $x$ multiplyed by $2^y$ exactly.}

\begin{lstlisting}
trim(x::arb)
\end{lstlisting}

\desc{Return an \code{arb} interval containing $x$ but which may be more economical,
by rounding off insignificant bits from the midpoint.}

\begin{lstlisting}
accuracy_bits(x::arb)
\end{lstlisting}

\desc{Return the relative accuracy of $x$ measured in bits, capped
between \code{typemax(Int)} and \code{-typemax(Int)}.}

\begin{lstlisting}
unique_integer(x::arb)
\end{lstlisting}

\desc{Return a pair where the first value is a boolean and the second
is a \code{fmpz} integer. The boolean indicates whether the interval $x$
contains a unique integer. If this is the case, the second return
value is set to this unique integer.}

\begin{lstlisting}
setunion(x::arb, y::arb)
\end{lstlisting}

\desc{Return an \code{arb} containing the union of the intervals
represented by \code{x} and \code{y}.}

\textbf{Examples.}

\begin{lstlisting}
x = RR("1 +/- 0.0001")
y = RR("2")

ldexp(x, 100)

accuracy_bits(x)
accuracy_bits(y)

unique_integer(y)

setunion(x, y)
\end{lstlisting}

\subsubsection{Mathematical constants}

\begin{lstlisting}
const_pi(r::ArbField)
\end{lstlisting}

\desc{Return $\pi = 3.14159\ldots$ as an element of $r$.}

\begin{lstlisting}
const_e(r::ArbField)
\end{lstlisting}

\desc{Return $e = 2.71828\ldots$ as an element of $r$.}

\begin{lstlisting}
const_log2(r::ArbField)
\end{lstlisting}

\desc{Return $\log(2) = 0.69314\ldots$ as an element of $r$.}

\begin{lstlisting}
const_log10(r::ArbField)
\end{lstlisting}

\desc{Return $\log(10) = 2.302585\ldots$ as an element of $r$.}

\begin{lstlisting}
const_euler(r::ArbField)
\end{lstlisting}

\desc{Return Euler's constant $\gamma = 0.577215\ldots$ as an element of $r$.}

\begin{lstlisting}
const_catalan(r::ArbField)
\end{lstlisting}

\desc{Return Catalan's constant $C = 0.915965\ldots$ as an element of $r$.}

\begin{lstlisting}
const_khinchin(r::ArbField)
\end{lstlisting}

\desc{Return Khinchin's constant $K = 2.685452\ldots$ as an element of $r$.}

\begin{lstlisting}
const_glaisher(r::ArbField)
\end{lstlisting}

\desc{Return Glaisher's constant $A = 1.282427\ldots$ as an element of $r$.}

\textbf{Examples.}

\begin{lstlisting}
x = const_pi(RR)

y = const_pi(ArbField(3323))

g = const_euler(R)
\end{lstlisting}

\subsubsection{Mathematical functions}

\begin{lstlisting}
floor(x::arb)
ceil(x::arb)
\end{lstlisting}

\desc{Return the floor and ceiling functions $\lfloor x \rfloor$ and
$\lceil x \rceil$ respectively.}

\begin{lstlisting}
sqrt(x::arb)
\end{lstlisting}

\desc{Return $\sqrt{x}$.}

\begin{lstlisting}
rsqrt(x::arb)
\end{lstlisting}

\desc{Return $1 / \sqrt{x}$.}

\begin{lstlisting}
sqrt1pm1(x::arb)
\end{lstlisting}

\desc{Return $\sqrt{1+x}-1$, evaluated accurately for small $x$.}

\begin{lstlisting}
hypot(x::arb, y::arb)
\end{lstlisting}

\desc{Return $\sqrt{x^2 + y^2}$.}

\begin{lstlisting}
root(x::arb, n::UInt)
root(x::arb, n::Int)
\end{lstlisting}

\desc{Return the principal branch of $x^{1/n}$. Require that $n > 0$.}

\begin{lstlisting}
log(x::arb)
\end{lstlisting}

\desc{Return the principal branch of $\log(x)$.}

\begin{lstlisting}
log1p(x::arb)
\end{lstlisting}

\desc{Return $\log(1+x)$, evaluated accurately for small $x$.}

\begin{lstlisting}
exp(x::arb)
\end{lstlisting}

\desc{Return $\exp(x)$.}

\begin{lstlisting}
expm1(x::arb)
\end{lstlisting}

\desc{Return $\exp(x)-1$, evaluated accurately for small $x$.}

\begin{lstlisting}
sin(x::arb)
cos(x::arb)
tan(x::arb)
cot(x::arb)
\end{lstlisting}

\desc{Return the respective trigonometric function $\sin(x)$, etc.}

\begin{lstlisting}
sinpi(x::arb)
cospi(x::arb)
tanpi(x::arb)
cotpi(x::arb)
\end{lstlisting}

\desc{Return the respective trigonometric function $\sin(\pi x)$, etc.}

\begin{lstlisting}
sincos(x::arb)
sincospi(x::arb)
\end{lstlisting}

\desc{Return a pair containing both the sine and cosine computed simultaneously.}

\begin{lstlisting}
sinpi(x::fmpq, r::ArbField)
cospi(x::fmpq, r::ArbField)
sincospi(x::fmpq, r::ArbField)
\end{lstlisting}

\desc{Return the sine and/or cosine of argument $\pi x$ as an element of $r$.}

\begin{lstlisting}
sinh(x::arb)
cosh(x::arb)
tanh(x::arb)
coth(x::arb)
sinhcosh(x::arb)
\end{lstlisting}

\desc{Return the respective hyperbolic function $\sinh(x)$, etc.}

\begin{lstlisting}
atan(x::arb)
asin(x::arb)
acos(x::arb)
atanh(x::arb)
asinh(x::arb)
acosh(x::arb)
\end{lstlisting}

\desc{Return the respective inverse trigonometric or hyperbolic function
$\operatorname{atan}(x)$, etc.}

\begin{lstlisting}
atan2(b::arb, a::arb)
\end{lstlisting}

\desc{Return $\operatorname{atan2}(b,a) = \arg(a+bi)$.}

\begin{lstlisting}
gamma(x::arb)
\end{lstlisting}

\desc{Return the gamma function $\Gamma(x)$.}

\begin{lstlisting}
gamma(x::fmpz, r::ArbField)
gamma(x::fmpq, r::ArbField)
\end{lstlisting}

\desc{Return the gamma function of $x$ as an element of $r$.}

\begin{lstlisting}
lgamma(x::arb)
\end{lstlisting}

\desc{Return the logarithm of the gamma function, $\log \Gamma(x)$.}

\begin{lstlisting}
rgamma(x::arb)
\end{lstlisting}

\desc{Return the reciprocal of the gamma function, $1 / \Gamma(x)$.}

\begin{lstlisting}
digamma(x::arb)
\end{lstlisting}

\desc{Return the logarithmic derivative of the gamma function, $\psi(x)$.}

\begin{lstlisting}
fac(x::arb)
\end{lstlisting}

\desc{Return the factorial $x! = \Gamma(x+1)$.}

\begin{lstlisting}
fac(n::UInt, r::ArbField)
fac(n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the factorial $n!$ as an element of $r$.}

\begin{lstlisting}
risingfac(x::arb, n::UInt)
risingfac(x::arb, n::Int)
\end{lstlisting}

\desc{Return the rising factorial $x (x+1) \cdots (x+n-1)$.}

\begin{lstlisting}
risingfac2(x::arb, n::UInt)
risingfac2(x::arb, n::Int)
\end{lstlisting}

\desc{Return a tuple containing the rising factorial and its derivative.}

\begin{lstlisting}
risingfac(x::fmpq, n::UInt, r::ArbField)
risingfac(x::fmpq, n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the rising factorial $x (x+1) \cdots (x+n-1)$ as an element of $r$.}

\begin{lstlisting}
binom(x::arb, k::UInt)
\end{lstlisting}

\desc{Return the binomial coefficient ${x \choose k}$.}

\begin{lstlisting}
binom(n::UInt, k::UInt, r::ArbField)
\end{lstlisting}

\desc{Return the binomial coefficient ${n \choose k}$ as an element of $r$.}

\begin{lstlisting}
fib(n::fmpz, r::ArbField)
fib(n::UInt, r::ArbField)
fib(n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the Fibonacci number $F_n$ as an element of $r$.}

\begin{lstlisting}
bell(n::fmpz, r::ArbField)
bell(n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the Bell number $B_n$ as an element of $r$.}

\begin{lstlisting}
bernoulli(n::UInt, r::ArbField)
bernoulli(n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the Bernoulli number $B_n$ as an element of $r$.}

\begin{lstlisting}
chebyshev_t(n::UInt, x::arb)
chebyshev_u(n::UInt, x::arb)
chebyshev_t(n::Int, x::arb)
chebyshev_u(n::Int, x::arb)
\end{lstlisting}

\desc{Return the value of the Chebyshev polynomial $T_n(x)$ or $U_n(x)$ respectively.}

\begin{lstlisting}
chebyshev_t2(n::UInt, x::arb)
chebyshev_u2(n::UInt, x::arb)
chebyshev_t2(n::Int, x::arb)
chebyshev_u2(n::Int, x::arb)
\end{lstlisting}

\desc{Return the tuple $(T_{n}(x), T_{n-1}(x))$ or $(U_{n}(x), U_{n-1}(x))$,
both values computed simultaneously.}

\begin{lstlisting}
zeta(s::arb)
\end{lstlisting}

\desc{Return the Riemann zeta function $\zeta(s)$.}

\begin{lstlisting}
zeta(n::UInt, r::ArbField)
zeta(n::Int, r::ArbField)
\end{lstlisting}

\desc{Return the Riemann zeta function $\zeta(n)$ as an element of $r$.}

\begin{lstlisting}
zeta(s::arb, a::arb)
\end{lstlisting}

\desc{Return the Hurwitz zeta function $\zeta(s,a)$.}

\begin{lstlisting}
polylog(s::arb, z::arb)
polylog(s::Int, z::arb)
\end{lstlisting}

\desc{Return the polylogarithm $\operatorname{Li}_s(z)$.}

\begin{lstlisting}
agm(x::arb, y::arb)
\end{lstlisting}

\desc{Return the arithmetic-geometric mean of $x$ and $y$.}

\textbf{Examples.}

\begin{lstlisting}

x = floor(exp(RR(1)))

x = sinpi(QQ(5,6), RR)

y = gamma(QQ(1,3), ArbField(256))

z = bernoulli(1000, ArbField(53))

w = polylog(3, RR(-10))

\end{lstlisting}

\subsection{Arb complex numbers ($\C$): \code|acb|}

Arb provides the module \code{acb} for complex numbers represented
in rectangular form $a+bi$ where $a,b$ are \code{arb} numbers.
The type of Arb complex numbers in Nemo is also given the name \code{acb}.

The parent object for Arb complex numbers is of type \code{AcbField}, which
belongs to the \code{Field} type class.

The \code{AcbField} parent is initialised with the precision in bits (\code{prec})
used for operations on interval midpoints.

The following creates a parent object \code{CC} representing
the field of complex numbers with 64-bit precision, and an
element $x = 2+3i$:

\begin{lstlisting}
CC = AcbField(64)
x = CC(2,3)
\end{lstlisting}

In the following, we will assume that \code{CC} is an \code{AcbField}
instance as above, and that \code{RR} is an \code{ArbField} instance.



\subsubsection{Constructors}

\begin{lstlisting}
CC(x::Int)
CC(x::UInt)
CC(x::fmpz)
CC(x::fmpq)
CC(x::arb)
CC(x::Float64)
CC(x::AbstractString)
CC(x::Union{Complex{Float64},Complex{Int}})
CC(x::arb, y::arb)
CC(x::Int, y::Int)
CC(x::Union{Int,Float64,fmpz,fmpq,arb,AbstractString},
+  y::Union{Int,Float64,fmpz,fmpq,arb,AbstractString})
\end{lstlisting}


\desc{Constructs an \code{acb} element from the given real number,
complex number, or pair of real numbers.}

\begin{lstlisting}
zero(r::AcbField)
one(r::AcbField)
onei(r::AcbField)
\end{lstlisting}

\desc{Respectively return 0, 1, $i = \sqrt{-1}$ as an element of $r$.}

\textbf{Examples.}

\begin{lstlisting}
x = CC(3)

y = CC(QQ(2,3))

z = CC(RR(3), RR(4))

w = CC("1.23", "5.6")
\end{lstlisting}

\subsubsection{Complex parts}

\begin{lstlisting}
real(x::acb)
imag(x::acb)
abs(x::acb)
angle(x::acb)
\end{lstlisting}

\desc{Real part, imaginary part, absolute value, phase. These functions
return a real number of type \code{arb}, belonging to an \code{ArbField}
with the same precision as the parent of $x$.}

\begin{lstlisting}
conj(x::acb)
\end{lstlisting}

\desc{Complex conjugate of $x$.}

\subsubsection{Comparisons and predicates}

See the section for \code{arb} numbers for definitions of boolean-valued
functions for intervals.

\begin{lstlisting}
iszero(x::acb)
isone(x::acb)
isfinite(x::acb)
isexact(x::acb)
isint(x::acb)
isreal(x::acb)
\end{lstlisting}

\desc{Return whether $x$ certainly is, respectively, equal to zero,
equal to 1, finite, exact, an exact integer, purely real (having zero
imaginary part).}

\begin{lstlisting}
overlaps(x::acb, y::acb)
\end{lstlisting}

\desc{Return whether $x$ and $y$ have any point in common.}

\begin{lstlisting}
contains(x::acb, y::fmpq)
contains(x::acb, y::fmpz)
contains(x::acb, y::Int)
contains(x::acb, y::acb)
contains_zero(x::acb)
\end{lstlisting}

\desc{Return whether the complex interval $x$ contains the point $y$,
or entirely contains $y$ when this is a complex interval.}

\begin{lstlisting}
==(x::acb,y::acb)
!=(x::acb,y::acb)

==(x::acb,y::Int)
==(x::Int,y::acb)
==(x::acb,y::arb)
==(x::arb,y::acb)
==(x::acb,y::fmpz)
==(x::fmpz,y::acb)
==(x::acb,y::arb)
==(x::arb,y::acb)
==(x::acb,y::Float64)
==(x::Float64,y::acb)
!=(x::acb,y::Int)
!=(x::Int,y::acb)
!=(x::acb,y::arb)
!=(x::arb,y::acb)
!=(x::acb,y::fmpz)
!=(x::fmpz,y::acb)
!=(x::acb,y::arb)
!=(x::arb,y::acb)
!=(x::acb,y::Float64)
!=(x::Float64,y::acb)
\end{lstlisting}

\desc{Compare for equality or inequality.}

\begin{lstlisting}
strongequal(x::acb, y::acb)
\end{lstlisting}

\desc{Returns whether $x$ and $y$ are identical as intervals, that is,
have identical midpoints and radii for the real and imaginary parts.
Note that this is
not the same as testing mathematical equality of complex numbers,
as implemented by the \code{==} operator.}

\textbf{Examples.}

\begin{lstlisting}
x = CC("1 +/- 0.001")
y = CC("3")
z = CC(4,5)

!isexact(x)
isexact(z)

isint(y)
isreal(x)

contains(x, 1)
!overlaps(y,z)

x == 1
x != y
\end{lstlisting}

\subsubsection{Arithmetic operations}

\begin{lstlisting}
-(x::acb)
inv(x::acb)
\end{lstlisting}

\desc{Additive and multiplicative inverse.}

\begin{lstlisting}
+(x::acb, y::acb)
-(x::acb, y::acb)
*(x::acb, y::acb)
//(x::acb, y::acb)
^(x::acb, y::acb)

+(x::acb, y::Int)
-(x::acb, y::Int)
*(x::acb, y::Int)
//(x::acb, y::Int)
^(x::acb, y::Int)

+(x::Int, y::acb)
-(x::Int, y::acb)
*(x::Int, y::acb)
//(x::Int, y::acb)
^(x::Int, y::acb)

+(x::acb, y::UInt)
-(x::acb, y::UInt)
*(x::acb, y::UInt)
//(x::acb, y::UInt)
^(x::acb, y::UInt)

+(x::UInt, y::acb)
-(x::UInt, y::acb)
*(x::UInt, y::acb)
//(x::UInt, y::acb)
^(x::UInt, y::acb)

+(x::acb, y::fmpz)
-(x::acb, y::fmpz)
*(x::acb, y::fmpz)
//(x::acb, y::fmpz)
^(x::acb, y::fmpz)

+(x::fmpz, y::acb)
-(x::fmpz, y::acb)
*(x::fmpz, y::acb)
//(x::fmpz, y::acb)
^(x::fmpz, y::acb)

+(x::acb, y::fmpq)
-(x::acb, y::fmpq)
*(x::acb, y::fmpq)
//(x::acb, y::fmpq)
^(x::acb, y::fmpq)

+(x::fmpq, y::acb)
-(x::fmpq, y::acb)
*(x::fmpq, y::acb)
//(x::fmpq, y::acb)
^(x::fmpq, y::acb)

+(x::acb, y::arb)
-(x::acb, y::arb)
*(x::acb, y::arb)
//(x::acb, y::arb)
^(x::acb, y::arb)

+(x::arb, y::acb)
-(x::arb, y::acb)
*(x::arb, y::acb)
//(x::arb, y::acb)
^(x::arb, y::acb)
\end{lstlisting}

\desc{Arithmetic operations with \code{acb} numbers and simpler types,
producing \code{acb} numbers as results. Complex powers
evaluate to the principal branch.}

\textbf{Examples.}

\begin{lstlisting}
z = CC(10,3)
w = CC(3,4)

z^2 + w ^ QQ(1,2) + z^w

-z * inv(z) + 1

3*z + 4*w + 5*real(z)
\end{lstlisting}

\subsubsection{Miscellaneous operations}

\begin{lstlisting}
ldexp(x::acb, y::Int)

ldexp(x::acb, y::fmpz)
\end{lstlisting}

\desc{Return $x$ multiplyed by $2^y$ exactly.}

\begin{lstlisting}
trim(x::acb)
\end{lstlisting}

\desc{Return an \code{acb} interval containing $x$ but which may be more economical,
by rounding off insignificant bits from the midpoints.}

\begin{lstlisting}
accuracy_bits(x::acb)
\end{lstlisting}

\desc{Return the relative accuracy of $x$ measured in bits, capped
between \code{typemax(Int)} and \code{-typemax(Int)}.}

\begin{lstlisting}
unique_integer(x::acb)
\end{lstlisting}

\desc{Return a pair where the first value is a boolean and the second
is a \code{fmpz} integer. The boolean indicates whether the interval $x$
contains a unique integer. If this is the case, the second return
value is set to this unique integer.}

\textbf{Examples.}

\begin{lstlisting}
x = CC("1 +/- 0.0001", "0 +/- 1e-30")
y = CC("2")

ldexp(x, 100)

accuracy_bits(x)
accuracy_bits(y)

unique_integer(y)
\end{lstlisting}

\subsubsection{Mathematical constants}

\begin{lstlisting}
const_pi(r::AcbField)
\end{lstlisting}

\desc{Return $\pi = 3.14159\ldots$ as an element of $r$.}

\subsubsection{Mathematical functions}

\begin{lstlisting}
sqrt(x::acb)
\end{lstlisting}

\desc{Return $\sqrt{x}$.}

\begin{lstlisting}
rsqrt(x::acb)
\end{lstlisting}

\desc{Return $1 / \sqrt{x}$.}

\begin{lstlisting}
log(x::acb)
\end{lstlisting}

\desc{Return the principal branch of $\log(x)$.}

\begin{lstlisting}
log1p(x::acb)
\end{lstlisting}

\desc{Return $\log(1+x)$, evaluated accurately for small $x$.}

\begin{lstlisting}
exp(x::acb)
\end{lstlisting}

\desc{Return $\exp(x)$.}

\begin{lstlisting}
exppii(x::acb)
\end{lstlisting}

\desc{Return $\exp(\pi i x)$.}

\begin{lstlisting}
sin(x::acb)
cos(x::acb)
tan(x::acb)
cot(x::acb)
\end{lstlisting}

\desc{Return the respective trigonometric function $\sin(x)$, etc.}

\begin{lstlisting}
sinpi(x::acb)
cospi(x::acb)
tanpi(x::acb)
cotpi(x::acb)
\end{lstlisting}

\desc{Return the respective trigonometric function $\sin(\pi x)$, etc.}

\begin{lstlisting}
sincos(x::acb)
sincospi(x::acb)
\end{lstlisting}

\desc{Return a pair containing both the sine and cosine computed simultaneously.}

\begin{lstlisting}
sinh(x::acb)
cosh(x::acb)
tanh(x::acb)
coth(x::acb)
sinhcosh(x::acb)
\end{lstlisting}

\desc{Return the respective hyperbolic function $\sinh(x)$, etc.}

\begin{lstlisting}
atan(x::acb)
\end{lstlisting}

\desc{Return the inverse tangent $\operatorname{atan}(x)$.}

\begin{lstlisting}
logsinpi(x::acb)
\end{lstlisting}

\desc{Return $\log\sin(\pi x)$, constructed without branch cuts off the real line.}

\begin{lstlisting}
gamma(x::acb)
\end{lstlisting}

\desc{Return the gamma function $\Gamma(x)$.}

\begin{lstlisting}
gamma(x::fmpz, r::ArbField)
gamma(x::fmpq, r::ArbField)
\end{lstlisting}

\desc{Return the gamma function of $x$ as an element of $r$.}

\begin{lstlisting}
lgamma(x::acb)
\end{lstlisting}

\desc{Return the logarithm of the gamma function, $\log \Gamma(x)$.}

\begin{lstlisting}
rgamma(x::acb)
\end{lstlisting}

\desc{Return the reciprocal of the gamma function, $1 / \Gamma(x)$.}

\begin{lstlisting}
digamma(x::acb)
\end{lstlisting}

\desc{Return the logarithmic derivative of the gamma function, $\psi(x)$.}

\begin{lstlisting}
risingfac(x::acb, n::UInt)
risingfac(x::acb, n::Int)
\end{lstlisting}

\desc{Return the rising factorial $x (x+1) \cdots (x+n-1)$.}

\begin{lstlisting}
risingfac2(x::acb, n::UInt)
risingfac2(x::acb, n::Int)
\end{lstlisting}

\desc{Return a tuple containing the rising factorial and its derivative.}

\begin{lstlisting}
polygamma(s::acb, z::acb)
\end{lstlisting}

\desc{Return the generalised polygamma function $\psi(s,z)$.}

\begin{lstlisting}
zeta(s::acb)
\end{lstlisting}

\desc{Return the Riemann zeta function $\zeta(s)$.}

\begin{lstlisting}
zeta(s::acb, a::acb)
\end{lstlisting}

\desc{Return the Hurwitz zeta function $\zeta(s,a)$.}

\begin{lstlisting}
polylog(s::acb, z::acb)
polylog(s::Int, z::acb)
\end{lstlisting}

\desc{Return the polylogarithm $\operatorname{Li}_s(z)$.}

\begin{lstlisting}
barnesg(s::acb)
\end{lstlisting}

\desc{Return the Barnes $G$-function $G(s)$.}

\begin{lstlisting}
logbarnesg(s::acb)
\end{lstlisting}

\desc{Return the logarithm of the Barnes $G$-function.}

\begin{lstlisting}
erf(x::acb)
erfi(x::acb)
erfc(x::acb)
\end{lstlisting}

\desc{Return the error function, imaginary error function, complementary error function.}

\begin{lstlisting}
ei(x::acb)
si(x::acb)
ci(x::acb)
shi(x::acb)
chi(x::acb)
li(x::acb)
lioffset(x::acb)
\end{lstlisting}

\desc{Return the exponential integral, sine integral, cosine integral
hyperbolic sine integral, hyperbolic cosine integral, logarithmic integral,
offset logarithmic integral.}

\begin{lstlisting}
expint(s::acb, x::acb)
\end{lstlisting}

\desc{Return the generalised exponential integral $E_s(x)$.}

\begin{lstlisting}
gamma(s::acb, x::acb)
\end{lstlisting}

\desc{Return the upper incomplete gamma function $\Gamma(s,x)$.}

\begin{lstlisting}
besselj(nu::acb, x::acb)
bessely(nu::acb, x::acb)
besseli(nu::acb, x::acb)
besselk(nu::acb, x::acb)
\end{lstlisting}

\desc{Return the Bessel function $J_{\nu}(x), Y_{\nu}(x), I_{\nu}(x), K_{\nu}(x)$.}

\begin{lstlisting}
hyp1f1(a::acb, b::acb, x::acb)
\end{lstlisting}

\desc{Return the confluent hypergeometric function ${}_1F1(a,b,x)$.}

\begin{lstlisting}
hyp1f1r(a::acb, b::acb, x::acb)
\end{lstlisting}

\desc{Return the regularized confluent hypergeometric function ${}_1F1(a,b,x) / \Gamma(b)$.}

\begin{lstlisting}
hyperu(a::acb, b::acb, x::acb)
\end{lstlisting}

\desc{Return the confluent hypergeometric function $U(a,b,x)$.}

\begin{lstlisting}
jtheta(z::acb, tau::acb)
\end{lstlisting}

\desc{Return a tuple of four elements containing the Jacobi theta function
values $\theta_1, \theta_2, \theta_3, \theta_4$ evaluated at $z, \tau$.}

\begin{lstlisting}
modeta(tau::acb)
modj(tau::acb)
modlambda(tau::acb)
moddelta(tau::acb)
\end{lstlisting}

\desc{Return the Dedekind eta function $\eta(\tau)$, the j-invariant $j(\tau)$,
the modular lambda function $\lambda(\tau)$, the modular delta function $\Delta(\tau)$.}

\begin{lstlisting}
ellipwp(z::acb, tau::acb)
\end{lstlisting}

\desc{Return the Weierstrass elliptic function $\wp(z,\tau)$.}

\begin{lstlisting}
ellipk(z::acb)
ellipe(z::acb)
\end{lstlisting}

\desc{Return the complete elliptic integral $K(z)$, $E(z)$.}

\begin{lstlisting}
agm(x::acb)
agm(x::acb, y::acb)
\end{lstlisting}

\desc{Return the arithmetic-geometric mean of $x$ and $y$. With one argument,
return the AGM of 1 and $x$.}

\textbf{Examples.}

\begin{lstlisting}

s = CC(1, 2)
z = CC("1.23", "3.45")

sin(z)^2 + cos(z)^2

zeta(z)

besselj(s, z)

hyp1f1(s, s+1, z)

\end{lstlisting}

\section{Pari rings}

Pari is a library for algebraic number theory, maintained in Bordeaux, France.
We currently use Pari to provide arithmetic in maximal orders (rings of integers)
of number fields and ideals of number fields.

Pari is dynamically typed, though on a lower level it has specific types for a
range of rings and fields. Many Pari objects are however represented not by
special objects, but simply by their low level representation in terms of vectors
of lower level objects, etc.

We give Nemo types to Pari objects where they have none in Pari.

\subsection{Pari maximal orders: \code|pari_maximal_order_elem|}

Pari has no specific type for an element of a maximal order. In Nemo a maximal
order parent object has type \code{PariMaximalOrder}, which belongs to the
\code{Ring} type class. Elements of a maximal order are given the type
\code{pari_maximal_order_elem} which belongs to the \code{MaximalOrderElem}
type class, which in turn belongs to \code{RingElem}.

The user need not deal with the types directly since we provide a function
\code{PariMaximalOrder} to create parent objects for Pari maximal orders and we
also provide various constructors to create elements of such orders.

By default, the global variable \code{MaximalOrder} is set equal to
\code{PariMaximalOrder} which means that the following code can be used to
create maximal order parent objects in Nemo.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)
\end{lstlisting}

Here, $x^3 + 3x + 1$ is the irreducible polynomial over $\Q$ giving the minimum
polynomial of the generator $a$ of the number field $K$ (though it need not be
a monic polynomial).

Note that at the present time, Pari maximal orders are constructed from Antic
number fields. This may change in a later version of Nemo.

\subsubsection{Constructors}

Various constructors are provided to create elements of a Pari maximal order.
In the constructors below we assume that $O$ is the parent object of such a maximal
order, for example created by the construction above.

\begin{lstlisting}
O()
\end{lstlisting}

\desc{Create the element $0$ of the number field.}

\begin{lstlisting}
O(d::Integer)
O(d::fmpz)
\end{lstlisting}

\desc{Create the element of the maximal order which results from mapping the
integer $d$ into the maximal order via the embedding of the integers into the
order.}

\begin{lstlisting}
O(d::fmpq_poly)
\end{lstlisting}

\desc{Given a polynomial $d$, consider the polynomial to be an element of the
number field $K$ and embed it into the maximal order $O$. The element is
represented in terms of a basis for $O$.}

\begin{lstlisting}
O(d::nf_elem)
\end{lstlisting}

\desc{Embed the number field element $d$ into the maximal order $O$. The element
is represented in terms of a basis for $O$.}

\begin{lstlisting}
O(d::pari_maximal_order_elem)
\end{lstlisting}

\desc{Return a reference to the maximal order element $d$. No copy of the data is
made.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

k = O()
l = O(123)
m = O(fmpz(12))
n = O(x^2 + 2x - 7)
p = O(a^2 + 2a - 7)
q = O(n)
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
basis(O::PariMaximalOrder)
\end{lstlisting}

\desc{Return the basis of the maximal order $O$. This is a vector of Pari
polynomials representing the basis elements. They can be accessed using
array notation and coerced into the ring of Flint polynomials over the
rationals.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

B = basis(O)
b3 = B[3]
c = R(b3)
\end{lstlisting}

\section{Pari collections}

Pari provides numerous objects which aren't rings or fields, but merely sets.
We call such an object a collection in Nemo.

\subsection{Pari ideals: \code|PariIdeal|}

Ideals behave more like a parent object than an element object, thus we capitalise
the name given to the types of both the parent object of an ideal and the ideal
itself in Nemo.

Pari has no specific type for an ideal of a number field. In Nemo the parent
object for an ideal collection has type \code{PariIdealCollection}, which belongs
to the \code{Collection} type class. Note that even though ideals can be added
and multiplied, they don't form a ring.

Elements of an ideal collection in Nemo are ideals, which are given the type
\code{PariIdeal} which belongs directly to the \code{CollectionElem} type class.

The user need not deal with the types directly since we provide a function
\code{PariIdeal} to create Pari ideal objects (not their parents) directly.

By default, the global variable \code{Ideal} is set equal to
\code{PariIdeal} so that ideals can be constructed using \code{Ideal}.

\subsubsection{Constructors}

In the following constructors, we take $O$ to be the parent object for a Pari
maximal order, constructed for example by the following code.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)
\end{lstlisting}

We note that the constructors for Pari ideals objects below are variadic,
meaning that they can take a comma separated list of generators for the ideal.

\begin{lstlisting}
Ideal(O::PariMaximalOrder, b::Integer, ...)
\end{lstlisting}

\desc{Construct the ideal generated by the number field elements represented
by the given variadic list of integers.}

\begin{lstlisting}
Ideal(O::PariMaximalOrder, b::fmpz, ...)
\end{lstlisting}

\desc{Construct the ideal generated by the number field elements represented
by the given variadic list of integers.}

\begin{lstlisting}
Ideal(O::PariMaximalOrder, b::fmpq_poly, ...)
\end{lstlisting}

\desc{Construct the ideal generated by the number field elements represented
by the given variadic list of polynomials.}

\begin{lstlisting}
Ideal(O::PariMaximalOrder, b::nf_elem, ...)
\end{lstlisting}

\desc{Construct the ideal generated by the given number field elements.}

\begin{lstlisting}
Ideal(O::PariMaximalOrder, b::pari_maximal_order_elem, ...)
\end{lstlisting}

\desc{Construct the ideal generated by the given maximal order elements.}

\textbf{Examples.}

Here are some examples of constructors.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

c = Ideal(O, 2, 3)
d = Ideal(O, x + 1, R(3))
f = Ideal(O, a + 1, K(3))
g = Ideal(O, O(a + 1), O(3))
\end{lstlisting}

\subsubsection{Listing ideals}

\begin{lstlisting}
bounded_ideals(R::PariMaximalOrder, bound::Int)
\end{lstlisting}

\desc{Create a list of all ideals of the given order with norm at most equal to the
given bound. The list is returned as a Julia array indexed by the norms from $1$ to
the given bound. Each entry in the array is a Pari vector of ideals which can be
accessed using array notation.}

\begin{lstlisting}
prime_decomposition(R::PariMaximalOrder, p::fmpz)
\end{lstlisting}

\desc{Create a list of all ideals dividing the given prime number $p$. We do not
check that $p$ is prime, though it is required to be prime. The list is returned
as a Pari vector of ideals which can be accessed using array notation.}

\textbf{Examples.}

Here are some examples of ideal lists.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = prime_decomposition(O, 13)
T = bounded_ideals(O, 100)

a = S[2]
b = T[97][1]
\end{lstlisting}

\subsubsection{Basic manipulation}

\begin{lstlisting}
numden(a::PariIdeal)
\end{lstlisting}

\desc{Return a pair $(n, d)$ consisting of the numerator and denominator
of the given ideal (as ideals).}

\begin{lstlisting}
valuation(a::PariIdeal, p::PariIdeal)
\end{lstlisting}

\desc{Given a prime ideal $p$ as returned by \code{prime_decomposition}, return
the valuation of $a$ at $p$.}

\textbf{Examples.}

Here are some examples of basic manipulation.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)
T = Ideal(O, fmpq(2, 3)*x + 1)
A = prime_decomposition(O, 3)

valuation(S, A[1])
(n, d) = numden(T)
\end{lstlisting}

\subsubsection{Ideal norm}

\begin{lstlisting}
norm(a::PariIdeal)
\end{lstlisting}

\desc{Return the norm of the ideal as an \code{fmpz} integer.}

\textbf{Examples.}

Here is an example of ideal norm.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)

a = norm(S)
\end{lstlisting}

\subsubsection{Binary operators}

\begin{lstlisting}
+(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Return the sum of the given ideals.}

\begin{lstlisting}
*(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Return the product of the given ideals.}

\begin{lstlisting}
intersect(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Return the intersection of the given ideals.}

\textbf{Examples.}

Here are some examples of binary operators.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)
T = Ideal(O, 3)

A = S + T
B = S*T
C = intersect(S, T)
\end{lstlisting}

\subsubsection{Comparison}

\begin{lstlisting}
==(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Return \code{true} if the ideals are arithmetically the same ideal.}

\textbf{Examples.}

Here are some examples of comparison.

\begin{lstlisting}
   R, x = PolynomialRing(QQ, "x")
   K, a = NumberField(x^3 + 3x + 1, "a")
   O = MaximalOrder(K)

   S = Ideal(O, x + 1)
   T = Ideal(O, 3)

   S == S
   S != T
\end{lstlisting}

\subsubsection{Powering}

\begin{lstlisting}
^(a::PariIdeal, n::Int)
\end{lstlisting}

\desc{Return $a^n$.}

\textbf{Examples.}

Here is an example of powering.

\begin{lstlisting}
   R, x = PolynomialRing(QQ, "x")
   K, a = NumberField(x^3 + 3x + 1, "a")
   O = MaximalOrder(K)

   S = Ideal(O, x + 1)
   
   T = S^3
\end{lstlisting}

\subsubsection{Exact division}

\begin{lstlisting}
divexact(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Return the exact quotient of the ideals $a$ and $b$.}

\textbf{Examples.}

Here is an example of exact division.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)
T = Ideal(O, 3)

divexact(S*T, T)
\end{lstlisting}

\subsubsection{Inverse}

\begin{lstlisting}
inv(a::PariIdeal)
\end{lstlisting}

\desc{Return the inverse of the given ideal.}

\textbf{Examples.}

Here is an example of inversion.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)

inv(S)
\end{lstlisting}

\subsubsection{Extended GCD}

\begin{lstlisting}
gcdx(a::PariIdeal, b::PariIdeal)
\end{lstlisting}

\desc{Given two coprime integer ideals $a$ and $b$ return a pair of values $(s, t)$,
with $s \in a$ and $t \in b$ such that $s + t = 1$. The values $s$ and $t$ will be
returned as \code{fmpq_poly}'s.}

\textbf{Examples.}

Here is an example of extended GCD.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, x + 1)
T = Ideal(O, 2x)

(s, t) = gcdx(S, T)
\end{lstlisting}

\subsubsection{Ideal factorisation}

\begin{lstlisting}
factor(a::PariIdeal)
\end{lstlisting}

\desc{Return the prime factorisation of the given ideal. This is given as a Julia
array of tuples $(P, n)$ consisting of a prime ideal $P$ and its exponent in the
factorisation of $a$.}

\begin{lstlisting}
factor_mul(a::PariFactor{pari_maximal_order_elem})
\end{lstlisting}

\desc{Given a factorisation of an ideal $a$ into prime factors as returned by
\code{factor}, this function retrieves the original ideal $a$.}

\textbf{Examples.}

Here is an example of ideal factorisation.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, 3)

A = factor(S)
T = factor_mul(A)
\end{lstlisting}

\subsubsection{Ideal approximation}

\begin{lstlisting}
approx(a::PariIdeal)
\end{lstlisting}

\desc{Return an element of the given ideal which approximates the ideal, in the
sense that the valuation at all prime ideals dividing $a$ is the same, and the
valuation at all other prime ideals is non-negative.}

\textbf{Examples.}

Here is an example of ideal factorisation.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, 3)

f = approx(S)
\end{lstlisting}

\subsubsection{Coprime ideal construction}

\begin{lstlisting}
coprime_multiplier(x::PariIdeal, y::PariIdeal)
\end{lstlisting}

\desc{Return an element of the number field $b$ such that $bx$ is an integral
ideal coprime to the ideal $y$.}

\textbf{Examples.}

Here is an example of coprime ideal construction.

\begin{lstlisting}
R, x = PolynomialRing(QQ, "x")
K, a = NumberField(x^3 + 3x + 1, "a")
O = MaximalOrder(K)

S = Ideal(O, 3)
T = Ideal(O, x + 1)

f = coprime_multiplier(S, T)
\end{lstlisting}




\end{document}
