<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Multivariate series Â· AbstractAlgebra.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractAlgebra.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">AbstractAlgebra.jl</a></li><li><span class="tocitem">Fundamental interface of AbstractAlgebra.jl</span><ul><li><a class="tocitem" href="../types/">Type interface of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../visualizing_types/">Visualization of the types of AbstractAlgebra.jl</a></li><li><a class="tocitem" href="../extending_abstractalgebra/">Extending the interface of AbstractAlgebra.jl</a></li></ul></li><li><a class="tocitem" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../ring_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../integer/">Integer ring</a></li><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li><li><a class="tocitem" href="../ncpolynomial/">Univariate polynomials over a noncommutative ring</a></li><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li><li><a class="tocitem" href="../univpolynomial/">Universal polynomial</a></li><li><a class="tocitem" href="../laurent_polynomial/">Generic Laurent polynomials</a></li><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li class="is-active"><a class="tocitem" href="">Multivariate series</a><ul class="internal"><li><a class="tocitem" href="#Generic-multivariate-series"><span>Generic multivariate series</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Multivariate-series-ring-constructors"><span>Multivariate series ring constructors</span></a></li><li><a class="tocitem" href="#Basic-ring-functionality"><span>Basic ring functionality</span></a></li><li><a class="tocitem" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl"><span>Power series functionality provided by AbstractAlgebra.jl</span></a></li></ul></li><li><a class="tocitem" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../field_introduction/">Introduction.</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../function_field/">Rational function fields</a></li><li><a class="tocitem" href="../finfield/">Finite fields</a></li><li><a class="tocitem" href="../real/">Real field</a></li><li><a class="tocitem" href="../numberfield/">Number fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../perm/">Permutations and Symmetric groups</a></li><li><a class="tocitem" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module_introduction/">Introduction.</a></li><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><span class="tocitem">Matrices</span><ul><li><a class="tocitem" href="../matrix_introduction/">Introduction</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="tocitem">Maps</span><ul><li><a class="tocitem" href="../map_introduction/">Introduction</a></li><li><a class="tocitem" href="../map/">Maps</a></li><li><a class="tocitem" href="../functional_map/">Functional maps</a></li><li><a class="tocitem" href="../map_cache/">Cached maps</a></li><li><a class="tocitem" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interface_introduction/">Introduction</a></li><li><a class="tocitem" href="../ring_interface/">Ring Interface</a></li><li><a class="tocitem" href="../euclidean_interface/">Euclidean Ring Interface</a></li><li><a class="tocitem" href="../poly_interface/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../mpoly_interface/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../series_interface/">Series Ring Interface</a></li><li><a class="tocitem" href="../residue_interface/">Residue Ring Interface</a></li><li><a class="tocitem" href="../field_interface/">Field Interface</a></li><li><a class="tocitem" href="../fraction_interface/">Fraction Field Interface</a></li><li><a class="tocitem" href="../module_interface/">Module Interface</a></li><li><a class="tocitem" href="../matrix_interface/">Matrix Interface</a></li><li><a class="tocitem" href="../map_interface/">Map interface</a></li><li><a class="tocitem" href="../rand/">Random interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li class="is-active"><a href="">Multivariate series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Multivariate series</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mseries.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-series"><a class="docs-heading-anchor" href="#Multivariate-series">Multivariate series</a><a id="Multivariate-series-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-series" title="Permalink"></a></h1><p>AbstractAlgebra.jl provide multivariate series over a commutative ring.</p><p>Currently only series with capped absolute precision are provided. The precision in each variable can be set, but is capped at some maximum precision which is set when defining the ring.</p><h2 id="Generic-multivariate-series"><a class="docs-heading-anchor" href="#Generic-multivariate-series">Generic multivariate series</a><a id="Generic-multivariate-series-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-multivariate-series" title="Permalink"></a></h2><p>Generic multivariate series over a commutative ring, <code>AbsMSeries{T}</code> is implemented in <code>src/generic/AbsMSeries.jl</code>.</p><p>Such series are capped absolute series and have type <code>Generic.AbsMSeries{T}</code> where <code>T</code> is the type of elements of the coefficient ring.</p><p>Internally they consist of a multivariate polynomial and a vector of precisions, one for each variable. See the file <code>src/generic/GenericTypes.jl</code> for details of the type.</p><p>The series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.</p><p>Only lex ordering is provided at present, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.</p><p>Parent objects of such series have type <code>Generic.AbsMSeriesRing{T}</code>.</p><p>The symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>Multivariate series element types belong to the abstract type <code>MSeriesElem{T}</code> and the multivariate series ring types belong to the abstract type <code>MSeriesRing{T}</code>. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.</p><h2 id="Multivariate-series-ring-constructors"><a class="docs-heading-anchor" href="#Multivariate-series-ring-constructors">Multivariate series ring constructors</a><a id="Multivariate-series-ring-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-series-ring-constructors" title="Permalink"></a></h2><p>In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructor.</p><pre><code class="language-julia">PowerSeriesRing(R::Ring, prec::Vector{Int}, s::Vector{U}; cached::Bool = true) where U &lt;: AbstractString</code></pre><p>Given a base ring <code>R</code> and vector of strings <code>s</code> specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple <code>U, (x, y, ...)</code> representing the new series ring <span>$S$</span> and the generators <span>$x, y, \ldots$</span> of the ring as a tuple. By default the parent object <code>S</code> will depend only on <code>R</code> and the variable names <code>x, y, ...</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object <code>S</code> from being cached.</p><p>Here are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.</p><p>Note that one can also use the function call <code>O(x^n)</code> to specify the precision in the variable <code>x</code> of a given series expression should be precision <code>n</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not possible to use <code>x^0</code> in the <code>O()</code> function, since there is no distinction between <code>x^0</code> and <code>y^0</code> as far as the system is concerned. If one wishes to set the precision of a variable to precision <code>0</code>, one must use the <code>set_precision!</code> function described below.</p></div></div><p>If one wants a series with the same precision in all variables, one can use <code>O(R, n)</code> where <code>R</code> is the series ring and <code>n</code> is the desired precision.</p><p>If all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y) = PowerSeriesRing(ZZ, [2, 3], ["x", "y"])
(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])

julia&gt; f = R()
O(y^3) + O(x^2)

julia&gt; g = R(123)
123 + O(y^3) + O(x^2)

julia&gt; h = R(BigInt(1234))
1234 + O(y^3) + O(x^2)

julia&gt; k = R(x + 1)
1 + x + O(y^3) + O(x^2)

julia&gt; m = x + y + O(y^2)
y + x + O(y^2) + O(x^2)

julia&gt; R, (x, y) = PowerSeriesRing(ZZ, 3, ["x", "y"])
(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])

julia&gt; n = x + y + O(R, 2)
y + x + O(y^2) + O(x^2)</code></pre><h2 id="Basic-ring-functionality"><a class="docs-heading-anchor" href="#Basic-ring-functionality">Basic ring functionality</a><a id="Basic-ring-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-ring-functionality" title="Permalink"></a></h2><p>Once a multivariate series ring is constructed, there are various ways to construct series in that ring.</p><p>The easiest way is simply using the generators returned by the <code>PowerSeriesRing</code> constructor and build up the power series using basic arithmetic, as described in the Ring interface.</p><p>The power series rings in AbstractAlgebra.jl implement the full Ring interface.</p><p>We give some examples of such functionality. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The divexact function can currently only divide by unit series (i.e. whose constant coefficient is invertible).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x,) = PowerSeriesRing(ZZ, [5], ["x"])
(Multivariate power series ring in x over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])

julia&gt; f = x^3 + 3x + 21
21 + 3*x + x^3 + O(x^5)

julia&gt; h = zero(R)
O(x^5)

julia&gt; k = one(R)
1 + O(x^5)

julia&gt; isone(k)
true

julia&gt; iszero(f)
false

julia&gt; n = length(f)
3

julia&gt; U = base_ring(R)
Integers

julia&gt; v = symbols(R)
1-element Vector{Symbol}:
 :x

julia&gt; T = parent(x + 1)
Multivariate power series ring in x over Integers

julia&gt; f == deepcopy(f)
true

julia&gt; t = divexact(f*x, 1 + x)
21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)</code></pre><h2 id="Power-series-functionality-provided-by-AbstractAlgebra.jl"><a class="docs-heading-anchor" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl">Power series functionality provided by AbstractAlgebra.jl</a><a id="Power-series-functionality-provided-by-AbstractAlgebra.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Power-series-functionality-provided-by-AbstractAlgebra.jl" title="Permalink"></a></h2><p>The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.</p><h3 id="Basic-functionality"><a class="docs-heading-anchor" href="#Basic-functionality">Basic functionality</a><a id="Basic-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functionality" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" id="AbstractAlgebra.nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.nvars</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nvars(R::AbsMSeriesRing)</code></pre><p>Return the number of variables in the series ring.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L53" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.symbols-Tuple{AbstractAlgebra.MSeriesRing}" id="AbstractAlgebra.symbols-Tuple{AbstractAlgebra.MSeriesRing}"><code>AbstractAlgebra.symbols</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbols(R::MSeriesRing)</code></pre><p>Return a vector of symbols, one for each of the variables of the series ring <span>$R$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/AbsMSeries.jl#L35" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="Base.precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.precision</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">precision(a::AbsMSeries)</code></pre><p>Return a vector of precisions, one for each variable in the series ring.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L60" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" id="AbstractAlgebra.max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>AbstractAlgebra.max_precision</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_precision(R::AbsMSeriesRing)</code></pre><p>Return a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L84" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.valuation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valuation(a::AbsMSeries)</code></pre><p>Return the valuation of <span>$a$</span> as a vector of integers, one for each variable.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L93" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}" id="AbstractAlgebra.coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}"><code>AbstractAlgebra.coeff</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coeff(a::AbsMSeries, n::Int)</code></pre><p>Return the coefficient of the <span>$n$</span>-th nonzero term of the series (or zero if there are fewer than <span>$n$</span> nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L112" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.characteristic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">characteristic(R::FracField{T}) where T &lt;: RingElem</code></pre><p>Return the characteristic of the given field.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/Fraction.jl#L29" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}" id="AbstractAlgebra.gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}"><code>AbstractAlgebra.gen</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen(R::AbsMSeriesRing, i::Int)</code></pre><p>Return the <span>$i$</span>-th generator (variable) of the series ring <span>$R$</span>. Numbering starts from <span>$1$</span> for the most significant variable.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L141" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#GroupsCore.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}" id="GroupsCore.gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}"><code>GroupsCore.gens</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(R::AbsMSeriesRing)</code></pre><p>Return a vector of the generators (variables) of the series ring <span>$R$</span>, starting with the most significant.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L154" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.isgen</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isgen(a::AbsMSeries)</code></pre><p>Return true if the series <span>$a$</span> is a generator of its parent series ring.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L163" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.isunit</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isunit(a::AbsMSeries)</code></pre><p>Return <code>true</code> if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L133" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="Base.length-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.length</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(a::AbsMSeries)</code></pre><p>Return the number of nonzero terms in the series <span>$a$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L46" target="_blank">source</a></section></article><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.coefficients</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficients(a::AbsMSeries)</code></pre><p>Return an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L191" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="AbstractAlgebra.exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>AbstractAlgebra.exponent_vectors</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exponent_vectors(a::AbsMSeries)</code></pre><p>Return an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L201" target="_blank">source</a></section></article><h3 id="Truncation"><a class="docs-heading-anchor" href="#Truncation">Truncation</a><a id="Truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Truncation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}" id="Base.truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}"><code>Base.truncate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})</code></pre><p>Return <span>$a$</span> truncated to (absolute) precisions given by the vector <code>prec</code>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L272" target="_blank">source</a></section></article><h3 id="Inversion"><a class="docs-heading-anchor" href="#Inversion">Inversion</a><a id="Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}" id="Base.inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}"><code>Base.inv</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.inv(x::AbsMSeries)</code></pre><p>Return the inverse of the series <span>$x$</span>. An exception is raised if the series is not a unit.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L421" target="_blank">source</a></section></article><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S, AbstractAlgebra.Generic.AbsMSeries{T, S} where S}} where T&lt;:RingElem" id="AbstractAlgebra.divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S, AbstractAlgebra.Generic.AbsMSeries{T, S} where S}} where T&lt;:RingElem"><code>AbstractAlgebra.divexact</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divexact(x::AbsMSeries{T}, y::AbsMSeries{T}; check::Bool=true) where T &lt;: RingElement</code></pre><p>Return the exact quotient of the series <span>$x$</span> by the series <span>$y$</span>. This function currently assumes <span>$y$</span> is an invertible series.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L459" target="_blank">source</a></section></article><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}"><code>AbstractAlgebra.evaluate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables with indices given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L476" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}"><code>AbstractAlgebra.evaluate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the corresponding variables given by the array <code>vars</code>. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L505" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}" id="AbstractAlgebra.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T&lt;:RingElement, U&lt;:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}"><code>AbstractAlgebra.evaluate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(a::U, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: AbsMSeries{T}}</code></pre><p>Evaluate the series expression by substituting in the supplied values in the array <code>vals</code> for the variables the series ring to which <span>$a$</span> belongs. The values must be in the same ring as <span>$a$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/generic/AbsMSeries.jl#L518" target="_blank">source</a></section></article><h3 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any, N} where N}" id="Base.rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any, N} where N}"><code>Base.rand</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(S::MSeriesRing, term_range, v...)</code></pre><p>Return a random element of the series ring <span>$S$</span> with number of terms in the range given by <code>term_range</code> and where coefficients of the series are randomly generated in the base ring using the data given by <code>v</code>. The exponents of the variable in the terms will be less than the precision caps for the Ring <span>$S$</span> when it was created.</p></div><a class="docs-sourcelink" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/5d8d18ac49ea532f6fd536f52d6119bfb9e66cd3/src/AbsMSeries.jl#L151" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../puiseux/">Â« Generic Puiseux series</a><a class="docs-footer-nextpage" href="../residue/">Generic residue rings Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 25 September 2021 20:18">Saturday 25 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>