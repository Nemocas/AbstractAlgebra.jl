<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Generic sparse distributed multivariate polynomials · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li class="current"><a class="toctext" href="">Generic sparse distributed multivariate polynomials</a><ul class="internal"><li><a class="toctext" href="#Types-and-parent-objects-1">Types and parent objects</a></li><li><a class="toctext" href="#Polynomial-ring-constructors-1">Polynomial ring constructors</a></li><li><a class="toctext" href="#Polynomial-functionality-provided-by-AbstractAlgebra.jl-1">Polynomial functionality provided by AbstractAlgebra.jl</a></li></ul></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li><a class="toctext" href="../series/">Generic power series</a></li><li><a class="toctext" href="../puiseux/">Generic Puiseux series</a></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fields/">Field Interface</a></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><a class="toctext" href="../types/">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="">Generic sparse distributed multivariate polynomials</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/mpolynomial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generic sparse distributed multivariate polynomials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Generic-sparse-distributed-multivariate-polynomials-1" id="Generic-sparse-distributed-multivariate-polynomials-1">Generic sparse distributed multivariate polynomials</a></h1><p>AbstractAlgebra.jl provides a module, implemented in <code>src/generic/MPoly.jl</code> for generic sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.</p><p>This modules implements the Multivariate Polynomial interface, including the sparse distributed, random access part of the interface.</p><p>All of the generic functionality is part of a submodule of AbstractAlgebra called <code>Generic</code>. This is exported by default so that it is not necessary to qualify the function names with the submodule name.</p><p>Multivariates are implemented in this module using a Julia array of coefficients and a 2-dimensional Julia array of <code>UInt</code>s for the exponent vectors. Note that exponent <span>$n$</span> is represented by the <span>$n$</span>-th column of the exponent array, not the <span>$n$</span>-th row. This is because Julia uses a column major representation.</p><h2><a class="nav-anchor" href="#Types-and-parent-objects-1" id="Types-and-parent-objects-1">Types and parent objects</a></h2><p>Multivariate polynomials implemented in AbstractAlgebra.jl have type <code>Generic.MPoly{T}</code> where <code>T</code> is the type of elements of the coefficient ring.</p><p>The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of <code>UInt</code>s for the exponent vectors. Note that exponent <span>$n$</span> is represented by the <span>$n$</span>-th column of the exponent array, not the <span>$n$</span>-th row. This is because Julia uses a column major representation. See the file <code>src/generic/GenericTypes.jl</code> for details.</p><p>The top bit of each <code>UInt</code> is reserved for overflow detection.</p><p>Parent objects of such polynomials have type <code>Generic.MPolyRing{T}</code>.</p><p>The string representation of the variables of the polynomial ring and the base/coefficient ring <span>$R$</span> and the ordering are stored in the parent object. </p><p>The polynomial element types belong to the abstract type <code>AbstractAlgebra.MPolyElem{T}</code> and the polynomial ring types belong to the abstract type <code>AbstractAlgebra.MPolyRing{T}</code>.</p><p>Note that both the generic polynomial ring type <code>Generic.MPolyRing{T}</code> and the abstract type it belongs to, <code>AbstractAlgebra.MPolyRing{T}</code> are both called <code>MPolyRing</code>. The  former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type <code>T</code>. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).</p><h2><a class="nav-anchor" href="#Polynomial-ring-constructors-1" id="Polynomial-ring-constructors-1">Polynomial ring constructors</a></h2><p>In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.</p><pre><code class="language-julia">PolynomialRing(R::AbstractAlgebra.Ring, S::Array{String, 1}; cached::Bool = true, ordering::Symbol=:lex)</code></pre><p>Given a base ring <code>R</code> and and array <code>S</code> of strings specifying how the generators (variables) should be printed, return a tuple <code>S, (x, ...)</code> representing the new polynomial ring <span>$S = R[x, \ldots]$</span> and a tuple of the generators <span>$(x, ...)$</span> of the ring. By default the parent object <code>S</code> will depend only on <code>R</code> and  <code>(x, ...)</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object  <code>S</code> from being cached.</p><p>The optional named argument <code>ordering</code> can be used to specify an ordering. The currently supported options are <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code>.</p><p>Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"]; ordering=:deglex)

f = R()
g = R(123)
h = R(BigInt(1234))
k = R(x + 1)
m = R(x + y + 1)
derivative(k, 1)
derivative(k, 2)</code></pre><p>All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a <code>PolynomialRing</code> constructor to allow creation of their polynomial rings.</p><h2><a class="nav-anchor" href="#Polynomial-functionality-provided-by-AbstractAlgebra.jl-1" id="Polynomial-functionality-provided-by-AbstractAlgebra.jl-1">Polynomial functionality provided by AbstractAlgebra.jl</a></h2><h3><a class="nav-anchor" href="#Basic-manipulation-1" id="Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.vars-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.vars-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.vars</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vars(p::AbstractAlgebra.MPolyElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the variables actually occuring in <span>$p$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.var_index-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.var_index-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.var_index</code></a> — <span class="docstring-category">Method</span>.</div><div><p>var_index(p::AbstractAlgebra.MPolyElem{T}) where {T &lt;: RingElement}</p><blockquote><p>Return the index of the given variable <span>$x$</span>. If <span>$x$</span> is not a variable in a multivariate polynomial ring, an exception is raised.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},Int64}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},Int64}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.degree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">degree(f::AbstractAlgebra.MPolyElem{T}, i::Int) where T &lt;: RingElement</code></pre><blockquote><p>Return the degree of the polynomial <span>$f$</span> in terms of the i-th variable.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.degree-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.degree</code></a> — <span class="docstring-category">Method</span>.</div><div><p>degree(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</p><blockquote><p>Return the degree of the polynomial <span>$f$</span> in terms of the variable <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.degrees-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.degrees-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.degrees</code></a> — <span class="docstring-category">Method</span>.</div><div><p>degrees(f::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</p><blockquote><p>Return an array of the degrees of the polynomial <span>$f$</span> in terms of each variable.</p></blockquote></div></section><pre><code class="language-none">isunit(::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.isconstant-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.isconstant-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.isconstant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isconstant(x::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</code></pre><blockquote><p>Return <code>true</code> if <code>x</code> is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.isterm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.isterm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.isterm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isterm(x::MPoly)</code></pre><blockquote><p>Return <code>true</code> if the given polynomial has precisely one term.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.ismonomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.ismonomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.ismonomial</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ismonomial(x::AbstractAlgebra.MPolyElem)</code></pre><blockquote><p>Return <code>true</code> if the given polynomial has precisely one term whose coefficient is one.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

f = x^2 + 2x + 1

V = vars(f)
var_index(y) == 2
degree(f, x) == 2
degree(f, 2) == 0
d = degrees(f)
isconstant(R(1))
isterm(2x)
ismonomial(y)
isunit(R(1))</code></pre><h3><a class="nav-anchor" href="#Changing-base-(coefficient)-rings-1" id="Changing-base-(coefficient)-rings-1">Changing base (coefficient) rings</a></h3><p>In order to substitute the variables of a polynomial <span>$f$</span> over a ring <span>$T$</span> by elements in a <span>$T$</span>-algebra <span>$S$</span>, you first have to change the base ring of <span>$f$</span> using the following function, where <span>$g$</span> is a function representing the structure homomorphism of the <span>$T$</span>-algebra <span>$S$</span>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.change_base_ring-Union{Tuple{T}, Tuple{MPolyElem{T},Any}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.change_base_ring-Union{Tuple{T}, Tuple{MPolyElem{T},Any}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.change_base_ring</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">change_base_ring(p::AbstractAlgebra.MPolyElem{T}, g) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the polynomial obtained by applying g to the coefficients of p.</p></blockquote></div></section><p>Note that <span>$g$</span> can also be a Nemo parent, e.g. <code>QQ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

fz = x^2*y^2 + x + 1

fq = change_base_ring(fz, QQ)</code></pre><h3><a class="nav-anchor" href="#Multivariate-coefficients-1" id="Multivariate-coefficients-1">Multivariate coefficients</a></h3><p>In order to return the "coefficient" (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.coeff</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">coeff(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T &lt;: RingElement</code></pre><blockquote><p>Return the "coefficient" of <span>$a$</span> (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. <code>coeff(f, [1, 3], [0, 2])</code> returns the coefficient of <span>$x^0*z^2$</span> in the polynomial <span>$f$</span> (assuming variables <span>$x, y, z$</span> in that order).</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{T,Array{T,1},Array{Int64,1}}} where T&lt;:MPolyElem" id="AbstractAlgebra.Generic.coeff-Union{Tuple{T}, Tuple{T,Array{T,1},Array{Int64,1}}} where T&lt;:MPolyElem"><code>AbstractAlgebra.Generic.coeff</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T &lt;: AbstractAlgebra.MPolyElem</code></pre><blockquote><p>Return the "coefficient" of <span>$a$</span> (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. <code>coeff(f, [x, z], [0, 2])</code> returns the coefficient of <span>$x^0*z^2$</span> in the polynomial <span>$f$</span>. </p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(ZZ, ["x", "y", "z"])

f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1

coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])</code></pre><h3><a class="nav-anchor" href="#Inflation/deflation-1" id="Inflation/deflation-1">Inflation/deflation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.deflation-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.deflation-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.deflation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">deflation(f::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</code></pre><blockquote><p>Computes deflation parameters for the exponents of the polynomial <span>$f$</span>. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.deflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.deflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.deflate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">deflate(f::AbstractAlgebra.MPolyElem{T}, v::Vector{Int}) where T &lt;: RingElement</code></pre><blockquote><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been shifted down by the given shifts (supplied as an array of shifts, one for each variable, then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of <span>$0$</span> by <span>$1$</span>, to avoid division by <span>$0$</span>.  </p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.inflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.inflate-Union{Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{Int64,1}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.inflate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">inflate(f::AbstractAlgebra.MPolyElem{T}, v::Vector{Int}) where T &lt;: RingElement</code></pre><blockquote><p>Return a polynomial with the same coefficients as <span>$f$</span> but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then shifted by the given shifts (again supplied as an array of shifts, one for each variable).  </p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2

def, shift = deflation(f)
f1 = deflate(f, def, shift)
f2 = inflate(f1, def, shift)
f2 == f</code></pre><h3><a class="nav-anchor" href="#Conversions-1" id="Conversions-1">Conversions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.to_univariate-Union{Tuple{T}, Tuple{PolyRing{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.to_univariate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">to_univariate(R::AbstractAlgebra.PolyRing{T}, p::AbstractAlgebra.MPolyElem{T}) where T &lt;: AbstractAlgebra.RingElement</code></pre><blockquote><p>Assuming the polynomial <span>$p$</span> is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring <span>$R$</span>. An exception is raised if the polynomial <span>$p$</span> involves more than one variable.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])
S, z = PolynomialRing(ZZ, "z")

f = 2x^5 + 3x^4 - 2x^2 - 1

g = to_univariate(S, f)</code></pre><h3><a class="nav-anchor" href="#Evaluation-1" id="Evaluation-1">Evaluation</a></h3><p>The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><blockquote><p>Evaluate the polynomial by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of the supplied vector.</p></blockquote></div></section><p>The following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><blockquote><p>Evaluate the polynomial by substituting in the supplied values in the array <code>vals</code> for the corresponding variables with indices given by the array <code>vars</code>. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of <code>vals</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S,Array{S,1},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where S&lt;:MPolyElem{T} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S,Array{S,1},Array{U,1}}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where S&lt;:MPolyElem{T} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S &lt;: AbstractAlgebra.MPolyElem{T}, U &lt;: RingElement} where T &lt;: RingElement</code></pre><blockquote><p>Evaluate the polynomial by substituting in the supplied values in the array <code>vals</code> for the corresponding variables (supplied as polynomials) given by the array <code>vars</code>. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of <span>$a$</span> and elements of <code>vals</code>.</p></blockquote></div></section><p>The following functions allow a map or function to be applied to the coefficients of the polynomial before doing the evaluation. Note that one can simply supply a <code>Ring</code> object for the map (see the examples).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::AbstractAlgebra.MPolyElem{T}, A::Vector{U}, g) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><blockquote><p>Evaluate the polynomial at the supplied values after applying the <code>Map</code> or <code>Function</code> given by <span>$g$</span> to the coefficients of the polynomial.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{Int64,1},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, vals::Vector{U}, g) where {T &lt;: RingElement, U &lt;: RingElement}</code></pre><blockquote><p>Evaluate the polynomial at the supplied values for the variables with given indices after applying the <code>Map</code> or <code>Function</code> given by <span>$g$</span> to the coefficients of the polynomial.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S,Array{S,1},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where S&lt;:MPolyElem{T} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S,Array{S,1},Array{U,1},Any}} where U&lt;:Union{RingElem, AbstractFloat, Integer, Rational} where S&lt;:MPolyElem{T} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::S, vars::Vector{S}, vals::Vector{U}, g) where {S &lt;: AbstractAlgebra.MPolyElem{T}, U &lt;: RingElement} where T &lt;: RingElement</code></pre><blockquote><p>Evaluate the polynomial at the supplied values for the given variables after  applying the <code>Map</code> or <code>Function</code> given by <span>$g$</span> to the coefficients of the polynomial.</p></blockquote></div></section><p>The following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U&lt;:NCRingElem where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T},Array{U,1}}} where U&lt;:NCRingElem where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T &lt;: RingElement, U &lt;: NCRingElem}</code></pre><blockquote><p>Evaluate the polynomial at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which <span>$a$</span> belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

f = 2x^2*y^2 + 3x + y + 1

evaluate(f, BigInt[1, 2])
evaluate(f, [QQ(1), QQ(2)])
evaluate(f, [1, 2])
f(1, 2) == 14

evaluate(f, [x + y, 2y - x])
f(x + y, 2y - x)

R, (x, y, z) = PolynomialRing(ZZ, ["x", "y", "z"])

f = x^2*y^2 + 2x*z + 3y*z + z + 1

evaluate(f, [1, 3], [3, 4])
evaluate(f, [x, z], [3, 4])

evaluate(f, [1, 2], [x + z, x - z])

evaluate(f, [2, 4, 6], QQ)
evaluate(f, [x, z], [2, 4], QQ)

S = MatrixAlgebra(ZZ, 2)

M1 = S([1 2; 3 4])
M2 = S([2 3; 1 -1])
M3 = S([-1 1; 1 1])

evaluate(f, [M1, M2, M3])
f(M1, M2, M3)

f(M1, ZZ(2), M3)
f(M1, ZZ(2), 3)</code></pre><h3><a class="nav-anchor" href="#Leading-coefficients,-leading-monomials-and-leading-terms-1" id="Leading-coefficients,-leading-monomials-and-leading-terms-1">Leading coefficients, leading monomials and leading terms</a></h3><p>The leading coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.lc-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.lc-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.lc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lc(p::MPolyElem)</code></pre><blockquote><p>Return the leading coefficient of the polynomial p.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.lm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.lm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.lm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lm(p::MPolyElem)</code></pre><blockquote><p>Return the leading monomial of the polynomial p.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.lt-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.lt-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.lt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lt(p::MPolyElem)</code></pre><blockquote><p>Return the leading term of the polynomial p.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">using AbstractAlgebra
R,(x,y) = PolynomialRing(ZZ, ["x", "y"], ordering=:deglex)
p = 2*x*y + 3*y^3
lt(p)
lm(p)
lc(p)
lt(p) == lc(p) * lm(p)</code></pre><h3><a class="nav-anchor" href="#Least-common-multiple,-greatest-common-divisor-1" id="Least-common-multiple,-greatest-common-divisor-1">Least common multiple, greatest common divisor</a></h3><p>The greated common divisor of two polynomials a and b is returned by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.gcd-Union{Tuple{T}, Tuple{MPoly{T},MPoly{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="Base.gcd-Union{Tuple{T}, Tuple{MPoly{T},MPoly{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>Base.gcd</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gcd(a::AbstractAlgebra.Generic.MPoly{T}, a::AbstractAlgebra.Generic.MPoly{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return the greatest common divisor of a and b in parent(a).</p></blockquote></div></section><p>The least common multiple of two polynomials a and b is returned by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.lcm-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="Base.lcm-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lcm(a::AbstractAlgebra.MPolyElem{T}, a::AbstractAlgebra.MPolyElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return the least common multiple of a and b in parent(a).</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">using AbstractAlgebra
R,(x,y) = PolynomialRing(ZZ, ["x", "y"])
a = x*y + 2*y
b = x^3*y + y
gcd(a,b)
lcm(a,b)
lcm(a,b) == a * b // gcd(a,b)</code></pre><h3><a class="nav-anchor" href="#Derivations-1" id="Derivations-1">Derivations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AbstractAlgebra.Generic.derivative-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}" id="AbstractAlgebra.Generic.derivative-Union{Tuple{T}, Tuple{MPolyElem{T},MPolyElem{T}}} where T&lt;:Union{RingElem, AbstractFloat, Integer, Rational}"><code>AbstractAlgebra.Generic.derivative</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">derivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T &lt;: RingElement</code></pre><blockquote><p>Return the partial derivative of <code>f</code> with respect to <code>x</code>. The value <code>x</code> must be a generator of the polynomial ring of <code>f</code>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = AbstractAlgebra.PolynomialRing(ZZ, ["x", "y"])

f = x*y + x + y + 1

derivative(f, x)
derivative(f, y)</code></pre><footer><hr/><a class="previous" href="../mpolynomial_rings/"><span class="direction">Previous</span><span class="title">Multivariate Polynomial Ring Interface</span></a><a class="next" href="../series_rings/"><span class="direction">Next</span><span class="title">Series Ring Interface</span></a></footer></article></body></HTML>