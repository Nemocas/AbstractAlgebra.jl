<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutations and Permutation groups · AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">AbstractAlgebra.jl</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="rings.html">Ring Interface</a></li><li><a class="toctext" href="euclidean.html">Euclidean Ring Interface</a></li><li><a class="toctext" href="integer.html">Integer ring</a></li><li><a class="toctext" href="polynomial_rings.html">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="polynomial.html">Generic univariate polynomials</a></li><li><a class="toctext" href="mpolynomial_rings.html">Multivariate Polynomial Ring Interface</a></li><li><a class="toctext" href="mpolynomial.html">Generic sparse distributed multivariate polynomials</a></li><li><a class="toctext" href="series_rings.html">Series Ring Interface</a></li><li><a class="toctext" href="series.html">Generic power series</a></li><li><a class="toctext" href="puiseux.html">Generic Puiseux series</a></li><li><a class="toctext" href="residue_rings.html">Residue Ring Interface</a></li><li><a class="toctext" href="residue.html">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="fields.html">Field Interface</a></li><li><a class="toctext" href="fraction_fields.html">Fraction Field Interface</a></li><li><a class="toctext" href="fraction.html">Generic fraction fields</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="finfield.html">Finite fields</a></li><li><a class="toctext" href="real.html">Real field</a></li><li><a class="toctext" href="numberfield.html">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li class="current"><a class="toctext" href="perm.html">Permutations and Permutation groups</a><ul class="internal"><li><a class="toctext" href="#Permutations-constructors-1">Permutations constructors</a></li><li><a class="toctext" href="#Permutation-interface-1">Permutation interface</a></li><li><a class="toctext" href="#Basic-manipulation-1">Basic manipulation</a></li><li><a class="toctext" href="#Arithmetic-operators-1">Arithmetic operators</a></li><li><a class="toctext" href="#Coercion-1">Coercion</a></li><li><a class="toctext" href="#Comparison-1">Comparison</a></li><li><a class="toctext" href="#Misc-1">Misc</a></li></ul></li><li><a class="toctext" href="ytabs.html">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="matrix_spaces.html">Matrix Interface</a></li><li><a class="toctext" href="matrix.html">Generic matrices</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="map.html">Map interface</a></li><li><a class="toctext" href="functional_map.html">Functional maps</a></li><li><a class="toctext" href="map_cache.html">Cached maps</a></li><li><a class="toctext" href="map_with_inverse.html">Map with inverse</a></li></ul></li><li><a class="toctext" href="types.html">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Groups</li><li><a href="perm.html">Permutations and Permutation groups</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/AbstractAlgebra.jl/blob/master/docs/src/perm.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Permutations and Permutation groups</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Permutations-and-Permutation-groups-1" href="#Permutations-and-Permutation-groups-1">Permutations and Permutation groups</a></h1><p>AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in <code>src/generic/PermGroups.jl</code>). All functionality of permutations is accesible in the <code>Generic</code> submodule.</p><p>Permutations are represented internally via vector of integers, wrapped in type <code>perm{T}</code>, where <code>T&lt;:Integer</code> carries the information on the type of elements of a permutation. Permutation groups are singleton parent objects of type <code>PermGroup{T}</code> and are used mostly to store the length of a permutation, since it is not included in the permutation type.</p><p>Permutation groups are created using the <code>PermGroup</code> (inner) constructor. However, for convenience we define</p><pre><code class="language-none">PermutationGroup = PermGroup</code></pre><p>so that permutation groups can be created using <code>PermutationGroup</code> instead of <code>PermGroup</code>.</p><p>Both <code>PermGroup</code> and <code>perm</code> and can be parametrized by any type <code>T&lt;:Integer</code> . By default the parameter is the <code>Int</code>-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as <code>Int32</code>, <code>Uint16</code>, or even <code>Int8</code>), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.</p><p>All the permutation group types belong to the <code>Group</code> abstract type and the corresponding permutation element types belong to the <code>GroupElem</code> abstract type.</p><pre><code class="language-none">Generic.setpermstyle</code></pre><h2><a class="nav-anchor" id="Permutations-constructors-1" href="#Permutations-constructors-1">Permutations constructors</a></h2><p>There are several methods to to construct permutations in AbstractAlgebra.jl.</p><ul><li>The easiest way is to directly call to the <code>perm</code> (inner) constructor:</li></ul><pre><code class="language-none">Generic.perm</code></pre><p>Since the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitely constructing the parent object.</p><ul><li>The other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor <code>PermGroup(n::Integer)</code> which constructs the permutation group on <span>$n$</span> symbols and returns the parent object representing the group.</li></ul><pre><code class="language-none">Generic.PermGroup</code></pre><p>A vector of integers can be then coerced to a permutation via call to parent. The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; G = PermutationGroup(BigInt(5)); p = G([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(p)
AbstractAlgebra.Generic.perm{BigInt}

julia&gt; H = PermutationGroup(UInt16(5)); r = H([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(r)
AbstractAlgebra.Generic.perm{UInt16}

julia&gt; H()
()</code></pre><p>By default the coercion checks for non-unique values in the vector, but this can be switched off with <code>G([2,3,1,5,4], false)</code>.</p><ul><li>Finally there is a <code>perm&quot;...&quot;</code> string macro to construct permutation from string input.</li></ul><pre><code class="language-none">@perm_str</code></pre><h2><a class="nav-anchor" id="Permutation-interface-1" href="#Permutation-interface-1">Permutation interface</a></h2><p>The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide these functions along with the usual group element arithmetic and comparison.</p><pre><code class="language-none">parent(::perm)
elem_type(::PermGroup)
parent_type(::perm)</code></pre><p>A custom implementation also needs to implement <code>hash(::perm, ::UInt)</code> and (possibly) <code>deepcopy_internal(::perm, ::ObjectIdDict)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Permutation group elements are mutable and so returning shallow copies is not sufficient.</p></div></div><pre><code class="language-julia">getindex(a::perm, n::Int)</code></pre><p>Allows access to entry <span>$n$</span> of the given permutation via the syntax <code>a[n]</code>. Note that entries are <span>$1$</span>-indexed.</p><pre><code class="language-julia">setindex!(a::perm, d::Int, n::Int)</code></pre><p>Set the <span>$n$</span>-th entry of the given permutation to <span>$d$</span>. This allows Julia to provide the syntax <code>a[n] = d</code> for setting entries of a permutation. Entries are <span>$1$</span>-indexed.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Using <code>setindex!</code> invalidates cycle decomposition cached in a permutation, i.e. it will be computed the next time cycle decomposition is needed.</p></div></div><p>Given the parent object <code>G</code> for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.</p><pre><code class="language-julia">G()</code></pre><p>Return the identity permutation.</p><pre><code class="language-julia">G(A::Vector{&lt;:Integer})</code></pre><p>Return the permutation whose entries are given by the elements of the supplied vector.</p><pre><code class="language-julia">G(p::perm)</code></pre><p>Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.</p><h2><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h2><p>Numerous functions are provided to manipulate permutation group elements.</p><pre><code class="language-none">cycles(::perm)</code></pre><p>Cycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.</p><pre><code class="language-none">parity(::perm)
sign(::perm)
permtype(::perm)
order(::perm)
order(::Generic.PermGroup)</code></pre><p>Note that even an <code>Int64</code> can be easily overflowed when computing with permutation groups. Thus, by default, <code>order</code> returns (always correct) <code>BigInt</code>s. If you are sure that the computation will not overflow, you may use <code>order(::Type{T}, ...)</code> to perform computations with machine integers. Julias standard promotion rules apply for the returned value.</p><p>Since <code>PermGroup</code> implements the iterator protocole You may iterate over all permutations via simple</p><pre><code class="language-none">for p in PermutationGroup(n)
   ...
end</code></pre><p>Iteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when <span>$n ≤ 13$</span>.</p><p>You may also use the non-allocating <code>Generic.elements!</code> function for <span>$n ≤ 14$</span> (or even <span>$15$</span> if you are patient enough), which is an order of mangitude faster.</p><pre><code class="language-none">Generic.elements!(::Generic.PermGroup)</code></pre><p>However, since all permutations yielded by <code>elements!</code> are aliased (modified &quot;in-place&quot;), <code>collect(Generic.elements!(PermGroup(n)))</code> returns a vector of identical permutations.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you intend to use or store elements yielded by <code>elements!</code> you need to <strong>deepcopy</strong> them explicitely.</p></div></div><h2><a class="nav-anchor" id="Arithmetic-operators-1" href="#Arithmetic-operators-1">Arithmetic operators</a></h2><pre><code class="language-none">*(::perm, ::perm)
^(::perm, n::Integer)
inv(::perm)</code></pre><p>Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:</p><pre><code class="language-julia">g = rand(PermGroup(Int8(5)));
h = rand(PermGroup(UInt32(5)));
typeof(g*h)

# output
AbstractAlgebra.Generic.perm{Int64}</code></pre><h2><a class="nav-anchor" id="Coercion-1" href="#Coercion-1">Coercion</a></h2><p>The following coercions are available for <code>G::PermGroup</code> parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">(G::PermGroup)()</code></pre><blockquote><p>Return the identity element of <code>G</code>.</p></blockquote><pre><code class="language-julia">(G::PermGrup)(::Vector{&lt;:Integer}[, check=true])</code></pre><blockquote><p>Turn a vector od integers into a permutation (performing conversion, if necessary).</p></blockquote><pre><code class="language-julia">(G::PermGroup)(::perm{&lt;:Integer}[, check=true])</code></pre><blockquote><p>Coerce a permutation <code>p</code> into group <span>$G$</span> (performing the conversion, if necessary). If <code>p</code> is already an element of <code>G</code> no copy is performed.</p></blockquote><pre><code class="language-julia">(G::PermGroup)(::String[, check=true])</code></pre><blockquote><p>Parse the string input e.g. copied from the output of GAP. The method uses the same logic as <code>perm&quot;...&quot;</code> macro. The string is sanitized and checked for disjoint cycles. Both <code>string(p::perm)</code> (if <code>setpermstyle(:cycles)</code>) and <code>string(cycles(p::perm))</code> are valid input for this method.</p></blockquote><pre><code class="language-julia">(G::PermGroup{T})(::CycleDec{T}[, check=true]) where T</code></pre><blockquote><p>Turn a cycle decomposition object into a permutation.</p></blockquote><h2><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h2><pre><code class="language-none">==(::perm, ::perm)
==(::Generic.PermGroup, ::Generic.PermGroup)</code></pre><h2><a class="nav-anchor" id="Misc-1" href="#Misc-1">Misc</a></h2><pre><code class="language-none">rand(::Generic.PermGroup)
Generic.matrix_repr(::perm)
Generic.emb(::Generic.PermGroup, ::Vector{Int}, ::Bool)
Generic.emb!(::perm, ::perm, V)</code></pre><footer><hr/><a class="previous" href="numberfield.html"><span class="direction">Previous</span><span class="title">Number fields</span></a><a class="next" href="ytabs.html"><span class="direction">Next</span><span class="title">Partitions and Young tableaux</span></a></footer></article></body></html>
